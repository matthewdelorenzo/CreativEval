Extracted Text,Reward,Prompt Name,Prompt Text,GoldenSolFull,TrimmedModule
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  );
    assign p2y = ~(p2a  & p2b  & p2c  & p2d  );

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  );
    assign p2y = ~(p2a  & p2b  & p2c  & p2d  );

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  );
    assign p2y = ~(p2a  & p2b  & p2c  & p2d  );

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  );
    assign p2y = ~(p2a  & p2b  & p2c  & p2d  );

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  );
    assign p2y = ~(p2a  & p2b  & p2c  & p2d  );

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  );
    assign p2y = ~(p2a  & p2b  & p2c  & p2d  );

endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);
    
endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c && p1d);
    assign p2y = ~(p2a && p2b && p2c && p2d);
    
endmodule"
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);
    
endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);
    
endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    wire w1;
    wire w2;
    wire w3;
    wire w4;
    
    assign w1=p2a && p2b;
    assign w2=p2c && p2d;
    assign p2y= w1 || w2;
    
    assign w3=p1a && p1b && p1c;
    assign w4=p1d && p1e && p1f;
    assign p1y=w3 || w4;
    

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    wire w1;
    wire w2;
    wire w3;
    wire w4;
    
    assign w1=p2a && p2b;
    assign w2=p2c && p2d;
    assign p2y= w1 || w2;
    
    assign w3=p1a && p1b && p1c;
    assign w4=p1d && p1e && p1f;
    assign p1y=w3 || w4;
    

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a ^ p1b ^ p1c ^ p1d ^ p1e ^ p1f);
    assign p2y = ~(p2a ^ p2b ^ p2c ^ p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a ^ p1b ^ p1c ^ p1d ^ p1e ^ p1f);
    assign p2y = ~(p2a ^ p2b ^ p2c ^ p2d);

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    wire w1;
    wire w2;
    wire w3;
    wire w4;
    
    assign w1 = p2a && p2b;
    assign w2 = p2c && p2d;
    assign p2y = w1 || w2;
    
    assign w3 = p1a && p1b && p1c;
    assign w4 = p1d && p1e && p1f;
    assign p1y = w3 || w4;
    

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    wire w1;
    wire w2;
    wire w3;
    wire w4;
    
    assign w1 = p2a && p2b;
    assign w2 = p2c && p2d;
    assign p2y = w1 || w2;
    
    assign w3 = p1a && p1b && p1c;
    assign w4 = p1d && p1e && p1f;
    assign p1y = w3 || w4;
    

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c);
    assign p2y = ~(p2a && p2b);
    
endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a && p1b && p1c);
    assign p2y = ~(p2a && p2b);
    
endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule"
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule",-0.5,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
    
    assign p1y = ~(p1a  & p1b  & p1c  & p1d  & p1e  & p1f);
    assign p2y = ~(p2a  & p2b  & p2c  & p2d);

endmodule"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [98:0] cr;
    
    FA ins1 (a[0], b[0], cin, sum[0], cr[0]);
    FA ins2 (a[99], b[99], cr[98], sum[99], cr[99]);
    FA ins3 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins4 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins5 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins6 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins7 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins8 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins9 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins10 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins11 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins12 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins13 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins14 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins15 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins16 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins17 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins18 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins19 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins20 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins21 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins22 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins23 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins24 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins25 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins26 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins27 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins28 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins29 (a[98:0], b[98:0], cr[97:0",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [98:0] cr;
    
    FA ins1 (a[0], b[0], cin, sum[0], cr[0]);
    FA ins2 (a[99], b[99], cr[98], sum[99], cr[99]);
    FA ins3 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins4 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins5 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins6 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins7 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins8 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins9 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins10 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins11 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins12 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins13 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins14 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins15 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins16 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins17 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins18 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins19 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins20 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins21 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins22 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins23 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins24 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins25 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins26 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins27 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins28 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    FA ins29 (a[98:0], b[98:0], cr[97:0"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cr;
    
    FA ins1 (a[0], b[0], cin, sum[0], cr[0]);
    FA ins2 (a[99], b[99], cr[98], sum[99], cr[99]);
    FA ins3 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins4 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    
    FA ins5 (a[99:2], b[99:2], cr[99:2], sum[99:2], cr[99:2]);
    FA ins6 (a[98:1], b[98:1], cr[99:1], sum[98:1], cr[98:1]);
    FA ins7 (a[99:0], b[99:0], cr[99:0], sum[99:0], cr[99:0]);
    FA ins8 (a[99:0], b[99:0], cin, sum[99:0], cout);
    
endmodule",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cr;
    
    FA ins1 (a[0], b[0], cin, sum[0], cr[0]);
    FA ins2 (a[99], b[99], cr[98], sum[99], cr[99]);
    FA ins3 (a[98:0], b[98:0], cr[97:0], sum[98:0], cr[98:0]);
    FA ins4 (a[99:1], b[99:1], cr[98:1], sum[99:1], cr[99:1]);
    
    FA ins5 (a[99:2], b[99:2], cr[99:2], sum[99:2], cr[99:2]);
    FA ins6 (a[98:1], b[98:1], cr[99:1], sum[98:1], cr[98:1]);
    FA ins7 (a[99:0], b[99:0], cr[99:0], sum[99:0], cr[99:0]);
    FA ins8 (a[99:0], b[99:0], cin, sum[99:0], cout);
    
endmodule"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb, ca1, cb1, ca2, cb2, ca3, cb3, ca4, cb4, ca5, cb5, ca6, cb6, ca7, cb7, ca8, cb8, ca9, cb9, ca10, cb10, ca11, cb11, ca12, cb12, ca13, cb13, ca14, cb14, ca15, cb15, ca16, cb16, ca17, cb17, ca18, cb18, ca19, cb19, ca20, cb20, ca21, cb21, ca22, cb22, ca23, cb23, ca24, cb24, ca25, cb25, ca26, cb26, ca27, cb27, ca28, cb28, ca29, cb29, ca30, cb30, ca31, cb31, ca32, cb32, ca33, cb33, ca34, cb34, ca35, cb35, ca36, cb36, ca37, cb37, ca38, cb38, ca39, cb39, ca40, cb40, ca41, cb41, ca42, cb42, ca43, cb43, ca44, cb44, ca45, cb45, ca46, cb46, ca47, cb47, ca48, cb48, ca49, cb49, ca50, cb50, ca51, cb51, ca52, cb52, ca53, cb53, ca54, cb54, ca55, cb55, ca56, cb56, ca57, cb57, ca58, cb58, ca59, cb59, ca60, cb60, ca61, cb61, ca62, cb62, ca63, cb63, ca64, cb64, ca65, cb65, ca66, cb66, ca67, cb67, ca68, cb68, ca69, cb69, ca70, cb70, ca71, cb71, ca72, cb72, ca73, cb73, ca74, cb74, ca75, cb75, ca76, cb76, ca77, cb77, ca78, cb78, ca79, cb79, ca80, cb80, ca81, cb81, ca82, cb82, ca83, cb83, ca84, cb84, ca85, cb85, ca86, cb86, ca87, cb87, ca88, cb88, ca89, cb89, ca90, cb90, ca91, cb91, ca92, cb92, ca93, cb93, ca94, cb94, ca95, cb95, ca96, cb96, ca97, cb97, ca98, cb98, ca99, cb99, ca100, cb100, ca101, cb101, ca102, cb102, ca103, cb103, ca104, cb104, ca105, cb105, ca106, cb106, ca107, cb107, ca108, cb108, ca109, cb109, ca110, cb110, ca111, cb111, ca112, cb112, ca113, cb113, ca114, cb114, ca115, cb115, ca116, cb116, ca117, cb117, ca118, cb118, ca119, cb119, ca120, cb120, ca121, cb121, ca122, cb122, ca123, cb123, ca124, cb124, ca125, cb125, ca126, cb126, ca127, cb127, ca128, cb128, ca129, cb129, ca130, cb130, ca131, cb131, ca132, cb132, ca133, cb133, ca134, cb134, ca135, cb135, ca136, cb136, ca137, cb137, ca138, cb138, ca139, cb139, ca140, cb140, ca141, cb141, ca142, cb142, ca143, cb143, ca144, cb144, ca",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb, ca1, cb1, ca2, cb2, ca3, cb3, ca4, cb4, ca5, cb5, ca6, cb6, ca7, cb7, ca8, cb8, ca9, cb9, ca10, cb10, ca11, cb11, ca12, cb12, ca13, cb13, ca14, cb14, ca15, cb15, ca16, cb16, ca17, cb17, ca18, cb18, ca19, cb19, ca20, cb20, ca21, cb21, ca22, cb22, ca23, cb23, ca24, cb24, ca25, cb25, ca26, cb26, ca27, cb27, ca28, cb28, ca29, cb29, ca30, cb30, ca31, cb31, ca32, cb32, ca33, cb33, ca34, cb34, ca35, cb35, ca36, cb36, ca37, cb37, ca38, cb38, ca39, cb39, ca40, cb40, ca41, cb41, ca42, cb42, ca43, cb43, ca44, cb44, ca45, cb45, ca46, cb46, ca47, cb47, ca48, cb48, ca49, cb49, ca50, cb50, ca51, cb51, ca52, cb52, ca53, cb53, ca54, cb54, ca55, cb55, ca56, cb56, ca57, cb57, ca58, cb58, ca59, cb59, ca60, cb60, ca61, cb61, ca62, cb62, ca63, cb63, ca64, cb64, ca65, cb65, ca66, cb66, ca67, cb67, ca68, cb68, ca69, cb69, ca70, cb70, ca71, cb71, ca72, cb72, ca73, cb73, ca74, cb74, ca75, cb75, ca76, cb76, ca77, cb77, ca78, cb78, ca79, cb79, ca80, cb80, ca81, cb81, ca82, cb82, ca83, cb83, ca84, cb84, ca85, cb85, ca86, cb86, ca87, cb87, ca88, cb88, ca89, cb89, ca90, cb90, ca91, cb91, ca92, cb92, ca93, cb93, ca94, cb94, ca95, cb95, ca96, cb96, ca97, cb97, ca98, cb98, ca99, cb99, ca100, cb100, ca101, cb101, ca102, cb102, ca103, cb103, ca104, cb104, ca105, cb105, ca106, cb106, ca107, cb107, ca108, cb108, ca109, cb109, ca110, cb110, ca111, cb111, ca112, cb112, ca113, cb113, ca114, cb114, ca115, cb115, ca116, cb116, ca117, cb117, ca118, cb118, ca119, cb119, ca120, cb120, ca121, cb121, ca122, cb122, ca123, cb123, ca124, cb124, ca125, cb125, ca126, cb126, ca127, cb127, ca128, cb128, ca129, cb129, ca130, cb130, ca131, cb131, ca132, cb132, ca133, cb133, ca134, cb134, ca135, cb135, ca136, cb136, ca137, cb137, ca138, cb138, ca139, cb139, ca140, cb140, ca141, cb141, ca142, cb142, ca143, cb143, ca144, cb144, ca"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_temp;
    
    full_adder inst1 (
       .a(a[0]),
       .b(b[0]),
       .cin(cin),
       .sum(sum[0]),
       .cout(cout_temp[0])
    );
    
    full_adder inst2 (
       .a(a[99]),
       .b(b[99]),
       .cin(cout_temp[0]),
       .sum(sum[99]),
       .cout(cout_temp[1])
    );
    
    full_adder inst3 (
       .a(a[98:0]),
       .b(b[98:0]),
       .cin(cout_temp[1]),
       .sum(sum[98:0]),
       .cout(cout_temp[2])
    );
    
    full_adder inst4 (
       .a(a[99:1]),
       .b(b[99:1]),
       .cin(cout_temp[2]),
       .sum(sum[99:1]),
       .cout(cout_temp[3])
    );
    
    full_adder inst5 (
       .a(a[98:2]),
       .b(b[98:2]),
       .cin(cout_temp[3]),
       .sum(sum[98:2]),
       .cout(cout_temp[4])
    );
    
    full_adder inst6 (
       .a(a[99:3]),
       .b(b[99:3]),
       .cin(cout_temp[4]),
       .sum(sum[99:3]),
       .cout(cout_temp[5])
    );
    
    full_adder inst7 (
       .a(a[98:4]),
       .b(b[98:4]),
       .cin(cout_temp[5]),
       .sum(sum[98:4]),
       .cout(cout_temp[6])
    );
    
    full_adder inst8 (
       .a(a[99:5]),
       .b(b[99:5]),
       .cin(cout_temp[6]),
       .sum(sum[99:5]),
       .cout(cout_temp[7])
    );
    
    full_adder inst9 (
       .a(a[98:6]),
       .b(b[98:6]),
       .cin(cout_temp[7]),
       .sum(sum[98:6]),
       .cout(cout_temp[8])
    );
    
    full_adder inst10 (
       .a(a[99:7]),
       .b(b[99:7]),
       .cin(cout_temp[8]),
       .sum(sum[99:7]),
       .cout(cout_temp[9])
    );
    
    full_adder inst11 (
       .a(a[98:8]),
       .b(b[98:8]),
       .cin(cout_temp[9]),
       .sum(sum[98:8]),
       .cout(cout_temp[10])
    );
    
    full_adder inst12 (
       .a(a[99:9]),
       .b(b[99:9]),
       .cin(cout_temp[10]),
       .sum(sum[99:9]),
       .cout(cout_temp[11])
    );
    
    full_adder inst13 (
       .a(a[98:10]),
       .b(b[98:10]),
       .cin(cout_temp[11]),
       .sum(sum[98:10]),
       .cout(cout_temp[12])
    );
    
    full_adder inst14 (
       .a(a[99:11]),
       .b(b[99:11]),
       .cin(cout_temp[12]),
       .sum(sum[99:11]),
       .cout(cout_temp[13])
    );
    
    full_adder inst15 (
       .a(a[98:12]),
       .b(b[98:12]),",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_temp;
    
    full_adder inst1 (
       .a(a[0]),
       .b(b[0]),
       .cin(cin),
       .sum(sum[0]),
       .cout(cout_temp[0])
    );
    
    full_adder inst2 (
       .a(a[99]),
       .b(b[99]),
       .cin(cout_temp[0]),
       .sum(sum[99]),
       .cout(cout_temp[1])
    );
    
    full_adder inst3 (
       .a(a[98:0]),
       .b(b[98:0]),
       .cin(cout_temp[1]),
       .sum(sum[98:0]),
       .cout(cout_temp[2])
    );
    
    full_adder inst4 (
       .a(a[99:1]),
       .b(b[99:1]),
       .cin(cout_temp[2]),
       .sum(sum[99:1]),
       .cout(cout_temp[3])
    );
    
    full_adder inst5 (
       .a(a[98:2]),
       .b(b[98:2]),
       .cin(cout_temp[3]),
       .sum(sum[98:2]),
       .cout(cout_temp[4])
    );
    
    full_adder inst6 (
       .a(a[99:3]),
       .b(b[99:3]),
       .cin(cout_temp[4]),
       .sum(sum[99:3]),
       .cout(cout_temp[5])
    );
    
    full_adder inst7 (
       .a(a[98:4]),
       .b(b[98:4]),
       .cin(cout_temp[5]),
       .sum(sum[98:4]),
       .cout(cout_temp[6])
    );
    
    full_adder inst8 (
       .a(a[99:5]),
       .b(b[99:5]),
       .cin(cout_temp[6]),
       .sum(sum[99:5]),
       .cout(cout_temp[7])
    );
    
    full_adder inst9 (
       .a(a[98:6]),
       .b(b[98:6]),
       .cin(cout_temp[7]),
       .sum(sum[98:6]),
       .cout(cout_temp[8])
    );
    
    full_adder inst10 (
       .a(a[99:7]),
       .b(b[99:7]),
       .cin(cout_temp[8]),
       .sum(sum[99:7]),
       .cout(cout_temp[9])
    );
    
    full_adder inst11 (
       .a(a[98:8]),
       .b(b[98:8]),
       .cin(cout_temp[9]),
       .sum(sum[98:8]),
       .cout(cout_temp[10])
    );
    
    full_adder inst12 (
       .a(a[99:9]),
       .b(b[99:9]),
       .cin(cout_temp[10]),
       .sum(sum[99:9]),
       .cout(cout_temp[11])
    );
    
    full_adder inst13 (
       .a(a[98:10]),
       .b(b[98:10]),
       .cin(cout_temp[11]),
       .sum(sum[98:10]),
       .cout(cout_temp[12])
    );
    
    full_adder inst14 (
       .a(a[99:11]),
       .b(b[99:11]),
       .cin(cout_temp[12]),
       .sum(sum[99:11]),
       .cout(cout_temp[13])
    );
    
    full_adder inst15 (
       .a(a[98:12]),
       .b(b[98:12]),"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb;
    
    assign ca[0] = cin;
    assign cb[0] = cin;
    
    genvar i;
    generate
        for(i=1; i<100; i=i+1) begin
            full_adder U_adder(.a(a[i-1]),.b(b[i-1]),.cin(ca[i-1]),
                              .sum(sum[i-1]),.cout(cb[i]));
        end
    endgenerate
    
    assign cout = cb[99];
    
endmodule",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb;
    
    assign ca[0] = cin;
    assign cb[0] = cin;
    
    genvar i;
    generate
        for(i=1; i<100; i=i+1) begin
            full_adder U_adder(.a(a[i-1]),.b(b[i-1]),.cin(ca[i-1]),
                              .sum(sum[i-1]),.cout(cb[i]));
        end
    endgenerate
    
    assign cout = cb[99];
    
endmodule"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb;
    
    assign ca[0] = cin;
    assign cb[0] = cin;
    
    genvar i;
    generate
        for(i=1; i<100; i=i+1) begin
            assign ca[i] = a[i] & b[i-1];
            assign cb[i] = a[i] | b[i-1];
        end
    endgenerate
    
    full_adder_1bit fa_0(a[0], b[0], ca[0], sum[0], ca[99:1]);
    full_adder_1bit fa_99(a[99], b[99], ca[99], sum[99], ca[98:0]);
    
    assign cout = a[99] & b[99];
    
endmodule",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb;
    
    assign ca[0] = cin;
    assign cb[0] = cin;
    
    genvar i;
    generate
        for(i=1; i<100; i=i+1) begin
            assign ca[i] = a[i] & b[i-1];
            assign cb[i] = a[i] | b[i-1];
        end
    endgenerate
    
    full_adder_1bit fa_0(a[0], b[0], ca[0], sum[0], ca[99:1]);
    full_adder_1bit fa_99(a[99], b[99], ca[99], sum[99], ca[98:0]);
    
    assign cout = a[99] & b[99];
    
endmodule"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb, ca_1, ca_2, ca_2_1, ca_2_2, ca_2_3, ca_2_4, ca_2_5, ca_2_6, ca_2_7, ca_2_8, ca_2_9, ca_2_10, ca_2_11, ca_2_12, ca_2_13, ca_2_14, ca_2_15, ca_2_16, ca_2_17, ca_2_18, ca_2_19, ca_2_20, ca_2_21, ca_2_22, ca_2_23, ca_2_24, ca_2_25, ca_2_26, ca_2_27, ca_2_28, ca_2_29, ca_2_30, ca_2_31, ca_2_32, ca_2_33, ca_2_34, ca_2_35, ca_2_36, ca_2_37, ca_2_38, ca_2_39, ca_2_40, ca_2_41, ca_2_42, ca_2_43, ca_2_44, ca_2_45, ca_2_46, ca_2_47, ca_2_48, ca_2_49, ca_2_50, ca_2_51, ca_2_52, ca_2_53, ca_2_54, ca_2_55, ca_2_56, ca_2_57, ca_2_58, ca_2_59, ca_2_60, ca_2_61, ca_2_62, ca_2_63, ca_2_64, ca_2_65, ca_2_66, ca_2_67, ca_2_68, ca_2_69, ca_2_70, ca_2_71, ca_2_72, ca_2_73, ca_2_74, ca_2_75, ca_2_76, ca_2_77, ca_2_78, ca_2_79, ca_2_80, ca_2_81, ca_2_82, ca_2_83, ca_2_84, ca_2_85, ca_2_86, ca_2_87, ca_2_88, ca_2_89, ca_2_90, ca_2_91, ca_2_92, ca_2_93, ca_2_94, ca_2_95, ca_2_96, ca_2_97, ca_2_98, ca_2_99, ca_2_100, ca_2_101, ca_2_102, ca_2_103, ca_2_104, ca_2_105, ca_2_106, ca_2_107, ca_2_108, ca_2_109, ca_2_110, ca_2_111, ca_2_112, ca_2_113, ca_2_114, ca_2_115, ca_2_116, ca_2_117, ca_2_118, ca_2_119, ca_2_120, ca_2_121, ca_2_122, ca_2_123, ca_2_124, ca_2_125, ca_2_126, ca_2_127, ca_2_128, ca_2_129, ca_2_130, ca_2_131, ca_2_132, ca_2_133, ca_2_134, ca_2_135, ca_2_136, ca_2_137, ca_2_138, ca_2_139, ca_2_140, ca_2_141, ca_2_142, ca_2_143, ca_2_144, ca_2_145, ca_2_146, ca_2_147, ca_2_148, ca_2_149, ca_2_150, ca_2_151, ca_2_152, ca_2_153, ca_2_154, ca_2_155, ca_2_156, ca_2_157, ca_2_158, ca_2_159, ca_2_160, ca_2_161, ca_2_162, ca_2_163, ca_2_164, ca_2_165, ca_2_166, ca_2_167",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb, ca_1, ca_2, ca_2_1, ca_2_2, ca_2_3, ca_2_4, ca_2_5, ca_2_6, ca_2_7, ca_2_8, ca_2_9, ca_2_10, ca_2_11, ca_2_12, ca_2_13, ca_2_14, ca_2_15, ca_2_16, ca_2_17, ca_2_18, ca_2_19, ca_2_20, ca_2_21, ca_2_22, ca_2_23, ca_2_24, ca_2_25, ca_2_26, ca_2_27, ca_2_28, ca_2_29, ca_2_30, ca_2_31, ca_2_32, ca_2_33, ca_2_34, ca_2_35, ca_2_36, ca_2_37, ca_2_38, ca_2_39, ca_2_40, ca_2_41, ca_2_42, ca_2_43, ca_2_44, ca_2_45, ca_2_46, ca_2_47, ca_2_48, ca_2_49, ca_2_50, ca_2_51, ca_2_52, ca_2_53, ca_2_54, ca_2_55, ca_2_56, ca_2_57, ca_2_58, ca_2_59, ca_2_60, ca_2_61, ca_2_62, ca_2_63, ca_2_64, ca_2_65, ca_2_66, ca_2_67, ca_2_68, ca_2_69, ca_2_70, ca_2_71, ca_2_72, ca_2_73, ca_2_74, ca_2_75, ca_2_76, ca_2_77, ca_2_78, ca_2_79, ca_2_80, ca_2_81, ca_2_82, ca_2_83, ca_2_84, ca_2_85, ca_2_86, ca_2_87, ca_2_88, ca_2_89, ca_2_90, ca_2_91, ca_2_92, ca_2_93, ca_2_94, ca_2_95, ca_2_96, ca_2_97, ca_2_98, ca_2_99, ca_2_100, ca_2_101, ca_2_102, ca_2_103, ca_2_104, ca_2_105, ca_2_106, ca_2_107, ca_2_108, ca_2_109, ca_2_110, ca_2_111, ca_2_112, ca_2_113, ca_2_114, ca_2_115, ca_2_116, ca_2_117, ca_2_118, ca_2_119, ca_2_120, ca_2_121, ca_2_122, ca_2_123, ca_2_124, ca_2_125, ca_2_126, ca_2_127, ca_2_128, ca_2_129, ca_2_130, ca_2_131, ca_2_132, ca_2_133, ca_2_134, ca_2_135, ca_2_136, ca_2_137, ca_2_138, ca_2_139, ca_2_140, ca_2_141, ca_2_142, ca_2_143, ca_2_144, ca_2_145, ca_2_146, ca_2_147, ca_2_148, ca_2_149, ca_2_150, ca_2_151, ca_2_152, ca_2_153, ca_2_154, ca_2_155, ca_2_156, ca_2_157, ca_2_158, ca_2_159, ca_2_160, ca_2_161, ca_2_162, ca_2_163, ca_2_164, ca_2_165, ca_2_166, ca_2_167"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [98:0] cr;
    
    FA ins1 (a[0], b[0], cin, sum[0], cr[0]);
    FA ins2 (a[99], b[99], cr[98], sum[99], cr[99]);
    FA ins3 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA ins4 (a[99:1], b[99:1], cr[99:1], sum[99:1], cr[99:1]);
    FA ins5 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA ins6 (a[99:2], b[99:2], cr[99:2], sum[99:2], cr[99:2]);
    FA ins7 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA ins8 (a[99:3], b[99:3], cr[99:3], sum[99:3], cr[99:3]);
    FA ins9 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insA (a[99:4], b[99:4], cr[99:4], sum[99:4], cr[99:4]);
    FA insB (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insC (a[99:5], b[99:5], cr[99:5], sum[99:5], cr[99:5]);
    FA insD (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insE (a[99:6], b[99:6], cr[99:6], sum[99:6], cr[99:6]);
    FA insF (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insG (a[99:7], b[99:7], cr[99:7], sum[99:7], cr[99:7]);
    FA insH (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insI (a[99:8], b[99:8], cr[99:8], sum[99:8], cr[99:8]);
    FA insJ (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insK (a[99:9], b[99:9], cr[99:9], sum[99:9], cr[99:9]);
    FA insL (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insM (a[99:10], b[99:10], cr[99:10], sum[99:10], cr[99:10]);
    FA insN (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insO (a[99:11], b[99:11], cr[99:11], sum[99:11], cr[99:11]);
    FA insP (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insQ (a[99:12], b[99:12], cr[99:12], sum[99:12], cr[99:12]);
    FA insR (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insS (a[99:13], b[99:13], cr[99:13], sum[99:13], cr[99:13]);
    FA insT (a[98:0], b[98:0], cr[98:0",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [98:0] cr;
    
    FA ins1 (a[0], b[0], cin, sum[0], cr[0]);
    FA ins2 (a[99], b[99], cr[98], sum[99], cr[99]);
    FA ins3 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA ins4 (a[99:1], b[99:1], cr[99:1], sum[99:1], cr[99:1]);
    FA ins5 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA ins6 (a[99:2], b[99:2], cr[99:2], sum[99:2], cr[99:2]);
    FA ins7 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA ins8 (a[99:3], b[99:3], cr[99:3], sum[99:3], cr[99:3]);
    FA ins9 (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insA (a[99:4], b[99:4], cr[99:4], sum[99:4], cr[99:4]);
    FA insB (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insC (a[99:5], b[99:5], cr[99:5], sum[99:5], cr[99:5]);
    FA insD (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insE (a[99:6], b[99:6], cr[99:6], sum[99:6], cr[99:6]);
    FA insF (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insG (a[99:7], b[99:7], cr[99:7], sum[99:7], cr[99:7]);
    FA insH (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insI (a[99:8], b[99:8], cr[99:8], sum[99:8], cr[99:8]);
    FA insJ (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insK (a[99:9], b[99:9], cr[99:9], sum[99:9], cr[99:9]);
    FA insL (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insM (a[99:10], b[99:10], cr[99:10], sum[99:10], cr[99:10]);
    FA insN (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insO (a[99:11], b[99:11], cr[99:11], sum[99:11], cr[99:11]);
    FA insP (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insQ (a[99:12], b[99:12], cr[99:12], sum[99:12], cr[99:12]);
    FA insR (a[98:0], b[98:0], cr[98:0], sum[98:0], cr[98:0]);
    FA insS (a[99:13], b[99:13], cr[99:13], sum[99:13], cr[99:13]);
    FA insT (a[98:0], b[98:0], cr[98:0"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb;
    
    assign ca[0] = cin;
    assign cb[0] = cin;
    
    genvar i;
    generate
        for(i=1; i<100; i=i+1) begin
            assign ca[i] = a[i] & b[i-1];
            assign cb[i] = a[i] | b[i-1];
        end
    endgenerate
    
    full_adder_1bit fa0(.a(a[0]),.b(b[0]),.cin(ca[0]),.sum(sum[0]),.cout(cout) );
    full_adder_1bit fa1(.a(a[99]),.b(b[99]),.cin(cb[99]),.sum(sum[99]),.cout(cout) );
    
endmodule",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] ca, cb;
    
    assign ca[0] = cin;
    assign cb[0] = cin;
    
    genvar i;
    generate
        for(i=1; i<100; i=i+1) begin
            assign ca[i] = a[i] & b[i-1];
            assign cb[i] = a[i] | b[i-1];
        end
    endgenerate
    
    full_adder_1bit fa0(.a(a[0]),.b(b[0]),.cin(ca[0]),.sum(sum[0]),.cout(cout) );
    full_adder_1bit fa1(.a(a[99]),.b(b[99]),.cin(cb[99]),.sum(sum[99]),.cout(cout) );
    
endmodule"
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

// Define the adder in a lower module

// Define the carry-out and sum-out nets in a lower module

// Define the input nets as regs and wires

// Define the output nets as regs and wires

// Define a 100-bit full adder

// Define the input logic

// Define the output logic

// Define the module

endmodule",-0.5,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

// Define the adder in a lower module

// Define the carry-out and sum-out nets in a lower module

// Define the input nets as regs and wires

// Define the output nets as regs and wires

// Define a 100-bit full adder

// Define the input logic

// Define the output logic

// Define the module

endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    always @(*)
        begin
            // The following 2 lines are a *very* simple (and perhaps most ""innacurate"") implementation of a 
            // full-adder.
            // The ""temp"" variable is used to delay the value of the full-adder's ""s"" (the ""sum"") output.
            // The ""c[99:0]"" are used as a ""carry-in"" to the full-adder.
            // These lines are a 1-bit implementation of a full-adder, so ""c[99:0]"" are added with a 0-bit carry in.
            // In an actual implementation, ""c[99:0]"" should be a 100-bit wide variable.
            temp = a[99] ^ b[99] ^ c[99];
            c[99:0] = a[99:0] + b[99:0] + {1'b0, temp};
        end
    
    assign sum = {temp, c[99:1]};
    assign cout = c[99];

endmodule",-0.5,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    always @(*)
        begin
            // The following 2 lines are a *very* simple (and perhaps most ""innacurate"") implementation of a 
            // full-adder.
            // The ""temp"" variable is used to delay the value of the full-adder's ""s"" (the ""sum"") output.
            // The ""c[99:0]"" are used as a ""carry-in"" to the full-adder.
            // These lines are a 1-bit implementation of a full-adder, so ""c[99:0]"" are added with a 0-bit carry in.
            // In an actual implementation, ""c[99:0]"" should be a 100-bit wide variable.
            temp = a[99] ^ b[99] ^ c[99];
            c[99:0] = a[99:0] + b[99:0] + {1'b0, temp};
        end
    
    assign sum = {temp, c[99:1]};
    assign cout = c[99];

endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] cout_temp;
    reg [99:0] sum_temp;
    
    always @(*) begin
        temp = b[0] | cin;
        cout_temp[0] = temp;
        sum_temp[0] = a[0] ^ temp;
        
        for(int i = 1; i < 100; i++) begin
            temp = (b[i] | cin) ^ b[i-1];
            cout_temp[i] = temp;
            sum_temp[i] = a[i] ^ temp;
        end
    end
    
    assign cout = cout_temp;
    assign sum = sum_temp;
    
endmodule",-0.5,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] cout_temp;
    reg [99:0] sum_temp;
    
    always @(*) begin
        temp = b[0] | cin;
        cout_temp[0] = temp;
        sum_temp[0] = a[0] ^ temp;
        
        for(int i = 1; i < 100; i++) begin
            temp = (b[i] | cin) ^ b[i-1];
            cout_temp[i] = temp;
            sum_temp[i] = a[i] ^ temp;
        end
    end
    
    assign cout = cout_temp;
    assign sum = sum_temp;
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] cout_temp;
    reg [99:0] sum_temp;
    
    always @(*)
        begin
            // assign {cout_temp, sum_temp} = a + b + cin;
            {cout_temp, sum_temp} = a + b + cin;
            
            // assign {cout, sum} = {cout_temp, sum_temp};
            {cout, sum} = {cout_temp, sum_temp};
            
            // assign temp = cin ^ cout_temp;
            temp = cin ^ cout_temp;
        end
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] cout_temp;
    reg [99:0] sum_temp;
    
    always @(*)
        begin
            // assign {cout_temp, sum_temp} = a + b + cin;
            {cout_temp, sum_temp} = a + b + cin;
            
            // assign {cout, sum} = {cout_temp, sum_temp};
            {cout, sum} = {cout_temp, sum_temp};
            
            // assign temp = cin ^ cout_temp;
            temp = cin ^ cout_temp;
        end
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f1
            full_adder u1(a[i],b[i],cin,s[i],c[i]);
            assign cout[i] = c[i];
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f2
            full_adder u2(a[i],b[i],c[i],s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f3
            full_adder u3(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f4
            full_adder u4(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f5
            full_adder u5(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f6
            full_adder u6(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f7
            full_adder u7(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f8
            full_adder u8(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f9
            full_adder u9(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f10
            full_adder u10(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f11
            full_adder u11(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f12
            full_adder u12(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f13
            full_adder u13(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f14
            full_adder u14(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f1
            full_adder u1(a[i],b[i],cin,s[i],c[i]);
            assign cout[i] = c[i];
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f2
            full_adder u2(a[i],b[i],c[i],s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f3
            full_adder u3(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f4
            full_adder u4(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f5
            full_adder u5(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f6
            full_adder u6(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f7
            full_adder u7(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f8
            full_adder u8(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f9
            full_adder u9(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f10
            full_adder u10(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f11
            full_adder u11(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f12
            full_adder u12(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f13
            full_adder u13(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)
       begin: f14
            full_adder u14(a[i],b[i],cin,s[i],cout[i]);
       end
    endgenerate
    
    generate
       for(i=0; i<100; i=i+1)"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    always @(*)
        begin
            temp = a[0]+b[0]+cin;
            c[0] = temp[0];
            c[99:1] = temp[99:1];
        end
    
    //assign {cout[99:1],s[99:1]} = {c[99:1],cin}+{c[0],s[0]};
    always @(*)
        begin
            c[99:1] = a[99:1]+b[99:1]+c[0];
            cout[99:1] = c[99:1];
            cout[0] = c[0];
        end
    
    //assign {cout[99:1],s[99:1]} = {c[99:1],cin}+{c[0],s[0]};
    
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    always @(*)
        begin
            temp = a[0]+b[0]+cin;
            c[0] = temp[0];
            c[99:1] = temp[99:1];
        end
    
    //assign {cout[99:1],s[99:1]} = {c[99:1],cin}+{c[0],s[0]};
    always @(*)
        begin
            c[99:1] = a[99:1]+b[99:1]+c[0];
            cout[99:1] = c[99:1];
            cout[0] = c[0];
        end
    
    //assign {cout[99:1],s[99:1]} = {c[99:1],cin}+{c[0],s[0]};
    
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    always @(*)
        begin
            c[0] = a[0]+b[0]+cin;
            temp = c[0];
            c[99:1] = a[99:1]+b[99:1]+temp;
        end
    
    assign sum = c;
    assign cout = c[99];
    
endmodule",-0.5,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    always @(*)
        begin
            c[0] = a[0]+b[0]+cin;
            temp = c[0];
            c[99:1] = a[99:1]+b[99:1]+temp;
        end
    
    assign sum = c;
    assign cout = c[99];
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    always @(*)
    begin
        // The following 2 are for a 100-bit adder.
        c = a ^ b;
        temp = cin ^ c[99];
        c = c[98:0] ^ temp;
    end
    
    assign cout = c[99];
    assign sum = a ^ b ^ cin;
    
endmodule",-0.5,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    always @(*)
    begin
        // The following 2 are for a 100-bit adder.
        c = a ^ b;
        temp = cin ^ c[99];
        c = c[98:0] ^ temp;
    end
    
    assign cout = c[99];
    assign sum = a ^ b ^ cin;
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] sum_reg;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    always @(*)
        begin
            sum_reg[0] = a[0]+b[0]+cin;
            temp = cin;
            for(int i=1; i<100; i=i+1)
                begin
                    sum_reg[i] = a[i]+b[i]+temp;
                    temp = sum_reg[i-1];
                end
            
            cout[99:0] = sum_reg[99:0];
            
        end
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] sum_reg;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    always @(*)
        begin
            sum_reg[0] = a[0]+b[0]+cin;
            temp = cin;
            for(int i=1; i<100; i=i+1)
                begin
                    sum_reg[i] = a[i]+b[i]+temp;
                    temp = sum_reg[i-1];
                end
            
            cout[99:0] = sum_reg[99:0];
            
        end
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    
    always @(*)
        begin
            c[99] = a[99] ^ b[99] ^ cin;
            
            //sum[0] = a[0]^b[0]^cin;
            temp = a[0] ^ b[0];
            
            for(int i=1; i<100; i=i+1)
                begin
                    c[i] = temp ^ b[i];
                    //sum[i] = temp ^ b[i];
                    temp = temp ^ a[i];
                end
            
            cout[99] = c[99];
            cout[0] = c[0];
            
            //cout[0] = c[0];
        end
    
    assign sum = {cout[99:1],c[0]};
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] c;
    
    // assign {cout[0],s[0]} = a[0]+b[0]+cin;   //we can use this also
    
    always @(*)
        begin
            c[99] = a[99] ^ b[99] ^ cin;
            
            //sum[0] = a[0]^b[0]^cin;
            temp = a[0] ^ b[0];
            
            for(int i=1; i<100; i=i+1)
                begin
                    c[i] = temp ^ b[i];
                    //sum[i] = temp ^ b[i];
                    temp = temp ^ a[i];
                end
            
            cout[99] = c[99];
            cout[0] = c[0];
            
            //cout[0] = c[0];
        end
    
    assign sum = {cout[99:1],c[0]};
    
endmodule"
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] cout_temp;
    reg [99:0] sum_temp;
    
    always @(*)
    begin
        temp = cin;
        cout_temp = a + b + temp;
        sum_temp = a + b + temp;
    end
    
    assign cout = cout_temp[99:0];
    assign sum = sum_temp[99:0];

endmodule",-0.5,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    reg temp;
    reg [99:0] cout_temp;
    reg [99:0] sum_temp;
    
    always @(*)
    begin
        temp = cin;
        cout_temp = a + b + temp;
        sum_temp = a + b + temp;
    end
    
    assign cout = cout_temp[99:0];
    assign sum = sum_temp[99:0];

endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;

endmodule",-0.5,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;

endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // This is a combinational circuit
    
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign sum[1] = a[1] ^ b[1] ^ (a[0] & b[0] & cin);
    assign sum[2] = a[2] ^ b[2] ^ (a[1] & b[1] & (a[0] & b[0]) & cin);
    
    // This is a method to implement the same circuit
    
    function [2:0] adder(input [2:0] a, b, input cin);
        begin
            adder[0] = a[0] ^ b[0] ^ cin;
            adder[1] = a[1] ^ b[1] ^ (a[0] & b[0] & cin);
            adder[2] = a[2] ^ b[2] ^ (a[1] & b[1] & (a[0] & b[0]) & cin);
        end
    endfunction
    
    assign cout = adder(a, b, cin);
    
endmodule",-0.5,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // This is a combinational circuit
    
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign sum[1] = a[1] ^ b[1] ^ (a[0] & b[0] & cin);
    assign sum[2] = a[2] ^ b[2] ^ (a[1] & b[1] & (a[0] & b[0]) & cin);
    
    // This is a method to implement the same circuit
    
    function [2:0] adder(input [2:0] a, b, input cin);
        begin
            adder[0] = a[0] ^ b[0] ^ cin;
            adder[1] = a[1] ^ b[1] ^ (a[0] & b[0] & cin);
            adder[2] = a[2] ^ b[2] ^ (a[1] & b[1] & (a[0] & b[0]) & cin);
        end
    endfunction
    
    assign cout = adder(a, b, cin);
    
endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;

endmodule",-0.5,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;

endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;

endmodule",-0.5,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;

endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    wire [2:0] c;
    
    full_adder inst1 (a[0], b[0], cin,   sum[0], c[0]);
    full_adder inst2 (a[1], b[1], c[0],   sum[1], c[1]);
    full_adder inst3 (a[2], b[2], c[1],   sum[2], c[2]);
    full_adder inst4 (a[0], b[0], 1'b0,    sum[0], cout[0]);
    full_adder inst5 (a[1], b[1], 1'b0,    sum[1], cout[1]);
    full_adder inst6 (a[2], b[2], 1'b0,    sum[2], cout[2]);
    
endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    wire [2:0] c;
    
    full_adder inst1 (a[0], b[0], cin,   sum[0], c[0]);
    full_adder inst2 (a[1], b[1], c[0],   sum[1], c[1]);
    full_adder inst3 (a[2], b[2], c[1],   sum[2], c[2]);
    full_adder inst4 (a[0], b[0], 1'b0,    sum[0], cout[0]);
    full_adder inst5 (a[1], b[1], 1'b0,    sum[1], cout[1]);
    full_adder inst6 (a[2], b[2], 1'b0,    sum[2], cout[2]);
    
endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    wire [2:0] ca, cb, ca1, cb1, ca2, cb2, ca3, cb3, ca4, cb4, ca5, cb5, ca6, cb6, ca7, cb7, ca8, cb8, ca9, cb9, ca10, cb10, ca11, cb11, ca12, cb12, ca13, cb13, ca14, cb14, ca15, cb15, ca16, cb16, ca17, cb17, ca18, cb18, ca19, cb19, ca20, cb20, ca21, cb21, ca22, cb22, ca23, cb23, ca24, cb24, ca25, cb25, ca26, cb26, ca27, cb27, ca28, cb28, ca29, cb29, ca30, cb30, ca31, cb31, ca32, cb32, ca33, cb33, ca34, cb34, ca35, cb35, ca36, cb36, ca37, cb37, ca38, cb38, ca39, cb39, ca40, cb40, ca41, cb41, ca42, cb42, ca43, cb43, ca44, cb44, ca45, cb45, ca46, cb46, ca47, cb47, ca48, cb48, ca49, cb49, ca50, cb50, ca51, cb51, ca52, cb52, ca53, cb53, ca54, cb54, ca55, cb55, ca56, cb56, ca57, cb57, ca58, cb58, ca59, cb59, ca60, cb60, ca61, cb61, ca62, cb62, ca63, cb63, ca64, cb64, ca65, cb65, ca66, cb66, ca67, cb67, ca68, cb68, ca69, cb69, ca70, cb70, ca71, cb71, ca72, cb72, ca73, cb73, ca74, cb74, ca75, cb75, ca76, cb76, ca77, cb77, ca78, cb78, ca79, cb79, ca80, cb80, ca81, cb81, ca82, cb82, ca83, cb83, ca84, cb84, ca85, cb85, ca86, cb86, ca87, cb87, ca88, cb88, ca89, cb89, ca90, cb90, ca91, cb91, ca92, cb92, ca93, cb93, ca94, cb94, ca95, cb95, ca96, cb96, ca97, cb97, ca98, cb98, ca99, cb99, ca100, cb100, ca101, cb101, ca102, cb102, ca103, cb103, ca104, cb104, ca105, cb105, ca106, cb106, ca107, cb107, ca108, cb108, ca109, cb109, ca110, cb110, ca111, cb111, ca112, cb112, ca113, cb113, ca114, cb114, ca115, cb115, ca116, cb116, ca117, cb117, ca118, cb118, ca119, cb119, ca120, cb120, ca121, cb121, ca122, cb122, ca123, cb123, ca124, cb124, ca125, cb125, ca126, cb126, ca127, cb127, ca128, cb128, ca129, cb129, ca130, cb130, ca131, cb131, ca132, cb132, ca133, cb133, ca134, cb134, ca135, cb135, ca136, cb136, ca137, cb137, ca138, cb138, ca139, cb139, ca140, cb140, ca141, cb141, ca142, cb142, ca143, cb143, ca144, cb144, ca145, c",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    wire [2:0] ca, cb, ca1, cb1, ca2, cb2, ca3, cb3, ca4, cb4, ca5, cb5, ca6, cb6, ca7, cb7, ca8, cb8, ca9, cb9, ca10, cb10, ca11, cb11, ca12, cb12, ca13, cb13, ca14, cb14, ca15, cb15, ca16, cb16, ca17, cb17, ca18, cb18, ca19, cb19, ca20, cb20, ca21, cb21, ca22, cb22, ca23, cb23, ca24, cb24, ca25, cb25, ca26, cb26, ca27, cb27, ca28, cb28, ca29, cb29, ca30, cb30, ca31, cb31, ca32, cb32, ca33, cb33, ca34, cb34, ca35, cb35, ca36, cb36, ca37, cb37, ca38, cb38, ca39, cb39, ca40, cb40, ca41, cb41, ca42, cb42, ca43, cb43, ca44, cb44, ca45, cb45, ca46, cb46, ca47, cb47, ca48, cb48, ca49, cb49, ca50, cb50, ca51, cb51, ca52, cb52, ca53, cb53, ca54, cb54, ca55, cb55, ca56, cb56, ca57, cb57, ca58, cb58, ca59, cb59, ca60, cb60, ca61, cb61, ca62, cb62, ca63, cb63, ca64, cb64, ca65, cb65, ca66, cb66, ca67, cb67, ca68, cb68, ca69, cb69, ca70, cb70, ca71, cb71, ca72, cb72, ca73, cb73, ca74, cb74, ca75, cb75, ca76, cb76, ca77, cb77, ca78, cb78, ca79, cb79, ca80, cb80, ca81, cb81, ca82, cb82, ca83, cb83, ca84, cb84, ca85, cb85, ca86, cb86, ca87, cb87, ca88, cb88, ca89, cb89, ca90, cb90, ca91, cb91, ca92, cb92, ca93, cb93, ca94, cb94, ca95, cb95, ca96, cb96, ca97, cb97, ca98, cb98, ca99, cb99, ca100, cb100, ca101, cb101, ca102, cb102, ca103, cb103, ca104, cb104, ca105, cb105, ca106, cb106, ca107, cb107, ca108, cb108, ca109, cb109, ca110, cb110, ca111, cb111, ca112, cb112, ca113, cb113, ca114, cb114, ca115, cb115, ca116, cb116, ca117, cb117, ca118, cb118, ca119, cb119, ca120, cb120, ca121, cb121, ca122, cb122, ca123, cb123, ca124, cb124, ca125, cb125, ca126, cb126, ca127, cb127, ca128, cb128, ca129, cb129, ca130, cb130, ca131, cb131, ca132, cb132, ca133, cb133, ca134, cb134, ca135, cb135, ca136, cb136, ca137, cb137, ca138, cb138, ca139, cb139, ca140, cb140, ca141, cb141, ca142, cb142, ca143, cb143, ca144, cb144, ca145, c"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;
    
endmodule",-0.5,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;
    
endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    
    full_adder inst1_full_adder0(
       .a(a[0]),
       .b(b[0]),
       .cin(cin),
       .sum(sum[0]),
       .cout(cout[0])
    );
    
    full_adder inst1_full_adder1(
       .a(a[1]),
       .b(b[1]),
       .cin(cout[0]),
       .sum(sum[1]),
       .cout(cout[1])
    );
    
    full_adder inst1_full_adder2(
       .a(a[2]),
       .b(b[2]),
       .cin(cout[1]),
       .sum(sum[2]),
       .cout(cout[2])
    );
    
endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    
    full_adder inst1_full_adder0(
       .a(a[0]),
       .b(b[0]),
       .cin(cin),
       .sum(sum[0]),
       .cout(cout[0])
    );
    
    full_adder inst1_full_adder1(
       .a(a[1]),
       .b(b[1]),
       .cin(cout[0]),
       .sum(sum[1]),
       .cout(cout[1])
    );
    
    full_adder inst1_full_adder2(
       .a(a[2]),
       .b(b[2]),
       .cin(cout[1]),
       .sum(sum[2]),
       .cout(cout[2])
    );
    
endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;
    
endmodule",-0.5,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign {cout[2:0], sum[2:0]} = a + b + cin;
    assign {cout[2:0], sum[2:0]} = a + b + cin;
    
endmodule"
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    
    wire [2:0] temp;
    wire [2:0] temp2;
    wire [2:0] temp3;
    
    full_adder inst1 (a[0], b[0], cin, temp[0], temp2[0]);
    full_adder inst2 (a[1], b[1], temp[0], temp[1], temp2[1]);
    full_adder inst3 (a[2], b[2], temp[1], temp[2], temp2[2]);
    
    assign sum = temp;
    assign cout = temp2;
    
endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    
    wire [2:0] temp;
    wire [2:0] temp2;
    wire [2:0] temp3;
    
    full_adder inst1 (a[0], b[0], cin, temp[0], temp2[0]);
    full_adder inst2 (a[1], b[1], temp[0], temp[1], temp2[1]);
    full_adder inst3 (a[2], b[2], temp[1], temp[2], temp2[2]);
    
    assign sum = temp;
    assign cout = temp2;
    
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign	out_assign = a&b;
    always@(*) begin
       out_alwaysblock = a&b; 
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign	out_assign = a&b;
    always@(*) begin
       out_alwaysblock = a&b; 
    end
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

assign	out_assign = a&b;
always@(*) begin
    out_alwaysblock = a&b;
end

endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

assign	out_assign = a&b;
always@(*) begin
    out_alwaysblock = a&b;
end

endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

assign	out_assign = a&b;
always@(*) begin
    out_alwaysblock = a&b;
end

endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

assign	out_assign = a&b;
always@(*) begin
    out_alwaysblock = a&b;
end

endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign	out_assign = a&b;
    always@(*) begin
       out_alwaysblock = a&b; 
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign	out_assign = a&b;
    always@(*) begin
       out_alwaysblock = a&b; 
    end
endmodule"
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*)
        out_alwaysblock = a & b;
endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign	out_assign = a^b;
    always@(*) begin
       out_always_comb = a^b;
    end
    always@(posedge clk) begin
       out_always_ff = a^b;
    end
endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign	out_assign = a^b;
    always@(*) begin
       out_always_comb = a^b;
    end
    always@(posedge clk) begin
       out_always_ff = a^b;
    end
endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign	out_assign = a^b;
    always@(*) begin
       out_always_comb = a^b;
    end
    always@(posedge clk) begin
       out_always_ff <= a^b;
    end

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign	out_assign = a^b;
    always@(*) begin
       out_always_comb = a^b;
    end
    always@(posedge clk) begin
       out_always_ff <= a^b;
    end

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*)
        out_always_comb <= a ^ b;
    always @(posedge clk)
        out_always_ff <= a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*)
        out_always_comb <= a ^ b;
    always @(posedge clk)
        out_always_ff <= a ^ b;

endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb <= a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
    
endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
    
    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb <= a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end
    
endmodule"
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff <= a ^ b;
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0 : out = data0;
            3'd1 : out = data1;
            3'd2 : out = data2;
            3'd3 : out = data3;
            3'd4 : out = data4;
            3'd5 : out = data5;
            default : out = 4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0 : out = data0;
            3'd1 : out = data1;
            3'd2 : out = data2;
            3'd3 : out = data3;
            3'd4 : out = data4;
            3'd5 : out = data5;
            default : out = 4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out=data0;
            3'd1:	out=data1;
            3'd2:	out=data2;
            3'd3:	out=data3;
            3'd4:	out=data4;
            3'd5:	out=data5;
            default:	out=4'b0000;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out=data0;
            3'd1:	out=data1;
            3'd2:	out=data2;
            3'd3:	out=data3;
            3'd4:	out=data4;
            3'd5:	out=data5;
            default:	out=4'b0000;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out=data0;
            3'd1:	out=data1;
            3'd2:	out=data2;
            3'd3:	out=data3;
            3'd4:	out=data4;
            3'd5:	out=data5;
            default:	out=4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out=data0;
            3'd1:	out=data1;
            3'd2:	out=data2;
            3'd3:	out=data3;
            3'd4:	out=data4;
            3'd5:	out=data5;
            default:	out=4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        // This is a combinational always block
        // There is only 1 assign statement, 
        // so it is inferred that out has a value.
        // It is also'reg' because it is writing to memory
        out = sel;
    end

endmodule",-0.5,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        // This is a combinational always block
        // There is only 1 assign statement, 
        // so it is inferred that out has a value.
        // It is also'reg' because it is writing to memory
        out = sel;
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out=data0;
            3'd1:	out=data1;
            3'd2:	out=data2;
            3'd3:	out=data3;
            3'd4:	out=data4;
            3'd5:	out=data5;
            default:	out=4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out=data0;
            3'd1:	out=data1;
            3'd2:	out=data2;
            3'd3:	out=data3;
            3'd4:	out=data4;
            3'd5:	out=data5;
            default:	out=4'b0;
        endcase
    end

endmodule"
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0:	out = data0;
            3'd1:	out = data1;
            3'd2:	out = data2;
            3'd3:	out = data3;
            3'd4:	out = data4;
            3'd5:	out = data5;
            default:	out = 4'b0;
        endcase
    end

endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always@(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    	else
        	pos = 2'd3;
endmodule",1,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always@(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    	else
        	pos = 2'd3;
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        case (in)
            4'b1000: pos = 2'd0;
            4'bx100: pos = 2'd1;
            4'bxx10: pos = 2'd2;
            4'bxxx1: pos = 2'd3;
            default: pos = 2'dx;
        endcase
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        case (in)
            4'b1000: pos = 2'd0;
            4'bx100: pos = 2'd1;
            4'bxx10: pos = 2'd2;
            4'bxxx1: pos = 2'd3;
            default: pos = 2'dx;
        endcase
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    	else if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 2'd1;
    	else if(in[2])
            pos = 2'd2;
    	else if(in[3])
            pos = 2'd3;
    
endmodule",1,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    	else if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 2'd1;
    	else if(in[2])
            pos = 2'd2;
    	else if(in[3])
            pos = 2'd3;
    
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    else if(in[3])
        	pos = 2'd3;
    else
        	pos = 2'd0;
endmodule",1,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    else if(in[3])
        	pos = 2'd3;
    else
        	pos = 2'd0;
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        casex (in)
            4'b1000: pos = 2'd0;
            4'bx100: pos = 2'd1;
            4'bxx10: pos = 2'd2;
            4'bxxx1: pos = 2'd3;
            default: pos = 2'dx;
        endcase
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        casex (in)
            4'b1000: pos = 2'd0;
            4'bx100: pos = 2'd1;
            4'bxx10: pos = 2'd2;
            4'bxxx1: pos = 2'd3;
            default: pos = 2'dx;
        endcase
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    else if(in[3])
        	pos = 2'd3;
    else
        	pos = 2'd0;
endmodule",1,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    else if(in[3])
        	pos = 2'd3;
    else
        	pos = 2'd0;
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    else if(in[3])
        	pos = 2'd3;
    else
        	pos = 2'd0;
endmodule",1,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        if(in == 0)
            pos = 0;
    else if(in[0])
            pos = 0;
    else if(in[1])
        	pos = 2'd1;
    else if(in[2])
        	pos = 2'd2;
    else if(in[3])
        	pos = 2'd3;
    else
        	pos = 2'd0;
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always@(*)
        begin
            casex(in)  //it can also be solved using casez we have to use 'z' instead of 'x' in case statements
                4'b0000: pos=2'b00; 
                4'b0001: pos=2'b01;
                4'b0010: pos=2'b10;
                4'b0011: pos=2'b11;
                default pos=2'bxx;
            endcase
        end
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always@(*)
        begin
            casex(in)  //it can also be solved using casez we have to use 'z' instead of 'x' in case statements
                4'b0000: pos=2'b00; 
                4'b0001: pos=2'b01;
                4'b0010: pos=2'b10;
                4'b0011: pos=2'b11;
                default pos=2'bxx;
            endcase
        end
endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always@(*)
        if(in == 0)
            pos = 0;
    else
            pos = in[0]? 0 : in[1]? 1 : in[2]? 2 : in[3]? 3 : 0;

endmodule",1,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always@(*)
        if(in == 0)
            pos = 0;
    else
            pos = in[0]? 0 : in[1]? 1 : in[2]? 2 : in[3]? 3 : 0;

endmodule"
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        casex (in)
            4'b1000: pos = 2'd0;
            4'bx100: pos = 2'd1;
            4'bxx10: pos = 2'd2;
            4'bxxx1: pos = 2'd3;
            default: pos = 2'd0;
        endcase
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        casex (in)
            4'b1000: pos = 2'd0;
            4'bx100: pos = 2'd1;
            4'bxx10: pos = 2'd2;
            4'bxxx1: pos = 2'd3;
            default: pos = 2'd0;
        endcase
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
        else if(in[1])
            pos = 1;
        else if(in[2])
            pos = 2;
        else if(in[3])
            pos = 3;
        else if(in[4])
            pos = 4;
        else if(in[5])
            pos = 5;
        else if(in[6])
            pos = 6;
        else if(in[7])
            pos = 7;
        else
            pos = 0;
            
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
        else if(in[1])
            pos = 1;
        else if(in[2])
            pos = 2;
        else if(in[3])
            pos = 3;
        else if(in[4])
            pos = 4;
        else if(in[5])
            pos = 5;
        else if(in[6])
            pos = 6;
        else if(in[7])
            pos = 7;
        else
            pos = 0;
            
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in == 8'b1000_0000)
            pos = 3'd0;
    	else if(in == 8'b0100_0000)
            pos = 3'd1;
    	else if(in == 8'b0010_0000)
            pos = 3'd2;
    	else if(in == 8'b0001_0000)
            pos = 3'd3;
    	else
            pos = 3'd4;
            
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in == 8'b1000_0000)
            pos = 3'd0;
    	else if(in == 8'b0100_0000)
            pos = 3'd1;
    	else if(in == 8'b0010_0000)
            pos = 3'd2;
    	else if(in == 8'b0001_0000)
            pos = 3'd3;
    	else
            pos = 3'd4;
            
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex ( in )
            8'b1xxx_x000:  pos = 3'd0;
            8'b01xx_x001:  pos = 3'd1;
            8'b001x_x010:  pos = 3'd2;
            8'b0001_x011:  pos = 3'd3;
            8'b1000_x100:  pos = 3'd4;
            8'b1001_x101:  pos = 3'd5;
            8'b1010_x110:  pos = 3'd6;
            8'b1011_x111:  pos = 3'd7;
            default:        pos = 3'dx;
        endcase
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex ( in )
            8'b1xxx_x000:  pos = 3'd0;
            8'b01xx_x001:  pos = 3'd1;
            8'b001x_x010:  pos = 3'd2;
            8'b0001_x011:  pos = 3'd3;
            8'b1000_x100:  pos = 3'd4;
            8'b1001_x101:  pos = 3'd5;
            8'b1010_x110:  pos = 3'd6;
            8'b1011_x111:  pos = 3'd7;
            default:        pos = 3'dx;
        endcase
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 1;
    	else if(in[2])
            pos = 2;
    	else if(in[3])
            pos = 3;
    	else if(in[4])
            pos = 4;
    	else if(in[5])
            pos = 5;
    	else if(in[6])
            pos = 6;
    	else if(in[7])
            pos = 7;
    	else
            pos = 0;
            
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 1;
    	else if(in[2])
            pos = 2;
    	else if(in[3])
            pos = 3;
    	else if(in[4])
            pos = 4;
    	else if(in[5])
            pos = 5;
    	else if(in[6])
            pos = 6;
    	else if(in[7])
            pos = 7;
    	else
            pos = 0;
            
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex ( in )
            8'b1x100100: pos = 3'd4;
            8'b1000x1000: pos = 3'd3;
            8'b1010x1010: pos = 3'd2;
            8'b11xx_11xx_11xx_11xx: pos = 3'd1;
            default: pos = 3'd0;
        endcase

endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex ( in )
            8'b1x100100: pos = 3'd4;
            8'b1000x1000: pos = 3'd3;
            8'b1010x1010: pos = 3'd2;
            8'b11xx_11xx_11xx_11xx: pos = 3'd1;
            default: pos = 3'd0;
        endcase

endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 1;
    	else if(in[2])
            pos = 2;
    	else if(in[3])
            pos = 3;
    	else if(in[4])
            pos = 4;
    	else if(in[5])
            pos = 5;
    	else if(in[6])
            pos = 6;
    	else if(in[7])
            pos = 7;
    	else
            pos = 0;
            
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 1;
    	else if(in[2])
            pos = 2;
    	else if(in[3])
            pos = 3;
    	else if(in[4])
            pos = 4;
    	else if(in[5])
            pos = 5;
    	else if(in[6])
            pos = 6;
    	else if(in[7])
            pos = 7;
    	else
            pos = 0;
            
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex ( in )
            8'b1x100100: pos = 3'd4;
            8'b10100101: pos = 3'd3;
            8'b10101010: pos = 3'd2;
            8'b10101011: pos = 3'd1;
            8'b10101100: pos = 3'd0;
            default: pos = 3'dx;
        endcase
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex ( in )
            8'b1x100100: pos = 3'd4;
            8'b10100101: pos = 3'd3;
            8'b10101010: pos = 3'd2;
            8'b10101011: pos = 3'd1;
            8'b10101100: pos = 3'd0;
            default: pos = 3'dx;
        endcase
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex (in)
            8'b1xxx_x000:  pos = 3'd0;
            8'b01xx_x001:  pos = 3'd1;
            8'b001x_x010:  pos = 3'd2;
            8'b0001_x011:  pos = 3'd3;
            8'b0001_x100:  pos = 3'd4;
            8'b0001_x001:  pos = 3'd5;
            8'b0011_x011:  pos = 3'd6;
            8'b0011_x001:  pos = 3'd7;
            default:        pos = 3'dx;
        endcase
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        casex (in)
            8'b1xxx_x000:  pos = 3'd0;
            8'b01xx_x001:  pos = 3'd1;
            8'b001x_x010:  pos = 3'd2;
            8'b0001_x011:  pos = 3'd3;
            8'b0001_x100:  pos = 3'd4;
            8'b0001_x001:  pos = 3'd5;
            8'b0011_x011:  pos = 3'd6;
            8'b0011_x001:  pos = 3'd7;
            default:        pos = 3'dx;
        endcase
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in == 8'b11111111)
            pos = 3'd7;
    	else if(in[0])
            pos = 3'd0;
        else if(in[1])
            pos = 3'd1;
        else if(in[2])
            pos = 3'd2;
        else if(in[3])
            pos = 3'd3;
        else if(in[4])
            pos = 3'd4;
        else if(in[5])
            pos = 3'd5;
        else if(in[6])
            pos = 3'd6;
        else if(in[7])
            pos = 3'd7;
        else
            pos = 3'bxxx;
            
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in == 8'b11111111)
            pos = 3'd7;
    	else if(in[0])
            pos = 3'd0;
        else if(in[1])
            pos = 3'd1;
        else if(in[2])
            pos = 3'd2;
        else if(in[3])
            pos = 3'd3;
        else if(in[4])
            pos = 3'd4;
        else if(in[5])
            pos = 3'd5;
        else if(in[6])
            pos = 3'd6;
        else if(in[7])
            pos = 3'd7;
        else
            pos = 3'bxxx;
            
endmodule"
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 1;
    	else if(in[2])
            pos = 2;
    	else if(in[3])
            pos = 3;
    	else if(in[4])
            pos = 4;
    	else if(in[5])
            pos = 5;
    	else if(in[6])
            pos = 6;
    	else if(in[7])
            pos = 7;
    	else
            pos = 0;
            
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule","module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    
    always @(*)
        if(in[0])
            pos = 0;
    	else if(in[1])
            pos = 1;
    	else if(in[2])
            pos = 2;
    	else if(in[3])
            pos = 3;
    	else if(in[4])
            pos = 4;
    	else if(in[5])
            pos = 5;
    	else if(in[6])
            pos = 6;
    	else if(in[7])
            pos = 7;
    	else
            pos = 0;
            
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always @(*)
        begin
            if(sel_b1&sel_b2)
                out_always = b;
            else
                out_always = a;
        end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always @(*)
        begin
            if(sel_b1&sel_b2)
                out_always = b;
            else
                out_always = a;
        end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)?b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)?b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)? b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)?b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1&sel_b2)?b:a;
    always @(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign	out_assign = (sel_b1&sel_b2)?b:a;
    always@(*) begin
        if(sel_b1&sel_b2)
            out_always = b;
        else
            out_always = a;
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always@(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left=1;
            16'he072: down=1;
            16'he074: right=1;
            16'he075: up=1;
           
                endcase
                end

endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always@(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left=1;
            16'he072: down=1;
            16'he074: right=1;
            16'he075: up=1;
           
                endcase
                end

endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0;
        down = 0;
        right = 0;
        up = 0;
        
        case(scancode)
            16'he06b: left = 1;
            16'he072: down = 1;
            16'he074: right = 1;
            16'he075: up = 1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0;
        down = 0;
        right = 0;
        up = 0;
        
        case(scancode)
            16'he06b: left = 1;
            16'he072: down = 1;
            16'he074: right = 1;
            16'he075: up = 1;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always@(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always@(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always@(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always@(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case(scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
            default: up = 1'b0;
        endcase
    end
    
endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule"
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;

endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    assign carry[0]  =  cin;
    assign cout = carry[16];
    
    genvar i;
    generate
        for (i=0; i<16; i=i+1)
            assign sum[i] = a[i] ^ b[i] ^ carry[i];
    endgenerate
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    assign carry[0]  =  cin;
    assign cout = carry[16];
    
    genvar i;
    generate
        for (i=0; i<16; i=i+1)
            assign sum[i] = a[i] ^ b[i] ^ carry[i];
    endgenerate
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], 1'b0, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], 1'b0, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] ca_0, ca_1, ca_2, ca_3, ca_4, ca_5, ca_6, ca_7, ca_8, ca_9, ca_10, ca_11, ca_12, ca_13, ca_14, ca_15, ca_16;
    wire [15:0] ca_17, ca_18, ca_19, ca_20, ca_21, ca_22, ca_23, ca_24, ca_25, ca_26, ca_27, ca_28, ca_29, ca_30, ca_31, ca_32, ca_33, ca_34, ca_35, ca_36, ca_37, ca_38, ca_39, ca_40, ca_41, ca_42, ca_43, ca_44, ca_45, ca_46, ca_47, ca_48, ca_49, ca_50, ca_51, ca_52, ca_53, ca_54, ca_55, ca_56, ca_57, ca_58, ca_59, ca_60, ca_61, ca_62, ca_63, ca_64, ca_65, ca_66, ca_67, ca_68, ca_69, ca_70, ca_71, ca_72, ca_73, ca_74, ca_75, ca_76, ca_77, ca_78, ca_79, ca_80, ca_81, ca_82, ca_83, ca_84, ca_85, ca_86, ca_87, ca_88, ca_89, ca_90, ca_91, ca_92, ca_93, ca_94, ca_95, ca_96, ca_97, ca_98, ca_99, ca_100, ca_101, ca_102, ca_103, ca_104, ca_105, ca_106, ca_107, ca_108, ca_109, ca_110, ca_111, ca_112, ca_113, ca_114, ca_115, ca_116, ca_117, ca_118, ca_119, ca_120, ca_121, ca_122, ca_123, ca_124, ca_125, ca_126, ca_127, ca_128, ca_129, ca_130, ca_131, ca_132, ca_133, ca_134, ca_135, ca_136, ca_137, ca_138, ca_139, ca_140, ca_141, ca_142, ca_143, ca_144, ca_145, ca_146, ca_147, ca_148, ca_149, ca_150, ca_151, ca_152, ca_153, ca_154, ca_155, ca_156, ca_157, ca_158, ca_159, ca_160, ca_161, ca_162, ca_163, ca_164, ca_165, ca_166, ca_167, ca_168, ca_169, ca_170, ca_171, ca_172, ca_173, ca_174, ca_175, ca_176, ca_177, ca_178, ca_179, ca_180, ca_181, ca_182, ca_183, ca_184, ca_185, ca_186, ca_187, ca_188, ca_189, ca_190, ca_191, ca_192, ca_193, ca_194, ca_195, ca_196, ca_197, ca_198, ca_199, ca_200, ca_201, ca_202, ca_203, ca_204, ca_205, ca_206, ca_207, ca_208, ca_209, ca_210, ca_211, ca_212, ca_213, ca_214, ca_215, ca_216, ca_217, ca_218, ca_219, ca_220, ca_221, ca_222, ca_223, ca_224, ca_225, ca_226, ca_227, ca_228, ca_229, ca_230, ca_231, ca_232, ca_233, ca_234, ca_235, ca_236, ca_237, ca_238, ca_239, ca_240, ca_241, ca_242, ca_243, ca_244, ca_245, ca_246, ca_247, ca_248, ca_249, ca_250, ca_251",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] ca_0, ca_1, ca_2, ca_3, ca_4, ca_5, ca_6, ca_7, ca_8, ca_9, ca_10, ca_11, ca_12, ca_13, ca_14, ca_15, ca_16;
    wire [15:0] ca_17, ca_18, ca_19, ca_20, ca_21, ca_22, ca_23, ca_24, ca_25, ca_26, ca_27, ca_28, ca_29, ca_30, ca_31, ca_32, ca_33, ca_34, ca_35, ca_36, ca_37, ca_38, ca_39, ca_40, ca_41, ca_42, ca_43, ca_44, ca_45, ca_46, ca_47, ca_48, ca_49, ca_50, ca_51, ca_52, ca_53, ca_54, ca_55, ca_56, ca_57, ca_58, ca_59, ca_60, ca_61, ca_62, ca_63, ca_64, ca_65, ca_66, ca_67, ca_68, ca_69, ca_70, ca_71, ca_72, ca_73, ca_74, ca_75, ca_76, ca_77, ca_78, ca_79, ca_80, ca_81, ca_82, ca_83, ca_84, ca_85, ca_86, ca_87, ca_88, ca_89, ca_90, ca_91, ca_92, ca_93, ca_94, ca_95, ca_96, ca_97, ca_98, ca_99, ca_100, ca_101, ca_102, ca_103, ca_104, ca_105, ca_106, ca_107, ca_108, ca_109, ca_110, ca_111, ca_112, ca_113, ca_114, ca_115, ca_116, ca_117, ca_118, ca_119, ca_120, ca_121, ca_122, ca_123, ca_124, ca_125, ca_126, ca_127, ca_128, ca_129, ca_130, ca_131, ca_132, ca_133, ca_134, ca_135, ca_136, ca_137, ca_138, ca_139, ca_140, ca_141, ca_142, ca_143, ca_144, ca_145, ca_146, ca_147, ca_148, ca_149, ca_150, ca_151, ca_152, ca_153, ca_154, ca_155, ca_156, ca_157, ca_158, ca_159, ca_160, ca_161, ca_162, ca_163, ca_164, ca_165, ca_166, ca_167, ca_168, ca_169, ca_170, ca_171, ca_172, ca_173, ca_174, ca_175, ca_176, ca_177, ca_178, ca_179, ca_180, ca_181, ca_182, ca_183, ca_184, ca_185, ca_186, ca_187, ca_188, ca_189, ca_190, ca_191, ca_192, ca_193, ca_194, ca_195, ca_196, ca_197, ca_198, ca_199, ca_200, ca_201, ca_202, ca_203, ca_204, ca_205, ca_206, ca_207, ca_208, ca_209, ca_210, ca_211, ca_212, ca_213, ca_214, ca_215, ca_216, ca_217, ca_218, ca_219, ca_220, ca_221, ca_222, ca_223, ca_224, ca_225, ca_226, ca_227, ca_228, ca_229, ca_230, ca_231, ca_232, ca_233, ca_234, ca_235, ca_236, ca_237, ca_238, ca_239, ca_240, ca_241, ca_242, ca_243, ca_244, ca_245, ca_246, ca_247, ca_248, ca_249, ca_250, ca_251"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] cout_w;
    
    bcd_fadd inst1 ( a[3:0], b[3:0], 1'b0, cout_w[0], sum[3:0] );
    bcd_fadd inst2 ( a[7:4], b[7:4], cout_w[0], cout_w[1], sum[7:4] );
    bcd_fadd inst3 ( a[11:8], b[11:8], cout_w[1], cout_w[2], sum[11:8] );
    bcd_fadd inst4 ( a[15:12], b[15:12], cout_w[2], cout, sum[15:12] );
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] cout_w;
    
    bcd_fadd inst1 ( a[3:0], b[3:0], 1'b0, cout_w[0], sum[3:0] );
    bcd_fadd inst2 ( a[7:4], b[7:4], cout_w[0], cout_w[1], sum[7:4] );
    bcd_fadd inst3 ( a[11:8], b[11:8], cout_w[1], cout_w[2], sum[11:8] );
    bcd_fadd inst4 ( a[15:12], b[15:12], cout_w[2], cout, sum[15:12] );
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] ca_0, ca_1; // carry-out of each full-adder
    wire [3:0]   co_0, co_1; // carry-out of each ripple-carry adder
    wire [3:0]   si_0, si_1; // (input) sum of each ripple-carry adder
    wire [7:0]   su_0, su_1; // (output) sum in base-10
    wire [7:0]   su_0_b, su_1_b;
    wire [3:0]   si_0_b, si_1_b;
    wire [15:0]  su_0_a, su_1_a;
    wire [15:0]  si_0_a, si_1_a;
    wire [3:0]   co_0_0, co_0_1, co_0_2, co_0_3;
    wire [3:0]   co_1_0, co_1_1, co_1_2, co_1_3;
    wire [3:0]   co_2_0, co_2_1, co_2_2, co_2_3;
    wire [3:0]   co_3_0, co_3_1, co_3_2, co_3_3;
    wire [7:0]   su_0_0, su_0_1, su_0_2, su_0_3, su_0_4, su_0_5, su_0_6, su_0_7;
    wire [7:0]   su_1_0, su_1_1, su_1_2, su_1_3, su_1_4, su_1_5, su_1_6, su_1_7;
    wire [3:0]   si_0_0, si_0_1, si_0_2, si_0_3, si_1_0, si_1_1, si_1_2, si_1_3;
    wire [3:0]   si_2_0, si_2_1, si_2_2, si_2_3, si_3_0, si_3_1, si_3_2, si_3_3;
    wire [3:0]   si_4_0, si_4_1, si_4_2, si_4_3, si_5_0, si_5_1, si_5_2, si_5_3;
    wire [3:0]   si_6_0, si_6_1, si_6_2, si_6_3, si_7_0, si_7_1, si_7_2, si_7_3;
    wire [3:0]   si_8_0, si_8_1, si_8_2, si_8_3, si_9_0, si_9_1, si_9_2, si_9_3;
    wire [3:0]   si_10_0, si_10_1, si_10_2, si_10_3, si_11_0, si_11_1, si_11_2, si_11_3;
    wire [3:0]   si_12_0, si_12_1, si_12_2, si_12_3, si_13_0, si_13_1, si_13_2, si_13_3;
    wire [3:0]   si_14_0, si_14_1, si_14_2, si_14_3, si_15_0, si_15_1, si_15_2, si_15_3;
    wire [3:0]   si_16_0, si_16_1, si_16_2, si_16_3, si_17_0, si_17_1, si_17_2, si_17_3;
    wire [3:0]   si_18_0, si_18_1, si_18_2, si_18_3, si_19_0, si_19_1, si_19_2, si_19_3;
    wire [3:0]   si_20_0,",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] ca_0, ca_1; // carry-out of each full-adder
    wire [3:0]   co_0, co_1; // carry-out of each ripple-carry adder
    wire [3:0]   si_0, si_1; // (input) sum of each ripple-carry adder
    wire [7:0]   su_0, su_1; // (output) sum in base-10
    wire [7:0]   su_0_b, su_1_b;
    wire [3:0]   si_0_b, si_1_b;
    wire [15:0]  su_0_a, su_1_a;
    wire [15:0]  si_0_a, si_1_a;
    wire [3:0]   co_0_0, co_0_1, co_0_2, co_0_3;
    wire [3:0]   co_1_0, co_1_1, co_1_2, co_1_3;
    wire [3:0]   co_2_0, co_2_1, co_2_2, co_2_3;
    wire [3:0]   co_3_0, co_3_1, co_3_2, co_3_3;
    wire [7:0]   su_0_0, su_0_1, su_0_2, su_0_3, su_0_4, su_0_5, su_0_6, su_0_7;
    wire [7:0]   su_1_0, su_1_1, su_1_2, su_1_3, su_1_4, su_1_5, su_1_6, su_1_7;
    wire [3:0]   si_0_0, si_0_1, si_0_2, si_0_3, si_1_0, si_1_1, si_1_2, si_1_3;
    wire [3:0]   si_2_0, si_2_1, si_2_2, si_2_3, si_3_0, si_3_1, si_3_2, si_3_3;
    wire [3:0]   si_4_0, si_4_1, si_4_2, si_4_3, si_5_0, si_5_1, si_5_2, si_5_3;
    wire [3:0]   si_6_0, si_6_1, si_6_2, si_6_3, si_7_0, si_7_1, si_7_2, si_7_3;
    wire [3:0]   si_8_0, si_8_1, si_8_2, si_8_3, si_9_0, si_9_1, si_9_2, si_9_3;
    wire [3:0]   si_10_0, si_10_1, si_10_2, si_10_3, si_11_0, si_11_1, si_11_2, si_11_3;
    wire [3:0]   si_12_0, si_12_1, si_12_2, si_12_3, si_13_0, si_13_1, si_13_2, si_13_3;
    wire [3:0]   si_14_0, si_14_1, si_14_2, si_14_3, si_15_0, si_15_1, si_15_2, si_15_3;
    wire [3:0]   si_16_0, si_16_1, si_16_2, si_16_3, si_17_0, si_17_1, si_17_2, si_17_3;
    wire [3:0]   si_18_0, si_18_1, si_18_2, si_18_3, si_19_0, si_19_1, si_19_2, si_19_3;
    wire [3:0]   si_20_0,"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd inst1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd inst1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule"
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], 1'b0, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [16:0] carry;
    
    bcd_fadd ins1 (a[3:0], b[3:0], 1'b0, carry[0], sum[3:0]);
    bcd_fadd ins2 (a[7:4], b[7:4], carry[0], carry[1], sum[7:4]);
    bcd_fadd ins3 (a[11:8], b[11:8], carry[1], carry[2], sum[11:8]);
    bcd_fadd ins4 (a[15:12], b[15:12], carry[2], cout, sum[15:12]);
    
endmodule"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    
    wire [399:0] cout_temp;
    wire [399:0] sum_temp;
    
    genvar i;
    
    generate
        for(i=0; i<400; i=i+1)
            begin: r_loop
                bcd_fadd inst1 (a[3*i+3:3*i], b[3*i+3:3*i], cin, cout_temp[3*i+3:3*i], sum_temp[3*i+3:3*i]);
            end
    endgenerate
    
    assign cout = cout_temp[399];
    assign sum = sum_temp[399:0];
    
endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    
    wire [399:0] cout_temp;
    wire [399:0] sum_temp;
    
    genvar i;
    
    generate
        for(i=0; i<400; i=i+1)
            begin: r_loop
                bcd_fadd inst1 (a[3*i+3:3*i], b[3*i+3:3*i], cin, cout_temp[3*i+3:3*i], sum_temp[3*i+3:3*i]);
            end
    endgenerate
    
    assign cout = cout_temp[399];
    assign sum = sum_temp[399:0];
    
endmodule"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    
    wire [399:0] cout_temp;
    bcd_fadd inst1_bcd_fadd0 (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(cout_temp[0]),
       .sum(sum[3:0])
    );
    
    generate
       genvar i;
       for(i = 4; i < 400; i = i+4) begin : inst
            bcd_fadd inst1_bcd_faddi (
               .a(a[i+3:i]),
               .b(b[i+3:i]),
               .cin(cout_temp[i/4-1]),
               .cout(cout_temp[i/4]),
               .sum(sum[i+3:i])
            );
        end
    endgenerate
    
    assign cout = cout_temp[99];
    
endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    
    wire [399:0] cout_temp;
    bcd_fadd inst1_bcd_fadd0 (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(cout_temp[0]),
       .sum(sum[3:0])
    );
    
    generate
       genvar i;
       for(i = 4; i < 400; i = i+4) begin : inst
            bcd_fadd inst1_bcd_faddi (
               .a(a[i+3:i]),
               .b(b[i+3:i]),
               .cin(cout_temp[i/4-1]),
               .cout(cout_temp[i/4]),
               .sum(sum[i+3:i])
            );
        end
    endgenerate
    
    assign cout = cout_temp[99];
    
endmodule"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// This is a combinational circuit
// The output is calculated as a*b+c*cin
// The circuit is created by instantiating the module
// and defining the input and output ports.
// The module is declared as a combinational logic
// function, although it can be defined
// as a task (combinatorial logic)
// as well.

// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// This is a combinational circuit
// The output is calculated as a*b+c*cin
// The circuit is created by instantiating the module
// and defining the input and output ports.
// The module is declared as a combinational logic
// function, although it can be defined
// as a task (combinatorial logic)
// as well.

// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by
// the genvar statements.
// The genvars are used to name the
// ports and give them default values.
// The module instantiates three of them
// The three instances are created by"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_temp;
    
    bcd_fadd inst1 (a[3:0], b[3:0], 1'b0, cout_temp[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], cout_temp[2], cout_temp[3], sum[15:12]);
    bcd_fadd inst5 (a[19:16], b[19:16], cout_temp[3], cout_temp[4], sum[19:16]);
    bcd_fadd inst6 (a[23:20], b[23:20], cout_temp[4], cout_temp[5], sum[23:20]);
    bcd_fadd inst7 (a[27:24], b[27:24], cout_temp[5], cout_temp[6], sum[27:24]);
    bcd_fadd inst8 (a[31:28], b[31:28], cout_temp[6], cout_temp[7], sum[31:28]);
    bcd_fadd inst9 (a[35:32], b[35:32], cout_temp[7], cout_temp[8], sum[35:32]);
    bcd_fadd inst10 (a[39:36], b[39:36], cout_temp[8], cout_temp[9], sum[39:36]);
    bcd_fadd inst11 (a[43:40], b[43:40], cout_temp[9], cout_temp[10], sum[43:40]);
    bcd_fadd inst12 (a[47:44], b[47:44], cout_temp[10], cout_temp[11], sum[47:44]);
    bcd_fadd inst13 (a[51:48], b[51:48], cout_temp[11], cout_temp[12], sum[51:48]);
    bcd_fadd inst14 (a[55:52], b[55:52], cout_temp[12], cout_temp[13], sum[55:52]);
    bcd_fadd inst15 (a[59:56], b[59:56], cout_temp[13], cout_temp[14], sum[59:56]);
    bcd_fadd inst16 (a[63:60], b[63:60], cout_temp[14], cout_temp[15], sum[63:60]);
    bcd_fadd inst17 (a[67:64], b[67:64], cout_temp[15], cout_temp[16], sum[67:64]);
    bcd_fadd inst18 (a[71:68], b[71:68], cout_temp[16], cout_temp[17], sum[71:68]);
    bcd_fadd inst19 (a[75:72], b[75:72], cout_temp[17], cout_temp[18], sum[75:72]);
    bcd_fadd inst20 (a[79:76], b[79:76], cout_temp[18], cout_temp[19], sum[79:76]);
    bcd_fadd inst21 (a[83:80], b[83:80], cout_temp[19], cout_temp[20], sum[83:80]);
    bcd_fadd inst22 (a[87:84], b[87:84], cout_temp[20], cout_temp[21], sum[87:84]);
    bcd_fadd inst23 (a[91:88], b[91:88], cout_temp[21], cout_temp[22], sum[91:88]);
    bcd_fadd inst24 (a[95:92], b[95:92], cout_temp[22], cout_temp[23], sum[95:92]);
    bcd_fadd inst25 (a[99:96], b[99:96], cout_temp[23], cout_temp[24], sum[99:96]);
    bcd_fadd inst26",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_temp;
    
    bcd_fadd inst1 (a[3:0], b[3:0], 1'b0, cout_temp[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], cout_temp[2], cout_temp[3], sum[15:12]);
    bcd_fadd inst5 (a[19:16], b[19:16], cout_temp[3], cout_temp[4], sum[19:16]);
    bcd_fadd inst6 (a[23:20], b[23:20], cout_temp[4], cout_temp[5], sum[23:20]);
    bcd_fadd inst7 (a[27:24], b[27:24], cout_temp[5], cout_temp[6], sum[27:24]);
    bcd_fadd inst8 (a[31:28], b[31:28], cout_temp[6], cout_temp[7], sum[31:28]);
    bcd_fadd inst9 (a[35:32], b[35:32], cout_temp[7], cout_temp[8], sum[35:32]);
    bcd_fadd inst10 (a[39:36], b[39:36], cout_temp[8], cout_temp[9], sum[39:36]);
    bcd_fadd inst11 (a[43:40], b[43:40], cout_temp[9], cout_temp[10], sum[43:40]);
    bcd_fadd inst12 (a[47:44], b[47:44], cout_temp[10], cout_temp[11], sum[47:44]);
    bcd_fadd inst13 (a[51:48], b[51:48], cout_temp[11], cout_temp[12], sum[51:48]);
    bcd_fadd inst14 (a[55:52], b[55:52], cout_temp[12], cout_temp[13], sum[55:52]);
    bcd_fadd inst15 (a[59:56], b[59:56], cout_temp[13], cout_temp[14], sum[59:56]);
    bcd_fadd inst16 (a[63:60], b[63:60], cout_temp[14], cout_temp[15], sum[63:60]);
    bcd_fadd inst17 (a[67:64], b[67:64], cout_temp[15], cout_temp[16], sum[67:64]);
    bcd_fadd inst18 (a[71:68], b[71:68], cout_temp[16], cout_temp[17], sum[71:68]);
    bcd_fadd inst19 (a[75:72], b[75:72], cout_temp[17], cout_temp[18], sum[75:72]);
    bcd_fadd inst20 (a[79:76], b[79:76], cout_temp[18], cout_temp[19], sum[79:76]);
    bcd_fadd inst21 (a[83:80], b[83:80], cout_temp[19], cout_temp[20], sum[83:80]);
    bcd_fadd inst22 (a[87:84], b[87:84], cout_temp[20], cout_temp[21], sum[87:84]);
    bcd_fadd inst23 (a[91:88], b[91:88], cout_temp[21], cout_temp[22], sum[91:88]);
    bcd_fadd inst24 (a[95:92], b[95:92], cout_temp[22], cout_temp[23], sum[95:92]);
    bcd_fadd inst25 (a[99:96], b[99:96], cout_temp[23], cout_temp[24], sum[99:96]);
    bcd_fadd inst26"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// This is a combinational circuit

// The output is calculated as follows:
// 1. Sum all the bits of a and b.
// 2. Add the input cin.
// 3. Remap all the bits of the sum to be in the range [0,3).
// 4. Subtract the input cin.
// 5. Flip all the bits of the sum to be in the range [3,0].

// The internal values of the input a, b, cin are not modified.
// The output is stored in the register ""sum"", which is a 400-bit vector.
// The register ""cout"" is 1 when the full 400-bit sum has been added to the register ""sum""
// with a carry-out.
// The function ""remap"" is a utility function that changes the range of the input values
// to match the range of the output.
// The function ""subtr"" is a utility function that changes the range of the input values
// to match the range of the output.
// The function ""flip"" is a utility function that changes the range of the input values
// to match the range of the output.

// ** Note that the adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.
// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The add",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// This is a combinational circuit

// The output is calculated as follows:
// 1. Sum all the bits of a and b.
// 2. Add the input cin.
// 3. Remap all the bits of the sum to be in the range [0,3).
// 4. Subtract the input cin.
// 5. Flip all the bits of the sum to be in the range [3,0].

// The internal values of the input a, b, cin are not modified.
// The output is stored in the register ""sum"", which is a 400-bit vector.
// The register ""cout"" is 1 when the full 400-bit sum has been added to the register ""sum""
// with a carry-out.
// The function ""remap"" is a utility function that changes the range of the input values
// to match the range of the output.
// The function ""subtr"" is a utility function that changes the range of the input values
// to match the range of the output.
// The function ""flip"" is a utility function that changes the range of the input values
// to match the range of the output.

// ** Note that the adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.
// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The adder in this circuit is a 4-bit ripple-carry adder,
// ** and the 400-bit adder is a 16-bit ripple-carry adder.

// ** The add"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// The concatenation {cout, sum} is a 498-bit vector.
    
assign {cout, sum} = a+b+cin;

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// The concatenation {cout, sum} is a 498-bit vector.
    
assign {cout, sum} = a+b+cin;

endmodule"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_temp;
    bcd_fadd inst1_bcd_fadd_1 (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(cout_temp[0]),
       .sum(sum[3:0])
    );
    
    wire [399:0] cout_temp_1;
    bcd_fadd inst2_bcd_fadd_1 (
       .a(a[7:4]),
       .b(b[7:4]),
       .cin(cout_temp[0]),
       .cout(cout_temp_1[0]),
       .sum(sum[7:4])
    );
    
    wire [399:0] cout_temp_2;
    bcd_fadd inst2_bcd_fadd_2 (
       .a(a[11:8]),
       .b(b[11:8]),
       .cin(cout_temp_1[0]),
       .cout(cout_temp_2[0]),
       .sum(sum[11:8])
    );
    
    wire [399:0] cout_temp_3;
    bcd_fadd inst2_bcd_fadd_3 (
       .a(a[15:12]),
       .b(b[15:12]),
       .cin(cout_temp_2[0]),
       .cout(cout_temp_3[0]),
       .sum(sum[15:12])
    );
    
    wire [399:0] cout_temp_4;
    bcd_fadd inst2_bcd_fadd_4 (
       .a(a[19:16]),
       .b(b[19:16]),
       .cin(cout_temp_3[0]),
       .cout(cout_temp_4[0]),
       .sum(sum[19:16])
    );
    
    wire [399:0] cout_temp_5;
    bcd_fadd inst2_bcd_fadd_5 (
       .a(a[23:20]),
       .b(b[23:20]),
       .cin(cout_temp_4[0]),
       .cout(cout_temp_5[0]),
       .sum(sum[23:20])
    );
    
    wire [399:0] cout_temp_6;
    bcd_fadd inst2_bcd_fadd_6 (
       .a(a[27:24]),
       .b(b[27:24]),
       .cin(cout_temp_5[0]),
       .cout(cout_temp_6[0]),
       .sum(sum[27:24])
    );
    
    wire [399:0] cout_temp_7;
    bcd_fadd inst2_bcd_fadd_7 (
       .a(a[31:28]),
       .b(b[31:28]),
       .cin(cout_temp_6[0]),
       .cout(cout_temp_7[0]),
       .sum(sum[31:28])
    );
    
    wire [399:0] cout_temp_8;
    bcd_fadd inst2_bcd_fadd_8 (
       .a(a[35:32]),
       .b(b[35:32]),
       .cin(cout_temp_7[0]),
       .cout(cout_temp_8[0]),
       .sum(sum[35:32])
    );
    
    wire [399:0] cout_temp_9;
    bcd_fadd inst2_bcd_fadd_9 (
       .a(a[39:36]),
       .b(b[39:36]),
       .cin(cout_temp_8[0]),
       .cout(cout_temp_9[0]),
       .sum(sum[39:36])
    );
    
    wire [399:0] cout_temp_10;
    bcd_fadd inst2_bcd_fadd_10 (
       .a(a[43:40]),",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_temp;
    bcd_fadd inst1_bcd_fadd_1 (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(cout_temp[0]),
       .sum(sum[3:0])
    );
    
    wire [399:0] cout_temp_1;
    bcd_fadd inst2_bcd_fadd_1 (
       .a(a[7:4]),
       .b(b[7:4]),
       .cin(cout_temp[0]),
       .cout(cout_temp_1[0]),
       .sum(sum[7:4])
    );
    
    wire [399:0] cout_temp_2;
    bcd_fadd inst2_bcd_fadd_2 (
       .a(a[11:8]),
       .b(b[11:8]),
       .cin(cout_temp_1[0]),
       .cout(cout_temp_2[0]),
       .sum(sum[11:8])
    );
    
    wire [399:0] cout_temp_3;
    bcd_fadd inst2_bcd_fadd_3 (
       .a(a[15:12]),
       .b(b[15:12]),
       .cin(cout_temp_2[0]),
       .cout(cout_temp_3[0]),
       .sum(sum[15:12])
    );
    
    wire [399:0] cout_temp_4;
    bcd_fadd inst2_bcd_fadd_4 (
       .a(a[19:16]),
       .b(b[19:16]),
       .cin(cout_temp_3[0]),
       .cout(cout_temp_4[0]),
       .sum(sum[19:16])
    );
    
    wire [399:0] cout_temp_5;
    bcd_fadd inst2_bcd_fadd_5 (
       .a(a[23:20]),
       .b(b[23:20]),
       .cin(cout_temp_4[0]),
       .cout(cout_temp_5[0]),
       .sum(sum[23:20])
    );
    
    wire [399:0] cout_temp_6;
    bcd_fadd inst2_bcd_fadd_6 (
       .a(a[27:24]),
       .b(b[27:24]),
       .cin(cout_temp_5[0]),
       .cout(cout_temp_6[0]),
       .sum(sum[27:24])
    );
    
    wire [399:0] cout_temp_7;
    bcd_fadd inst2_bcd_fadd_7 (
       .a(a[31:28]),
       .b(b[31:28]),
       .cin(cout_temp_6[0]),
       .cout(cout_temp_7[0]),
       .sum(sum[31:28])
    );
    
    wire [399:0] cout_temp_8;
    bcd_fadd inst2_bcd_fadd_8 (
       .a(a[35:32]),
       .b(b[35:32]),
       .cin(cout_temp_7[0]),
       .cout(cout_temp_8[0]),
       .sum(sum[35:32])
    );
    
    wire [399:0] cout_temp_9;
    bcd_fadd inst2_bcd_fadd_9 (
       .a(a[39:36]),
       .b(b[39:36]),
       .cin(cout_temp_8[0]),
       .cout(cout_temp_9[0]),
       .sum(sum[39:36])
    );
    
    wire [399:0] cout_temp_10;
    bcd_fadd inst2_bcd_fadd_10 (
       .a(a[43:40]),"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// The concatenation {cout, sum} is a 498-bit vector.

// assign {cout, sum} = a+b+cin;

// assign {cout, sum} = a+b+cin;

// assign {cout, sum} = {cout, sum}+{cout, 4'h0};

// assign {cout, sum} = {cout, sum}+{cout, 4'h0};

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// The concatenation {cout, sum} is a 498-bit vector.

// assign {cout, sum} = a+b+cin;

// assign {cout, sum} = a+b+cin;

// assign {cout, sum} = {cout, sum}+{cout, 4'h0};

// assign {cout, sum} = {cout, sum}+{cout, 4'h0};

endmodule"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// This is a combinational circuit

// The output is calculated as a[0] + b[0] + cin

assign sum[0] = a[0] ^ b[0] ^ cin;
assign cout = a[399] ^ b[399] ^ cin;

// Note: The following line is a combinational operation

assign sum[399:1] = a[399:1] ^ b[399:1] ^ {a[398:0], cin};

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
// This is a combinational circuit

// The output is calculated as a[0] + b[0] + cin

assign sum[0] = a[0] ^ b[0] ^ cin;
assign cout = a[399] ^ b[399] ^ cin;

// Note: The following line is a combinational operation

assign sum[399:1] = a[399:1] ^ b[399:1] ^ {a[398:0], cin};

endmodule"
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_temp;
    
    bcd_fadd inst1 (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(cout_temp[0]),
       .sum(sum[3:0])
    );
    
    generate
        genvar i;
        for(i=4; i<400; i=i+4) begin : inst
            bcd_fadd inst (
               .a(a[i+3:i]),
               .b(b[i+3:i]),
               .cin(cout_temp[i/4-1]),
               .cout(cout_temp[i/4]),
               .sum(sum[i+3:i])
            );
        end
    endgenerate
    
    assign cout = cout_temp[99];
    
endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_temp;
    
    bcd_fadd inst1 (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(cout_temp[0]),
       .sum(sum[3:0])
    );
    
    generate
        genvar i;
        for(i=4; i<400; i=i+4) begin : inst
            bcd_fadd inst (
               .a(a[i+3:i]),
               .b(b[i+3:i]),
               .cin(cout_temp[i/4-1]),
               .cout(cout_temp[i/4]),
               .sum(sum[i+3:i])
            );
        end
    endgenerate
    
    assign cout = cout_temp[99];
    
endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
   
    assign min = a;

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
   
    assign min = a;

endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1 | intermediate_result2): (a<b?a:b);

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1 | intermediate_result2): (a<b?a:b);

endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1 | intermediate_result2): (a<b)? a:b;
    
    assign min = a;
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1 | intermediate_result2): (a<b)? a:b;
    
    assign min = a;
    
endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min1 = a<b?a:b;
    assign min2 = c<d?c:d;
    assign min = min1<min2?min1:min2;

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min1 = a<b?a:b;
    assign min2 = c<d?c:d;
    assign min = min1<min2?min1:min2;

endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
    
    assign min = a;
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
    
    assign min = a;
    
endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
    
    assign min = a;

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
    
    assign min = a;

endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare?(intermediate_result1&intermediate_result2):(a&b);
    
    assign min = a;
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare?(intermediate_result1&intermediate_result2):(a&b);
    
    assign min = a;
    
endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min1 = compare? (intermediate_result1&(~intermediate_result2)):(intermediate_result1|(~intermediate_result2));
    // assign min2 = (compare2)? (intermediate_result2&(~intermediate_result1)):(intermediate_result2|(~intermediate_result1));
    // assign min = compare? min1:min2;
   
    wire [7:0] min1, min2;
    wire [7:0] result1, result2;
    wire and1, and2, and3, and4;
    wire nand1, nand2, nand3, nand4;
    
    assign and1 = (a<b)? a:b;
    assign and2 = (c<d)? c:d;
    assign and3 = (e<f)? e:f;
    assign and4 = (g<h)? g:h;
    assign nand1 = (a<b)? ~a:b;
    assign nand2 = (c<d)? ~c:d;
    assign nand3 = (e<f)? ~e:f;
    assign nand4 = (g<h)? ~g:h;
    
    assign result1 = and1 & and2 & and3 & and4;
    assign result2 = nand1 & nand2 & nand3 & nand4;
    assign min1 = result1;
    assign min2 = result2;
    assign min = result1;

endmodule",-1,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min1 = compare? (intermediate_result1&(~intermediate_result2)):(intermediate_result1|(~intermediate_result2));
    // assign min2 = (compare2)? (intermediate_result2&(~intermediate_result1)):(intermediate_result2|(~intermediate_result1));
    // assign min = compare? min1:min2;
   
    wire [7:0] min1, min2;
    wire [7:0] result1, result2;
    wire and1, and2, and3, and4;
    wire nand1, nand2, nand3, nand4;
    
    assign and1 = (a<b)? a:b;
    assign and2 = (c<d)? c:d;
    assign and3 = (e<f)? e:f;
    assign and4 = (g<h)? g:h;
    assign nand1 = (a<b)? ~a:b;
    assign nand2 = (c<d)? ~c:d;
    assign nand3 = (e<f)? ~e:f;
    assign nand4 = (g<h)? ~g:h;
    
    assign result1 = and1 & and2 & and3 & and4;
    assign result2 = nand1 & nand2 & nand3 & nand4;
    assign min1 = result1;
    assign min2 = result2;
    assign min = result1;

endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare?(intermediate_result1 | intermediate_result2):(a<b?a:b);
    
    assign min = a<b?a:b;
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare?(intermediate_result1 | intermediate_result2):(a<b?a:b);
    
    assign min = a<b?a:b;
    
endmodule"
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
    
    assign min = a;

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare2? true: false;
    // assign min = compare? (intermediate_result1?a:b):(intermediate_result2?c:d);
    
    assign min = a;

endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    
    // Modify FSM and datapath from Fsm_serialdata
	parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] data_count;
    reg [7:0] data_reg;
    reg [7:0] pm_count;
    reg [3:0] h_count;
    reg [3:0] m_count;
    reg [3:0] s_count;
    reg [2:0] h_state;
    reg [2:0] m_state;
    reg [7:0] h_reg;
    reg [7:0] m_reg;
    reg [7:0] s_reg;
    reg [2:0] h_next;
    reg [2:0] m_next;
    reg [7:0] s_next;
    reg [2:0] h_cnt;
    reg [3:0] m_cnt;
    reg [3:0] s_cnt;
    reg [2:0] m_state_c;
    reg [3:0] h_state_c;
    reg [7:0] m_reg_c;
    reg [7:0] s_reg_c;
    reg [7:0] h_next_c;
    reg [7:0] m_next_c;
    reg [7:0] s_next_c;
    reg [2:0] h_cnt_c;
    reg [3:0] m_cnt_c;
    reg [3:0] s_cnt_c;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0] h_cnt_c_reg;
    reg [3:0] m_cnt_c_reg;
    reg [3:0] s_cnt_c_reg;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0] h_cnt_c_reg;
    reg [3:0] m_cnt_c_reg;
    reg [3:0] s_cnt_c_reg;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0] h_cnt_c_reg;
    reg [3:0] m_cnt_c_reg;
    reg [3:0] s_cnt_c_reg;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0]",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    
    // Modify FSM and datapath from Fsm_serialdata
	parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] data_count;
    reg [7:0] data_reg;
    reg [7:0] pm_count;
    reg [3:0] h_count;
    reg [3:0] m_count;
    reg [3:0] s_count;
    reg [2:0] h_state;
    reg [2:0] m_state;
    reg [7:0] h_reg;
    reg [7:0] m_reg;
    reg [7:0] s_reg;
    reg [2:0] h_next;
    reg [2:0] m_next;
    reg [7:0] s_next;
    reg [2:0] h_cnt;
    reg [3:0] m_cnt;
    reg [3:0] s_cnt;
    reg [2:0] m_state_c;
    reg [3:0] h_state_c;
    reg [7:0] m_reg_c;
    reg [7:0] s_reg_c;
    reg [7:0] h_next_c;
    reg [7:0] m_next_c;
    reg [7:0] s_next_c;
    reg [2:0] h_cnt_c;
    reg [3:0] m_cnt_c;
    reg [3:0] s_cnt_c;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0] h_cnt_c_reg;
    reg [3:0] m_cnt_c_reg;
    reg [3:0] s_cnt_c_reg;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0] h_cnt_c_reg;
    reg [3:0] m_cnt_c_reg;
    reg [3:0] s_cnt_c_reg;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0] h_cnt_c_reg;
    reg [3:0] m_cnt_c_reg;
    reg [3:0] s_cnt_c_reg;
    reg [2:0] m_state_c_reg;
    reg [3:0] h_state_c_reg;
    reg [7:0] m_reg_c_reg;
    reg [7:0] s_reg_c_reg;
    reg [7:0] h_next_c_reg;
    reg [7:0] m_next_c_reg;
    reg [7:0] s_next_c_reg;
    reg [2:0]"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    
    // Modify FSM and datapath from Fsm_serialdata
	parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] data_count;
    reg [7:0] bcd_data;
    reg [4:0] bcd_valid;
    reg [7:0] h_bcd, m_bcd, s_bcd;
    reg [2:0] h_valid, m_valid, s_valid;
    reg [1:0] pm_count;
    
    
    // FSM output logic
    always @(*) begin
        case(state)
            START: next_state = ena? DATA : START;
            DATA: next_state = DATA;
            STOP: next_state = START;
            DELAY: next_state = DELAY;
            default: next_state = START;
        endcase
    end
    
    
    // FSM state update
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    
    // FSM data input
    always @(posedge clk) begin
        if(state == DATA)
            data_count <= data_count + 4'd1;
        else
            data_count <= 3'd0;
    end
    
    
    // FSM data to BCD
    always @(posedge clk) begin
        if(state == DATA)
            bcd_data <= {bcd_data[6:0], data_count[2:0]};
    end
    
    
    // FSM data valid
    always @(posedge clk) begin
        if(state == DATA)
            bcd_valid <= {bcd_valid[0], 1'b1};
        else
            bcd_valid <= {bcd_valid[0], 1'b0};
    end
    
    
    // FSM pm
    always @(posedge clk) begin
        if(state == START)
            pm_count <= 2'd0;
        else if(state == DATA && (data_count == 3'd2 || data_count == 3'd5))
            pm_count <= pm_count + 2'd1;
    end
    
    
    // FSM hh
    always @(posedge clk) begin
        if(state == START)
            hh_bcd <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd2))
            hh_bcd <= {hh_bcd[3:0], bcd_data[3:0]};
    end
    
    
    // FSM hh valid
    always @(posedge clk) begin
        if(state == START)
            hh_valid <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd2))
            hh_valid <= {hh_valid[1:0], 1'b1};
        else
            hh_valid <= {hh_valid[1:0], 1'b0};
    end
    
    
    // FSM m
    always @(posedge clk) begin
        if(state == START)
            m_bcd <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd5))
            m_bcd <= {m_bcd[3:0], bcd_data[3:0]};
    end
    
    
    // FSM m valid
    always @(posedge clk) begin
        if(state == START)
            m_valid <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd2))
            m_valid <= {m_valid[1:0], 1'b1};
        else
            m_valid <= {m_valid[1:0], 1'b0};
    end
    
    
    // FSM s
    always @(posedge clk) begin",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    
    // Modify FSM and datapath from Fsm_serialdata
	parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] data_count;
    reg [7:0] bcd_data;
    reg [4:0] bcd_valid;
    reg [7:0] h_bcd, m_bcd, s_bcd;
    reg [2:0] h_valid, m_valid, s_valid;
    reg [1:0] pm_count;
    
    
    // FSM output logic
    always @(*) begin
        case(state)
            START: next_state = ena? DATA : START;
            DATA: next_state = DATA;
            STOP: next_state = START;
            DELAY: next_state = DELAY;
            default: next_state = START;
        endcase
    end
    
    
    // FSM state update
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    
    // FSM data input
    always @(posedge clk) begin
        if(state == DATA)
            data_count <= data_count + 4'd1;
        else
            data_count <= 3'd0;
    end
    
    
    // FSM data to BCD
    always @(posedge clk) begin
        if(state == DATA)
            bcd_data <= {bcd_data[6:0], data_count[2:0]};
    end
    
    
    // FSM data valid
    always @(posedge clk) begin
        if(state == DATA)
            bcd_valid <= {bcd_valid[0], 1'b1};
        else
            bcd_valid <= {bcd_valid[0], 1'b0};
    end
    
    
    // FSM pm
    always @(posedge clk) begin
        if(state == START)
            pm_count <= 2'd0;
        else if(state == DATA && (data_count == 3'd2 || data_count == 3'd5))
            pm_count <= pm_count + 2'd1;
    end
    
    
    // FSM hh
    always @(posedge clk) begin
        if(state == START)
            hh_bcd <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd2))
            hh_bcd <= {hh_bcd[3:0], bcd_data[3:0]};
    end
    
    
    // FSM hh valid
    always @(posedge clk) begin
        if(state == START)
            hh_valid <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd2))
            hh_valid <= {hh_valid[1:0], 1'b1};
        else
            hh_valid <= {hh_valid[1:0], 1'b0};
    end
    
    
    // FSM m
    always @(posedge clk) begin
        if(state == START)
            m_bcd <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd5))
            m_bcd <= {m_bcd[3:0], bcd_data[3:0]};
    end
    
    
    // FSM m valid
    always @(posedge clk) begin
        if(state == START)
            m_valid <= 4'd0;
        else if(state == DATA && (data_count_valid == 2'd1 || data_count == 3'd2))
            m_valid <= {m_valid[1:0], 1'b1};
        else
            m_valid <= {m_valid[1:0], 1'b0};
    end
    
    
    // FSM s
    always @(posedge clk) begin"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // When counter is maxed out, it turns off.
    
    counter ut(.clk(clk),.reset(reset),.ena(ena),.count(pm_count));
    
    // A mod-2 counter is used to make the 
    // output pulse widths even.
    
    always @(posedge clk) begin
        if(reset) begin
            pm_count <= 0;
        end
        else begin
            pm_count <= (pm_count==1)? 0 : pm_count+1;
        end
    end
    
    // Make sure the PM count is always greater than 0.
    // If the counter is maxed out, it turns off.
    
    always @(posedge clk) begin
        if(reset) begin
            pm <= 1'b0;
        end
        else begin
            pm <= (pm_count==1)? 1'b1 : 1'b0;
        end
    end
    
    // The mod-2 counter makes the 
    // output pulse widths even.
    // It turns off when the 
    // counter is maxed out.
    
    assign enain = (pm_count==1)? 2'b10 : 2'b00;
    
    // Count to 60. The first 2 counts are skipped since
    // they are not reached in a minute.
    // The last 2 counts are skipped since
    // during that last 2 counts,
    // pm is asserted, and therefore
    // the last 2 counts are added.
    
    always @(posedge clk) begin
        if(reset) begin
            hh <= 0;
            mm <= 0;
            ss <= 0;
        end
        else begin
            hh <= (hh==5'd59)? 0 : hh+1;
            mm <= (mm==5'd59)? 0 : mm+1;
            ss <= (ss==5'd59)? 0 : ss+1;
        end
    end
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // When counter is maxed out, it turns off.
    
    counter ut(.clk(clk),.reset(reset),.ena(ena),.count(pm_count));
    
    // A mod-2 counter is used to make the 
    // output pulse widths even.
    
    always @(posedge clk) begin
        if(reset) begin
            pm_count <= 0;
        end
        else begin
            pm_count <= (pm_count==1)? 0 : pm_count+1;
        end
    end
    
    // Make sure the PM count is always greater than 0.
    // If the counter is maxed out, it turns off.
    
    always @(posedge clk) begin
        if(reset) begin
            pm <= 1'b0;
        end
        else begin
            pm <= (pm_count==1)? 1'b1 : 1'b0;
        end
    end
    
    // The mod-2 counter makes the 
    // output pulse widths even.
    // It turns off when the 
    // counter is maxed out.
    
    assign enain = (pm_count==1)? 2'b10 : 2'b00;
    
    // Count to 60. The first 2 counts are skipped since
    // they are not reached in a minute.
    // The last 2 counts are skipped since
    // during that last 2 counts,
    // pm is asserted, and therefore
    // the last 2 counts are added.
    
    always @(posedge clk) begin
        if(reset) begin
            hh <= 0;
            mm <= 0;
            ss <= 0;
        end
        else begin
            hh <= (hh==5'd59)? 0 : hh+1;
            mm <= (mm==5'd59)? 0 : mm+1;
            ss <= (ss==5'd59)? 0 : ss+1;
        end
    end
    
endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // The counter for the mod-5 system.
    
    counter3 count_0(.clk(clk),.reset(reset),.ena(ena),.cclk(enain[2]),.up(enain[1]),.down(enain[0]),.cout(pm_count));
    
    // The mod-5 divider is a system for simply dividing the 
    // output rate by 5. It is basically a counter with a 
    // ""clear"" function. The output is a system that can 
    // be enabled (low) or reset (high).
    
    mod5_divider mod5_div(.clk(clk),.reset(reset),.enable(ena),.cclk(enain[2]),.cout(pm));
    
    // The mod-5 system is a system that can be enabled 
    // to make the counter up or down.
    
    mod5_up_down mod5_ud(.clk(clk),.reset(reset),.enable(enain[0]),.cclk(enain[2]),.cout(hh[7]),.d(~hh[7]),.ud(~hh[6]),.ld(~hh[5]),.dn(~hh[4]),.up(~hh[3]),.dn(~hh[2]),.ld(~hh[1]),.up(~hh[0]),.dn(~hh[1]));
    
    // The mod-5 divider is a system for simply dividing the 
    // output rate by 5. It is basically a counter with a 
    // ""clear"" function. The output is a system that can 
    // be enabled (low) or reset (high).
    
    mod5_divider mod5_ud1(.clk(clk),.reset(reset),.enable(enain[1]),.cclk(enain[2]),.cout(mm[7]),.d(~mm[7]),.ud(~mm[6]),.ld(~mm[5]),.dn(~mm[4]),.up(~mm[3]),.dn(~mm[2]),.ld(~mm[1]),.up(~mm[0]),.dn(~mm[1]));
    
    // The mod-5 system is a system that can be enabled 
    // to make the counter up or down.
    
    mod5_up_down mod5_ud2(.clk(clk),.reset(reset),.enable(enain[0]),.cclk(enain[2]),.cout(ss[7]),.d(~ss[7]),.ud(~ss[6]),.ld(~ss[5]),.dn(~ss[4]),.up(~ss[3]),.dn(~ss[2]),.ld(~ss[1]),.up(~ss[0]),.dn(~ss[1]));
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // The counter for the mod-5 system.
    
    counter3 count_0(.clk(clk),.reset(reset),.ena(ena),.cclk(enain[2]),.up(enain[1]),.down(enain[0]),.cout(pm_count));
    
    // The mod-5 divider is a system for simply dividing the 
    // output rate by 5. It is basically a counter with a 
    // ""clear"" function. The output is a system that can 
    // be enabled (low) or reset (high).
    
    mod5_divider mod5_div(.clk(clk),.reset(reset),.enable(ena),.cclk(enain[2]),.cout(pm));
    
    // The mod-5 system is a system that can be enabled 
    // to make the counter up or down.
    
    mod5_up_down mod5_ud(.clk(clk),.reset(reset),.enable(enain[0]),.cclk(enain[2]),.cout(hh[7]),.d(~hh[7]),.ud(~hh[6]),.ld(~hh[5]),.dn(~hh[4]),.up(~hh[3]),.dn(~hh[2]),.ld(~hh[1]),.up(~hh[0]),.dn(~hh[1]));
    
    // The mod-5 divider is a system for simply dividing the 
    // output rate by 5. It is basically a counter with a 
    // ""clear"" function. The output is a system that can 
    // be enabled (low) or reset (high).
    
    mod5_divider mod5_ud1(.clk(clk),.reset(reset),.enable(enain[1]),.cclk(enain[2]),.cout(mm[7]),.d(~mm[7]),.ud(~mm[6]),.ld(~mm[5]),.dn(~mm[4]),.up(~mm[3]),.dn(~mm[2]),.ld(~mm[1]),.up(~mm[0]),.dn(~mm[1]));
    
    // The mod-5 system is a system that can be enabled 
    // to make the counter up or down.
    
    mod5_up_down mod5_ud2(.clk(clk),.reset(reset),.enable(enain[0]),.cclk(enain[2]),.cout(ss[7]),.d(~ss[7]),.ud(~ss[6]),.ld(~ss[5]),.dn(~ss[4]),.up(~ss[3]),.dn(~ss[2]),.ld(~ss[1]),.up(~ss[0]),.dn(~ss[1]));
    
endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    
    assign enain[1] = ena;
    assign enain[2] = enain[1] & enain[0];
    
    wire pm_out;
    
    count60s inst0(.clk(clk),.reset(reset),.ena(enain[2]),.pm(pm_out));
    
    count24h inst1(.clk(clk),.reset(reset),.ena(enain[1]),.pm(pm),.hh(hh),.mm(mm),.ss(ss));
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    
    assign enain[1] = ena;
    assign enain[2] = enain[1] & enain[0];
    
    wire pm_out;
    
    count60s inst0(.clk(clk),.reset(reset),.ena(enain[2]),.pm(pm_out));
    
    count24h inst1(.clk(clk),.reset(reset),.ena(enain[1]),.pm(pm),.hh(hh),.mm(mm),.ss(ss));
    
endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // use three counters to model a 12-hour clock
    // (counter1 is used to model the current hour)
    // (counter2 is used to model the current minute)
    // (counter3 is used to model the current second)
    counter counter1(clk, reset, ena, hh, counter1_overflow, counter1_carry);
    counter counter2(counter1_overflow, counter1_carry,  clk, mm, counter2_overflow, counter2_carry);
    counter counter3(counter2_overflow, counter2_carry,  clk, ss, counter3_overflow, counter3_carry);
    
    // When the button is pushed, and the counters are at 0:59:59,
    // The system will reset the counters to 1:00:00
    
    // use a ""and"" gate to determine when the counters are at 0:59:59
    // (the time is 12:59:59)
    
    // assign pm = (counter1_overflow == 1'b1 && counter2_overflow == 1'b1 && counter3_overflow == 1'b1);
    // if all of the above are true, pm is 1
    
    // assign enain = {counter1_overflow, counter2_overflow, counter3_overflow};
    // if any of the above are true, enain is 2
    
    // The value of the counters is determined by the following truth table.
    // When the above are true, the value of the counters is shown in the table.
    //   counter1_overflow | counter2_overflow | counter3_overflow | counter1_value | counter2_value | counter3_value
    //   0                    |   0                   |   0                |   0    |   0
    //   0                    |   0                   |   1                |   0    |   1
    //   0                    |   1                   |   0                |   1    |   0
    //   0                    |   1                   |   1                |   1    |   1
    //   1                    |   0                   |   0                |   0    |   0
    //   1                    |   0                   |   1                |   0    |   1
    //   1                    |   1                   |   0                |   1    |   0
    //   1                    |   1                   |   1                |   1    |   1
    
    
    assign enain = {counter1_overflow, counter2_overflow, counter3_overflow};
    
    
    
    // The value of the counters is determined by the following truth table.
    // When the above are true, the value of the counters is shown in the table.
    //   counter1_overflow | counter2_overflow | counter3_overflow | counter1_value | counter2_value | counter3_value
    //   0                    |   0                   |   0                |   0    |   0
    //   0                    |   0                   |   1                |   0    |   1
    //   0                    |   1                   |   0                |   1    |   0
    //   0                    |   1                   |   1                |   1    |   1
    //   1                    |   0                   |   0                |   0    |   0
    //   1                    |   0                   |   1                |   0    |   1
    //   1                    |   1                   |   0                |   1    |   0
    //   1                    |   1                   |   1                |   1    |   1
    
    
    
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // use three counters to model a 12-hour clock
    // (counter1 is used to model the current hour)
    // (counter2 is used to model the current minute)
    // (counter3 is used to model the current second)
    counter counter1(clk, reset, ena, hh, counter1_overflow, counter1_carry);
    counter counter2(counter1_overflow, counter1_carry,  clk, mm, counter2_overflow, counter2_carry);
    counter counter3(counter2_overflow, counter2_carry,  clk, ss, counter3_overflow, counter3_carry);
    
    // When the button is pushed, and the counters are at 0:59:59,
    // The system will reset the counters to 1:00:00
    
    // use a ""and"" gate to determine when the counters are at 0:59:59
    // (the time is 12:59:59)
    
    // assign pm = (counter1_overflow == 1'b1 && counter2_overflow == 1'b1 && counter3_overflow == 1'b1);
    // if all of the above are true, pm is 1
    
    // assign enain = {counter1_overflow, counter2_overflow, counter3_overflow};
    // if any of the above are true, enain is 2
    
    // The value of the counters is determined by the following truth table.
    // When the above are true, the value of the counters is shown in the table.
    //   counter1_overflow | counter2_overflow | counter3_overflow | counter1_value | counter2_value | counter3_value
    //   0                    |   0                   |   0                |   0    |   0
    //   0                    |   0                   |   1                |   0    |   1
    //   0                    |   1                   |   0                |   1    |   0
    //   0                    |   1                   |   1                |   1    |   1
    //   1                    |   0                   |   0                |   0    |   0
    //   1                    |   0                   |   1                |   0    |   1
    //   1                    |   1                   |   0                |   1    |   0
    //   1                    |   1                   |   1                |   1    |   1
    
    
    assign enain = {counter1_overflow, counter2_overflow, counter3_overflow};
    
    
    
    // The value of the counters is determined by the following truth table.
    // When the above are true, the value of the counters is shown in the table.
    //   counter1_overflow | counter2_overflow | counter3_overflow | counter1_value | counter2_value | counter3_value
    //   0                    |   0                   |   0                |   0    |   0
    //   0                    |   0                   |   1                |   0    |   1
    //   0                    |   1                   |   0                |   1    |   0
    //   0                    |   1                   |   1                |   1    |   1
    //   1                    |   0                   |   0                |   0    |   0
    //   1                    |   0                   |   1                |   0    |   1
    //   1                    |   1                   |   0                |   1    |   0
    //   1                    |   1                   |   1                |   1    |   1
    
    
    
    
endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // When enabled, count up on the bus
    // When disabled, count down on the bus
    
    // Set the pm counter to 0 when we start the countdown, and increase to 1 when we finish the countdown
    
    always @(posedge clk) begin
        if(reset) begin
            pm_count <= 0;
        end
        else begin
            if(ena) begin
                pm_count <= pm_count + 1;
            end
            else begin
                pm_count <= pm_count - 1;
            end
        end
    end
    
    // Determine the state of the PM based on the value of the counter
    
    always @(posedge clk) begin
        if(pm_count == 0) begin
            pm <= 1;
        end
        else begin
            pm <= 0;
        end
    end
    
    // Determine the two BCD values for the current time (hh:mm:ss)
    
    // If the counter is enabled, then the current time is the maximum time
    // Otherwise, the current time is the minimum time
    
    always @(posedge clk) begin
        if(ena) begin
            hh <= 8'h23;
            mm <= 8'h59;
            ss <= 8'h59;
        end
        else begin
            hh <= {1'b0, hh[7:4]};
            mm <= {1'b0, mm[7:4]};
            ss <= {1'b0, ss[7:4]};
        end
    end
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // When enabled, count up on the bus
    // When disabled, count down on the bus
    
    // Set the pm counter to 0 when we start the countdown, and increase to 1 when we finish the countdown
    
    always @(posedge clk) begin
        if(reset) begin
            pm_count <= 0;
        end
        else begin
            if(ena) begin
                pm_count <= pm_count + 1;
            end
            else begin
                pm_count <= pm_count - 1;
            end
        end
    end
    
    // Determine the state of the PM based on the value of the counter
    
    always @(posedge clk) begin
        if(pm_count == 0) begin
            pm <= 1;
        end
        else begin
            pm <= 0;
        end
    end
    
    // Determine the two BCD values for the current time (hh:mm:ss)
    
    // If the counter is enabled, then the current time is the maximum time
    // Otherwise, the current time is the minimum time
    
    always @(posedge clk) begin
        if(ena) begin
            hh <= 8'h23;
            mm <= 8'h59;
            ss <= 8'h59;
        end
        else begin
            hh <= {1'b0, hh[7:4]};
            mm <= {1'b0, mm[7:4]};
            ss <= {1'b0, ss[7:4]};
        end
    end
    
endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    
    assign enain[1] = ena;
    assign enain[2] = enain[1];
    
    wire clk_out;
    
    clk_div #(.N(3)) cd1(.clk_in(clk),.clk_out(clk_out),.reset(reset),.ena(enain[2]));
    
    count60m inst1(.clk_out(clk_out),.reset(reset),.ena(enain[1]),
       .set(1'b1),.clk_out1(hh[7:4]),.clk_out2(hh[3:0]),
       .set1(1'b1),.set2(1'b0),.up(1'b1),.down(1'b0));
        
    count24h inst2(.clk_out(clk_out),.reset(reset),.ena(enain[1]),
       .set(1'b1),.clk_out1(mm[7:4]),.clk_out2(mm[3:0]),
       .set1(1'b1),.set2(1'b0),.up(1'b0),.down(1'b1));
        
    count60s inst3(.clk_out(clk_out),.reset(reset),.ena(enain[1]),
       .set(1'b1),.clk_out1(ss[7:4]),.clk_out2(ss[3:0]),
       .set1(1'b1),.set2(1'b0),.up(1'b0),.down(1'b1));
        
    count24h inst4(.clk_out(clk_out),.reset(reset),.ena(enain[2]),
       .set(1'b1),.clk_out1(ss[3:0]),.clk_out2(ss[7:4]),
       .set1(1'b1),.set2(1'b0),.up(1'b1),.down(1'b0));
        
    count24h inst5(.clk_out(clk_out),.reset(reset),.ena(enain[2]),
       .set(1'b1),.clk_out1(mm[3:0]),.clk_out2(mm[7:4]),
       .set1(1'b1),.set2(1'b0),.up(1'b0),.down(1'b1));
        
    count24h inst6(.clk_out(clk_out),.reset(reset),.ena(enain[2]),
       .set(1'b1),.clk_out1(hh[3:0]),.clk_out2(hh[7:4]),
       .set1(1'b1),.set2(1'b0),.up(1'b1),.down(1'b0));
        
    
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    
    assign enain[1] = ena;
    assign enain[2] = enain[1];
    
    wire clk_out;
    
    clk_div #(.N(3)) cd1(.clk_in(clk),.clk_out(clk_out),.reset(reset),.ena(enain[2]));
    
    count60m inst1(.clk_out(clk_out),.reset(reset),.ena(enain[1]),
       .set(1'b1),.clk_out1(hh[7:4]),.clk_out2(hh[3:0]),
       .set1(1'b1),.set2(1'b0),.up(1'b1),.down(1'b0));
        
    count24h inst2(.clk_out(clk_out),.reset(reset),.ena(enain[1]),
       .set(1'b1),.clk_out1(mm[7:4]),.clk_out2(mm[3:0]),
       .set1(1'b1),.set2(1'b0),.up(1'b0),.down(1'b1));
        
    count60s inst3(.clk_out(clk_out),.reset(reset),.ena(enain[1]),
       .set(1'b1),.clk_out1(ss[7:4]),.clk_out2(ss[3:0]),
       .set1(1'b1),.set2(1'b0),.up(1'b0),.down(1'b1));
        
    count24h inst4(.clk_out(clk_out),.reset(reset),.ena(enain[2]),
       .set(1'b1),.clk_out1(ss[3:0]),.clk_out2(ss[7:4]),
       .set1(1'b1),.set2(1'b0),.up(1'b1),.down(1'b0));
        
    count24h inst5(.clk_out(clk_out),.reset(reset),.ena(enain[2]),
       .set(1'b1),.clk_out1(mm[3:0]),.clk_out2(mm[7:4]),
       .set1(1'b1),.set2(1'b0),.up(1'b0),.down(1'b1));
        
    count24h inst6(.clk_out(clk_out),.reset(reset),.ena(enain[2]),
       .set(1'b1),.clk_out1(hh[3:0]),.clk_out2(hh[7:4]),
       .set1(1'b1),.set2(1'b0),.up(1'b1),.down(1'b0));
        
    
    
endmodule"
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // use two 16-bit counters
    
    count60m inst1(.clk(clk),.reset(reset),.ena(ena),.count(count));
    count10m inst2(.clk(clk),.reset(reset),.ena(enain[1]),.count(secs));
    
    // when the 60-count reaches 59:59, set the ena to 0 so that
    // the 1-count (or 1/60 s) is enabled
    
    assign enain[2] = (count[3:0] == 4'd9 && count[7:4] == 4'd9)? 0 : 1;
    
    // set the outputs
    
    assign pm = pm_count;
    
    // counter for the 12-hour clock
    
    always @(posedge clk)
        begin
            if(reset)
                pm_count <= 0;
            else
                pm_count <= (pm_count == 4'd1)? 0 : pm_count + 4'd1;
        end
    
    // counter for the 1-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                secs <= 0;
            else if(enain[1] && secs == 4'd9)
                secs <= 0;
            else if(enain[1] == 0)
                secs <= secs + 4'd1;
        end
                
    // counter for the 2-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                mins <= mins_stored;
            else if(enain[0] && mins == 4'd9)
                mins <= 0;
            else if(enain[0] == 0)
                mins <= mins + 4'd1;
        end
    
    // counter for the 5-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                hrs <= 0;
            else if(enain[0] && hrs == 4'd9)
                hrs <= 0;
            else if(enain[0] == 0)
                hrs <= hrs + 4'd1;
        end
    
    // counter for the 10-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                mins_stored <= mins;
            else if(mins_stored == 4'd9 && mins_stored!= 4'd9)
                mins_stored <= mins_stored;
            else if(enain[1] && mins_stored == 4'd9)
                mins_stored <= 0;
            else if(enain[1] == 0)
                mins_stored <= mins_stored + 4'd1;
        end
    
    // counter for the 1- and 2-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                secs_stored <= 0;
            else if(enain[2] && secs_stored == 4'd9)
                secs_stored <= 0;
            else if(enain[2] == 0)
                secs_stored <= secs_stored + 4'd1;
        end
    
    // counter for the 5-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                hrs_stored <= 0;
            else if(enain[3] && hrs_stored == 4'd9)
                hrs_stored <= 0;
            else if(enain[3] == 0)
                hrs_stored <= hrs_stored + 4'd1;
        end
    
    // counter for the 10-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                mins_stored_latch <= mins_stored;
            else if(mins_stored_latch == 9 && mins_stored_latch!= 9)
                mins_stored_latch <= mins_stored_latch;
            else if(enain[4] && mins_stored_latch == 9)
                mins_stored_latch <=",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [2:1] enain;
    reg pm_count;
    
    // use two 16-bit counters
    
    count60m inst1(.clk(clk),.reset(reset),.ena(ena),.count(count));
    count10m inst2(.clk(clk),.reset(reset),.ena(enain[1]),.count(secs));
    
    // when the 60-count reaches 59:59, set the ena to 0 so that
    // the 1-count (or 1/60 s) is enabled
    
    assign enain[2] = (count[3:0] == 4'd9 && count[7:4] == 4'd9)? 0 : 1;
    
    // set the outputs
    
    assign pm = pm_count;
    
    // counter for the 12-hour clock
    
    always @(posedge clk)
        begin
            if(reset)
                pm_count <= 0;
            else
                pm_count <= (pm_count == 4'd1)? 0 : pm_count + 4'd1;
        end
    
    // counter for the 1-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                secs <= 0;
            else if(enain[1] && secs == 4'd9)
                secs <= 0;
            else if(enain[1] == 0)
                secs <= secs + 4'd1;
        end
                
    // counter for the 2-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                mins <= mins_stored;
            else if(enain[0] && mins == 4'd9)
                mins <= 0;
            else if(enain[0] == 0)
                mins <= mins + 4'd1;
        end
    
    // counter for the 5-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                hrs <= 0;
            else if(enain[0] && hrs == 4'd9)
                hrs <= 0;
            else if(enain[0] == 0)
                hrs <= hrs + 4'd1;
        end
    
    // counter for the 10-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                mins_stored <= mins;
            else if(mins_stored == 4'd9 && mins_stored!= 4'd9)
                mins_stored <= mins_stored;
            else if(enain[1] && mins_stored == 4'd9)
                mins_stored <= 0;
            else if(enain[1] == 0)
                mins_stored <= mins_stored + 4'd1;
        end
    
    // counter for the 1- and 2-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                secs_stored <= 0;
            else if(enain[2] && secs_stored == 4'd9)
                secs_stored <= 0;
            else if(enain[2] == 0)
                secs_stored <= secs_stored + 4'd1;
        end
    
    // counter for the 5-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                hrs_stored <= 0;
            else if(enain[3] && hrs_stored == 4'd9)
                hrs_stored <= 0;
            else if(enain[3] == 0)
                hrs_stored <= hrs_stored + 4'd1;
        end
    
    // counter for the 10-second counter
    
    always @(posedge clk)
        begin
            if(reset)
                mins_stored_latch <= mins_stored;
            else if(mins_stored_latch == 9 && mins_stored_latch!= 9)
                mins_stored_latch <= mins_stored_latch;
            else if(enain[4] && mins_stored_latch == 9)
                mins_stored_latch <="
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    
    // Modify FSM and datapath from Fsm_serialdata
	parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] idx;
    reg [7:0] data;
    reg d1, d2, d3, d4, d5, d6, d7;
	
	// Modify FSM state table
    always @(*)
        case(state)
            START: next_state = ena? DATA : START;
            DATA: next_state = done? START : DATA;
            STOP: next_state = START;
            DELAY: next_state = next_state;
            default: next_state = state;
        endcase
    
    // Modify FSM data path
    always @(posedge clk)
        if(reset)
            begin
                state <= START;
                count <= 0;
                idx <= 0;
                data <= 0;
                d1 <= 0;
                d2 <= 0;
                d3 <= 0;
                d4 <= 0;
                d5 <= 0;
                d6 <= 0;
                d7 <= 0;
            end
        else
            begin
                // State transition
                // count is a 3-bit counter
                if(count == 3'b100)
                    begin
                        count <= 0;
                        state <= next_state;
                        // Set all the other outputs to 0
                        // ""ena"" is a special case
                        // It is asserted when the ""START"" state is reached
                        d1 <= 0;
                        d2 <= 0;
                        d3 <= 0;
                        d4 <= 0;
                        d5 <= 0;
                        d6 <= 0;
                        d7 <= 0;
                        ena <= 0;
                        // Count up ""counter""
                        idx <= idx + 1;
                    end
                else
                    begin
                        count <= count + 1;
                        // Set outputs
                        d1 <= data[0];
                        d2 <= data[1];
                        d3 <= data[2];
                        d4 <= data[3];
                        d5 <= data[4];
                        d6 <= data[5];
                        d7 <= data[6];
                        // Count up ""counter""
                        idx <= idx + 1;
                    end
            end
    
    // This is a ""one-off"" signal
    // It goes high when the counter reaches the last bit
    assign done = (idx == 7);
    
    // Modify FSM state table
    always @(*)
        case(state)
            START:
                begin
                    if(ena)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if(done)
                        next_state = STOP;
                    else
                        next_state = DATA;
                end
            STOP:
                begin
                    next_state = (done)? DELAY : START;
                end
            DELAY:
                begin
                    next_state = (done)? DELAY2 : DELAY;
                end
            DELAY2:
                begin
                    next_state = (done)? DELAY3 : DELAY2;
                end
            DELAY3:
                begin
                    next_state = (done)? DELAY4 : DELAY3;
                end
            DELAY4:
                begin
                    next_state = (done)? START : DELAY4;
                end
            default:
                next_state = state;
        endcase
    
    // Modify counter
    always @(posedge clk)
        if(reset)
            counter <= 0;
        else
            counter <= counter + 1;
    
    // Modify FSM output
    always @(posedge clk)
        if(reset)
            data <= 0;
        else
            case(state)
                START:
                    data <= {1'b1, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    
    // Modify FSM and datapath from Fsm_serialdata
	parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] idx;
    reg [7:0] data;
    reg d1, d2, d3, d4, d5, d6, d7;
	
	// Modify FSM state table
    always @(*)
        case(state)
            START: next_state = ena? DATA : START;
            DATA: next_state = done? START : DATA;
            STOP: next_state = START;
            DELAY: next_state = next_state;
            default: next_state = state;
        endcase
    
    // Modify FSM data path
    always @(posedge clk)
        if(reset)
            begin
                state <= START;
                count <= 0;
                idx <= 0;
                data <= 0;
                d1 <= 0;
                d2 <= 0;
                d3 <= 0;
                d4 <= 0;
                d5 <= 0;
                d6 <= 0;
                d7 <= 0;
            end
        else
            begin
                // State transition
                // count is a 3-bit counter
                if(count == 3'b100)
                    begin
                        count <= 0;
                        state <= next_state;
                        // Set all the other outputs to 0
                        // ""ena"" is a special case
                        // It is asserted when the ""START"" state is reached
                        d1 <= 0;
                        d2 <= 0;
                        d3 <= 0;
                        d4 <= 0;
                        d5 <= 0;
                        d6 <= 0;
                        d7 <= 0;
                        ena <= 0;
                        // Count up ""counter""
                        idx <= idx + 1;
                    end
                else
                    begin
                        count <= count + 1;
                        // Set outputs
                        d1 <= data[0];
                        d2 <= data[1];
                        d3 <= data[2];
                        d4 <= data[3];
                        d5 <= data[4];
                        d6 <= data[5];
                        d7 <= data[6];
                        // Count up ""counter""
                        idx <= idx + 1;
                    end
            end
    
    // This is a ""one-off"" signal
    // It goes high when the counter reaches the last bit
    assign done = (idx == 7);
    
    // Modify FSM state table
    always @(*)
        case(state)
            START:
                begin
                    if(ena)
                        next_state = DATA;
                    else
                        next_state = START;
                end
            DATA:
                begin
                    if(done)
                        next_state = STOP;
                    else
                        next_state = DATA;
                end
            STOP:
                begin
                    next_state = (done)? DELAY : START;
                end
            DELAY:
                begin
                    next_state = (done)? DELAY2 : DELAY;
                end
            DELAY2:
                begin
                    next_state = (done)? DELAY3 : DELAY2;
                end
            DELAY3:
                begin
                    next_state = (done)? DELAY4 : DELAY3;
                end
            DELAY4:
                begin
                    next_state = (done)? START : DELAY4;
                end
            default:
                next_state = state;
        endcase
    
    // Modify counter
    always @(posedge clk)
        if(reset)
            counter <= 0;
        else
            counter <= counter + 1;
    
    // Modify FSM output
    always @(posedge clk)
        if(reset)
            data <= 0;
        else
            case(state)
                START:
                    data <= {1'b1, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'b0, 4'hA, 1'"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset == 1'b1)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 1'b1;
                    else
                        q <= 4'b0000;
                end
        end
    
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset == 1'b1)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 1'b1;
                    else
                        q <= 4'b0000;
                end
        end
    
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 1'b1;
                    else
                        q <= 4'b0000;
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 1'b1;
                    else
                        q <= 4'b0000;
                end
        end

endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
        end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
        end
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
        end

endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 4'b0001;
                    else
                        q <= 4'b0000;
                end
        end
    
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 4'b0001;
                    else
                        q <= 4'b0000;
                end
        end
    
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 1'b1;
                    else
                        q <= 4'b0000;
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 1'b1;
                    else
                        q <= 4'b0000;
                end
        end

endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 1'b1;
        end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 1'b1;
        end
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset == 1'b1)
            q <= 4'b0000;
        else
            q <= q + 1'b1;
    end
    
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset == 1'b1)
            q <= 4'b0000;
        else
            q <= q + 1'b1;
    end
    
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset == 1)
                q <= 0;
            else
                q <= q + 1;
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset == 1)
                q <= 0;
            else
                q <= q + 1;
        end

endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
    
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
    
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                q <= q + 1'b1;
        end
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset == 1'b1)
            q <= 4'b0000;
        else
            q <= q + 1'b1;
    end
    
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset == 1'b1)
            q <= 4'b0000;
        else
            q <= q + 1'b1;
    end
    
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                begin
                    if(q <= 9)
                        q <= q + 4'b1;
                    else
                        q <= 4'b0;
                end
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                begin
                    if(q <= 9)
                        q <= q + 4'b1;
                    else
                        q <= 4'b0;
                end
        end

endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 4'b0001;
                    else
                        q <= 4'b0000;
                end
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0000;
            else
                begin
                    if(q <= 4'b1000)
                        q <= q + 4'b0001;
                    else
                        q <= 4'b0000;
                end
        end

endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
        end
    
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
        end
    
endmodule"
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
                
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'b0;
            else
                q <= q + 1'b1;
                
        end

endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
    	else if(q <= 4'd9)
            q <= q + 1'b1;
        else
            q <= 4'd0;
    
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
    	else if(q <= 4'd9)
            q <= q + 1'b1;
        else
            q <= 4'd0;
    
endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0001;
    	else
            begin
                if(q <= 4'b1000)
                    q <= q + 1'b1;
                else
                    q <= 4'b0001;
            end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0001;
    	else
            begin
                if(q <= 4'b1000)
                    q <= q + 1'b1;
                else
                    q <= 4'b0001;
            end

endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0;
    	else if(q <= 4'b1000)
            q <= q + 1'b1;
        else
            q <= 4'b0;

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0;
    	else if(q <= 4'b1000)
            q <= q + 1'b1;
        else
            q <= 4'b0;

endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0001;
    	else
            begin
                if(q <= 4'b1000)
                    q <= q + 1'b1;
                else
                    q <= 4'b0001;
            end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0001;
    	else
            begin
                if(q <= 4'b1000)
                    q <= q + 1'b1;
                else
                    q <= 4'b0001;
            end

endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0;
    	else if(q <= 4'b1000)
            q <= q + 4'b0001;
        else
            q <= 4'b0;
    
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'b0;
    	else if(q <= 4'b1000)
            q <= q + 4'b0001;
        else
            q <= 4'b0;
    
endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
    	else if(q <= 9)
            q <= q + 1'b1;
        else
            q <= 4'd0;
    
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
    	else if(q <= 9)
            q <= q + 1'b1;
        else
            q <= 4'd0;
    
endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
    	else if(q == 9)
            q <= 4'd0;
        else
            q <= q + 1'b1;

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
    	else if(q == 9)
            q <= 4'd0;
        else
            q <= q + 1'b1;

endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else if(q <= 4'd9)
                q <= q + 1'b1;
            else
                q <= 4'd0;
        end
    
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else if(q <= 4'd9)
                q <= q + 1'b1;
            else
                q <= 4'd0;
        end
    
endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else if(q <= 4'd9)
                q <= q + 4'd1;
            else
                q <= 4'd0;
        end
    
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else if(q <= 4'd9)
                q <= q + 4'd1;
            else
                q <= 4'd0;
        end
    
endmodule"
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else if(q <= 4'd9)
            q <= q + 4'd1;
        else
            q <= 4'd0;
    end
    
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else if(q <= 4'd9)
            q <= q + 4'd1;
        else
            q <= 4'd0;
    end
    
endmodule"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'h9 && q[7:4] == 4'h9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[19:16] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[23:20])
    );
    
    // Inst5_count is an instance of a decade counter
    // Inst5_count has 4 inputs: clk, reset, ena, and q.
    // When reset is high, the counter resets to 0.
    // The value of ena determines which decade counter is incremented.
    // For this problem, we do not care which counter is incremented;
    // we just want a value to be produced.
    // By default, the counter is set to 0.
    count Inst5_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[23:20])
    );
    
    
    assign ena = {q[23:20] == 4'h9 && q[19:16] == 4'h9 && q[15:8] == 4'h9,
            q[23:16] == 4'h9 && q[15:8] == 4'h9,
            q[23:16] == 4'h9 && q[7:4] == 4'h9,
            q[23:16] == 4'h9 && q[3:0] == 4'h9};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'h9 && q[7:4] == 4'h9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[19:16] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[23:20])
    );
    
    // Inst5_count is an instance of a decade counter
    // Inst5_count has 4 inputs: clk, reset, ena, and q.
    // When reset is high, the counter resets to 0.
    // The value of ena determines which decade counter is incremented.
    // For this problem, we do not care which counter is incremented;
    // we just want a value to be produced.
    // By default, the counter is set to 0.
    count Inst5_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[23:20])
    );
    
    
    assign ena = {q[23:20] == 4'h9 && q[19:16] == 4'h9 && q[15:8] == 4'h9,
            q[23:16] == 4'h9 && q[15:8] == 4'h9,
            q[23:16] == 4'h9 && q[7:4] == 4'h9,
            q[23:16] == 4'h9 && q[3:0] == 4'h9};
    
endmodule"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'h9 && q[15:12] == 4'h9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'h9 && q[19:16] == 4'h9 && q[23:20] == 4'h9),
       .q(q[27:24])
    );
    
    // Set the counter output signals to match the current count.
    assign ena = {(q == 12'hfff)? 1'b1 : 1'b0, (q == 12'hff8)? 1'b1 : 1'b0, (q == 12'hff0)? 1'b1 : 1'b0, (q == 12'hfe0)? 1'b1 : 1'b0, (q == 12'hfd0)? 1'b1 : 1'b0, (q == 12'hfc0)? 1'b1 : 1'b0, (q == 12'hfb0)? 1'b1 : 1'b0, (q == 12'hfa0)? 1'b1 : 1'b0, (q == 12'hf90)? 1'b1 : 1'b0, (q == 12'hf80)? 1'b1 : 1'b0, (q == 12'hf70)? 1'b1 : 1'b0, (q == 12'hf60)? 1'b1 : 1'b0, (q == 12'hf50)? 1'b1 : 1'b0, (q == 12'hf40)? 1'b1 : 1'b0, (q == 12'hf30)? 1'b1 : 1'b0, (q == 12'hf20)? 1'b1 : 1'b0, (q == 12'hf10)? 1'b1 : 1'b0, (q == 12'hf00)? 1'b1 : 1'b0, (q == 12'hef0)? 1'b1 : 1'b0, (q == 12'hee0)? 1'b1 : 1'b0, (q == 12'hed0)? 1'b1 : 1'b0, (q == 12'hec0)? 1'b1 : 1'b0, (q == 12'heb0)? 1'b1 : 1'b0, (q == 12'hea0)? 1'b1 : 1'b0, (q == 12'he9)? 1'b1 : 1'b0, (q == 12'he8)? 1'b1 : 1'b0, (q == 12'he7)? 1'b1 : 1'b0, (q == 12'he6)? 1'b1 : 1'b0, (q == 12'he5)? 1'b1 : 1'b0, (q == 12'he4)? 1'b1 : 1'b0, (q == 12'he3)? 1'b1 : 1'b0, (q == 12'he2)? 1'b1 : 1'b0, (q == 12'he1)? 1'b1 : 1'b0, (q == 12'he0)? 1'b1 : 1'b0, (q == 12'hdf)? 1'b1 : 1'b0, (q == 12'hde)? 1'b1 : 1'b0, (q == 12'hdd)? 1'b1 : 1'b0, (q == 12'hdc)? 1",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'h9 && q[15:12] == 4'h9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'h9 && q[19:16] == 4'h9 && q[23:20] == 4'h9),
       .q(q[27:24])
    );
    
    // Set the counter output signals to match the current count.
    assign ena = {(q == 12'hfff)? 1'b1 : 1'b0, (q == 12'hff8)? 1'b1 : 1'b0, (q == 12'hff0)? 1'b1 : 1'b0, (q == 12'hfe0)? 1'b1 : 1'b0, (q == 12'hfd0)? 1'b1 : 1'b0, (q == 12'hfc0)? 1'b1 : 1'b0, (q == 12'hfb0)? 1'b1 : 1'b0, (q == 12'hfa0)? 1'b1 : 1'b0, (q == 12'hf90)? 1'b1 : 1'b0, (q == 12'hf80)? 1'b1 : 1'b0, (q == 12'hf70)? 1'b1 : 1'b0, (q == 12'hf60)? 1'b1 : 1'b0, (q == 12'hf50)? 1'b1 : 1'b0, (q == 12'hf40)? 1'b1 : 1'b0, (q == 12'hf30)? 1'b1 : 1'b0, (q == 12'hf20)? 1'b1 : 1'b0, (q == 12'hf10)? 1'b1 : 1'b0, (q == 12'hf00)? 1'b1 : 1'b0, (q == 12'hef0)? 1'b1 : 1'b0, (q == 12'hee0)? 1'b1 : 1'b0, (q == 12'hed0)? 1'b1 : 1'b0, (q == 12'hec0)? 1'b1 : 1'b0, (q == 12'heb0)? 1'b1 : 1'b0, (q == 12'hea0)? 1'b1 : 1'b0, (q == 12'he9)? 1'b1 : 1'b0, (q == 12'he8)? 1'b1 : 1'b0, (q == 12'he7)? 1'b1 : 1'b0, (q == 12'he6)? 1'b1 : 1'b0, (q == 12'he5)? 1'b1 : 1'b0, (q == 12'he4)? 1'b1 : 1'b0, (q == 12'he3)? 1'b1 : 1'b0, (q == 12'he2)? 1'b1 : 1'b0, (q == 12'he1)? 1'b1 : 1'b0, (q == 12'he0)? 1'b1 : 1'b0, (q == 12'hdf)? 1'b1 : 1'b0, (q == 12'hde)? 1'b1 : 1'b0, (q == 12'hdd)? 1'b1 : 1'b0, (q == 12'hdc)? 1"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    one o1(.clk(clk),.reset(reset),.q(q[3:0]));
    
    // ten
    ten t1(.clk(clk),.reset(reset),.q(q[7:4]));
    
    // hundred
    hundred h1(.clk(clk),.reset(reset),.q(q[11:8]));
    
    // thousand
    thousand t2(.clk(clk),.reset(reset),.q(q[15:12]));
    
    // Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    one o1(.clk(clk),.reset(reset),.q(q[3:0]));
    
    // ten
    ten t1(.clk(clk),.reset(reset),.q(q[7:4]));
    
    // hundred
    hundred h1(.clk(clk),.reset(reset),.q(q[11:8]));
    
    // thousand
    thousand t2(.clk(clk),.reset(reset),.q(q[15:12]));
    
    // Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[15:12] == 4'd9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[19:16] == 4'd9),
       .q(q[23:20])
    );
    
    // Set the counter output signals to match the current values of the counter inputs.
    assign ena = {(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9), (q[3:0] == 4'd9 && q[11:8] == 4'd9), (q[3:0] == 4'd9 && q[15:12] == 4'd9), (q[11:8] == 4'd9 && q[15:12] == 4'd9), (q[3:0] == 4'd9 && q[19:16] == 4'd9), (q[11:8] == 4'd9 && q[19:16] == 4'd9), (q[15:12] == 4'd9 && q[23:20] == 4'd9)};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[15:12] == 4'd9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[19:16] == 4'd9),
       .q(q[23:20])
    );
    
    // Set the counter output signals to match the current values of the counter inputs.
    assign ena = {(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9), (q[3:0] == 4'd9 && q[11:8] == 4'd9), (q[3:0] == 4'd9 && q[15:12] == 4'd9), (q[11:8] == 4'd9 && q[15:12] == 4'd9), (q[3:0] == 4'd9 && q[19:16] == 4'd9), (q[11:8] == 4'd9 && q[19:16] == 4'd9), (q[15:12] == 4'd9 && q[23:20] == 4'd9)};
    
endmodule"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    one
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[0]),
       .q(q[3:0])
    );
    
    // ten
    ten
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[1]),
       .q(q[7:4])
    );
    
    // hundred
    hundred
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[2]),
       .q(q[11:8])
    );
    
    // thousand
    thousand
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[3]),
       .q(q[15:12])
    );
    
    // Set the counter to 0.
    
    initial
        q = 16'h0000;
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    one
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[0]),
       .q(q[3:0])
    );
    
    // ten
    ten
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[1]),
       .q(q[7:4])
    );
    
    // hundred
    hundred
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[2]),
       .q(q[11:8])
    );
    
    // thousand
    thousand
    (
       .clk(clk),
       .reset(reset),
       .ena(ena[3]),
       .q(q[15:12])
    );
    
    // Set the counter to 0.
    
    initial
        q = 16'h0000;
    
endmodule"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst10_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'd9 && q[3:0] == 4'd9),
       .q(q[11:8])
    );
    
    // hundred
    count Inst100_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[15:12])
    );
    
    // thousand
    count Inst1000_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[19:16])
    );
    
    // Set the counter output signals to match the current count.
    // (You may need to run./count_digits.py to see the count digits.)
    assign ena[3:1] = {q[3:0], q[7:4] == 4'd9 && q[3:0] == 4'd9};
    assign ena[0] = q[8:4] == 4'd9 && q[3:0] == 4'd9;
    assign ena[4:0] = {q[11:9], q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst10_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'd9 && q[3:0] == 4'd9),
       .q(q[11:8])
    );
    
    // hundred
    count Inst100_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[15:12])
    );
    
    // thousand
    count Inst1000_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[19:16])
    );
    
    // Set the counter output signals to match the current count.
    // (You may need to run./count_digits.py to see the count digits.)
    assign ena[3:1] = {q[3:0], q[7:4] == 4'd9 && q[3:0] == 4'd9};
    assign ena[0] = q[8:4] == 4'd9 && q[3:0] == 4'd9;
    assign ena[4:0] = {q[11:9], q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9};
    
endmodule"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[7:4] == 4'd9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[19:16] == 4'd9 && q[15:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[23:20])
    );
    
    // Set the counter output signals to match the current values of the counter.
    // This is a good time to set the output signals, because if the count values are
    // incorrect, it is possible (and very unlikely) that the modulus operation will
    // return an invalid count value.
    
    assign ena[3:1] = {q[3:0] == 4'd9, q[7:4] == 4'd9, q[11:8] == 4'd9, q[15:12] == 4'd9, q[19:16] == 4'd9, q[23:20] == 4'd9};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[7:4] == 4'd9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[19:16] == 4'd9 && q[15:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[23:20])
    );
    
    // Set the counter output signals to match the current values of the counter.
    // This is a good time to set the output signals, because if the count values are
    // incorrect, it is possible (and very unlikely) that the modulus operation will
    // return an invalid count value.
    
    assign ena[3:1] = {q[3:0] == 4'd9, q[7:4] == 4'd9, q[11:8] == 4'd9, q[15:12] == 4'd9, q[19:16] == 4'd9, q[23:20] == 4'd9};
    
endmodule"
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'h9 && q[7:4] == 4'h9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[19:16] == 4'd9 && q[11:8] == 4'h9 && q[7:4] == 4'h9 && q[3:0] == 4'h9),
       .q(q[23:20])
    );
    
    // Inst5_count is an enabled count for the five-digit run counter
    // This is different from the other four-digit run counters, in that
    // the digit values for this counter are inputs to the module, whereas
    // the other digit values are outputs from the module.
    // You will need to instantiate this counter on the module's own.
    count Inst5_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // Counts 1, 2, or 3 of the enabled counts in the other counters
    // These counters are for the individual digits of the seven-
    // digit result counter.
    // You may need to instantiate these counters on the module's own.
    count Inst1_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'h1 && q[7:4] == 4'h2 && q[11:8] == 4'h3),
       .q(q[11:8])
    );
    
    count Inst2_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'h2 && q[3:0] == 4'h1 && q[7:4] == 4'h3),
       .q(q[7:4])
    );
    
    count Inst3_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'h2 && q[11:8] == 4'h1 && q[3:0] == 4'h3),
       .q(q[3:0])
    );
    
    count Inst4_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'h1 && q[3:0] == 4'h2 && q[7:4] == 4'h3),
       .q(q[11:8])
    );
    
    count Inst5_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'h1 && q[11:8] == 4'h2 && q[7:4] == 4'h3),
       .q(q[7:4])
    );
    
    // Counts 1, 2, or 3 of the enabled counts in the other counters
    // These counters are for the individual digits of the seven-
    // digit result counter.
    // You may need to instantiate these counters on the module's own.
    count Inst1_count_dig2
    (
       .clk(",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten 
    count Inst2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'h9 && q[11:8] == 4'h9),
       .q(q[15:12])
    );
    
    // hundred
    count Inst3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'h9 && q[7:4] == 4'h9),
       .q(q[19:16])
    );
    
    // thousand
    count Inst4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[19:16] == 4'd9 && q[11:8] == 4'h9 && q[7:4] == 4'h9 && q[3:0] == 4'h9),
       .q(q[23:20])
    );
    
    // Inst5_count is an enabled count for the five-digit run counter
    // This is different from the other four-digit run counters, in that
    // the digit values for this counter are inputs to the module, whereas
    // the other digit values are outputs from the module.
    // You will need to instantiate this counter on the module's own.
    count Inst5_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // Counts 1, 2, or 3 of the enabled counts in the other counters
    // These counters are for the individual digits of the seven-
    // digit result counter.
    // You may need to instantiate these counters on the module's own.
    count Inst1_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'h1 && q[7:4] == 4'h2 && q[11:8] == 4'h3),
       .q(q[11:8])
    );
    
    count Inst2_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'h2 && q[3:0] == 4'h1 && q[7:4] == 4'h3),
       .q(q[7:4])
    );
    
    count Inst3_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'h2 && q[11:8] == 4'h1 && q[3:0] == 4'h3),
       .q(q[3:0])
    );
    
    count Inst4_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'h1 && q[3:0] == 4'h2 && q[7:4] == 4'h3),
       .q(q[11:8])
    );
    
    count Inst5_count_dig1
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'h1 && q[11:8] == 4'h2 && q[7:4] == 4'h3),
       .q(q[7:4])
    );
    
    // Counts 1, 2, or 3 of the enabled counts in the other counters
    // These counters are for the individual digits of the seven-
    // digit result counter.
    // You may need to instantiate these counters on the module's own.
    count Inst1_count_dig2
    (
       .clk("
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten
    count Inst10_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[11:8])
    );
    
    // hundred
    count Inst100_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[15:12])
    );
    
    // thousand
    count Inst1000_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[19:16])
    );
    
    // Count instances of a digit on one of the seven segments.
    // For the first 3 segments, each instance is counted as a 2.
    // For the last 3 segments, each instance is counted as a 1.
    
    // Seg0 is special.
    count Seg0_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9),
       .q(q[3:0])
    );
    
    count Seg1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[7:4])
    );
    
    count Seg2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[11:8])
    );
    
    count Seg3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[11:8] == 4'd9 && q[7:4] == 4'd9),
       .q(q[3:0])
    );
    
    count Seg4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[7:4])
    );
    
    count Seg5_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[11:8])
    );
    
    count Seg6_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[11:8] == 4'd9 && q[7:4] == 4'd9),
       .q(q[3:0])
    );
    
    count Seg7_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[7:4] == 4'd9 && q[3:0] == 4'd9),
       .q(q[11:8])
    );
    
    count Seg8_count
    (
       .clk(",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    count Inst1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(1'b1),
       .q(q[3:0])
    );
    
    // ten
    count Inst10_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[11:8])
    );
    
    // hundred
    count Inst100_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[15:12])
    );
    
    // thousand
    count Inst1000_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[15:12] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[19:16])
    );
    
    // Count instances of a digit on one of the seven segments.
    // For the first 3 segments, each instance is counted as a 2.
    // For the last 3 segments, each instance is counted as a 1.
    
    // Seg0 is special.
    count Seg0_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[7:4] == 4'd9 && q[11:8] == 4'd9),
       .q(q[3:0])
    );
    
    count Seg1_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[7:4])
    );
    
    count Seg2_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[11:8])
    );
    
    count Seg3_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[11:8] == 4'd9 && q[7:4] == 4'd9),
       .q(q[3:0])
    );
    
    count Seg4_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[7:4] == 4'd9 && q[11:8] == 4'd9 && q[3:0] == 4'd9),
       .q(q[7:4])
    );
    
    count Seg5_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[3:0] == 4'd9 && q[7:4] == 4'd9),
       .q(q[11:8])
    );
    
    count Seg6_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[3:0] == 4'd9 && q[11:8] == 4'd9 && q[7:4] == 4'd9),
       .q(q[3:0])
    );
    
    count Seg7_count
    (
       .clk(clk),
       .reset(reset),
       .ena(q[11:8] == 4'd9 && q[7:4] == 4'd9 && q[3:0] == 4'd9),
       .q(q[11:8])
    );
    
    count Seg8_count
    (
       .clk("
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    one o1(clk, reset, q[3:0]);
    
    // ten 
    ten t1(clk, reset, q[7:4]);
    
    // hundred
    hundred h1(clk, reset, q[11:8]);
    
    // thousand
    thousand h0(clk, reset, q[15:12]);
    
    // Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // one
    one o1(clk, reset, q[3:0]);
    
    // ten 
    ten t1(clk, reset, q[7:4]);
    
    // hundred
    hundred h1(clk, reset, q[11:8]);
    
    // thousand
    thousand h0(clk, reset, q[15:12]);
    
    // Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want to instantiate or modify some one-digit decade counters.

// You may want"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter control
    //   {q[3], q[2], q[1], q[0]} = {q[2], q[1], q[0], q[3]}
    //   {q[2], q[1], q[0]}   = {q[1], q[0], q[3]}
    //   {q[1], q[0]}        = {q[0], q[3]}
    //   {q[0]}                = {q[3], q[2], q[1], q[0]}
    
    // This works if you explicitly specify the order of the bits
    //   {q[0], q[3:1]} = {q[3], q[2:0], q[0]}
    //   {q[1:0], q[3:2]} = {q[2:0], q[1:0], q[0]}
    //   {q[3:0], q[3:2]} = {q[2:0], q[3:0]}
    
    reg [3:0] reg_3;
    reg [2:0] reg_2;
    reg [1:0] reg_1;
    reg [0:0] reg_0;
    
    always @(posedge clk)
    begin
        reg_0 <= {reg_0[0], q[0]};
        reg_1 <= {reg_1[0], q[1]};
        reg_2 <= {reg_2[0], q[2]};
        reg_3 <= {reg_3[0], q[3]};
    end
    
    assign q = {reg_3, reg_2, reg_1, reg_0};
    
endmodule",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter control
    //   {q[3], q[2], q[1], q[0]} = {q[2], q[1], q[0], q[3]}
    //   {q[2], q[1], q[0]}   = {q[1], q[0], q[3]}
    //   {q[1], q[0]}        = {q[0], q[3]}
    //   {q[0]}                = {q[3], q[2], q[1], q[0]}
    
    // This works if you explicitly specify the order of the bits
    //   {q[0], q[3:1]} = {q[3], q[2:0], q[0]}
    //   {q[1:0], q[3:2]} = {q[2:0], q[1:0], q[0]}
    //   {q[3:0], q[3:2]} = {q[2:0], q[3:0]}
    
    reg [3:0] reg_3;
    reg [2:0] reg_2;
    reg [1:0] reg_1;
    reg [0:0] reg_0;
    
    always @(posedge clk)
    begin
        reg_0 <= {reg_0[0], q[0]};
        reg_1 <= {reg_1[0], q[1]};
        reg_2 <= {reg_2[0], q[2]};
        reg_3 <= {reg_3[0], q[3]};
    end
    
    assign q = {reg_3, reg_2, reg_1, reg_0};
    
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter control
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b1};
    
    // Build a decade counter that counts from 0 to 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter control
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b1};
    
    // Build a decade counter that counts from 0 to 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter control
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b1};
    
    // Build a decade counter that counts from 0 to 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter control
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b0, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b0, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b0, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b0};
    //   {q[3], q[2], q[1], q[0]} = {1'b1, 1'b1, 1'b1, 1'b1};
    
    // Build a decade counter that counts from 0 to 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter a
    // Non-blocking assignment for counter b
    // Non-blocking assignment for counter c
    // Non-blocking assignment for counter d
    // Non-blocking assignment for counter e
    // Non-blocking assignment for counter f
    // Non-blocking assignment for counter g
    // Non-blocking assignment for counter h
    // Non-blocking assignment for counter i
    // Non-blocking assignment for counter j
    // Non-blocking assignment for counter k
    // Non-blocking assignment for counter l
    // Non-blocking assignment for counter m
    // Non-blocking assignment for counter n
    // Non-blocking assignment for counter o
    // Non-blocking assignment for counter p
    // Non-blocking assignment for counter q
    
    // Create modules for each of the seven counters
    // Create modules for each of the 16 7-segment displays
    // Set the value of the first display to 0
    // Set the value of the second display to 1
    // Set the value of the third display to 2
    // Set the value of the fourth display to 3
    // Set the value of the fifth display to 4
    // Set the value of the sixth display to 5
    // Set the value of the seventh display to 6
    // Set the value of the eighth display to 7
    // Set the value of the ninth display to 8
    // Set the value of the tenth display to 9
    // Set the value of the eleventh display to A
    // Set the value of the twelfth display to B
    // Set the value of the thirteenth display to C
    // Set the value of the fourteenth display to D
    // Set the value of the fifteenth display to E
    // Set the value of the sixteenth display to F
    // Set the value of the seventeenth display to G
    // Set the value of the eighteenth display to H
    // Set the value of the nineteenth display to I
    // Set the value of the twentieth display to J
    // Set the value of the eleventh display to K
    // Set the value of the twelfth display to L
    // Set the value of the thirteenth display to M
    // Set the value of the fourteenth display to N
    // Set the value of the fifteenth display to O
    // Set the value of the sixteenth display to P
    // Set the value of the seventeenth display to Q
    // Set the value of the eighth display to R
    // Set the value of the ninth display to S
    // Set the value of the tenth display to T
    // Set the value of the eleventh display to U
    // Set the value of the twelfth display to V
    // Set the value of the thirteenth display to W
    // Set the value of the fourteenth display to X
    // Set the value of the fifteenth display to Y
    // Set the value of the sixteenth display to Z
    
    // Create an instance of a decade counter called c1
    // Set the value of the counter to 0
    // Set the clock to 1
    // Create an instance of a decade counter called c2
    // Set the value of the counter to 1
    // Set the clock to 1
    // Create an instance of a decade counter called c3
    // Set the value of the counter to 2
    // Set the clock to 1
    // Create an instance of a decade counter called c4
    // Set the value of the counter to 3
    // Set the clock to 1
    // Create an instance of a decade counter called c5
    // Set the value of the counter to 4
    // Set the clock to 1
    // Create an instance of a decade counter called c6
    // Set the value of the counter to 5
    // Set the clock to 1
    // Create an instance of a decade counter called c7
    // Set the value of the counter to 6
    // Set the clock to 1
    // Create an instance of a decade counter called c8
    // Set the value of the counter to 7
    // Set the clock to 1
    // Create an instance of a decade counter called c9
    // Set the value of the counter to 8
    // Set the clock to 1
    // Create an instance of a decade counter called c10
    // Set the value of the counter to 9
    // Set the clock to 1
    // Create an instance of a decade counter called c11
    // Set the value of the counter to A
    // Set the clock to 1
    // Create an instance of a decade counter called c12",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter a
    // Non-blocking assignment for counter b
    // Non-blocking assignment for counter c
    // Non-blocking assignment for counter d
    // Non-blocking assignment for counter e
    // Non-blocking assignment for counter f
    // Non-blocking assignment for counter g
    // Non-blocking assignment for counter h
    // Non-blocking assignment for counter i
    // Non-blocking assignment for counter j
    // Non-blocking assignment for counter k
    // Non-blocking assignment for counter l
    // Non-blocking assignment for counter m
    // Non-blocking assignment for counter n
    // Non-blocking assignment for counter o
    // Non-blocking assignment for counter p
    // Non-blocking assignment for counter q
    
    // Create modules for each of the seven counters
    // Create modules for each of the 16 7-segment displays
    // Set the value of the first display to 0
    // Set the value of the second display to 1
    // Set the value of the third display to 2
    // Set the value of the fourth display to 3
    // Set the value of the fifth display to 4
    // Set the value of the sixth display to 5
    // Set the value of the seventh display to 6
    // Set the value of the eighth display to 7
    // Set the value of the ninth display to 8
    // Set the value of the tenth display to 9
    // Set the value of the eleventh display to A
    // Set the value of the twelfth display to B
    // Set the value of the thirteenth display to C
    // Set the value of the fourteenth display to D
    // Set the value of the fifteenth display to E
    // Set the value of the sixteenth display to F
    // Set the value of the seventeenth display to G
    // Set the value of the eighteenth display to H
    // Set the value of the nineteenth display to I
    // Set the value of the twentieth display to J
    // Set the value of the eleventh display to K
    // Set the value of the twelfth display to L
    // Set the value of the thirteenth display to M
    // Set the value of the fourteenth display to N
    // Set the value of the fifteenth display to O
    // Set the value of the sixteenth display to P
    // Set the value of the seventeenth display to Q
    // Set the value of the eighth display to R
    // Set the value of the ninth display to S
    // Set the value of the tenth display to T
    // Set the value of the eleventh display to U
    // Set the value of the twelfth display to V
    // Set the value of the thirteenth display to W
    // Set the value of the fourteenth display to X
    // Set the value of the fifteenth display to Y
    // Set the value of the sixteenth display to Z
    
    // Create an instance of a decade counter called c1
    // Set the value of the counter to 0
    // Set the clock to 1
    // Create an instance of a decade counter called c2
    // Set the value of the counter to 1
    // Set the clock to 1
    // Create an instance of a decade counter called c3
    // Set the value of the counter to 2
    // Set the clock to 1
    // Create an instance of a decade counter called c4
    // Set the value of the counter to 3
    // Set the clock to 1
    // Create an instance of a decade counter called c5
    // Set the value of the counter to 4
    // Set the clock to 1
    // Create an instance of a decade counter called c6
    // Set the value of the counter to 5
    // Set the clock to 1
    // Create an instance of a decade counter called c7
    // Set the value of the counter to 6
    // Set the clock to 1
    // Create an instance of a decade counter called c8
    // Set the value of the counter to 7
    // Set the clock to 1
    // Create an instance of a decade counter called c9
    // Set the value of the counter to 8
    // Set the clock to 1
    // Create an instance of a decade counter called c10
    // Set the value of the counter to 9
    // Set the clock to 1
    // Create an instance of a decade counter called c11
    // Set the value of the counter to A
    // Set the clock to 1
    // Create an instance of a decade counter called c12"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    reg	[3:0]	q_next;
    
    // This DFF is a regular decade counter. It resets to 0 when
    // the reset input is asserted, and it increments when
    // slowena is asserted.
    
    always @(posedge clk, posedge reset)
        if(reset)
            q_next <= 4'b0;
        else if(slowena)
            q_next <= q_next + 4'b1;
    
    // This FF is a register that stores q. It loads the next
    // value when the value is read, and it saves the current
    // value when it is written.
    
    always @(posedge clk, posedge slowena)
        q <= q_next;

endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    reg	[3:0]	q_next;
    
    // This DFF is a regular decade counter. It resets to 0 when
    // the reset input is asserted, and it increments when
    // slowena is asserted.
    
    always @(posedge clk, posedge reset)
        if(reset)
            q_next <= 4'b0;
        else if(slowena)
            q_next <= q_next + 4'b1;
    
    // This FF is a register that stores q. It loads the next
    // value when the value is read, and it saves the current
    // value when it is written.
    
    always @(posedge clk, posedge slowena)
        q <= q_next;

endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    reg [3:0] d;
    
    always @(posedge clk)
        if(slowena)
            d <= d + 1;
    
    always @(posedge clk)
        if(reset)
            d <= 4'b0;
    
    assign q = d;
endmodule",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    reg [3:0] d;
    
    always @(posedge clk)
        if(slowena)
            d <= d + 1;
    
    always @(posedge clk)
        if(reset)
            d <= 4'b0;
    
    assign q = d;
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter a
    // Non-blocking assignment can change a value even if the clock is stopped
    // Non-blocking assignment can change a value even if the clock is stopped
    // When the counter is reset, it goes to 0, independent of the clock
    
    reg [3:0] a;
    
    always @(posedge clk)
        if(reset)
            a <= 4'b0;
    	else if(slowena)
            if(a < 9)
                a <= a + 4'b1;
            else
                a <= 4'b0;
    
    // This is a combinational logic of a decade counter
    assign q = a;
    
endmodule",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter a
    // Non-blocking assignment can change a value even if the clock is stopped
    // Non-blocking assignment can change a value even if the clock is stopped
    // When the counter is reset, it goes to 0, independent of the clock
    
    reg [3:0] a;
    
    always @(posedge clk)
        if(reset)
            a <= 4'b0;
    	else if(slowena)
            if(a < 9)
                a <= a + 4'b1;
            else
                a <= 4'b0;
    
    // This is a combinational logic of a decade counter
    assign q = a;
    
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // This is a decade counter with a clock and a reset
    // The counter counts from 0 to 9, with a period of 10
    // When the counter is 9, the counter resets to 0
    
    // To determine the value of q, we need to first determine the current value of the counter.
    // We get the current counter value by calling the 'q' function.
    // The value of the counter is found by incrementing the counter value by one.
    // We need to perform the operation in a blocking fashion, so that the value of q is returned correctly.
    
    // When the counter is reset, it is necessary to reinitialize the counter to 0.
    // To do this, we call the 'clear' function, passing the parameter'reset'.
    
    // When the counter is incremented, it is necessary to check the new value of q.
    // If the value of q has not changed, then the counter has reached the value 9.
    // In this case, we need to reinitialize the counter to 0.
    // To do this, we call the 'clear' function, this time passing the parameter 'not_full'.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // This is a decade counter with a clock and a reset
    // The counter counts from 0 to 9, with a period of 10
    // When the counter is 9, the counter resets to 0
    
    // To determine the value of q, we need to first determine the current value of the counter.
    // We get the current counter value by calling the 'q' function.
    // The value of the counter is found by incrementing the counter value by one.
    // We need to perform the operation in a blocking fashion, so that the value of q is returned correctly.
    
    // When the counter is reset, it is necessary to reinitialize the counter to 0.
    // To do this, we call the 'clear' function, passing the parameter'reset'.
    
    // When the counter is incremented, it is necessary to check the new value of q.
    // If the value of q has not changed, then the counter has reached the value 9.
    // In this case, we need to reinitialize the counter to 0.
    // To do this, we call the 'clear' function, this time passing the parameter 'not_full'.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is also possible to do this with a loop, but it will not work for this problem.
    
    // The value of the counter is set to the parameter 'value'.
    // Once the counter reaches the value 9, we need to set the counter to 0.
    // To do this, we call the 'clear' function with the parameter'set'.
    // We can also use the blocking assignment operator to set the counter, but it is recommended to use the function call operator.
    // It is"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use a clocked always block
    //   copy d to q at every edge of clk
    //   whenever reset goes high, set all q's to 4'b0
    
    always @(posedge clk) begin
        if(reset)
            q <= 4'b0000;
        else if(slowena) begin
            //q[0] <= d[0] ^ q[0];
            q[0] <= {q[0], 1'b0} ^ q[0];
            q[1] <= {q[1], 1'b0} ^ q[1];
            q[2] <= {q[2], 1'b0} ^ q[2];
            q[3] <= {q[3], 1'b0} ^ q[3];
        end
    end
    
endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use a clocked always block
    //   copy d to q at every edge of clk
    //   whenever reset goes high, set all q's to 4'b0
    
    always @(posedge clk) begin
        if(reset)
            q <= 4'b0000;
        else if(slowena) begin
            //q[0] <= d[0] ^ q[0];
            q[0] <= {q[0], 1'b0} ^ q[0];
            q[1] <= {q[1], 1'b0} ^ q[1];
            q[2] <= {q[2], 1'b0} ^ q[2];
            q[3] <= {q[3], 1'b0} ^ q[3];
        end
    end
    
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    reg [3:0] d;
    
    always @(posedge clk)
        if(reset)
            d <= 4'b0;
    	else if(slowena)
            d <= d + 4'b1;
    
    assign q = d;
    
endmodule",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    reg [3:0] d;
    
    always @(posedge clk)
        if(reset)
            d <= 4'b0;
    	else if(slowena)
            d <= d + 4'b1;
    
    assign q = d;
    
endmodule"
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter
    
    reg [3:0] counter;
    
    // Count from 0 to 9, and wrap around
    
    always @(posedge clk, negedge resetn)
        if(~resetn)
            counter <= 4'h0;
        else
            counter <= counter + 4'h1;
            
    // Enable counter for 4 half-cycles
    
    always @(posedge clk)
        if(slowena)
            counter <= counter + 4'h1;

endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use non-blocking assignment for counter
    
    reg [3:0] counter;
    
    // Count from 0 to 9, and wrap around
    
    always @(posedge clk, negedge resetn)
        if(~resetn)
            counter <= 4'h0;
        else
            counter <= counter + 4'h1;
            
    // Enable counter for 4 half-cycles
    
    always @(posedge clk)
        if(slowena)
            counter <= counter + 4'h1;

endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every
    //   positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every
    //   positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every
    //   positive edge of clk
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every
    //   positive edge of clk
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // This is a two clock cycle read at the cost of a longer clock-to-out timing
    // The first stage is a left shift, while the second stage is a right shift.
    // The output is a value of the form 100010111011101110111011101110111.
    
    // Create a 16x16 decoder. I'm lazy, so I first build the matrix then split it into 16 1-bit vectors.
    // It would be nice if Verilog had some form of optional module parameters, but I can't figure out how.
    //   http://stackoverflow.com/a/162439
    //   http://stackoverflow.com/a/162440
    
    reg [15:0] matrix [0:15];
    
    initial
    begin
        $readmemb(""matrix.mem"", matrix);
    end
    
    wire [0:15] d_out;
    
    // d_out is the output that we see in the simulation waveform.
    // The other module outputs are registered in an attempt to help with the simulation.
    
    decoder dec0 (
       .data(d),
       .row_A(1'b0),
       .row_B(1'b1),
       .an(an),
       .seg(d_out)
    );
    
    // The value (d_out) is compared with the known good ouput (q_expect)
    
    always @(posedge clk)
    begin
        if (d_out == q_expect)
            $display(""Simulation succeeded"");
        else
            $display(""Simulation failed: %b!= %b"", d_out, q_expect);
    end
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // This is a two clock cycle read at the cost of a longer clock-to-out timing
    // The first stage is a left shift, while the second stage is a right shift.
    // The output is a value of the form 100010111011101110111011101110111.
    
    // Create a 16x16 decoder. I'm lazy, so I first build the matrix then split it into 16 1-bit vectors.
    // It would be nice if Verilog had some form of optional module parameters, but I can't figure out how.
    //   http://stackoverflow.com/a/162439
    //   http://stackoverflow.com/a/162440
    
    reg [15:0] matrix [0:15];
    
    initial
    begin
        $readmemb(""matrix.mem"", matrix);
    end
    
    wire [0:15] d_out;
    
    // d_out is the output that we see in the simulation waveform.
    // The other module outputs are registered in an attempt to help with the simulation.
    
    decoder dec0 (
       .data(d),
       .row_A(1'b0),
       .row_B(1'b1),
       .an(an),
       .seg(d_out)
    );
    
    // The value (d_out) is compared with the known good ouput (q_expect)
    
    always @(posedge clk)
    begin
        if (d_out == q_expect)
            $display(""Simulation succeeded"");
        else
            $display(""Simulation failed: %b!= %b"", d_out, q_expect);
    end
    
endmodule"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // This is a 16x16 shift register.
    // reg16 inst_mem_16x16 (clk, reset, d[15:0], q[15:0]);
    reg16 d_ff0 (clk, reset, d[0], q[0]);
    reg16 d_ff1 (clk, reset, d[1], q[1]);
    reg16 d_ff2 (clk, reset, d[2], q[2]);
    reg16 d_ff3 (clk, reset, d[3], q[3]);
    reg16 d_ff4 (clk, reset, d[4], q[4]);
    reg16 d_ff5 (clk, reset, d[5], q[5]);
    reg16 d_ff6 (clk, reset, d[6], q[6]);
    reg16 d_ff7 (clk, reset, d[7], q[7]);
    reg16 d_ff8 (clk, reset, d[8], q[8]);
    reg16 d_ff9 (clk, reset, d[9], q[9]);
    reg16 d_ff10 (clk, reset, d[10], q[10]);
    reg16 d_ff11 (clk, reset, d[11], q[11]);
    reg16 d_ff12 (clk, reset, d[12], q[12]);
    reg16 d_ff13 (clk, reset, d[13], q[13]);
    reg16 d_ff14 (clk, reset, d[14], q[14]);
    reg16 d_ff15 (clk, reset, d[15], q[15]);
    
    // This is a 16x8 decoder.
    // The 8 MSB's are stored in the 8 LSB's.
    // The 16x8 decoder is a combinational logic function.
    // It can be synthesized in a combinational fashion.
    // assign byte_en = {4{(~|byteena)}};
    
    
    // Alternatively, ""assign byte_en = byteena[1:0];"" works too.
    
    
    // 16x8 decoder
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // This is a 16x16 shift register.
    // reg16 inst_mem_16x16 (clk, reset, d[15:0], q[15:0]);
    reg16 d_ff0 (clk, reset, d[0], q[0]);
    reg16 d_ff1 (clk, reset, d[1], q[1]);
    reg16 d_ff2 (clk, reset, d[2], q[2]);
    reg16 d_ff3 (clk, reset, d[3], q[3]);
    reg16 d_ff4 (clk, reset, d[4], q[4]);
    reg16 d_ff5 (clk, reset, d[5], q[5]);
    reg16 d_ff6 (clk, reset, d[6], q[6]);
    reg16 d_ff7 (clk, reset, d[7], q[7]);
    reg16 d_ff8 (clk, reset, d[8], q[8]);
    reg16 d_ff9 (clk, reset, d[9], q[9]);
    reg16 d_ff10 (clk, reset, d[10], q[10]);
    reg16 d_ff11 (clk, reset, d[11], q[11]);
    reg16 d_ff12 (clk, reset, d[12], q[12]);
    reg16 d_ff13 (clk, reset, d[13], q[13]);
    reg16 d_ff14 (clk, reset, d[14], q[14]);
    reg16 d_ff15 (clk, reset, d[15], q[15]);
    
    // This is a 16x8 decoder.
    // The 8 MSB's are stored in the 8 LSB's.
    // The 16x8 decoder is a combinational logic function.
    // It can be synthesized in a combinational fashion.
    // assign byte_en = {4{(~|byteena)}};
    
    
    // Alternatively, ""assign byte_en = byteena[1:0];"" works too.
    
    
    // 16x8 decoder
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001
    // 10:  0010
    // 11:  0011
    // 00:  0000
    // 01:  0001"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // Use FSM from Fsm_serial
	parameter S_idle = 0;
	parameter S_wait_for_low = 1;
	parameter S_wait_for_high = 2;
	parameter S_print_char = 3;
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg [15:0] data;
    reg [2:0] byteena_reg;
    
    
    // Next state logic aka our state table
    always@(*)
    begin: state_table
        case (state)
            S_idle:
                begin
                    if(~resetn)
                        next_state = S_idle;
                    else
                        next_state = S_wait_for_low;
                end
            S_wait_for_low:
                begin
                    if(d[0] == 1'b0)
                        next_state = S_wait_for_high;
                    else
                        next_state = S_wait_for_low;
                end
            S_wait_for_high:
                begin
                    if(d[1] == 1'b0)
                        next_state = S_print_char;
                    else
                        next_state = S_wait_for_high;
                end
            S_print_char:
                begin
                    if(d[2] == 1'b0)
                        next_state = S_idle;
                    else
                        next_state = S_print_char;
                end
            default:
                next_state = S_idle;
        endcase
    end // state_table
    
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
    begin: state_FFs
        if(!resetn)
            state <= S_idle;
        else
            state <= next_state;
    end // state_FFS
    
    
    // Output logic aka all of our datapath control signals
    always @(*)
    begin: enable_signals
        // By default make all our signals 0
        ld_A = 1'b0;
        ld_B = 1'b0;
        ld_l = 1'b0;
        ld_w = 1'b0;
        ld_r = 1'b0;
        ld_alu = 1'b0;
        alu_select_a = 2'b00;
        alu_select_b = 2'b00;
        alu_op       = 1'b0;
        
        case (state)
            S_idle:
                begin
                    ld_A = 1'b1;
                    ld_B = 1'b1;
                    ld_l = 1'b1;
                    ld_w = 1'b1;
                    ld_r = 1'b1;
                    ld_alu = 1'b1;
                    
                    alu_select_a = 2'b00;
                    alu_select_b = 2'b01;
                    alu_op = 1'b0;
                end
            S_wait_for_low:
                begin
                    ld_A = 1'b1;
                    ld_B = 1'b1;
                    ld_l = 1'b1;
                    ld_w = 1'b1;
                    ld_r = 1'b1;
                    ld_alu = 1'b1;
                    
                    alu_select_a = 2'b00;
                    alu_select_b = 2'b01;
                    alu_op = 1'b0;
                end
            S_wait_for_high:
                begin
                    ld_A = 1'b1;
                    ld_B = 1'b1;
                    ld_l = 1'b1;
                    ld_w = 1'b1;
                    ld_r = 1'b1;
                    ld_alu = 1'b1;
                    
                    alu_select_a = 2'b00;
                    alu_select_b = 2'b01;
                    alu_op = 1'b0;
                end
            S_print_char:
                begin
                    ld_A = 1'b0;
                    ld_B = 1'b",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // Use FSM from Fsm_serial
	parameter S_idle = 0;
	parameter S_wait_for_low = 1;
	parameter S_wait_for_high = 2;
	parameter S_print_char = 3;
    
    reg [2:0] state, next_state;
    reg [3:0] count;
    reg [15:0] data;
    reg [2:0] byteena_reg;
    
    
    // Next state logic aka our state table
    always@(*)
    begin: state_table
        case (state)
            S_idle:
                begin
                    if(~resetn)
                        next_state = S_idle;
                    else
                        next_state = S_wait_for_low;
                end
            S_wait_for_low:
                begin
                    if(d[0] == 1'b0)
                        next_state = S_wait_for_high;
                    else
                        next_state = S_wait_for_low;
                end
            S_wait_for_high:
                begin
                    if(d[1] == 1'b0)
                        next_state = S_print_char;
                    else
                        next_state = S_wait_for_high;
                end
            S_print_char:
                begin
                    if(d[2] == 1'b0)
                        next_state = S_idle;
                    else
                        next_state = S_print_char;
                end
            default:
                next_state = S_idle;
        endcase
    end // state_table
    
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
    begin: state_FFs
        if(!resetn)
            state <= S_idle;
        else
            state <= next_state;
    end // state_FFS
    
    
    // Output logic aka all of our datapath control signals
    always @(*)
    begin: enable_signals
        // By default make all our signals 0
        ld_A = 1'b0;
        ld_B = 1'b0;
        ld_l = 1'b0;
        ld_w = 1'b0;
        ld_r = 1'b0;
        ld_alu = 1'b0;
        alu_select_a = 2'b00;
        alu_select_b = 2'b00;
        alu_op       = 1'b0;
        
        case (state)
            S_idle:
                begin
                    ld_A = 1'b1;
                    ld_B = 1'b1;
                    ld_l = 1'b1;
                    ld_w = 1'b1;
                    ld_r = 1'b1;
                    ld_alu = 1'b1;
                    
                    alu_select_a = 2'b00;
                    alu_select_b = 2'b01;
                    alu_op = 1'b0;
                end
            S_wait_for_low:
                begin
                    ld_A = 1'b1;
                    ld_B = 1'b1;
                    ld_l = 1'b1;
                    ld_w = 1'b1;
                    ld_r = 1'b1;
                    ld_alu = 1'b1;
                    
                    alu_select_a = 2'b00;
                    alu_select_b = 2'b01;
                    alu_op = 1'b0;
                end
            S_wait_for_high:
                begin
                    ld_A = 1'b1;
                    ld_B = 1'b1;
                    ld_l = 1'b1;
                    ld_w = 1'b1;
                    ld_r = 1'b1;
                    ld_alu = 1'b1;
                    
                    alu_select_a = 2'b00;
                    alu_select_b = 2'b01;
                    alu_op = 1'b0;
                end
            S_print_char:
                begin
                    ld_A = 1'b0;
                    ld_B = 1'b"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // This is a reset-free version of the shift register.
    // Create a register that is 32 bits wide, with d as the value.
    // For the output, split the d value into two 16-bit ""components"":
    // the two bytes that will make up byte 0 of the output.
    reg [15:0] d_ff0, d_ff1;
    
    assign q[0] = d_ff0[0];
    assign q[1] = d_ff0[1];
    assign q[2] = d_ff0[2];
    assign q[3] = d_ff0[3];
    assign q[4] = d_ff0[4];
    assign q[5] = d_ff0[5];
    assign q[6] = d_ff0[6];
    assign q[7] = d_ff0[7];
    assign q[8] = d_ff0[8];
    assign q[9] = d_ff0[9];
    assign q[10] = d_ff0[10];
    assign q[11] = d_ff0[11];
    assign q[12] = d_ff0[12];
    assign q[13] = d_ff0[13];
    assign q[14] = d_ff0[14];
    assign q[15] = d_ff0[15];
    assign q[16] = d_ff1[0];
    assign q[17] = d_ff1[1];
    assign q[18] = d_ff1[2];
    assign q[19] = d_ff1[3];
    assign q[20] = d_ff1[4];
    assign q[21] = d_ff1[5];
    assign q[22] = d_ff1[6];
    assign q[23] = d_ff1[7];
    assign q[24] = d_ff1[8];
    assign q[25] = d_ff1[9];
    assign q[26] = d_ff1[10];
    assign q[27] = d_ff1[11];
    assign q[28] = d_ff1[12];
    assign q[29] = d_ff1[13];
    assign q[30] = d_ff1[14];
    assign q[31] = d_ff1[15];
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // This is a reset-free version of the shift register.
    // Create a register that is 32 bits wide, with d as the value.
    // For the output, split the d value into two 16-bit ""components"":
    // the two bytes that will make up byte 0 of the output.
    reg [15:0] d_ff0, d_ff1;
    
    assign q[0] = d_ff0[0];
    assign q[1] = d_ff0[1];
    assign q[2] = d_ff0[2];
    assign q[3] = d_ff0[3];
    assign q[4] = d_ff0[4];
    assign q[5] = d_ff0[5];
    assign q[6] = d_ff0[6];
    assign q[7] = d_ff0[7];
    assign q[8] = d_ff0[8];
    assign q[9] = d_ff0[9];
    assign q[10] = d_ff0[10];
    assign q[11] = d_ff0[11];
    assign q[12] = d_ff0[12];
    assign q[13] = d_ff0[13];
    assign q[14] = d_ff0[14];
    assign q[15] = d_ff0[15];
    assign q[16] = d_ff1[0];
    assign q[17] = d_ff1[1];
    assign q[18] = d_ff1[2];
    assign q[19] = d_ff1[3];
    assign q[20] = d_ff1[4];
    assign q[21] = d_ff1[5];
    assign q[22] = d_ff1[6];
    assign q[23] = d_ff1[7];
    assign q[24] = d_ff1[8];
    assign q[25] = d_ff1[9];
    assign q[26] = d_ff1[10];
    assign q[27] = d_ff1[11];
    assign q[28] = d_ff1[12];
    assign q[29] = d_ff1[13];
    assign q[30] = d_ff1[14];
    assign q[31] = d_ff1[15];
    
endmodule"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Because this counter is a general counter, it can be used for all of the 16-bit D flip-flops.
    // To define a 16-bit D flip-flop, you will need to declare a 16-bit wire d_i and a 16-bit wire q_i.
    
    wire [15:0] d_i;
    wire [15:0] q_i;
    
    genvar i;
    generate
        // Define the 16-bit D flip-flop.
        for (i = 0; i < 16; i = i + 1) begin: d_ff
            d_flip_flop d_i(clk, resetn, d[i], d_i[i], q_i[i]);
        end
    endgenerate
    
    // Define the 16-bit counter.
    counter_16 counter(clk, resetn, q_i, q);
    
    // Define the bus between the D flip-flops and the counter.
    // The 'byteena' bus controls which bytes are written to the counter.
    // The 'd_i' bus is the input to the D flip-flops.
    // The 'q_i' bus is the output from the D flip-flops.
    
    reg [15:0] d_i;
    reg [15:0] q_i;
    
    always @(posedge clk) begin
        if (!resetn) begin
            d_i <= 0;
            q_i <= 0;
        end
        else begin
            d_i <= d_i + 1;
            q_i <= q_i + 1;
            
            // You can increase the size of the counter by concatenating the declaration of the counter with the declaration of the d_flip_flop.
            // It works if both are inside the same module.
            // counter16 counter(clk, resetn, q_i, q);
        end
    end
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Because this counter is a general counter, it can be used for all of the 16-bit D flip-flops.
    // To define a 16-bit D flip-flop, you will need to declare a 16-bit wire d_i and a 16-bit wire q_i.
    
    wire [15:0] d_i;
    wire [15:0] q_i;
    
    genvar i;
    generate
        // Define the 16-bit D flip-flop.
        for (i = 0; i < 16; i = i + 1) begin: d_ff
            d_flip_flop d_i(clk, resetn, d[i], d_i[i], q_i[i]);
        end
    endgenerate
    
    // Define the 16-bit counter.
    counter_16 counter(clk, resetn, q_i, q);
    
    // Define the bus between the D flip-flops and the counter.
    // The 'byteena' bus controls which bytes are written to the counter.
    // The 'd_i' bus is the input to the D flip-flops.
    // The 'q_i' bus is the output from the D flip-flops.
    
    reg [15:0] d_i;
    reg [15:0] q_i;
    
    always @(posedge clk) begin
        if (!resetn) begin
            d_i <= 0;
            q_i <= 0;
        end
        else begin
            d_i <= d_i + 1;
            q_i <= q_i + 1;
            
            // You can increase the size of the counter by concatenating the declaration of the counter with the declaration of the d_flip_flop.
            // It works if both are inside the same module.
            // counter16 counter(clk, resetn, q_i, q);
        end
    end
    
endmodule"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Each DFF is a clocked up shift register of length 2^n.
    // For n=2, each DFF is a register.
    // For n=3, each DFF is a flip-flop.
    // In the output generation, I'm only using the LSB (n=2) and the MSB (n=3)
    // I'm not using the other bits, even though they are present in the register.
    // I'm only using the LSB (n=2) and the MSB (n=3)
    
    reg [15:0] d_reg;
    reg [15:0] q_reg;
    
    // d_reg is the DFF input.
    // q_reg is the DFF output.
    
    always @(posedge clk)
        if(~resetn)
            d_reg <= 16'h0000;
        else
            d_reg <= d;
            
    always @(posedge clk)
        if(~resetn)
            q_reg <= 16'h0000;
        else
            if(byteena == 2'b00)
                q_reg[7:0] <= d_reg[7:0];
            else if(byteena == 2'b01)
                q_reg[15:8] <= d_reg[15:8];
            else if(byteena == 2'b10)
                q_reg[15:0] <= d_reg[15:0];
            else
                q_reg <= d_reg;
    
    // If the MSB is set, then it's a flip-flop.
    // If the LSB is set, then it's a register.
    // Otherwise, it's a register.
    assign q = ~(byteena == 2'b00? {q_reg[15:1], 1'b0} :
                 byteena == 2'b01? {8{q_reg[7:0]}} :
                 {q_reg});
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Each DFF is a clocked up shift register of length 2^n.
    // For n=2, each DFF is a register.
    // For n=3, each DFF is a flip-flop.
    // In the output generation, I'm only using the LSB (n=2) and the MSB (n=3)
    // I'm not using the other bits, even though they are present in the register.
    // I'm only using the LSB (n=2) and the MSB (n=3)
    
    reg [15:0] d_reg;
    reg [15:0] q_reg;
    
    // d_reg is the DFF input.
    // q_reg is the DFF output.
    
    always @(posedge clk)
        if(~resetn)
            d_reg <= 16'h0000;
        else
            d_reg <= d;
            
    always @(posedge clk)
        if(~resetn)
            q_reg <= 16'h0000;
        else
            if(byteena == 2'b00)
                q_reg[7:0] <= d_reg[7:0];
            else if(byteena == 2'b01)
                q_reg[15:8] <= d_reg[15:8];
            else if(byteena == 2'b10)
                q_reg[15:0] <= d_reg[15:0];
            else
                q_reg <= d_reg;
    
    // If the MSB is set, then it's a flip-flop.
    // If the LSB is set, then it's a register.
    // Otherwise, it's a register.
    assign q = ~(byteena == 2'b00? {q_reg[15:1], 1'b0} :
                 byteena == 2'b01? {8{q_reg[7:0]}} :
                 {q_reg});
    
endmodule"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // Use FSM from Fsm_serial
	parameter S_IDLE = 0;
	parameter S_START = 1;
	parameter S_BYTE_1 = 2;
	parameter S_BYTE_2 = 3;
	parameter S_BYTE_3 = 4;
	parameter S_BYTE_4 = 5;
	parameter S_BYTE_5 = 6;
	parameter S_BYTE_6 = 7;
	parameter S_BYTE_7 = 8;
	parameter S_BYTE_8 = 9;
	parameter S_BYTE_9 = 10;
	parameter S_BYTE_10 = 11;
	parameter S_BYTE_11 = 12;
	parameter S_BYTE_12 = 13;
	parameter S_BYTE_13 = 14;
	parameter S_BYTE_14 = 15;
	parameter S_BYTE_15 = 16;
	parameter S_BYTE_16 = 17;
	parameter S_BYTE_17 = 18;
	parameter S_BYTE_18 = 19;
	parameter S_BYTE_19 = 20;
	parameter S_BYTE_20 = 21;
	parameter S_BYTE_21 = 22;
	parameter S_BYTE_22 = 23;
	parameter S_BYTE_23 = 24;
	parameter S_BYTE_24 = 25;
	parameter S_BYTE_25 = 26;
	parameter S_BYTE_26 = 27;
	parameter S_BYTE_27 = 28;
	parameter S_BYTE_28 = 29;
	parameter S_BYTE_29 = 30;
	parameter S_BYTE_30 = 31;
	parameter S_BYTE_31 = 32;
	parameter S_BYTE_32 = 33;
	parameter S_BYTE_33 = 34;
	parameter S_BYTE_34 = 35;
	parameter S_BYTE_35 = 36;
	parameter S_BYTE_36 = 37;
	parameter S_BYTE_37 = 38;
	parameter S_BYTE_38 = 39;
	parameter S_BYTE_39 = 40;
	parameter S_BYTE_40 = 41;
	parameter S_BYTE_41 = 42;
	parameter S_BYTE_42 = 43;
	parameter S_BYTE_43 = 44;
	parameter S_BYTE_44 = 45;
	parameter S_BYTE_45 = 46;
	parameter S_BYTE_46 = 47;
	parameter S_BYTE_47 = 48;
	parameter S_BYTE_48 = 49;
	parameter S_BYTE_49 = 50;
	parameter S_BYTE_50 = 51;
	parameter S_BYTE_51 = 52;
	parameter S_BYTE_52 = 53;
	parameter S_BYTE_53 = 54;
	parameter S_BYTE_54 = 55;
	parameter S_BYTE_55 = 56;
	parameter S_BYTE_56 = 57;
	parameter S_BYTE_57 = 58;
	parameter S_BYTE_58 = 59;
	parameter S_BYTE_59 = 60;
	parameter S_BYTE_60 = 61;
	parameter S_BYTE_61 = 62;
	parameter S_BYTE_62 = 63;
	parameter S_BYTE_63 = 64;
	parameter S_BYTE_64 = 65;
	parameter S_RX_1_STOP_BIT = 66;
	parameter S_RX_2_STOP_BITS = 67;
	parameter S_RX_3_STOP_BITS = 68;
	parameter S_RX_4_STOP_BITS = 69;
	
    
    reg [3:0] state;
    reg [3:0] next_state;
    reg [7:0] byte_data;
    reg [7:0] next_byte_data;
    reg [7:0] start_bit_det_counter;
    reg [7:0] end_bit_det_counter;",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    // Use FSM from Fsm_serial
	parameter S_IDLE = 0;
	parameter S_START = 1;
	parameter S_BYTE_1 = 2;
	parameter S_BYTE_2 = 3;
	parameter S_BYTE_3 = 4;
	parameter S_BYTE_4 = 5;
	parameter S_BYTE_5 = 6;
	parameter S_BYTE_6 = 7;
	parameter S_BYTE_7 = 8;
	parameter S_BYTE_8 = 9;
	parameter S_BYTE_9 = 10;
	parameter S_BYTE_10 = 11;
	parameter S_BYTE_11 = 12;
	parameter S_BYTE_12 = 13;
	parameter S_BYTE_13 = 14;
	parameter S_BYTE_14 = 15;
	parameter S_BYTE_15 = 16;
	parameter S_BYTE_16 = 17;
	parameter S_BYTE_17 = 18;
	parameter S_BYTE_18 = 19;
	parameter S_BYTE_19 = 20;
	parameter S_BYTE_20 = 21;
	parameter S_BYTE_21 = 22;
	parameter S_BYTE_22 = 23;
	parameter S_BYTE_23 = 24;
	parameter S_BYTE_24 = 25;
	parameter S_BYTE_25 = 26;
	parameter S_BYTE_26 = 27;
	parameter S_BYTE_27 = 28;
	parameter S_BYTE_28 = 29;
	parameter S_BYTE_29 = 30;
	parameter S_BYTE_30 = 31;
	parameter S_BYTE_31 = 32;
	parameter S_BYTE_32 = 33;
	parameter S_BYTE_33 = 34;
	parameter S_BYTE_34 = 35;
	parameter S_BYTE_35 = 36;
	parameter S_BYTE_36 = 37;
	parameter S_BYTE_37 = 38;
	parameter S_BYTE_38 = 39;
	parameter S_BYTE_39 = 40;
	parameter S_BYTE_40 = 41;
	parameter S_BYTE_41 = 42;
	parameter S_BYTE_42 = 43;
	parameter S_BYTE_43 = 44;
	parameter S_BYTE_44 = 45;
	parameter S_BYTE_45 = 46;
	parameter S_BYTE_46 = 47;
	parameter S_BYTE_47 = 48;
	parameter S_BYTE_48 = 49;
	parameter S_BYTE_49 = 50;
	parameter S_BYTE_50 = 51;
	parameter S_BYTE_51 = 52;
	parameter S_BYTE_52 = 53;
	parameter S_BYTE_53 = 54;
	parameter S_BYTE_54 = 55;
	parameter S_BYTE_55 = 56;
	parameter S_BYTE_56 = 57;
	parameter S_BYTE_57 = 58;
	parameter S_BYTE_58 = 59;
	parameter S_BYTE_59 = 60;
	parameter S_BYTE_60 = 61;
	parameter S_BYTE_61 = 62;
	parameter S_BYTE_62 = 63;
	parameter S_BYTE_63 = 64;
	parameter S_BYTE_64 = 65;
	parameter S_RX_1_STOP_BIT = 66;
	parameter S_RX_2_STOP_BITS = 67;
	parameter S_RX_3_STOP_BITS = 68;
	parameter S_RX_4_STOP_BITS = 69;
	
    
    reg [3:0] state;
    reg [3:0] next_state;
    reg [7:0] byte_data;
    reg [7:0] next_byte_data;
    reg [7:0] start_bit_det_counter;
    reg [7:0] end_bit_det_counter;"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Use FSM from Fsm_serial
    parameter S_idle = 0, S_wait1 = 1, S_wait2 = 2, S_wait3 = 3, S_send1 = 4, S_send2 = 5, S_send3 = 6, S_wait4 = 7, S_send4 = 8, S_send5 = 9, S_send6 = 10, S_send7 = 11, S_send8 = 12, S_send9 = 13, S_send10 = 14, S_send11 = 15, S_send12 = 16, S_send13 = 17, S_send14 = 18, S_send15 = 19, S_send16 = 20, S_send17 = 21, S_send18 = 22, S_send19 = 23, S_send20 = 24, S_send21 = 25, S_send22 = 26, S_send23 = 27, S_send24 = 28, S_send25 = 29, S_send26 = 30, S_send27 = 31, S_send28 = 32, S_send29 = 33, S_send30 = 34, S_send31 = 35, S_send32 = 36, S_send33 = 37, S_send34 = 38, S_send35 = 39, S_send36 = 40, S_send37 = 41, S_send38 = 42, S_send39 = 43, S_send40 = 44, S_send41 = 45, S_send42 = 46, S_send43 = 47, S_send44 = 48, S_send45 = 49, S_send46 = 50, S_send47 = 51, S_send48 = 52, S_send49 = 53, S_send50 = 54, S_send51 = 55, S_send52 = 56, S_send53 = 57, S_send54 = 58, S_send55 = 59, S_send56 = 60, S_send57 = 61, S_send58 = 62, S_send59 = 63, S_send60 = 64, S_send61 = 65, S_send62 = 66, S_send63 = 67, S_send64 = 68, S_send65 = 69, S_send66 = 70, S_send67 = 71, S_send68 = 72, S_send69 = 73, S_send70 = 74, S_send71 = 75, S_send72 = 76, S_send73 = 77, S_send74 = 78, S_send75 = 79, S_send76 = 80, S_send77 = 81, S_send78 = 82, S_send79 = 83, S_send80 = 84, S_send81 = 85, S_send82 = 86, S_send83 = 87, S_send84 = 88, S_send85 = 89, S_send86 = 90, S_send87 = 91, S_send88 = 92, S_send89 = 93, S_send90 = 94, S_send91 = 95, S_send92 = 96, S_send93 = 97, S_send94 = 98, S_send95 = 99, S_send96 = 100, S_send97 = 101, S_send98 = 102, S_send99 = 103, S_send100 = 104, S_send101 = 105, S_send102 = 106, S_send103 = 107, S_send104 = 108, S_send105 = 109, S_send106 = 110, S_send107 = 111, S_send108 = 112, S_send109 = 113, S_send110 = 114, S_send111 = 115, S_send112 = 116, S_send113 = 117, S_send114 = 118, S_send115 = 119, S_send116 = 120, S_send117 = 121, S_send118 = 122, S_send119 = 123, S_send120 = 124, S_send121 = 125, S_send122 = 126, S_send123 = 127, S_send124 = 128, S_send125 = 129, S_send126 = 130, S_send127 = 131, S_send128 = 132, S_send129 = 133, S_send130 = 134, S_send131 = 135, S_send132 = 136, S_send133 = 137, S_send134 = 138, S_send135 = 139, S_send136 = 140, S_send137 = 141, S_send138 = 142, S_send139 = 143",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Use FSM from Fsm_serial
    parameter S_idle = 0, S_wait1 = 1, S_wait2 = 2, S_wait3 = 3, S_send1 = 4, S_send2 = 5, S_send3 = 6, S_wait4 = 7, S_send4 = 8, S_send5 = 9, S_send6 = 10, S_send7 = 11, S_send8 = 12, S_send9 = 13, S_send10 = 14, S_send11 = 15, S_send12 = 16, S_send13 = 17, S_send14 = 18, S_send15 = 19, S_send16 = 20, S_send17 = 21, S_send18 = 22, S_send19 = 23, S_send20 = 24, S_send21 = 25, S_send22 = 26, S_send23 = 27, S_send24 = 28, S_send25 = 29, S_send26 = 30, S_send27 = 31, S_send28 = 32, S_send29 = 33, S_send30 = 34, S_send31 = 35, S_send32 = 36, S_send33 = 37, S_send34 = 38, S_send35 = 39, S_send36 = 40, S_send37 = 41, S_send38 = 42, S_send39 = 43, S_send40 = 44, S_send41 = 45, S_send42 = 46, S_send43 = 47, S_send44 = 48, S_send45 = 49, S_send46 = 50, S_send47 = 51, S_send48 = 52, S_send49 = 53, S_send50 = 54, S_send51 = 55, S_send52 = 56, S_send53 = 57, S_send54 = 58, S_send55 = 59, S_send56 = 60, S_send57 = 61, S_send58 = 62, S_send59 = 63, S_send60 = 64, S_send61 = 65, S_send62 = 66, S_send63 = 67, S_send64 = 68, S_send65 = 69, S_send66 = 70, S_send67 = 71, S_send68 = 72, S_send69 = 73, S_send70 = 74, S_send71 = 75, S_send72 = 76, S_send73 = 77, S_send74 = 78, S_send75 = 79, S_send76 = 80, S_send77 = 81, S_send78 = 82, S_send79 = 83, S_send80 = 84, S_send81 = 85, S_send82 = 86, S_send83 = 87, S_send84 = 88, S_send85 = 89, S_send86 = 90, S_send87 = 91, S_send88 = 92, S_send89 = 93, S_send90 = 94, S_send91 = 95, S_send92 = 96, S_send93 = 97, S_send94 = 98, S_send95 = 99, S_send96 = 100, S_send97 = 101, S_send98 = 102, S_send99 = 103, S_send100 = 104, S_send101 = 105, S_send102 = 106, S_send103 = 107, S_send104 = 108, S_send105 = 109, S_send106 = 110, S_send107 = 111, S_send108 = 112, S_send109 = 113, S_send110 = 114, S_send111 = 115, S_send112 = 116, S_send113 = 117, S_send114 = 118, S_send115 = 119, S_send116 = 120, S_send117 = 121, S_send118 = 122, S_send119 = 123, S_send120 = 124, S_send121 = 125, S_send122 = 126, S_send123 = 127, S_send124 = 128, S_send125 = 129, S_send126 = 130, S_send127 = 131, S_send128 = 132, S_send129 = 133, S_send130 = 134, S_send131 = 135, S_send132 = 136, S_send133 = 137, S_send134 = 138, S_send135 = 139, S_send136 = 140, S_send137 = 141, S_send138 = 142, S_send139 = 143"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // This D flip-flop is a 16-bit D flip-flop.
    // The clk input is used to clock the D flip-flop.
    // The resetn input is used to reset the D flip-flop.
    // The byteena input is a byte-selector which chooses whether to write to the upper or lower 4 bytes of the D flip-flop.
    // The d input is the input byte stream to be clocked in to the D flip-flop.
    
    wire [15:0] d_in;
    
    // By default, the upper 4 bytes are written to the D flip-flop.
    // The byte-selector selects which 4 bytes are written, in this case, the upper 4 bytes.
    assign d_in = (byteena == 2'b11)? d[15:8] : d[7:0];
    
    // Triggered whenever the D flip-flop changes.
    // This is the input byte stream from the keyboard.
    // d_in is a wire holding the input byte stream from the keyboard.
    
    // Triggered whenever the D flip-flop has changed.
    // d_out is the current value of the D flip-flop.
    // To trigger the above event, this module needs to be notified when the D flip-flop has changed.
    
    // The above module, kevin_G, is an instance of this module.
    
    d_flip_flop_16 dff16(clk, resetn, d_in, d_out, q_out);
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // This D flip-flop is a 16-bit D flip-flop.
    // The clk input is used to clock the D flip-flop.
    // The resetn input is used to reset the D flip-flop.
    // The byteena input is a byte-selector which chooses whether to write to the upper or lower 4 bytes of the D flip-flop.
    // The d input is the input byte stream to be clocked in to the D flip-flop.
    
    wire [15:0] d_in;
    
    // By default, the upper 4 bytes are written to the D flip-flop.
    // The byte-selector selects which 4 bytes are written, in this case, the upper 4 bytes.
    assign d_in = (byteena == 2'b11)? d[15:8] : d[7:0];
    
    // Triggered whenever the D flip-flop changes.
    // This is the input byte stream from the keyboard.
    // d_in is a wire holding the input byte stream from the keyboard.
    
    // Triggered whenever the D flip-flop has changed.
    // d_out is the current value of the D flip-flop.
    // To trigger the above event, this module needs to be notified when the D flip-flop has changed.
    
    // The above module, kevin_G, is an instance of this module.
    
    d_flip_flop_16 dff16(clk, resetn, d_in, d_out, q_out);
    
endmodule"
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Because this counter is a general counter, it should be possible to generalize it.
    // In order to generalize it, you need to take it out of the module.
    // It is also possible to have a register inside the module that is a counter.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    // Because this counter is a general counter, it should be possible to generalize it.
    // In order to generalize it, you need to take it out of the module.
    // It is also possible to have a register inside the module that is a counter.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register inside the module that is a memory.
    // It is also possible to have a register"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    wire [7:0] q1, q2, q3, q4, q5, q6, q7;
    
    // Create 8 instances of my_dff8, with different instance names (d1, d2, d3, d4, d5, d6, d7, and d8, respectively)
    // Triggered by different combinations of clk edge (positive or negative) and d input (different for each).
    // Use different in values (different for each).
    my_dff8 d1 (clk, d, q1);
    my_dff8 d2 (clk, q1, q2);
    my_dff8 d3 (clk, q2, q3);
    my_dff8 d4 (clk, q3, q4);
    my_dff8 d5 (clk, q4, q5);
    my_dff8 d6 (clk, q5, q6);
    my_dff8 d7 (clk, q6, q7);
    my_dff8 d8 (clk, q7, q);

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    wire [7:0] q1, q2, q3, q4, q5, q6, q7;
    
    // Create 8 instances of my_dff8, with different instance names (d1, d2, d3, d4, d5, d6, d7, and d8, respectively)
    // Triggered by different combinations of clk edge (positive or negative) and d input (different for each).
    // Use different in values (different for each).
    my_dff8 d1 (clk, d, q1);
    my_dff8 d2 (clk, q1, q2);
    my_dff8 d3 (clk, q2, q3);
    my_dff8 d4 (clk, q3, q4);
    my_dff8 d5 (clk, q4, q5);
    my_dff8 d6 (clk, q5, q6);
    my_dff8 d7 (clk, q6, q7);
    my_dff8 d8 (clk, q7, q);

endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] q0, q1, q2, q3;
    wire [3:0] q_next;
    
    // Create four 1-bit registers
    d_ff dff0 (clk, d[0], q[0]);
    d_ff dff1 (clk, d[1], q[1]);
    d_ff dff2 (clk, d[2], q[2]);
    d_ff dff3 (clk, d[3], q[3]);
    
    // Create a combinational block
    assign q_next = {q[0], q[1], q[2], q[3]};
    
    // Create a counter
    reg [3:0] count;
    
    always @(posedge clk)
        count <= count + 4'd1;
    
    // Create a saturating counter
    always @(posedge clk)
        if (count == 7)
            count <= 4'd0;
    	else
            q_next <= {q_next[0], q_next[1], q_next[2], q_next[3]};
    
    // Create a set of D flip-flops
    d_ff dff0_2 (clk, q_next[0], q[0]);
    d_ff dff1_2 (clk, q_next[1], q[1]);
    d_ff dff2_2 (clk, q_next[2], q[2]);
    d_ff dff3_2 (clk, q_next[3], q[3]);

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] q0, q1, q2, q3;
    wire [3:0] q_next;
    
    // Create four 1-bit registers
    d_ff dff0 (clk, d[0], q[0]);
    d_ff dff1 (clk, d[1], q[1]);
    d_ff dff2 (clk, d[2], q[2]);
    d_ff dff3 (clk, d[3], q[3]);
    
    // Create a combinational block
    assign q_next = {q[0], q[1], q[2], q[3]};
    
    // Create a counter
    reg [3:0] count;
    
    always @(posedge clk)
        count <= count + 4'd1;
    
    // Create a saturating counter
    always @(posedge clk)
        if (count == 7)
            count <= 4'd0;
    	else
            q_next <= {q_next[0], q_next[1], q_next[2], q_next[3]};
    
    // Create a set of D flip-flops
    d_ff dff0_2 (clk, q_next[0], q[0]);
    d_ff dff1_2 (clk, q_next[1], q[1]);
    d_ff dff2_2 (clk, q_next[2], q[2]);
    d_ff dff3_2 (clk, q_next[3], q[3]);

endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [7:0] q1, q2, q3, q4;
    
    assign q1 = d;
    assign q2 = d;
    assign q3 = d;
    assign q4 = d;
    
    d_ff d0 (clk, q1, q2);
    d_ff d1 (clk, q2, q3);
    d_ff d2 (clk, q3, q4);
    d_ff d3 (clk, q4, q1);

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [7:0] q1, q2, q3, q4;
    
    assign q1 = d;
    assign q2 = d;
    assign q3 = d;
    assign q4 = d;
    
    d_ff d0 (clk, q1, q2);
    d_ff d1 (clk, q2, q3);
    d_ff d2 (clk, q3, q4);
    d_ff d3 (clk, q4, q1);

endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [7:0] q1, q2, q3, q4, q5, q6, q7;
    
    // Create 8 instances of my_dff8, with different instance names
    //   and different D inputs
    my_dff8 d1 (clk, d[0], q[0]);
    my_dff8 d2 (clk, d[1], q[1]);
    my_dff8 d3 (clk, d[2], q[2]);
    my_dff8 d4 (clk, d[3], q[3]);
    my_dff8 d5 (clk, d[4], q[4]);
    my_dff8 d6 (clk, d[5], q[5]);
    my_dff8 d7 (clk, d[6], q[6]);
    my_dff8 d8 (clk, d[7], q[7]);
    
endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [7:0] q1, q2, q3, q4, q5, q6, q7;
    
    // Create 8 instances of my_dff8, with different instance names
    //   and different D inputs
    my_dff8 d1 (clk, d[0], q[0]);
    my_dff8 d2 (clk, d[1], q[1]);
    my_dff8 d3 (clk, d[2], q[2]);
    my_dff8 d4 (clk, d[3], q[3]);
    my_dff8 d5 (clk, d[4], q[4]);
    my_dff8 d6 (clk, d[5], q[5]);
    my_dff8 d7 (clk, d[6], q[6]);
    my_dff8 d8 (clk, d[7], q[7]);
    
endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] e = {q[3:0], d[3:0]};
    wire [3:0] f = {q[7:4], d[7:4]};
    
    bcd ins1(clk, e, q[3:0]);
    bcd ins2(clk, f, q[7:4]);
    
endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] e = {q[3:0], d[3:0]};
    wire [3:0] f = {q[7:4], d[7:4]};
    
    bcd ins1(clk, e, q[3:0]);
    bcd ins2(clk, f, q[7:4]);
    
endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] q0, q1, q2, q3, q4, q5, q6, q7;
    
    assign q0 = d[3:0];
    assign q1 = d[4:1];
    assign q2 = d[5:2];
    assign q3 = d[6:3];
    assign q4 = d[7:4];
    assign q5 = {1'b0, d[7:5]};
    assign q6 = {2'b0, d[7:6]};
    assign q7 = {3'b0, d[7:7]};
    
    dff_t ins1(clk, q0, q0_d, q0_c);
    dff_t ins2(clk, q1, q1_d, q1_c);
    dff_t ins3(clk, q2, q2_d, q2_c);
    dff_t ins4(clk, q3, q3_d, q3_c);
    dff_t ins5(clk, q4, q4_d, q4_c);
    dff_t ins6(clk, q5, q5_d, q5_c);
    dff_t ins7(clk, q6, q6_d, q6_c);
    dff_t ins8(clk, q7, q7_d, q7_c);
    
endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] q0, q1, q2, q3, q4, q5, q6, q7;
    
    assign q0 = d[3:0];
    assign q1 = d[4:1];
    assign q2 = d[5:2];
    assign q3 = d[6:3];
    assign q4 = d[7:4];
    assign q5 = {1'b0, d[7:5]};
    assign q6 = {2'b0, d[7:6]};
    assign q7 = {3'b0, d[7:7]};
    
    dff_t ins1(clk, q0, q0_d, q0_c);
    dff_t ins2(clk, q1, q1_d, q1_c);
    dff_t ins3(clk, q2, q2_d, q2_c);
    dff_t ins4(clk, q3, q3_d, q3_c);
    dff_t ins5(clk, q4, q4_d, q4_c);
    dff_t ins6(clk, q5, q5_d, q5_c);
    dff_t ins7(clk, q6, q6_d, q6_c);
    dff_t ins8(clk, q7, q7_d, q7_c);
    
endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    wire [7:0] q1, q2, q3, q4;
    
    // Create four 1-bit registers.
    
    dff_t ins1(clk, d[0], q[0]);
    dff_t ins2(clk, d[1], q[1]);
    dff_t ins3(clk, d[2], q[2]);
    dff_t ins4(clk, d[3], q[3]);
    dff_t ins5(clk, d[4], q[4]);
    dff_t ins6(clk, d[5], q[5]);
    dff_t ins7(clk, d[6], q[6]);
    dff_t ins8(clk, d[7], q[7]);
    
endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    wire [7:0] q1, q2, q3, q4;
    
    // Create four 1-bit registers.
    
    dff_t ins1(clk, d[0], q[0]);
    dff_t ins2(clk, d[1], q[1]);
    dff_t ins3(clk, d[2], q[2]);
    dff_t ins4(clk, d[3], q[3]);
    dff_t ins5(clk, d[4], q[4]);
    dff_t ins6(clk, d[5], q[5]);
    dff_t ins7(clk, d[6], q[6]);
    dff_t ins8(clk, d[7], q[7]);
    
endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [7:0] q1, q2, q3, q4, q5, q6, q7;
    
    // Create 8 D flip-flops.
    // The order in which the DFF are created does not matter.
    // [D1, D2, D3, D4, D5, D6, D7]
    
    DFF D1 (clk, d[0], q[0]);
    DFF D2 (clk, d[1], q[1]);
    DFF D3 (clk, d[2], q[2]);
    DFF D4 (clk, d[3], q[3]);
    DFF D5 (clk, d[4], q[4]);
    DFF D6 (clk, d[5], q[5]);
    DFF D7 (clk, d[6], q[6]);
    DFF D8 (clk, d[7], q[7]);
    
endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [7:0] q1, q2, q3, q4, q5, q6, q7;
    
    // Create 8 D flip-flops.
    // The order in which the DFF are created does not matter.
    // [D1, D2, D3, D4, D5, D6, D7]
    
    DFF D1 (clk, d[0], q[0]);
    DFF D2 (clk, d[1], q[1]);
    DFF D3 (clk, d[2], q[2]);
    DFF D4 (clk, d[3], q[3]);
    DFF D5 (clk, d[4], q[4]);
    DFF D6 (clk, d[5], q[5]);
    DFF D7 (clk, d[6], q[6]);
    DFF D8 (clk, d[7], q[7]);
    
endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    wire [3:0] q4;
    wire [3:0] temp1;
    wire [3:0] temp2;
    wire [3:0] temp3;
    wire [3:0] temp4;
    wire [3:0] temp5;
    wire [3:0] temp6;
    wire [3:0] temp7;
    wire [3:0] temp8;

    d_flip_flop dff0 (clk, d[0], q[0]);
    d_flip_flop dff1 (clk, d[1], q[1]);
    d_flip_flop dff2 (clk, d[2], q[2]);
    d_flip_flop dff3 (clk, d[3], q[3]);
    d_flip_flop dff4 (clk, d[4], temp1);
    d_flip_flop dff5 (clk, d[5], temp2);
    d_flip_flop dff6 (clk, d[6], temp3);
    d_flip_flop dff7 (clk, d[7], temp4);
    d_flip_flop dff8 (clk, temp1, temp5);
    d_flip_flop dff9 (clk, temp2, temp6);
    d_flip_flop dff10 (clk, temp3, temp7);
    d_flip_flop dff11 (clk, temp4, temp8);

    assign q[4] = temp1;
    assign temp1 = d[7]? 8'h80 : 8'h00;
    assign q[5] = temp2;
    assign temp2 = d[7]? 8'h80 : 8'h00;
    assign q[6] = temp3;
    assign temp3 = d[7]? 8'h80 : 8'h00;
    assign q[7] = temp4;
    assign temp4 = d[7]? 8'h80 : 8'h00;
    assign q[8] = temp5;
    assign temp5 = d[7]? 8'h80 : 8'h00;
    assign q[9] = temp6;
    assign temp6 = d[7]? 8'h80 : 8'h00;
    assign q[10] = temp7;
    assign temp7 = d[7]? 8'h80 : 8'h00;
    assign q[11] = temp8;
    assign temp8 = d[7]? 8'h80 : 8'h00;
    assign q[12] = temp8;
    assign q[13] = temp8;
    assign q[14] = temp8;
    assign q[15] = temp8;
    assign q[16] = temp8;
    assign q[17] = temp8;
    assign q[18] = temp8;
    assign q[19] = temp8;
    assign q[20] = temp8;
    assign q[21] = temp8;
    assign q[22] = temp8;
    assign q[23] = temp8;
    assign q[24] = temp8;
    assign q[25] = temp8;
    assign q[26] = temp8;
    assign q[27] = temp8;
    assign q[28] = temp8;
    assign q[29] = temp8;
    assign q[30] = temp8;
    assign q[31] = temp8;
    assign q[32] = temp8;
    assign q[33] = temp8;
    assign q[34] = temp8;
    assign q[35] = temp8;
    assign q[36] = temp8;
    assign q[37] = temp8;
    assign q[38] = temp8;
    assign q[39] = temp8;
    assign q[40]",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    wire [3:0] q4;
    wire [3:0] temp1;
    wire [3:0] temp2;
    wire [3:0] temp3;
    wire [3:0] temp4;
    wire [3:0] temp5;
    wire [3:0] temp6;
    wire [3:0] temp7;
    wire [3:0] temp8;

    d_flip_flop dff0 (clk, d[0], q[0]);
    d_flip_flop dff1 (clk, d[1], q[1]);
    d_flip_flop dff2 (clk, d[2], q[2]);
    d_flip_flop dff3 (clk, d[3], q[3]);
    d_flip_flop dff4 (clk, d[4], temp1);
    d_flip_flop dff5 (clk, d[5], temp2);
    d_flip_flop dff6 (clk, d[6], temp3);
    d_flip_flop dff7 (clk, d[7], temp4);
    d_flip_flop dff8 (clk, temp1, temp5);
    d_flip_flop dff9 (clk, temp2, temp6);
    d_flip_flop dff10 (clk, temp3, temp7);
    d_flip_flop dff11 (clk, temp4, temp8);

    assign q[4] = temp1;
    assign temp1 = d[7]? 8'h80 : 8'h00;
    assign q[5] = temp2;
    assign temp2 = d[7]? 8'h80 : 8'h00;
    assign q[6] = temp3;
    assign temp3 = d[7]? 8'h80 : 8'h00;
    assign q[7] = temp4;
    assign temp4 = d[7]? 8'h80 : 8'h00;
    assign q[8] = temp5;
    assign temp5 = d[7]? 8'h80 : 8'h00;
    assign q[9] = temp6;
    assign temp6 = d[7]? 8'h80 : 8'h00;
    assign q[10] = temp7;
    assign temp7 = d[7]? 8'h80 : 8'h00;
    assign q[11] = temp8;
    assign temp8 = d[7]? 8'h80 : 8'h00;
    assign q[12] = temp8;
    assign q[13] = temp8;
    assign q[14] = temp8;
    assign q[15] = temp8;
    assign q[16] = temp8;
    assign q[17] = temp8;
    assign q[18] = temp8;
    assign q[19] = temp8;
    assign q[20] = temp8;
    assign q[21] = temp8;
    assign q[22] = temp8;
    assign q[23] = temp8;
    assign q[24] = temp8;
    assign q[25] = temp8;
    assign q[26] = temp8;
    assign q[27] = temp8;
    assign q[28] = temp8;
    assign q[29] = temp8;
    assign q[30] = temp8;
    assign q[31] = temp8;
    assign q[32] = temp8;
    assign q[33] = temp8;
    assign q[34] = temp8;
    assign q[35] = temp8;
    assign q[36] = temp8;
    assign q[37] = temp8;
    assign q[38] = temp8;
    assign q[39] = temp8;
    assign q[40]"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for edge-triggered always blocks
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 0;
            else
                q <= d;
        end

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for edge-triggered always blocks
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 0;
            else
                q <= d;
        end

endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for d flip-flop to dff
    //   When areset goes high, dff is set to 0
    //   When areset goes low, dff is set to input d
    
    always @(posedge clk or posedge areset)
        if(areset)
            dff_q <= 8'h00;
        else
            dff_q <= d;
            
    // Create a toggle-active low reset (asynchronous)
    
    always @(posedge clk)
        if(~areset)
            dff_rst_n <= 1'b1;
        else
            dff_rst_n <= 1'b0;
            
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for d flip-flop to dff
    //   When areset goes high, dff is set to 0
    //   When areset goes low, dff is set to input d
    
    always @(posedge clk or posedge areset)
        if(areset)
            dff_q <= 8'h00;
        else
            dff_q <= d;
            
    // Create a toggle-active low reset (asynchronous)
    
    always @(posedge clk)
        if(~areset)
            dff_rst_n <= 1'b1;
        else
            dff_rst_n <= 1'b0;
            
endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Create 8 flip-flops with active high asynchronous reset. 
    // All DFFs should be triggered by the positive edge of clk.
    //
    // Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

reg [7:0] q_reg;

always @(posedge clk or posedge areset)
    begin
        if(areset)
            q_reg <= 0;
        else
            q_reg <= d;
    end
    
assign q = q_reg;
    
endmodule",-0.5,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Create 8 flip-flops with active high asynchronous reset. 
    // All DFFs should be triggered by the positive edge of clk.
    //
    // Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

reg [7:0] q_reg;

always @(posedge clk or posedge areset)
    begin
        if(areset)
            q_reg <= 0;
        else
            q_reg <= d;
    end
    
assign q = q_reg;
    
endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for d flip-flop to d
    //   When areset is high, d is set to 0 (asynchronous)
    //   When areset is low, d is set to d when clk is high
    
    always @(posedge clk or posedge areset)
        if(areset)
            d <= 8'h00;
        else
            d <= d;
            
    // Create a toggle-active low reset (asynchronous)
    
    always @(posedge clk)
        q <= ~q;

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for d flip-flop to d
    //   When areset is high, d is set to 0 (asynchronous)
    //   When areset is low, d is set to d when clk is high
    
    always @(posedge clk or posedge areset)
        if(areset)
            d <= 8'h00;
        else
            d <= d;
            
    // Create a toggle-active low reset (asynchronous)
    
    always @(posedge clk)
        q <= ~q;

endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for edge-triggered always blocks
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for edge-triggered always blocks
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end
    
endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 1'b0;
            else
                q <= d;
        end
    
endmodule"
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        if(areset)
            q <= 1'b0;
        else
            q <= d;
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset)
        if(areset)
            q <= 1'b0;
        else
            q <= d;
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    // Use FSM from Fsm_serial
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] first_count;
    reg [7:0] data_reg;
    reg [4:0] data_parity;
    
    always @(*) begin
        case(state)
            START: begin
                next_state = DATA;
                first_count = count;
                data_parity = ^d;
            end
            DATA: begin
                if(count < 4'h8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(count < 4'h8)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(first_count < 5'h1f)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(posedge clk)
        if(state == DATA)
            data_reg <= d;
    
    always @(posedge clk)
        if(state == STOP)
            count <= count + 4'h1;
    
    always @(posedge clk)
        if(state == START)
            first_count <= count;
    
    assign q = data_reg;
    assign data_parity_error = (data_parity == ^data_reg)? 1'b1 : 1'b0;
    
endmodule",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    // Use FSM from Fsm_serial
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [2:0] first_count;
    reg [7:0] data_reg;
    reg [4:0] data_parity;
    
    always @(*) begin
        case(state)
            START: begin
                next_state = DATA;
                first_count = count;
                data_parity = ^d;
            end
            DATA: begin
                if(count < 4'h8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(count < 4'h8)
                    next_state = DELAY;
                else
                    next_state = STOP;
            end
            DELAY: begin
                if(first_count < 5'h1f)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    always @(posedge clk)
        if(state == DATA)
            data_reg <= d;
    
    always @(posedge clk)
        if(state == STOP)
            count <= count + 4'h1;
    
    always @(posedge clk)
        if(state == START)
            first_count <= count;
    
    assign q = data_reg;
    assign data_parity_error = (data_parity == ^data_reg)? 1'b1 : 1'b0;
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    // Use non-blocking assignment for edge-triggered always blocks
    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    // Use non-blocking assignment for edge-triggered always blocks
    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg	[7:0]	q_reg;
    
    // Create a shift register
    always @(posedge clk) begin
        if(reset)
            q_reg <= 0;
        else
            q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg	[7:0]	q_reg;
    
    // Create a shift register
    always @(posedge clk) begin
        if(reset)
            q_reg <= 0;
        else
            q_reg <= d;
    end
    
    assign q = q_reg;
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg	[7:0]	q_reg;
    
    // Create a register
    always @(posedge clk) begin
        if(reset)
            q_reg <= 0;
        else
            q_reg <= d;
    end
    
    // Create a flip-flop with active low reset
    assign q = ~q_reg;
    
endmodule",-0.5,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    reg	[7:0]	q_reg;
    
    // Create a register
    always @(posedge clk) begin
        if(reset)
            q_reg <= 0;
        else
            q_reg <= d;
    end
    
    // Create a flip-flop with active low reset
    assign q = ~q_reg;
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin
            d_ff df(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin
            d_ff df(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    d_ff_8bit d0 (clk, reset, d[0], q[0]);
    d_ff_8bit d1 (clk, reset, d[1], q[1]);
    d_ff_8bit d2 (clk, reset, d[2], q[2]);
    d_ff_8bit d3 (clk, reset, d[3], q[3]);
    d_ff_8bit d4 (clk, reset, d[4], q[4]);
    d_ff_8bit d5 (clk, reset, d[5], q[5]);
    d_ff_8bit d6 (clk, reset, d[6], q[6]);
    d_ff_8bit d7 (clk, reset, d[7], q[7]);
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    d_ff_8bit d0 (clk, reset, d[0], q[0]);
    d_ff_8bit d1 (clk, reset, d[1], q[1]);
    d_ff_8bit d2 (clk, reset, d[2], q[2]);
    d_ff_8bit d3 (clk, reset, d[3], q[3]);
    d_ff_8bit d4 (clk, reset, d[4], q[4]);
    d_ff_8bit d5 (clk, reset, d[5], q[5]);
    d_ff_8bit d6 (clk, reset, d[6], q[6]);
    d_ff_8bit d7 (clk, reset, d[7], q[7]);
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use FSM from Fsm_serial
	parameter idle = 0, d1 = 1, d2 = 2, d3 = 3, d4 = 4, d5 = 5, d6 = 6, d7 = 7, d8 = 8, d9 = 9, d10 = 10, d11 = 11, d12 = 12, d13 = 13, d14 = 14, d15 = 15, d16 = 16, d17 = 17, d18 = 18, d19 = 19, d20 = 20, d21 = 21, d22 = 22, d23 = 23, d24 = 24, d25 = 25, d26 = 26, d27 = 27, d28 = 28, d29 = 29, d30 = 30, d31 = 31, d32 = 32, d33 = 33, d34 = 34, d35 = 35, d36 = 36, d37 = 37, d38 = 38, d39 = 39, d40 = 40, d41 = 41, d42 = 42, d43 = 43, d44 = 44, d45 = 45, d46 = 46, d47 = 47, d48 = 48, d49 = 49, d50 = 50, d51 = 51, d52 = 52, d53 = 53, d54 = 54, d55 = 55, d56 = 56, d57 = 57, d58 = 58, d59 = 59, d60 = 60, d61 = 61, d62 = 62, d63 = 63, d64 = 64, d65 = 65, d66 = 66, d67 = 67, d68 = 68, d69 = 69, d70 = 70, d71 = 71, d72 = 72, d73 = 73, d74 = 74, d75 = 75, d76 = 76, d77 = 77, d78 = 78, d79 = 79, d80 = 80, d81 = 81, d82 = 82, d83 = 83, d84 = 84, d85 = 85, d86 = 86, d87 = 87, d88 = 88, d89 = 89, d90 = 90, d91 = 91, d92 = 92, d93 = 93, d94 = 94, d95 = 95, d96 = 96, d97 = 97, d98 = 98, d99 = 99, d100 = 100, d101 = 101, d102 = 102, d103 = 103, d104 = 104, d105 = 105, d106 = 106, d107 = 107, d108 = 108, d109 = 109, d110 = 110, d111 = 111, d112 = 112, d113 = 113, d114 = 114, d115 = 115, d116 = 116, d117 = 117, d118 = 118, d119 = 119, d120 = 120, d121 = 121, d122 = 122, d123 = 123, d124 = 124, d125 = 125, d126 = 126, d127 = 127, d128 = 128, d129 = 129, d130 = 130, d131 = 131, d132 = 132, d133 = 133, d134 = 134, d135 = 135, d136 = 136, d137 = 137, d138 = 138, d139 = 139, d140 = 140, d141 = 141, d142 = 142, d143 = 143, d144 = 144, d145 = 145, d146 = 146, d147 = 147, d148 = 148, d149 = 149, d150 = 150, d151 = 151, d152 = 152, d153 = 153, d154 = 154, d155 = 155, d156 = 156, d157 = 157, d158 = 158, d159 = 159, d160 = 160, d161 = 161, d162 = 162, d163 = 163, d164 = 164, d165 = 165, d166 = 166, d167 = 167, d168 = 168, d169 = 169, d170 = 170, d171 = 171, d172 = 172, d173 = 173, d174 = 174, d175 = 175, d176 = 176, d177 = 177, d178 = 178, d179 = 179, d180 = 180, d181 = 181, d182 = 182, d183 = 183, d184 = 184, d185 = 185, d186 = 186, d187 = 187, d188 = 188, d189 = 189, d190 = 190, d191 = 191, d192 = 192, d193 = 193, d194 = 194, d195 = 195, d196 = 196, d197 = 197, d198 = 198, d199 = 199, d200 = 200, d201 =",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use FSM from Fsm_serial
	parameter idle = 0, d1 = 1, d2 = 2, d3 = 3, d4 = 4, d5 = 5, d6 = 6, d7 = 7, d8 = 8, d9 = 9, d10 = 10, d11 = 11, d12 = 12, d13 = 13, d14 = 14, d15 = 15, d16 = 16, d17 = 17, d18 = 18, d19 = 19, d20 = 20, d21 = 21, d22 = 22, d23 = 23, d24 = 24, d25 = 25, d26 = 26, d27 = 27, d28 = 28, d29 = 29, d30 = 30, d31 = 31, d32 = 32, d33 = 33, d34 = 34, d35 = 35, d36 = 36, d37 = 37, d38 = 38, d39 = 39, d40 = 40, d41 = 41, d42 = 42, d43 = 43, d44 = 44, d45 = 45, d46 = 46, d47 = 47, d48 = 48, d49 = 49, d50 = 50, d51 = 51, d52 = 52, d53 = 53, d54 = 54, d55 = 55, d56 = 56, d57 = 57, d58 = 58, d59 = 59, d60 = 60, d61 = 61, d62 = 62, d63 = 63, d64 = 64, d65 = 65, d66 = 66, d67 = 67, d68 = 68, d69 = 69, d70 = 70, d71 = 71, d72 = 72, d73 = 73, d74 = 74, d75 = 75, d76 = 76, d77 = 77, d78 = 78, d79 = 79, d80 = 80, d81 = 81, d82 = 82, d83 = 83, d84 = 84, d85 = 85, d86 = 86, d87 = 87, d88 = 88, d89 = 89, d90 = 90, d91 = 91, d92 = 92, d93 = 93, d94 = 94, d95 = 95, d96 = 96, d97 = 97, d98 = 98, d99 = 99, d100 = 100, d101 = 101, d102 = 102, d103 = 103, d104 = 104, d105 = 105, d106 = 106, d107 = 107, d108 = 108, d109 = 109, d110 = 110, d111 = 111, d112 = 112, d113 = 113, d114 = 114, d115 = 115, d116 = 116, d117 = 117, d118 = 118, d119 = 119, d120 = 120, d121 = 121, d122 = 122, d123 = 123, d124 = 124, d125 = 125, d126 = 126, d127 = 127, d128 = 128, d129 = 129, d130 = 130, d131 = 131, d132 = 132, d133 = 133, d134 = 134, d135 = 135, d136 = 136, d137 = 137, d138 = 138, d139 = 139, d140 = 140, d141 = 141, d142 = 142, d143 = 143, d144 = 144, d145 = 145, d146 = 146, d147 = 147, d148 = 148, d149 = 149, d150 = 150, d151 = 151, d152 = 152, d153 = 153, d154 = 154, d155 = 155, d156 = 156, d157 = 157, d158 = 158, d159 = 159, d160 = 160, d161 = 161, d162 = 162, d163 = 163, d164 = 164, d165 = 165, d166 = 166, d167 = 167, d168 = 168, d169 = 169, d170 = 170, d171 = 171, d172 = 172, d173 = 173, d174 = 174, d175 = 175, d176 = 176, d177 = 177, d178 = 178, d179 = 179, d180 = 180, d181 = 181, d182 = 182, d183 = 183, d184 = 184, d185 = 185, d186 = 186, d187 = 187, d188 = 188, d189 = 189, d190 = 190, d191 = 191, d192 = 192, d193 = 193, d194 = 194, d195 = 195, d196 = 196, d197 = 197, d198 = 198, d199 = 199, d200 = 200, d201 ="
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin
            d_ff dff(.clk(clk),.reset(reset),.d(d[i]),.q(q[i]));
        end
    endgenerate
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin
            d_ff dff(.clk(clk),.reset(reset),.d(d[i]),.q(q[i]));
        end
    endgenerate
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for edge-triggered always block
    //   Create 8 D flip-flops with active high synchronous reset
    //   Implement a shift register
    //   D flip-flop inputs are accepted as a parameter
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 0;
            else
                q <= d;
        end
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use non-blocking assignment for edge-triggered always block
    //   Create 8 D flip-flops with active high synchronous reset
    //   Implement a shift register
    //   D flip-flop inputs are accepted as a parameter
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 0;
            else
                q <= d;
        end
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    genvar i;
    generate
        for(i=0; i<8; i=i+1) begin
            d_ff df(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    genvar i;
    generate
        for(i=0; i<8; i=i+1) begin
            d_ff df(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use FSM from Fsm_serial
	parameter idle = 0, d1 = 1, d2 = 2, d3 = 3, d4 = 4, d5 = 5, d6 = 6, d7 = 7, d8 = 8, d9 = 9, d10 = 10, d11 = 11, d12 = 12, d13 = 13, d14 = 14, d15 = 15, d16 = 16, d17 = 17, d18 = 18, d19 = 19, d20 = 20, d21 = 21, d22 = 22, d23 = 23, d24 = 24, d25 = 25, d26 = 26, d27 = 27, d28 = 28, d29 = 29, d30 = 30, d31 = 31, d32 = 32, d33 = 33, d34 = 34, d35 = 35, d36 = 36, d37 = 37, d38 = 38, d39 = 39, d40 = 40, d41 = 41, d42 = 42, d43 = 43, d44 = 44, d45 = 45, d46 = 46, d47 = 47, d48 = 48, d49 = 49, d50 = 50, d51 = 51, d52 = 52, d53 = 53, d54 = 54, d55 = 55, d56 = 56, d57 = 57, d58 = 58, d59 = 59, d60 = 60, d61 = 61, d62 = 62, d63 = 63, d64 = 64, d65 = 65, d66 = 66, d67 = 67, d68 = 68, d69 = 69, d70 = 70, d71 = 71, d72 = 72, d73 = 73, d74 = 74, d75 = 75, d76 = 76, d77 = 77, d78 = 78, d79 = 79, d80 = 80, d81 = 81, d82 = 82, d83 = 83, d84 = 84, d85 = 85, d86 = 86, d87 = 87, d88 = 88, d89 = 89, d90 = 90, d91 = 91, d92 = 92, d93 = 93, d94 = 94, d95 = 95, d96 = 96, d97 = 97, d98 = 98, d99 = 99, d100 = 100, d101 = 101, d102 = 102, d103 = 103, d104 = 104, d105 = 105, d106 = 106, d107 = 107, d108 = 108, d109 = 109, d110 = 110, d111 = 111, d112 = 112, d113 = 113, d114 = 114, d115 = 115, d116 = 116, d117 = 117, d118 = 118, d119 = 119, d120 = 120, d121 = 121, d122 = 122, d123 = 123, d124 = 124, d125 = 125, d126 = 126, d127 = 127, d128 = 128, d129 = 129, d130 = 130, d131 = 131, d132 = 132, d133 = 133, d134 = 134, d135 = 135, d136 = 136, d137 = 137, d138 = 138, d139 = 139, d140 = 140, d141 = 141, d142 = 142, d143 = 143, d144 = 144, d145 = 145, d146 = 146, d147 = 147, d148 = 148, d149 = 149, d150 = 150, d151 = 151, d152 = 152, d153 = 153, d154 = 154, d155 = 155, d156 = 156, d157 = 157, d158 = 158, d159 = 159, d160 = 160, d161 = 161, d162 = 162, d163 = 163, d164 = 164, d165 = 165, d166 = 166, d167 = 167, d168 = 168, d169 = 169, d170 = 170, d171 = 171, d172 = 172, d173 = 173, d174 = 174, d175 = 175, d176 = 176, d177 = 177, d178 = 178, d179 = 179, d180 = 180, d181 = 181, d182 = 182, d183 = 183, d184 = 184, d185 = 185, d186 = 186, d187 = 187, d188 = 188, d189 = 189, d190 = 190, d191 = 191, d192 = 192, d193 = 193, d194 = 194, d195 = 195, d196 = 196, d197 = 197, d198 = 198, d199 = 199, d200 = 200, d201 =",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    // Use FSM from Fsm_serial
	parameter idle = 0, d1 = 1, d2 = 2, d3 = 3, d4 = 4, d5 = 5, d6 = 6, d7 = 7, d8 = 8, d9 = 9, d10 = 10, d11 = 11, d12 = 12, d13 = 13, d14 = 14, d15 = 15, d16 = 16, d17 = 17, d18 = 18, d19 = 19, d20 = 20, d21 = 21, d22 = 22, d23 = 23, d24 = 24, d25 = 25, d26 = 26, d27 = 27, d28 = 28, d29 = 29, d30 = 30, d31 = 31, d32 = 32, d33 = 33, d34 = 34, d35 = 35, d36 = 36, d37 = 37, d38 = 38, d39 = 39, d40 = 40, d41 = 41, d42 = 42, d43 = 43, d44 = 44, d45 = 45, d46 = 46, d47 = 47, d48 = 48, d49 = 49, d50 = 50, d51 = 51, d52 = 52, d53 = 53, d54 = 54, d55 = 55, d56 = 56, d57 = 57, d58 = 58, d59 = 59, d60 = 60, d61 = 61, d62 = 62, d63 = 63, d64 = 64, d65 = 65, d66 = 66, d67 = 67, d68 = 68, d69 = 69, d70 = 70, d71 = 71, d72 = 72, d73 = 73, d74 = 74, d75 = 75, d76 = 76, d77 = 77, d78 = 78, d79 = 79, d80 = 80, d81 = 81, d82 = 82, d83 = 83, d84 = 84, d85 = 85, d86 = 86, d87 = 87, d88 = 88, d89 = 89, d90 = 90, d91 = 91, d92 = 92, d93 = 93, d94 = 94, d95 = 95, d96 = 96, d97 = 97, d98 = 98, d99 = 99, d100 = 100, d101 = 101, d102 = 102, d103 = 103, d104 = 104, d105 = 105, d106 = 106, d107 = 107, d108 = 108, d109 = 109, d110 = 110, d111 = 111, d112 = 112, d113 = 113, d114 = 114, d115 = 115, d116 = 116, d117 = 117, d118 = 118, d119 = 119, d120 = 120, d121 = 121, d122 = 122, d123 = 123, d124 = 124, d125 = 125, d126 = 126, d127 = 127, d128 = 128, d129 = 129, d130 = 130, d131 = 131, d132 = 132, d133 = 133, d134 = 134, d135 = 135, d136 = 136, d137 = 137, d138 = 138, d139 = 139, d140 = 140, d141 = 141, d142 = 142, d143 = 143, d144 = 144, d145 = 145, d146 = 146, d147 = 147, d148 = 148, d149 = 149, d150 = 150, d151 = 151, d152 = 152, d153 = 153, d154 = 154, d155 = 155, d156 = 156, d157 = 157, d158 = 158, d159 = 159, d160 = 160, d161 = 161, d162 = 162, d163 = 163, d164 = 164, d165 = 165, d166 = 166, d167 = 167, d168 = 168, d169 = 169, d170 = 170, d171 = 171, d172 = 172, d173 = 173, d174 = 174, d175 = 175, d176 = 176, d177 = 177, d178 = 178, d179 = 179, d180 = 180, d181 = 181, d182 = 182, d183 = 183, d184 = 184, d185 = 185, d186 = 186, d187 = 187, d188 = 188, d189 = 189, d190 = 190, d191 = 191, d192 = 192, d193 = 193, d194 = 194, d195 = 195, d196 = 196, d197 = 197, d198 = 198, d199 = 199, d200 = 200, d201 ="
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    dff_t ins1(clk, reset, d[0], q[0]);
    dff_t ins2(clk, reset, d[1], q[1]);
    dff_t ins3(clk, reset, d[2], q[2]);
    dff_t ins4(clk, reset, d[3], q[3]);
    dff_t ins5(clk, reset, d[4], q[4]);
    dff_t ins6(clk, reset, d[5], q[5]);
    dff_t ins7(clk, reset, d[6], q[6]);
    dff_t ins8(clk, reset, d[7], q[7]);
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    dff_t ins1(clk, reset, d[0], q[0]);
    dff_t ins2(clk, reset, d[1], q[1]);
    dff_t ins3(clk, reset, d[2], q[2]);
    dff_t ins4(clk, reset, d[3], q[3]);
    dff_t ins5(clk, reset, d[4], q[4]);
    dff_t ins6(clk, reset, d[5], q[5]);
    dff_t ins7(clk, reset, d[6], q[6]);
    dff_t ins8(clk, reset, d[7], q[7]);
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin : r_loop
            d_ff df (clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin : r_loop
            d_ff df (clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin : d_loop
            d_ff df(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    genvar i;
    
    generate
        for (i = 0; i < 8; i = i + 1) begin : d_loop
            d_ff df(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    reg q1, q2;
    always @(posedge clk)
        q1 <= d;
    always @(negedge clk)
        q2 <= d;
    assign q = clk?q1:q2;
endmodule",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    reg q1, q2;
    always @(posedge clk)
        q1 <= d;
    always @(negedge clk)
        q2 <= d;
    assign q = clk?q1:q2;
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire t1, t2;
    
    assign t1 = d ^ q;
    assign t2 = t1 & q;
    
    always @(posedge clk)
        q <= t2 | t1;

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    wire t1, t2;
    
    assign t1 = d ^ q;
    assign t2 = t1 & q;
    
    always @(posedge clk)
        q <= t2 | t1;

endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    reg q1, q2;
    
    always @(posedge clk)
        q1 <= d;
    
    always @(negedge clk)
        q2 <= d;
    
    assign q = clk?q1:q2;
    
endmodule",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    reg q1, q2;
    
    always @(posedge clk)
        q1 <= d;
    
    always @(negedge clk)
        q2 <= d;
    
    assign q = clk?q1:q2;
    
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1(clk, d, q1);
    my_dff ins2(clk, q1, q2);
    
    always @(*)
        q = q1 || q2;
        
endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1(clk, d, q1);
    my_dff ins2(clk, q1, q2);
    
    always @(*)
        q = q1 || q2;
        
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1 (clk, d, q1);
    my_dff ins2 (clk, q1, q2);
    my_dff ins3 (clk, q2, q);
    
endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1 (clk, d, q1);
    my_dff ins2 (clk, q1, q2);
    my_dff ins3 (clk, q2, q);
    
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1(clk, d, q1);
    my_dff ins2(clk, q1, q2);
    my_dff ins3(clk, q2, q);
    
endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1(clk, d, q1);
    my_dff ins2(clk, q1, q2);
    my_dff ins3(clk, q2, q);
    
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1(clk, d, q1);
    my_dff ins2(clk, q1, q2);
    my_dff ins3(clk, q2, q);
    
endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    my_dff ins1(clk, d, q1);
    my_dff ins2(clk, q1, q2);
    my_dff ins3(clk, q2, q);
    
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    wire t1, t2;
    my_dff ins1(clk, d, t1);
    my_dff ins2(clk, t1, t2);
    my_dff ins3(clk, t2, q);
endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    wire t1, t2;
    my_dff ins1(clk, d, t1);
    my_dff ins2(clk, t1, t2);
    my_dff ins3(clk, t2, q);
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    reg q1, q2, q3, q4;
    always @(posedge clk)
        q1 <= d;
    always @(negedge clk)
        q2 <= d;
    always @(posedge clk)
        q3 <= d;
    always @(negedge clk)
        q4 <= d;
    assign q = (q1 & q2) | (q3 & q4);
endmodule",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    reg q1, q2, q3, q4;
    always @(posedge clk)
        q1 <= d;
    always @(negedge clk)
        q2 <= d;
    always @(posedge clk)
        q3 <= d;
    always @(negedge clk)
        q4 <= d;
    assign q = (q1 & q2) | (q3 & q4);
endmodule"
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    reg	q1, q2;
    
    always@(posedge clk) begin
        q1 <= d;
    end
    
    always@(negedge clk) begin
        q2 <= d;
    end
    
    assign	q = clk?q1:q2;
    
endmodule",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    reg	q1, q2;
    
    always@(posedge clk) begin
        q1 <= d;
    end
    
    always@(negedge clk) begin
        q2 <= d;
    end
    
    assign	q = clk?q1:q2;
    
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b;
    
    // This assign statement doesn't work on the ARM processor.
    // The reason is that the ARM processor executes the ""assign"" statement
    // as two separate instructions, and only recognizes the result of the
    // first instruction in the ""out"" variable.
    //
    // This works fine on the x86 processor, and it is perhaps possible
    // to modify this to work on the ARM processor as well.
    assign out = reg_a;
    
    always @(posedge clk) begin
        if (reset) begin
            reg_a <= 0;
            reg_b <= 0;
        end
        else begin
            reg_a <= in;
            reg_b <= reg_a;
        end
    end
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b;
    
    // This assign statement doesn't work on the ARM processor.
    // The reason is that the ARM processor executes the ""assign"" statement
    // as two separate instructions, and only recognizes the result of the
    // first instruction in the ""out"" variable.
    //
    // This works fine on the x86 processor, and it is perhaps possible
    // to modify this to work on the ARM processor as well.
    assign out = reg_a;
    
    always @(posedge clk) begin
        if (reset) begin
            reg_a <= 0;
            reg_b <= 0;
        end
        else begin
            reg_a <= in;
            reg_b <= reg_a;
        end
    end
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last_in;
    reg [31:0] last_out;
    
    always @(posedge clk) begin
        last_out <= out;
        last_in <= in;
    end
    
    always @(posedge clk)
        if(reset)
            out <= 0;
    	else
            out <= (last_out == last_in)? out : last_out;

endmodule",-1,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last_in;
    reg [31:0] last_out;
    
    always @(posedge clk) begin
        last_out <= out;
        last_in <= in;
    end
    
    always @(posedge clk)
        if(reset)
            out <= 0;
    	else
            out <= (last_out == last_in)? out : last_out;

endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7, reg8, reg9, reg10, reg11, reg12, reg13, reg14, reg15, reg16, reg17, reg18, reg19, reg20, reg21, reg22, reg23, reg24, reg25, reg26, reg27, reg28, reg29, reg30, reg31;
    
    always @(posedge clk)
        begin
            reg0 <= in;
            reg1 <= reg0;
            reg2 <= reg1;
            reg3 <= reg2;
            reg4 <= reg3;
            reg5 <= reg4;
            reg6 <= reg5;
            reg7 <= reg6;
            reg8 <= reg7;
            reg9 <= reg8;
            reg10 <= reg9;
            reg11 <= reg10;
            reg12 <= reg11;
            reg13 <= reg12;
            reg14 <= reg13;
            reg15 <= reg14;
            reg16 <= reg15;
            reg17 <= reg16;
            reg18 <= reg17;
            reg19 <= reg18;
            reg20 <= reg19;
            reg21 <= reg20;
            reg22 <= reg21;
            reg23 <= reg22;
            reg24 <= reg23;
            reg25 <= reg24;
            reg26 <= reg25;
            reg27 <= reg26;
            reg28 <= reg27;
            reg29 <= reg28;
            reg30 <= reg29;
            reg31 <= reg30;
        end
    
    assign out = {reg31, reg30, reg29, reg28, reg27, reg26, reg25, reg24, reg23, reg22, reg21, reg20, reg19, reg18, reg17, reg16, reg15, reg14, reg13, reg12, reg11, reg10, reg9, reg8, reg7, reg6, reg5, reg4, reg3, reg2, reg1, reg0};
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg0, reg1, reg2, reg3, reg4, reg5, reg6, reg7, reg8, reg9, reg10, reg11, reg12, reg13, reg14, reg15, reg16, reg17, reg18, reg19, reg20, reg21, reg22, reg23, reg24, reg25, reg26, reg27, reg28, reg29, reg30, reg31;
    
    always @(posedge clk)
        begin
            reg0 <= in;
            reg1 <= reg0;
            reg2 <= reg1;
            reg3 <= reg2;
            reg4 <= reg3;
            reg5 <= reg4;
            reg6 <= reg5;
            reg7 <= reg6;
            reg8 <= reg7;
            reg9 <= reg8;
            reg10 <= reg9;
            reg11 <= reg10;
            reg12 <= reg11;
            reg13 <= reg12;
            reg14 <= reg13;
            reg15 <= reg14;
            reg16 <= reg15;
            reg17 <= reg16;
            reg18 <= reg17;
            reg19 <= reg18;
            reg20 <= reg19;
            reg21 <= reg20;
            reg22 <= reg21;
            reg23 <= reg22;
            reg24 <= reg23;
            reg25 <= reg24;
            reg26 <= reg25;
            reg27 <= reg26;
            reg28 <= reg27;
            reg29 <= reg28;
            reg30 <= reg29;
            reg31 <= reg30;
        end
    
    assign out = {reg31, reg30, reg29, reg28, reg27, reg26, reg25, reg24, reg23, reg22, reg21, reg20, reg19, reg18, reg17, reg16, reg15, reg14, reg13, reg12, reg11, reg10, reg9, reg8, reg7, reg6, reg5, reg4, reg3, reg2, reg1, reg0};
    
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last = 0;
    
    always @(posedge clk) begin
        last <= in;
        if(reset)
            out <= 0;
        else
            out <= (last == 0)? in : last;
    end
endmodule",-1,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last = 0;
    
    always @(posedge clk) begin
        last <= in;
        if(reset)
            out <= 0;
        else
            out <= (last == 0)? in : last;
    end
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last = 0;
    
    always @(posedge clk) begin
        last <= in;
        if(reset)
            out <= 0;
        else
            out <= (last == 0)? in : last;
    end
endmodule",-1,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last = 0;
    
    always @(posedge clk) begin
        last <= in;
        if(reset)
            out <= 0;
        else
            out <= (last == 0)? in : last;
    end
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b;
    
    always @(posedge clk) begin
        if(reset) begin
            reg_a <= 0;
            reg_b <= 0;
        end
        else begin
            reg_a <= in;
            reg_b <= reg_a;
        end
    end
    
    assign out = reg_a;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b;
    
    always @(posedge clk) begin
        if(reset) begin
            reg_a <= 0;
            reg_b <= 0;
        end
        else begin
            reg_a <= in;
            reg_b <= reg_a;
        end
    end
    
    assign out = reg_a;
    
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last_in;
    reg [31:0] last_out;
    reg [31:0] temp;
    always @(posedge clk)
    begin
        last_out <= out;
        temp <= in;
        if(reset == 1'b1)
            out <= 0;
        else
            out <= last_out;
    end
    always @(posedge clk)
    begin
        last_in <= temp;
    end
endmodule",-1,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] last_in;
    reg [31:0] last_out;
    reg [31:0] temp;
    always @(posedge clk)
    begin
        last_out <= out;
        temp <= in;
        if(reset == 1'b1)
            out <= 0;
        else
            out <= last_out;
    end
    always @(posedge clk)
    begin
        last_in <= temp;
    end
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b, reg_c, reg_d, reg_e, reg_f, reg_g, reg_h;
    
    // This initial block is only used to initialize
    // all of the registers to a known set of values.
    initial
    begin
        reg_a = 32'h00ff00ff;
        reg_b = 32'h11111111;
        reg_c = 32'h22222222;
        reg_d = 32'h33333333;
        reg_e = 32'h44444444;
        reg_f = 32'h55555555;
        reg_g = 32'h66666666;
        reg_h = 32'h77777777;
    end
    
    // At each clock, the value of each
    // register is updated based on the
    // input.
    always @(posedge clk)
    begin
        reg_a <= in;
        reg_b <= in;
        reg_c <= in;
        reg_d <= in;
        reg_e <= in;
        reg_f <= in;
        reg_g <= in;
        reg_h <= in;
    end
    
    // The value of out is the value
    // of the register that was written
    // to the most recently
    // updated register.
    assign out = reg_h;
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b, reg_c, reg_d, reg_e, reg_f, reg_g, reg_h;
    
    // This initial block is only used to initialize
    // all of the registers to a known set of values.
    initial
    begin
        reg_a = 32'h00ff00ff;
        reg_b = 32'h11111111;
        reg_c = 32'h22222222;
        reg_d = 32'h33333333;
        reg_e = 32'h44444444;
        reg_f = 32'h55555555;
        reg_g = 32'h66666666;
        reg_h = 32'h77777777;
    end
    
    // At each clock, the value of each
    // register is updated based on the
    // input.
    always @(posedge clk)
    begin
        reg_a <= in;
        reg_b <= in;
        reg_c <= in;
        reg_d <= in;
        reg_e <= in;
        reg_f <= in;
        reg_g <= in;
        reg_h <= in;
    end
    
    // The value of out is the value
    // of the register that was written
    // to the most recently
    // updated register.
    assign out = reg_h;
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b;
    
    always @(posedge clk) begin
        reg_a = in;
        reg_b = reg_a;
    end
    
    assign out = reg_a;
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    reg [31:0] reg_a, reg_b;
    
    always @(posedge clk) begin
        reg_a = in;
        reg_b = reg_a;
    end
    
    assign out = reg_a;
endmodule"
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_a, reg_b;
    
    // This assign statement is a sequential 'always' block, which is a combinational always block.
    assign out = reg_a + reg_b;
    
    // This always block is a combinational always block.
    always @(posedge clk)
        begin
            if(reset)
                reg_a <= 0;
            else
                reg_a <= in;
        end
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_a, reg_b;
    
    // This assign statement is a sequential 'always' block, which is a combinational always block.
    assign out = reg_a + reg_b;
    
    // This always block is a combinational always block.
    always @(posedge clk)
        begin
            if(reset)
                reg_a <= 0;
            else
                reg_a <= in;
        end
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

reg	[7:0]	temp;

always @(posedge clk)
    begin
        temp <= in;
        pedge <= ~temp & in;
    end

endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

reg	[7:0]	temp;

always @(posedge clk)
    begin
        temp <= in;
        pedge <= ~temp & in;
    end

endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg	[7:0]	temp;
    
    always@(posedge clk)	begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg	[7:0]	temp;
    
    always@(posedge clk)	begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

reg	[7:0]	temp;

always @(posedge clk)
    begin
        temp <= in;
        pedge <= ~temp & in;
    end

endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

reg	[7:0]	temp;

always @(posedge clk)
    begin
        temp <= in;
        pedge <= ~temp & in;
    end

endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    
    reg [7:0] temp;
    
    always @(posedge clk) begin
        temp <= in;
        pedge <= ~temp & in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	last_in;
    
    always@(posedge clk) begin
        last_in <= in;
        anyedge <= in & (last_in ^ in);
    end
    
endmodule",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	last_in;
    
    always@(posedge clk) begin
        last_in <= in;
        anyedge <= in & (last_in ^ in);
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in ^ in_reg;
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in ^ in_reg;
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    reg	[7:0]	last_in;
    
    always@(posedge clk) begin
        last_in <= in;
        anyedge <= in ^ last_in;
    end
    
endmodule",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    reg	[7:0]	last_in;
    
    always@(posedge clk) begin
        last_in <= in;
        anyedge <= in ^ last_in;
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    reg	[7:0]	history;
    
    always@(posedge clk) begin
        history <= in;
        anyedge <= in & (history == 0);
    end
    
endmodule",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    reg	[7:0]	history;
    
    always@(posedge clk) begin
        history <= in;
        anyedge <= in & (history == 0);
    end
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    
    always@(posedge clk) begin
        in_reg <= in;
    end
    
    assign	anyedge = in ^ in_reg;
    
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    
    always@(posedge clk) begin
        in_reg <= in;
    end
    
    assign	anyedge = in ^ in_reg;
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	last_in;
    always@(posedge clk) begin
        last_in <= in;
        anyedge <= in & (last_in ^ in);
    end
endmodule",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	last_in;
    always@(posedge clk) begin
        last_in <= in;
        anyedge <= in & (last_in ^ in);
    end
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

reg	[7:0]	in_reg;

always@(posedge clk)
    in_reg <= in;

assign	anyedge = in_reg;

endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

reg	[7:0]	in_reg;

always@(posedge clk)
    in_reg <= in;

assign	anyedge = in_reg;

endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in ^ in_reg;
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in ^ in_reg;
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    reg	[7:0]	in_reg;
    
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in_reg;
    
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    reg	[7:0]	in_reg;
    
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in_reg;
    
endmodule"
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in_reg;
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    reg	[7:0]	in_reg;
    
    always@(posedge clk)
        in_reg <= in;
    assign	anyedge = in_reg;
endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & x[4]);
endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (~x[1] & ~x[3] & x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (~x[1] & ~x[3] & x[2] & x[4]);

endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & x[4]);
endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[2] & x[4]);

endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[2] & x[4]);

endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1]&x[3]) | (x[2]&x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1]&x[3]) | (x[2]&x[4]);

endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & ~x[4] & x[3]);
    
endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & ~x[4] & x[3]);
    
endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (x[1] & x[3]) | (x[2] & x[4]);

endmodule"
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[4]) | (x[2] & x[3]);

endmodule",1,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[4]) | (x[2] & x[3]);

endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[3:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x, y})
            {A, 1'b0, 1'b0}:	next_state = B;
            {A, 1'b0, 1'b1}:	next_state = C;
            {A, 1'b1, 1'b0}:	next_state = D;
            {A, 1'b1, 1'b1}:	next_state = E;
            {B, 1'b0, 1'b0}:	next_state = B;
            {B, 1'b0, 1'b1}:	next_state = C;
            {B, 1'b1, 1'b0}:	next_state = D;
            {B, 1'b1, 1'b1}:	next_state = E;
            {C, 1'b0, 1'b0}:	next_state = B;
            {C, 1'b0, 1'b1}:	next_state = C;
            {C, 1'b1, 1'b0}:	next_state = D;
            {C, 1'b1, 1'b1}:	next_state = E;
            {D, 1'b0, 1'b0}:	next_state = B;
            {D, 1'b0, 1'b1}:	next_state = C;
            {D, 1'b1, 1'b0}:	next_state = D;
            {D, 1'b1, 1'b1}:	next_state = E;
            {E, 1'b0, 1'b0}:	next_state = B;
            {E, 1'b0, 1'b1}:	next_state = C;
            {E, 1'b1, 1'b0}:	next_state = D;
            {E, 1'b1, 1'b1}:	next_state = E;
            {F, 1'b0, 1'b0}:	next_state = B;
            {F, 1'b0, 1'b1}:	next_state = C;
            {F, 1'b1, 1'b0}:	next_state = D;
            {F, 1'b1, 1'b1}:	next_state = E;
            {G, 1'b0, 1'b0}:	next_state = B;
            {G, 1'b0, 1'b1}:	next_state = C;
            {G, 1'b1, 1'b0}:	next_state = D;
            {G, 1'b1, 1'b1}:	next_state = E;
            {H, 1'b0, 1'b0}:	next_state = B;
            {H, 1'b0, 1'b1}:	next_state = C;
            {H, 1'b1, 1'b0}:	next_state = D;
            {H, 1'b1, 1'b1}:	next_state = E;
            {I, 1'b0, 1'b0}:	next_state = B;
            {I, 1'b0, 1'b1}:	next_state = C;
            {I, 1'b1, 1'b0}:	next_state = D;
            {I, 1'b1, 1'b1}:	next_state = E;
            {J, 1'b0, 1'b0}:	next_state = B;
            {J, 1'b0, 1'b1}:	next_state = C;
            {J, 1'b1, 1'b0}:	next_state = D;
            {J, 1'b1, 1'b1}:	next_state = E;
            {K, 1'b0, 1'b0}:	next_state = B;
            {K, 1'b0, 1'b1}:	next_state = C;
            {K, 1'b1, 1'b0}:",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[3:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x, y})
            {A, 1'b0, 1'b0}:	next_state = B;
            {A, 1'b0, 1'b1}:	next_state = C;
            {A, 1'b1, 1'b0}:	next_state = D;
            {A, 1'b1, 1'b1}:	next_state = E;
            {B, 1'b0, 1'b0}:	next_state = B;
            {B, 1'b0, 1'b1}:	next_state = C;
            {B, 1'b1, 1'b0}:	next_state = D;
            {B, 1'b1, 1'b1}:	next_state = E;
            {C, 1'b0, 1'b0}:	next_state = B;
            {C, 1'b0, 1'b1}:	next_state = C;
            {C, 1'b1, 1'b0}:	next_state = D;
            {C, 1'b1, 1'b1}:	next_state = E;
            {D, 1'b0, 1'b0}:	next_state = B;
            {D, 1'b0, 1'b1}:	next_state = C;
            {D, 1'b1, 1'b0}:	next_state = D;
            {D, 1'b1, 1'b1}:	next_state = E;
            {E, 1'b0, 1'b0}:	next_state = B;
            {E, 1'b0, 1'b1}:	next_state = C;
            {E, 1'b1, 1'b0}:	next_state = D;
            {E, 1'b1, 1'b1}:	next_state = E;
            {F, 1'b0, 1'b0}:	next_state = B;
            {F, 1'b0, 1'b1}:	next_state = C;
            {F, 1'b1, 1'b0}:	next_state = D;
            {F, 1'b1, 1'b1}:	next_state = E;
            {G, 1'b0, 1'b0}:	next_state = B;
            {G, 1'b0, 1'b1}:	next_state = C;
            {G, 1'b1, 1'b0}:	next_state = D;
            {G, 1'b1, 1'b1}:	next_state = E;
            {H, 1'b0, 1'b0}:	next_state = B;
            {H, 1'b0, 1'b1}:	next_state = C;
            {H, 1'b1, 1'b0}:	next_state = D;
            {H, 1'b1, 1'b1}:	next_state = E;
            {I, 1'b0, 1'b0}:	next_state = B;
            {I, 1'b0, 1'b1}:	next_state = C;
            {I, 1'b1, 1'b0}:	next_state = D;
            {I, 1'b1, 1'b1}:	next_state = E;
            {J, 1'b0, 1'b0}:	next_state = B;
            {J, 1'b0, 1'b1}:	next_state = C;
            {J, 1'b1, 1'b0}:	next_state = D;
            {J, 1'b1, 1'b1}:	next_state = E;
            {K, 1'b0, 1'b0}:	next_state = B;
            {K, 1'b0, 1'b1}:	next_state = C;
            {K, 1'b1, 1'b0}:"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A = 0,
               B = 1,
               C = 2,
               D = 3,
               E = 4,
               F = 5,
               G = 6,
               H = 7,
               I = 8,
               J = 9,
               K = 10,
               L = 11,
               M = 12,
               N = 13,
               O = 14,
               P = 15,
               Q = 16,
               R = 17,
               S = 18,
               T = 19,
               U = 20,
               V = 21,
               W = 22,
               X = 23,
               Y = 24,
               Z = 25,
               DONE = 26;

    reg [3:0] state, next_state;
    
    // State transition logic
    always @(*)
        begin
            case(state)
                A: next_state = x?B:A;
                B: next_state = x?C:B;
                C: next_state = x?C:D;
                D: next_state = x?E:C;
                E: next_state = x?E:F;
                F: next_state = x?F:G;
                G: next_state = x?C:H;
                H: next_state = x?C:I;
                I: next_state = x?H:I;
                J: next_state = x?C:K;
                K: next_state = x?K:L;
                L: next_state = x?L:M;
                M: next_state = x?C:N;
                N: next_state = x?M:O;
                O: next_state = x?O:P;
                P: next_state = x?P:Q;
                Q: next_state = x?Q:R;
                R: next_state = x?R:S;
                S: next_state = x?R:T;
                T: next_state = x?S:U;
                U: next_state = x?U:V;
                V: next_state = x?V:W;
                W: next_state = x?W:X;
                X: next_state = x?W:Y;
                Y: next_state = x?X:Z;
                Z: next_state = x?Y:DONE;
                DONE: next_state = x?C:DONE;
                default: next_state = state;
            endcase
        end
    
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(~resetn)
            state = A;
    	else
            state = next_state;

endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A = 0,
               B = 1,
               C = 2,
               D = 3,
               E = 4,
               F = 5,
               G = 6,
               H = 7,
               I = 8,
               J = 9,
               K = 10,
               L = 11,
               M = 12,
               N = 13,
               O = 14,
               P = 15,
               Q = 16,
               R = 17,
               S = 18,
               T = 19,
               U = 20,
               V = 21,
               W = 22,
               X = 23,
               Y = 24,
               Z = 25,
               DONE = 26;

    reg [3:0] state, next_state;
    
    // State transition logic
    always @(*)
        begin
            case(state)
                A: next_state = x?B:A;
                B: next_state = x?C:B;
                C: next_state = x?C:D;
                D: next_state = x?E:C;
                E: next_state = x?E:F;
                F: next_state = x?F:G;
                G: next_state = x?C:H;
                H: next_state = x?C:I;
                I: next_state = x?H:I;
                J: next_state = x?C:K;
                K: next_state = x?K:L;
                L: next_state = x?L:M;
                M: next_state = x?C:N;
                N: next_state = x?M:O;
                O: next_state = x?O:P;
                P: next_state = x?P:Q;
                Q: next_state = x?Q:R;
                R: next_state = x?R:S;
                S: next_state = x?R:T;
                T: next_state = x?S:U;
                U: next_state = x?U:V;
                V: next_state = x?V:W;
                W: next_state = x?W:X;
                X: next_state = x?W:Y;
                Y: next_state = x?X:Z;
                Z: next_state = x?Y:DONE;
                DONE: next_state = x?C:DONE;
                default: next_state = state;
            endcase
        end
    
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(~resetn)
            state = A;
    	else
            state = next_state;

endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	parameter A = 0, B = 1, C = 2, D = 3, E = 4;
    reg [1:0] state, next_state;
    reg [1:0] sel;
    reg g1, an;
    wire a, b;
    
    always @(*)
        case(state)
            A: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = B;
            end
            B: begin
                if(x == 1'b1)
                    next_state = B;
                else
                    next_state = C;
            end
            C: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if(~resetn)
                    next_state = E;
                else
                    next_state = B;
            end
            E: begin
                if(y == 1'b1)
                    next_state = E;
                else
                    next_state = A;
            end
            default:
                next_state = A;
        endcase
    
    always @(posedge clk)
        if(~resetn)
            state <= A;
    	else
            state <= next_state;
    
    assign f = (state == D) || (state == E);
    assign g = (state == C) || (state == E);
    assign an = ~resetn;
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	parameter A = 0, B = 1, C = 2, D = 3, E = 4;
    reg [1:0] state, next_state;
    reg [1:0] sel;
    reg g1, an;
    wire a, b;
    
    always @(*)
        case(state)
            A: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = B;
            end
            B: begin
                if(x == 1'b1)
                    next_state = B;
                else
                    next_state = C;
            end
            C: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if(~resetn)
                    next_state = E;
                else
                    next_state = B;
            end
            E: begin
                if(y == 1'b1)
                    next_state = E;
                else
                    next_state = A;
            end
            default:
                next_state = A;
        endcase
    
    always @(posedge clk)
        if(~resetn)
            state <= A;
    	else
            state <= next_state;
    
    assign f = (state == D) || (state == E);
    assign g = (state == C) || (state == E);
    assign an = ~resetn;
    
endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5, G = 6, H = 7, I = 8, J = 9;
    reg [3:0] state, next_state;
    reg [1:0] c;
    
    
    always@(*) begin
        case(state)
            A : next_state = x? B : A;
            B : next_state = x? B : C;
            C : next_state = x? D : C;
            D : next_state = x? D : E;
            E : next_state = x? D : E;
            F : next_state = x? D : F;
            G : next_state = x? D : G;
            H : next_state = x? D : H;
            I : next_state = x? D : I;
            J : next_state = x? D : J;
            default : next_state = 4'bxxxx;
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
        c <= {g, f, e, d, c};
    end
    
    assign f = (state == F) || (state == G);
    assign g = (state == G) || (state == H) || (state == I) || (state == J);
    
endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5, G = 6, H = 7, I = 8, J = 9;
    reg [3:0] state, next_state;
    reg [1:0] c;
    
    
    always@(*) begin
        case(state)
            A : next_state = x? B : A;
            B : next_state = x? B : C;
            C : next_state = x? D : C;
            D : next_state = x? D : E;
            E : next_state = x? D : E;
            F : next_state = x? D : F;
            G : next_state = x? D : G;
            H : next_state = x? D : H;
            I : next_state = x? D : I;
            J : next_state = x? D : J;
            default : next_state = 4'bxxxx;
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
        c <= {g, f, e, d, c};
    end
    
    assign f = (state == F) || (state == G);
    assign g = (state == G) || (state == H) || (state == I) || (state == J);
    
endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	parameter A = 0, B = 1, C = 2, D = 3, E = 4;
    reg [1:0] state, next_state;
    reg [1:0] p_state;
    reg f_reg, g_reg;
    
    always@(*) begin
        case(state)
            A : next_state = x? B : A;
            B : next_state = x? B : C;
            C : next_state = x? D : C;
            D : next_state = x? D : E;
            E : next_state = x? D : C;
            default : next_state = 2'bxx;
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
        
        p_state <= next_state;
    end
    
    always@(posedge clk) begin
        f <= (state == D || state == E);
        g <= (state == C || state == E);
    end
    
endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	parameter A = 0, B = 1, C = 2, D = 3, E = 4;
    reg [1:0] state, next_state;
    reg [1:0] p_state;
    reg f_reg, g_reg;
    
    always@(*) begin
        case(state)
            A : next_state = x? B : A;
            B : next_state = x? B : C;
            C : next_state = x? D : C;
            D : next_state = x? D : E;
            E : next_state = x? D : C;
            default : next_state = 2'bxx;
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
        
        p_state <= next_state;
    end
    
    always@(posedge clk) begin
        f <= (state == D || state == E);
        g <= (state == C || state == E);
    end
    
endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=2'b00,
               B=2'b01,
               C=2'b10,
               D=2'b11;
    reg [1:0] state, next_state;
    
    // State transition logic
    always @(*)
        case(state)
            A: next_state = x?B:A;
            B: next_state = x?C:A;
            C: next_state = x?C:D;
            D: next_state = x?C:A;
            default: next_state = 2'bxx;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk, negedge resetn)
        if(~resetn)
            state = A;
        else
            state = next_state;
    
    // Output logic
    assign f = (state == D);
    assign g = (state == C);
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=2'b00,
               B=2'b01,
               C=2'b10,
               D=2'b11;
    reg [1:0] state, next_state;
    
    // State transition logic
    always @(*)
        case(state)
            A: next_state = x?B:A;
            B: next_state = x?C:A;
            C: next_state = x?C:D;
            D: next_state = x?C:A;
            default: next_state = 2'bxx;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk, negedge resetn)
        if(~resetn)
            state = A;
        else
            state = next_state;
    
    // Output logic
    assign f = (state == D);
    assign g = (state == C);
    
endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x, y})
            {A, 1'b0, 1'b0}:	next_state = B;
            {A, 1'b0, 1'b1}:	next_state = B;
            {A, 1'b1, 1'b0}:	next_state = C;
            {A, 1'b1, 1'b1}:	next_state = D;
            {B, 1'b0, 1'b0}:	next_state = B;
            {B, 1'b0, 1'b1}:	next_state = E;
            {B, 1'b1, 1'b0}:	next_state = B;
            {B, 1'b1, 1'b1}:	next_state = F;
            {C, 1'b0, 1'b0}:	next_state = C;
            {C, 1'b0, 1'b1}:	next_state = G;
            {C, 1'b1, 1'b0}:	next_state = D;
            {C, 1'b1, 1'b1}:	next_state = H;
            {D, 1'b0, 1'b0}:	next_state = B;
            {D, 1'b0, 1'b1}:	next_state = I;
            {D, 1'b1, 1'b0}:	next_state = B;
            {D, 1'b1, 1'b1}:	next_state = J;
            {E, 1'b0, 1'b0}:	next_state = E;
            {E, 1'b0, 1'b1}:	next_state = C;
            {E, 1'b1, 1'b0}:	next_state = B;
            {E, 1'b1, 1'b1}:	next_state = I;
            {F, 1'b0, 1'b0}:	next_state = B;
            {F, 1'b0, 1'b1}:	next_state = J;
            {F, 1'b1, 1'b0}:	next_state = B;
            {F, 1'b1, 1'b1}:	next_state = I;
            {G, 1'b0, 1'b0}:	next_state = C;
            {G, 1'b0, 1'b1}:	next_state = H;
            {G, 1'b1, 1'b0}:	next_state = B;
            {G, 1'b1, 1'b1}:	next_state = J;
            {H, 1'b0, 1'b0}:	next_state = D;
            {H, 1'b0, 1'b1}:	next_state = I;
            {H, 1'b1, 1'b0}:	next_state = B;
            {H, 1'b1, 1'b1}:	next_state = J;
            {I, 1'b0, 1'b0}:	next_state = B;
            {I, 1'b0, 1'b1}:	next_state = J;
            {I, 1'b1, 1'b0}:	next_state = B;
            {I, 1'b1, 1'b1}:	next_state = H;
            {J, 1'b0, 1'b0}:	next_state = B;
            {J, 1'b0, 1'b1}:	next_state = I;
            {J, 1'b1, 1'b0}:	next_state = B;
            {J, 1'b1, 1'b1}:	next_state = H;
            {K, 1'b0, 1'b0}:	next_state = C;
            {K, 1'b0, 1'b1}:	next_state = I;
            {K, 1'b1, 1'b0}:",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x, y})
            {A, 1'b0, 1'b0}:	next_state = B;
            {A, 1'b0, 1'b1}:	next_state = B;
            {A, 1'b1, 1'b0}:	next_state = C;
            {A, 1'b1, 1'b1}:	next_state = D;
            {B, 1'b0, 1'b0}:	next_state = B;
            {B, 1'b0, 1'b1}:	next_state = E;
            {B, 1'b1, 1'b0}:	next_state = B;
            {B, 1'b1, 1'b1}:	next_state = F;
            {C, 1'b0, 1'b0}:	next_state = C;
            {C, 1'b0, 1'b1}:	next_state = G;
            {C, 1'b1, 1'b0}:	next_state = D;
            {C, 1'b1, 1'b1}:	next_state = H;
            {D, 1'b0, 1'b0}:	next_state = B;
            {D, 1'b0, 1'b1}:	next_state = I;
            {D, 1'b1, 1'b0}:	next_state = B;
            {D, 1'b1, 1'b1}:	next_state = J;
            {E, 1'b0, 1'b0}:	next_state = E;
            {E, 1'b0, 1'b1}:	next_state = C;
            {E, 1'b1, 1'b0}:	next_state = B;
            {E, 1'b1, 1'b1}:	next_state = I;
            {F, 1'b0, 1'b0}:	next_state = B;
            {F, 1'b0, 1'b1}:	next_state = J;
            {F, 1'b1, 1'b0}:	next_state = B;
            {F, 1'b1, 1'b1}:	next_state = I;
            {G, 1'b0, 1'b0}:	next_state = C;
            {G, 1'b0, 1'b1}:	next_state = H;
            {G, 1'b1, 1'b0}:	next_state = B;
            {G, 1'b1, 1'b1}:	next_state = J;
            {H, 1'b0, 1'b0}:	next_state = D;
            {H, 1'b0, 1'b1}:	next_state = I;
            {H, 1'b1, 1'b0}:	next_state = B;
            {H, 1'b1, 1'b1}:	next_state = J;
            {I, 1'b0, 1'b0}:	next_state = B;
            {I, 1'b0, 1'b1}:	next_state = J;
            {I, 1'b1, 1'b0}:	next_state = B;
            {I, 1'b1, 1'b1}:	next_state = H;
            {J, 1'b0, 1'b0}:	next_state = B;
            {J, 1'b0, 1'b1}:	next_state = I;
            {J, 1'b1, 1'b0}:	next_state = B;
            {J, 1'b1, 1'b1}:	next_state = H;
            {K, 1'b0, 1'b0}:	next_state = C;
            {K, 1'b0, 1'b1}:	next_state = I;
            {K, 1'b1, 1'b0}:"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	
    // Define the input logic for the d_flip_flop
    assign d = (x ^ y);
    
    // Define the FSM
    
    parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5, G = 6, H = 7, I = 8, J = 9;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        case (state)
            A : next_state = (x)?B:A;
            B : next_state = (x)?C:B;
            C : next_state = (x)?C:D;
            D : next_state = (x)?E:C;
            E : next_state = (x)?E:F;
            F : next_state = (x)?G:D;
            G : next_state = (x)?C:H;
            H : next_state = (x)?C:I;
            I : next_state = (x)?C:J;
            J : next_state = (x)?C:A;
            default : next_state = state;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign f = (state == F) || (state == G);
    assign g = (state == C) || (state == D) || (state == E) || (state == F);
    
endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use the FSM from Fsm_serial
	
    // Define the input logic for the d_flip_flop
    assign d = (x ^ y);
    
    // Define the FSM
    
    parameter A = 0, B = 1, C = 2, D = 3, E = 4, F = 5, G = 6, H = 7, I = 8, J = 9;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        case (state)
            A : next_state = (x)?B:A;
            B : next_state = (x)?C:B;
            C : next_state = (x)?C:D;
            D : next_state = (x)?E:C;
            E : next_state = (x)?E:F;
            F : next_state = (x)?G:D;
            G : next_state = (x)?C:H;
            H : next_state = (x)?C:I;
            I : next_state = (x)?C:J;
            J : next_state = (x)?C:A;
            default : next_state = state;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign f = (state == F) || (state == G);
    assign g = (state == C) || (state == D) || (state == E) || (state == F);
    
endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use two-state-transition to create a reset-free counter
    // This is a T flip-flop
    reg [2:0] t;
    always @(posedge clk, negedge resetn)
        if(~resetn)
            t <= 3'b000;
        else
            t <= t + 1;
            
    assign f = t[2] & t[1] & t[0];
    assign g = t[2] & t[1] & ~t[0];
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    // Use two-state-transition to create a reset-free counter
    // This is a T flip-flop
    reg [2:0] t;
    always @(posedge clk, negedge resetn)
        if(~resetn)
            t <= 3'b000;
        else
            t <= t + 1;
            
    assign f = t[2] & t[1] & t[0];
    assign g = t[2] & t[1] & ~t[0];
    
endmodule"
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=2'd0, B=2'd1, C=2'd2, D=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = A;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign f = (state == D);
    assign g = (state == C);
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=2'd0, B=2'd1, C=2'd2, D=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = A;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign f = (state == D);
    assign g = (state == C);
    
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg [3:0] PS, NS;
    
    assign z = ((PS == D) || (PS == J))? 1:0;
        
    always @(posedge clk)
        PS <= NS;
    
    always @(PS, x)
        case(PS)
            A:begin
                NS <= B;
                z <= 0;
            end
            
            B:begin
                NS <= J;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            C:begin
                NS <= (x == 0)? D:E;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            D:begin
                NS <= (x == 0)? E:F;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            E:begin
                NS <= (x == 0)? F:G;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            F:begin
                NS <= G;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            G:begin
                NS <= (x == 0)? H:I;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            H:begin
                NS <= (x == 0)? I:J;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            I:begin
                NS <= (x == 0)? J:A;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            J:begin
                NS <= A;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            default: NS <= PS;
        endcase
    
endmodule",-1,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg [3:0] PS, NS;
    
    assign z = ((PS == D) || (PS == J))? 1:0;
        
    always @(posedge clk)
        PS <= NS;
    
    always @(PS, x)
        case(PS)
            A:begin
                NS <= B;
                z <= 0;
            end
            
            B:begin
                NS <= J;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            C:begin
                NS <= (x == 0)? D:E;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            D:begin
                NS <= (x == 0)? E:F;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            E:begin
                NS <= (x == 0)? F:G;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            F:begin
                NS <= G;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            G:begin
                NS <= (x == 0)? H:I;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            H:begin
                NS <= (x == 0)? I:J;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            I:begin
                NS <= (x == 0)? J:A;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            J:begin
                NS <= A;
                z <= ((x == 0) || (x == 3))? 0:1;
            end
            
            default: NS <= PS;
        endcase
    
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg [3:0] PS, NS;
    
    assign z = ((PS == D) || (PS == I))? 1:0;
        
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? C:B;
            C: NS = (x)? C:D;
            D: NS = (x)? E:C;
            E: NS = (x)? E:F;
            F: NS = (x)? F:G;
            G: NS = (x)? C:E;
            H: NS = (x)? I:C;
            I: NS = (x)? I:J;
            J: NS = (x)? C:I;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg [3:0] PS, NS;
    
    assign z = ((PS == D) || (PS == I))? 1:0;
        
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? C:B;
            C: NS = (x)? C:D;
            D: NS = (x)? E:C;
            E: NS = (x)? E:F;
            F: NS = (x)? F:G;
            G: NS = (x)? C:E;
            H: NS = (x)? I:C;
            I: NS = (x)? I:J;
            J: NS = (x)? C:I;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = B;
            {A, 1'b1}:	next_state = A;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = D;
            {C, 1'b0}:	next_state = E;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = E;
            {D, 1'b1}:	next_state = F;
            {E, 1'b0}:	next_state = E;
            {E, 1'b1}:	next_state = F;
            {F, 1'b0}:	next_state = G;
            {F, 1'b1}:	next_state = D;
            {G, 1'b0}:	next_state = C;
            {G, 1'b1}:	next_state = D;
            {H, 1'b0}:	next_state = I;
            {H, 1'b1}:	next_state = J;
            {I, 1'b0}:	next_state = E;
            {I, 1'b1}:	next_state = J;
            {J, 1'b0}:	next_state = E;
            {J, 1'b1}:	next_state = I;
            {K, 1'b0}:	next_state = C;
            {K, 1'b1}:	next_state = J;
            {L, 1'b0}:	next_state = E;
            {L, 1'b1}:	next_state = I;
            {M, 1'b0}:	next_state = A;
            {M, 1'b1}:	next_state = B;
            {N, 1'b0}:	next_state = E;
            {N, 1'b1}:	next_state = M;
            {O, 1'b0}:	next_state = E;
            {O, 1'b1}:	next_state = N;
            {P, 1'b0}:	next_state = B;
            {P, 1'b1}:	next_state = N;
            {Q, 1'b0}:	next_state = E;
            {Q, 1'b1}:	next_state = P;
            {R, 1'b0}:	next_state = B;
            {R, 1'b1}:	next_state = Q;
            {S, 1'b0}:	next_state = E;
            {S, 1'b1}:	next_state = R;
            {T, 1'b0}:	next_state = B;
            {T, 1'b1}:	next_state = S;
            {U, 1'b0}:	next_state = E;
            {U, 1'b1}:	next_state = U;
            {V, 1'b0}:	next_state = B;
            {V, 1'b1}:	next_state = V;
            {W, 1'b0}:	next_state = B;
            {W, 1'b1}:	next_state = W;
            {X, 1'b0}:	next_state = B;
            {X, 1'b1}:	next_state = X;
            {Y, 1'b0}:	next_state = B;
            {Y, 1'b1}:	next_state = Y;
            {Z, 1'b0}:	next_state = B;
            {Z, 1'b1}:	next_state = Z;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = D;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@",-1,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = B;
            {A, 1'b1}:	next_state = A;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = D;
            {C, 1'b0}:	next_state = E;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = E;
            {D, 1'b1}:	next_state = F;
            {E, 1'b0}:	next_state = E;
            {E, 1'b1}:	next_state = F;
            {F, 1'b0}:	next_state = G;
            {F, 1'b1}:	next_state = D;
            {G, 1'b0}:	next_state = C;
            {G, 1'b1}:	next_state = D;
            {H, 1'b0}:	next_state = I;
            {H, 1'b1}:	next_state = J;
            {I, 1'b0}:	next_state = E;
            {I, 1'b1}:	next_state = J;
            {J, 1'b0}:	next_state = E;
            {J, 1'b1}:	next_state = I;
            {K, 1'b0}:	next_state = C;
            {K, 1'b1}:	next_state = J;
            {L, 1'b0}:	next_state = E;
            {L, 1'b1}:	next_state = I;
            {M, 1'b0}:	next_state = A;
            {M, 1'b1}:	next_state = B;
            {N, 1'b0}:	next_state = E;
            {N, 1'b1}:	next_state = M;
            {O, 1'b0}:	next_state = E;
            {O, 1'b1}:	next_state = N;
            {P, 1'b0}:	next_state = B;
            {P, 1'b1}:	next_state = N;
            {Q, 1'b0}:	next_state = E;
            {Q, 1'b1}:	next_state = P;
            {R, 1'b0}:	next_state = B;
            {R, 1'b1}:	next_state = Q;
            {S, 1'b0}:	next_state = E;
            {S, 1'b1}:	next_state = R;
            {T, 1'b0}:	next_state = B;
            {T, 1'b1}:	next_state = S;
            {U, 1'b0}:	next_state = E;
            {U, 1'b1}:	next_state = U;
            {V, 1'b0}:	next_state = B;
            {V, 1'b1}:	next_state = V;
            {W, 1'b0}:	next_state = B;
            {W, 1'b1}:	next_state = W;
            {X, 1'b0}:	next_state = B;
            {X, 1'b1}:	next_state = X;
            {Y, 1'b0}:	next_state = B;
            {Y, 1'b1}:	next_state = Y;
            {Z, 1'b0}:	next_state = B;
            {Z, 1'b1}:	next_state = Z;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = D;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg [3:0] PS, NS;
    
    assign z = ((PS == D) || (PS == J))? 1:0;
        
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? E:C;
            D: NS = (x)? B:D;
            E: NS = (x)? E:E;
            F: NS = (x)? B:F;
            G: NS = (x)? E:G;
            H: NS = (x)? B:H;
            I: NS = (x)? B:I;
            J: NS = (x)? E:J;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg [3:0] PS, NS;
    
    assign z = ((PS == D) || (PS == J))? 1:0;
        
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? E:C;
            D: NS = (x)? B:D;
            E: NS = (x)? E:E;
            F: NS = (x)? B:F;
            G: NS = (x)? E:G;
            H: NS = (x)? B:H;
            I: NS = (x)? B:I;
            J: NS = (x)? E:J;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = A;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == D);
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = A;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == D);
    
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg	[1:0]	y, Y;
    
    always@(*) begin
        case({y, x})
            {A, 1'b0}:	Y = A;
            {A, 1'b1}:	Y = B;
            {B, 1'b0}:	Y = C;
            {B, 1'b1}:	Y = B;
            {C, 1'b0}:	Y = C;
            {C, 1'b1}:	Y = D;
            {D, 1'b0}:	Y = C;
            {D, 1'b1}:	Y = B;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            y <= 2'b00;
        else
            y <= Y;
    end
    
    assign z = (y == D);
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg	[1:0]	y, Y;
    
    always@(*) begin
        case({y, x})
            {A, 1'b0}:	Y = A;
            {A, 1'b1}:	Y = B;
            {B, 1'b0}:	Y = C;
            {B, 1'b1}:	Y = B;
            {C, 1'b0}:	Y = C;
            {C, 1'b1}:	Y = D;
            {D, 1'b0}:	Y = C;
            {D, 1'b1}:	Y = B;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            y <= 2'b00;
        else
            y <= Y;
    end
    
    assign z = (y == D);
    
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [1:0] PS, NS;
    
    assign z = ((PS == D) || (PS == E))? 1:0;
    
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? B:C;
            D: NS = (x)? C:B;
            E: NS = (x)? E:D;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [1:0] PS, NS;
    
    assign z = ((PS == D) || (PS == E))? 1:0;
    
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? B:C;
            D: NS = (x)? C:B;
            E: NS = (x)? E:D;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == E))? 1:0;
    
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? B:C;
            D: NS = (x)? C:B;
            E: NS = (x)? E:D;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == E))? 1:0;
    
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? B:C;
            D: NS = (x)? C:B;
            E: NS = (x)? E:D;
            default: NS = PS;
        endcase
    
    always @(posedge clk)
        if(reset)
            PS = A;
    	else
            PS = NS;
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = B;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = C;
            {C, 1'b0}:	next_state = D;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = E;
            {D, 1'b1}:	next_state = E;
            {E, 1'b0}:	next_state = F;
            {E, 1'b1}:	next_state = F;
            {F, 1'b0}:	next_state = G;
            {F, 1'b1}:	next_state = G;
            {G, 1'b0}:	next_state = H;
            {G, 1'b1}:	next_state = H;
            {H, 1'b0}:	next_state = I;
            {H, 1'b1}:	next_state = I;
            {I, 1'b0}:	next_state = J;
            {I, 1'b1}:	next_state = J;
            {J, 1'b0}:	next_state = A;
            {J, 1'b1}:	next_state = A;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == H);
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = B;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = C;
            {C, 1'b0}:	next_state = D;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = E;
            {D, 1'b1}:	next_state = E;
            {E, 1'b0}:	next_state = F;
            {E, 1'b1}:	next_state = F;
            {F, 1'b0}:	next_state = G;
            {F, 1'b1}:	next_state = G;
            {G, 1'b0}:	next_state = H;
            {G, 1'b1}:	next_state = H;
            {H, 1'b0}:	next_state = I;
            {H, 1'b1}:	next_state = I;
            {I, 1'b0}:	next_state = J;
            {I, 1'b1}:	next_state = J;
            {J, 1'b0}:	next_state = A;
            {J, 1'b1}:	next_state = A;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == H);
    
endmodule"
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = A;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == D);
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = A;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == D);
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*)
        begin
            Y[0] = (y[2]&y[1])|(y[2]&y[0])|(~y[2]&~y[1]&~y[0]);
            Y[1] = (y[2]&y[1])|(y[2]&y[0])|(~y[2]&~y[1]&y[0]);
            Y[2] = (y[2]&y[1])|(y[2]&y[0])|(y[2]&~y[1]&~y[0])|(y[2]&~y[1]&y[0]);
        end
    
    assign z = (y[2]&y[1])|(y[2]&y[0])|(~y[2]&~y[1]&~y[0])|(~y[2]&~y[1]&y[0]);
    
    always @(posedge clk)
        begin
            if(y[2] == 1'b1)
                Y[0] <= Y[0] + 1'b1;
            if(y[2] == 1'b0)
                Y[1] <= Y[1] + 1'b1;
            Y[2] <= Y[2] + 1'b1;
        end
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*)
        begin
            Y[0] = (y[2]&y[1])|(y[2]&y[0])|(~y[2]&~y[1]&~y[0]);
            Y[1] = (y[2]&y[1])|(y[2]&y[0])|(~y[2]&~y[1]&y[0]);
            Y[2] = (y[2]&y[1])|(y[2]&y[0])|(y[2]&~y[1]&~y[0])|(y[2]&~y[1]&y[0]);
        end
    
    assign z = (y[2]&y[1])|(y[2]&y[0])|(~y[2]&~y[1]&~y[0])|(~y[2]&~y[1]&y[0]);
    
    always @(posedge clk)
        begin
            if(y[2] == 1'b1)
                Y[0] <= Y[0] + 1'b1;
            if(y[2] == 1'b0)
                Y[1] <= Y[1] + 1'b1;
            Y[2] <= Y[2] + 1'b1;
        end
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000 :	Y = 3'b000;
            4'b0001 :	Y = 3'b001;
            4'b0010 :	Y = 3'b001;
            4'b0011 :	Y = 3'b100;
            4'b0100 :	Y = 3'b010;
            4'b0101 :	Y = 3'b001;
            4'b0110 :	Y = 3'b001;
            4'b0111 :	Y = 3'b010;
            4'b1000 :	Y = 3'b011;
            4'b1001 :	Y = 3'b100;
            4'b1010 :	Y = 3'b011;
            4'b1011 :	Y = 3'b100;
            4'b1100 :	Y = 3'b100;
            4'b1101 :	Y = 3'b100;
            4'b1110 :	Y = 3'b100;
            4'b1111 :	Y = 3'b100;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000 :	Y = 3'b000;
            4'b0001 :	Y = 3'b001;
            4'b0010 :	Y = 3'b001;
            4'b0011 :	Y = 3'b100;
            4'b0100 :	Y = 3'b010;
            4'b0101 :	Y = 3'b001;
            4'b0110 :	Y = 3'b001;
            4'b0111 :	Y = 3'b010;
            4'b1000 :	Y = 3'b011;
            4'b1001 :	Y = 3'b100;
            4'b1010 :	Y = 3'b011;
            4'b1011 :	Y = 3'b100;
            4'b1100 :	Y = 3'b100;
            4'b1101 :	Y = 3'b100;
            4'b1110 :	Y = 3'b100;
            4'b1111 :	Y = 3'b100;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(posedge clk)
        Y[0] <= y[0]&(~x) | y[2]&(~x);
    always@(posedge clk)
        Y[1] <= y[1]&(~x) | y[2]&(~x);
    always@(posedge clk)
        Y[2] <= y[2]&(~x);
    
    assign Y0 = Y[0];
    assign z = Y[2];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(posedge clk)
        Y[0] <= y[0]&(~x) | y[2]&(~x);
    always@(posedge clk)
        Y[1] <= y[1]&(~x) | y[2]&(~x);
    always@(posedge clk)
        Y[2] <= y[2]&(~x);
    
    assign Y0 = Y[0];
    assign z = Y[2];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000 :	Y = 3'b000;
            4'b0001 :	Y = 3'b001;
            4'b0010 :	Y = 3'b001;
            4'b0011 :	Y = 3'b100;
            4'b0100 :	Y = 3'b010;
            4'b0101 :	Y = 3'b001;
            4'b0110 :	Y = 3'b001;
            4'b0111 :	Y = 3'b010;
            4'b1000 :	Y = 3'b011;
            4'b1001 :	Y = 3'b001;
            4'b1010 :	Y = 3'b001;
            4'b1011 :	Y = 3'b010;
            4'b1100 :	Y = 3'b011;
            4'b1101 :	Y = 3'b001;
            4'b1110 :	Y = 3'b001;
            4'b1111 :	Y = 3'b010;
            default:	Y = 3'bxxx;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000 :	Y = 3'b000;
            4'b0001 :	Y = 3'b001;
            4'b0010 :	Y = 3'b001;
            4'b0011 :	Y = 3'b100;
            4'b0100 :	Y = 3'b010;
            4'b0101 :	Y = 3'b001;
            4'b0110 :	Y = 3'b001;
            4'b0111 :	Y = 3'b010;
            4'b1000 :	Y = 3'b011;
            4'b1001 :	Y = 3'b001;
            4'b1010 :	Y = 3'b001;
            4'b1011 :	Y = 3'b010;
            4'b1100 :	Y = 3'b011;
            4'b1101 :	Y = 3'b001;
            4'b1110 :	Y = 3'b001;
            4'b1111 :	Y = 3'b010;
            default:	Y = 3'bxxx;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    assign Y0 = y[0]&(~x) | y[1]&(~x) | y[2]&(~x);
    assign z = y[0]&x | y[1]&x | y[2]&x;
    
    always@(posedge clk)
        Y <= y;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    assign Y0 = y[0]&(~x) | y[1]&(~x) | y[2]&(~x);
    assign z = y[0]&x | y[1]&x | y[2]&x;
    
    always@(posedge clk)
        Y <= y;
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(posedge clk) begin
        Y[0] <= (y[2:0] & {3{x}}) | (~y[2:0] & {3{(~x)}});
        Y[1] <= (y[2:0] & {3{x}}) | (~y[2:0] & {3{(~x)}});
        Y[2] <= (y[2:0] & {3{x}}) | (~y[2:0] & {3{(~x)}});
    end
    
    assign Y0 = Y[0],
            z = Y[2];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(posedge clk) begin
        Y[0] <= (y[2:0] & {3{x}}) | (~y[2:0] & {3{(~x)}});
        Y[1] <= (y[2:0] & {3{x}}) | (~y[2:0] & {3{(~x)}});
        Y[2] <= (y[2:0] & {3{x}}) | (~y[2:0] & {3{(~x)}});
    end
    
    assign Y0 = Y[0],
            z = Y[2];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:	Y = 3'b000;
            4'b0001:	Y = 3'b001;
            4'b0010:	Y = 3'b001;
            4'b0011:	Y = 3'b100;
            4'b0100:	Y = 3'b010;
            4'b0101:	Y = 3'b001;
            4'b0110:	Y = 3'b001;
            4'b0111:	Y = 3'b010;
            4'b1000:	Y = 3'b011;
            4'b1001:	Y = 3'b001;
            4'b1010:	Y = 3'b001;
            4'b1011:	Y = 3'b011;
            4'b1100:	Y = 3'b100;
            4'b1101:	Y = 3'b001;
            4'b1110:	Y = 3'b001;
            4'b1111:	Y = 3'b011;
            default:	Y = 3'b111;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:	Y = 3'b000;
            4'b0001:	Y = 3'b001;
            4'b0010:	Y = 3'b001;
            4'b0011:	Y = 3'b100;
            4'b0100:	Y = 3'b010;
            4'b0101:	Y = 3'b001;
            4'b0110:	Y = 3'b001;
            4'b0111:	Y = 3'b010;
            4'b1000:	Y = 3'b011;
            4'b1001:	Y = 3'b001;
            4'b1010:	Y = 3'b001;
            4'b1011:	Y = 3'b011;
            4'b1100:	Y = 3'b100;
            4'b1101:	Y = 3'b001;
            4'b1110:	Y = 3'b001;
            4'b1111:	Y = 3'b011;
            default:	Y = 3'b111;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:	Y = 3'b000;
            4'b0001:	Y = 3'b001;
            4'b0010:	Y = 3'b001;
            4'b0011:	Y = 3'b100;
            4'b0100:	Y = 3'b010;
            4'b0101:	Y = 3'b001;
            4'b0110:	Y = 3'b001;
            4'b0111:	Y = 3'b010;
            4'b1000:	Y = 3'b011;
            4'b1001:	Y = 3'b001;
            4'b1010:	Y = 3'b001;
            4'b1011:	Y = 3'b010;
            4'b1100:	Y = 3'b011;
            4'b1101:	Y = 3'b001;
            4'b1110:	Y = 3'b001;
            4'b1111:	Y = 3'b010;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:	Y = 3'b000;
            4'b0001:	Y = 3'b001;
            4'b0010:	Y = 3'b001;
            4'b0011:	Y = 3'b100;
            4'b0100:	Y = 3'b010;
            4'b0101:	Y = 3'b001;
            4'b0110:	Y = 3'b001;
            4'b0111:	Y = 3'b010;
            4'b1000:	Y = 3'b011;
            4'b1001:	Y = 3'b001;
            4'b1010:	Y = 3'b001;
            4'b1011:	Y = 3'b010;
            4'b1100:	Y = 3'b011;
            4'b1101:	Y = 3'b001;
            4'b1110:	Y = 3'b001;
            4'b1111:	Y = 3'b010;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:	Y = 3'b000;
            4'b0001:	Y = 3'b001;
            4'b0010:	Y = 3'b001;
            4'b0011:	Y = 3'b100;
            4'b0100:	Y = 3'b010;
            4'b0101:	Y = 3'b001;
            4'b0110:	Y = 3'b001;
            4'b0111:	Y = 3'b010;
            4'b1000:	Y = 3'b011;
            4'b1001:	Y = 3'b001;
            4'b1010:	Y = 3'b001;
            4'b1011:	Y = 3'b011;
            4'b1100:	Y = 3'b100;
            4'b1101:	Y = 3'b001;
            4'b1110:	Y = 3'b001;
            4'b1111:	Y = 3'b011;
            default:	Y = 3'bxxx;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg	[2:0]	Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:	Y = 3'b000;
            4'b0001:	Y = 3'b001;
            4'b0010:	Y = 3'b001;
            4'b0011:	Y = 3'b100;
            4'b0100:	Y = 3'b010;
            4'b0101:	Y = 3'b001;
            4'b0110:	Y = 3'b001;
            4'b0111:	Y = 3'b010;
            4'b1000:	Y = 3'b011;
            4'b1001:	Y = 3'b001;
            4'b1010:	Y = 3'b001;
            4'b1011:	Y = 3'b011;
            4'b1100:	Y = 3'b100;
            4'b1101:	Y = 3'b001;
            4'b1110:	Y = 3'b001;
            4'b1111:	Y = 3'b011;
            default:	Y = 3'bxxx;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] | Y[3];
    
endmodule"
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg	[2:0]	Y;
    
    always@(posedge clk)
        Y <= y;
    
    assign	z = (y == 3'd3 & ~x) | (y == 3'd4 & x);
    assign	Y0 = Y[0]&Y[2]&~x | Y[1]&Y[2]&x;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg	[2:0]	Y;
    
    always@(posedge clk)
        Y <= y;
    
    assign	z = (y == 3'd3 & ~x) | (y == 3'd4 & x);
    assign	Y0 = Y[0]&Y[2]&~x | Y[1]&Y[2]&x;
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = a;
            {c, 1'b1}:	next_state = d;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = a;
            {c, 1'b1}:	next_state = d;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'd0, b=2'd1, c=2'd2, d=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'd0, b=2'd1, c=2'd2, d=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a = 0, b = 1, c = 2, d = 3, e = 4, f = 5;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = e;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = f;
            {e, 1'b0}:	next_state = d;
            {e, 1'b1}:	next_state = e;
            {f, 1'b0}:	next_state = d;
            {f, 1'b1}:	next_state = c;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == e || state == f);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a = 0, b = 1, c = 2, d = 3, e = 4, f = 5;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = e;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = f;
            {e, 1'b0}:	next_state = d;
            {e, 1'b1}:	next_state = e;
            {f, 1'b0}:	next_state = d;
            {f, 1'b1}:	next_state = c;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == e || state == f);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a = 2'b00, b = 2'b01, c = 2'b10, d = 2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = a;
            {c, 1'b1}:	next_state = d;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a = 2'b00, b = 2'b01, c = 2'b10, d = 2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = a;
            {c, 1'b1}:	next_state = d;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = a;
            {c, 1'b1}:	next_state = d;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = a;
            {c, 1'b1}:	next_state = d;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = b;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'b00, b=2'b01, c=2'b10, d=2'b11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'd0, b=2'd1, c=2'd2, d=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter a=2'd0, b=2'd1, c=2'd2, d=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, s})
            {a, 1'b0}:	next_state = a;
            {a, 1'b1}:	next_state = b;
            {b, 1'b0}:	next_state = d;
            {b, 1'b1}:	next_state = c;
            {c, 1'b0}:	next_state = d;
            {c, 1'b1}:	next_state = b;
            {d, 1'b0}:	next_state = a;
            {d, 1'b1}:	next_state = c;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= a;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == d);
    
endmodule"
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25, NONE=26, DONE=27;
    reg	[3:0]	state, next_state, old_w, old_s, next_s;
    
    // State transition logic
    always@(*) begin
        case({old_s, s})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = D;
            {C, 1'b1}:	next_state = B;
            {D, 1'b0}:	next_state = E;
            {D, 1'b1}:	next_state = B;
            {E, 1'b0}:	next_state = F;
            {E, 1'b1}:	next_state = B;
            {F, 1'b0}:	next_state = G;
            {F, 1'b1}:	next_state = B;
            {G, 1'b0}:	next_state = H;
            {G, 1'b1}:	next_state = B;
            {H, 1'b0}:	next_state = I;
            {H, 1'b1}:	next_state = B;
            {I, 1'b0}:	next_state = J;
            {I, 1'b1}:	next_state = B;
            {J, 1'b0}:	next_state = K;
            {J, 1'b1}:	next_state = B;
            {K, 1'b0}:	next_state = L;
            {K, 1'b1}:	next_state = B;
            {L, 1'b0}:	next_state = M;
            {L, 1'b1}:	next_state = B;
            {M, 1'b0}:	next_state = N;
            {M, 1'b1}:	next_state = B;
            {N, 1'b0}:	next_state = O;
            {N, 1'b1}:	next_state = B;
            {O, 1'b0}:	next_state = P;
            {O, 1'b1}:	next_state = B;
            {P, 1'b0}:	next_state = Q;
            {P, 1'b1}:	next_state = B;
            {Q, 1'b0}:	next_state = R;
            {Q, 1'b1}:	next_state = B;
            {R, 1'b0}:	next_state = S;
            {R, 1'b1}:	next_state = B;
            {S, 1'b0}:	next_state = T;
            {S, 1'b1}:	next_state = B;
            {T, 1'b0}:	next_state = U;
            {T, 1'b1}:	next_state = B;
            {U, 1'b0}:	next_state = V;
            {U, 1'b1}:	next_state = B;
            {V, 1'b0}:	next_state = W;
            {V, 1'b1}:	next_state = B;
            {W, 1'b0}:	next_state = X;
            {W, 1'b1}:	next_state = B;
            {X, 1'b0}:	next_state = Y;
            {X, 1'b1}:	next_state = B;
            {Y, 1'b0}:	next_state = Z;
            {Y, 1'b1}:	next_state = B;
            {",-1,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25, NONE=26, DONE=27;
    reg	[3:0]	state, next_state, old_w, old_s, next_s;
    
    // State transition logic
    always@(*) begin
        case({old_s, s})
            {A, 1'b0}:	next_state = A;
            {A, 1'b1}:	next_state = B;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = B;
            {C, 1'b0}:	next_state = D;
            {C, 1'b1}:	next_state = B;
            {D, 1'b0}:	next_state = E;
            {D, 1'b1}:	next_state = B;
            {E, 1'b0}:	next_state = F;
            {E, 1'b1}:	next_state = B;
            {F, 1'b0}:	next_state = G;
            {F, 1'b1}:	next_state = B;
            {G, 1'b0}:	next_state = H;
            {G, 1'b1}:	next_state = B;
            {H, 1'b0}:	next_state = I;
            {H, 1'b1}:	next_state = B;
            {I, 1'b0}:	next_state = J;
            {I, 1'b1}:	next_state = B;
            {J, 1'b0}:	next_state = K;
            {J, 1'b1}:	next_state = B;
            {K, 1'b0}:	next_state = L;
            {K, 1'b1}:	next_state = B;
            {L, 1'b0}:	next_state = M;
            {L, 1'b1}:	next_state = B;
            {M, 1'b0}:	next_state = N;
            {M, 1'b1}:	next_state = B;
            {N, 1'b0}:	next_state = O;
            {N, 1'b1}:	next_state = B;
            {O, 1'b0}:	next_state = P;
            {O, 1'b1}:	next_state = B;
            {P, 1'b0}:	next_state = Q;
            {P, 1'b1}:	next_state = B;
            {Q, 1'b0}:	next_state = R;
            {Q, 1'b1}:	next_state = B;
            {R, 1'b0}:	next_state = S;
            {R, 1'b1}:	next_state = B;
            {S, 1'b0}:	next_state = T;
            {S, 1'b1}:	next_state = B;
            {T, 1'b0}:	next_state = U;
            {T, 1'b1}:	next_state = B;
            {U, 1'b0}:	next_state = V;
            {U, 1'b1}:	next_state = B;
            {V, 1'b0}:	next_state = W;
            {V, 1'b1}:	next_state = B;
            {W, 1'b0}:	next_state = X;
            {W, 1'b1}:	next_state = B;
            {X, 1'b0}:	next_state = Y;
            {X, 1'b1}:	next_state = B;
            {Y, 1'b0}:	next_state = Z;
            {Y, 1'b1}:	next_state = B;
            {"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3
    
    // KEY[0] is the input signal x
    // KEY[1] is the input signal y
    // KEY[2] is the input signal z
    // KEY[3] is the input signal w
    
    // LEDR[3:0] are the outputs of the shift register
    
    shift_register_4bit register_4bit_top(
       .s0(SW[0]),
       .s1(SW[1]),
       .s2(SW[2]),
       .s3(SW[3]),
       .x(KEY[0]),
       .y(KEY[1]),
       .z(KEY[2]),
       .w(KEY[3]),
       .q(LEDR[3:0])
    );
    
endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3
    
    // KEY[0] is the input signal x
    // KEY[1] is the input signal y
    // KEY[2] is the input signal z
    // KEY[3] is the input signal w
    
    // LEDR[3:0] are the outputs of the shift register
    
    shift_register_4bit register_4bit_top(
       .s0(SW[0]),
       .s1(SW[1]),
       .s2(SW[2]),
       .s3(SW[3]),
       .x(KEY[0]),
       .y(KEY[1]),
       .z(KEY[2]),
       .w(KEY[3]),
       .q(LEDR[3:0])
    );
    
endmodule"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    // Use three wires to connect the submodules together:
    //   KEY[0] to SW[0]
    //   KEY[1] to SW[1]
    //   KEY[2] to SW[2]
    //   KEY[3] to SW[3]
    //   SW[0] to LEDR[0]
    //   SW[1] to LEDR[1]
    //   SW[2] to LEDR[2]
    //   SW[3] to LEDR[3]
    
    // Define the inputs and outputs.
    // Each of the following is a wire with a default value.
    // When the push button is pushed down, the value of the
    // corresponding input will be changed.
    // When the push button is released, the value of the
    // corresponding input will be set to its default value.
    // The value of the input can be accessed by using a
    // variable.
    //   input [3:0] in;
    //   input [3:0] out;
    //   out = in;
    
    // Define the instances of the submodules.
    // Each instance is created by using the 'new' operator.
    //   LEDR[0] = new_instance(LEDR[0]);
    //   LEDR[1] = new_instance(LEDR[1]);
    //   LEDR[2] = new_instance(LEDR[2]);
    //   LEDR[3] = new_instance(LEDR[3]);
    
    // Define the function for instantiating the submodules.
    // When the function is called, the value of the
    // corresponding input is passed to the submodules.
    //   function [3:0] new_instance(input [3:0] in);
    //     begin
    //         in = in + 1;
    //     end
    
    //   endfunction
    
    // Set the value of the LEDs to the value of the
    // corresponding input.
    //   always @(*)
    //     begin
    //         LEDR[0] = SW[0];
    //         LEDR[1] = SW[1];
    //         LEDR[2] = SW[2];
    //         LEDR[3] = SW[3];
    //     end
    
endmodule",-0.5,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    // Use three wires to connect the submodules together:
    //   KEY[0] to SW[0]
    //   KEY[1] to SW[1]
    //   KEY[2] to SW[2]
    //   KEY[3] to SW[3]
    //   SW[0] to LEDR[0]
    //   SW[1] to LEDR[1]
    //   SW[2] to LEDR[2]
    //   SW[3] to LEDR[3]
    
    // Define the inputs and outputs.
    // Each of the following is a wire with a default value.
    // When the push button is pushed down, the value of the
    // corresponding input will be changed.
    // When the push button is released, the value of the
    // corresponding input will be set to its default value.
    // The value of the input can be accessed by using a
    // variable.
    //   input [3:0] in;
    //   input [3:0] out;
    //   out = in;
    
    // Define the instances of the submodules.
    // Each instance is created by using the 'new' operator.
    //   LEDR[0] = new_instance(LEDR[0]);
    //   LEDR[1] = new_instance(LEDR[1]);
    //   LEDR[2] = new_instance(LEDR[2]);
    //   LEDR[3] = new_instance(LEDR[3]);
    
    // Define the function for instantiating the submodules.
    // When the function is called, the value of the
    // corresponding input is passed to the submodules.
    //   function [3:0] new_instance(input [3:0] in);
    //     begin
    //         in = in + 1;
    //     end
    
    //   endfunction
    
    // Set the value of the LEDs to the value of the
    // corresponding input.
    //   always @(*)
    //     begin
    //         LEDR[0] = SW[0];
    //         LEDR[1] = SW[1];
    //         LEDR[2] = SW[2];
    //         LEDR[3] = SW[3];
    //     end
    
endmodule"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    
    // instantiate four 1-bit full-adder (DFF) submodules
    // one for each of the R, S, and C inputs
    
    // R input is positive logic
    // S and C input are negative logic
    // C input is the output of the first 2-bit adder
    // R, S, and C are all input to the second 2-bit adder
    
    // set all outputs to 0
    // assign the output of the first adder to the output LEDR[0],
    // the output of the second adder to LEDR[1]
    
    // set all the negating inputs to be 0
    // so that the DFF outputs will be 1
    
    // set the first 2-bit adder's C input to be the output of the first 2-bit adder
    // set the second 2-bit adder's R input to be the result of the first 2-bit adder's S output
    // set the second 2-bit adder's C input to be the result of the first 2-bit adder's S output
    
    // in the final simulation, the adder outputs should look like:
    // R = 0, S = 0, C = 1
    // R = 0, S = 0, C = 0
    // R = 0, S = 1, C = 0
    // R = 0, S = 1, C = 1
    // R = 1, S = 0, C = 0
    // R = 1, S = 0, C = 1
    // R = 1, S = 1, C = 0
    // R = 1, S = 1, C = 1

// Define a module for the adder, ADDER1.
// Define a module for the 2-bit adder, ADDER2.
// Define a module for the 4-bit adder, ADDER4.
// Define a module for the 8-bit adder, ADDER8.
// Define a module for the 16-bit adder, ADDER16.
// Define a module for the 32-bit adder, ADDER32.
// Define a module for the 4-bit adder with carry, ADDER4c.
// Define a module for the 8-bit adder with carry, ADDER8c.
// Define a module for the 16-bit adder with carry, ADDER16c.
// Define a module for the 32-bit adder with carry, ADDER32c.
// Define a module for the 4-bit adder with carry and ripple, ADDER4r.
// Define a module for the 8-bit adder with carry and ripple, ADDER8r.
// Define a module for the 16-bit adder with carry and ripple, ADDER16r.
// Define a module for the 32-bit adder with carry and ripple, ADDER32r.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rr.
// Define a module for the 16-bit adder with carry and ripple and ripple, ADDER16rr.
// Define a module for the 32-bit adder with carry and ripple and ripple, ADDER32rr.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rrr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rrr.
// Define a module for the 16-bit adder with carry and ripple and ripple, ADDER16rrr.
// Define a module for the 32-bit adder with carry and ripple and ripple, ADDER32rrr.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rrrr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rrrr.
// Define a module for the 16-bit adder with carry and ripple and ripple, ADDER16rrrr.
// Define a module for the 32-bit adder with carry and ripple and ripple, ADDER32rrrr.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rrrrr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rrrrr.
//",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    
    // instantiate four 1-bit full-adder (DFF) submodules
    // one for each of the R, S, and C inputs
    
    // R input is positive logic
    // S and C input are negative logic
    // C input is the output of the first 2-bit adder
    // R, S, and C are all input to the second 2-bit adder
    
    // set all outputs to 0
    // assign the output of the first adder to the output LEDR[0],
    // the output of the second adder to LEDR[1]
    
    // set all the negating inputs to be 0
    // so that the DFF outputs will be 1
    
    // set the first 2-bit adder's C input to be the output of the first 2-bit adder
    // set the second 2-bit adder's R input to be the result of the first 2-bit adder's S output
    // set the second 2-bit adder's C input to be the result of the first 2-bit adder's S output
    
    // in the final simulation, the adder outputs should look like:
    // R = 0, S = 0, C = 1
    // R = 0, S = 0, C = 0
    // R = 0, S = 1, C = 0
    // R = 0, S = 1, C = 1
    // R = 1, S = 0, C = 0
    // R = 1, S = 0, C = 1
    // R = 1, S = 1, C = 0
    // R = 1, S = 1, C = 1

// Define a module for the adder, ADDER1.
// Define a module for the 2-bit adder, ADDER2.
// Define a module for the 4-bit adder, ADDER4.
// Define a module for the 8-bit adder, ADDER8.
// Define a module for the 16-bit adder, ADDER16.
// Define a module for the 32-bit adder, ADDER32.
// Define a module for the 4-bit adder with carry, ADDER4c.
// Define a module for the 8-bit adder with carry, ADDER8c.
// Define a module for the 16-bit adder with carry, ADDER16c.
// Define a module for the 32-bit adder with carry, ADDER32c.
// Define a module for the 4-bit adder with carry and ripple, ADDER4r.
// Define a module for the 8-bit adder with carry and ripple, ADDER8r.
// Define a module for the 16-bit adder with carry and ripple, ADDER16r.
// Define a module for the 32-bit adder with carry and ripple, ADDER32r.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rr.
// Define a module for the 16-bit adder with carry and ripple and ripple, ADDER16rr.
// Define a module for the 32-bit adder with carry and ripple and ripple, ADDER32rr.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rrr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rrr.
// Define a module for the 16-bit adder with carry and ripple and ripple, ADDER16rrr.
// Define a module for the 32-bit adder with carry and ripple and ripple, ADDER32rrr.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rrrr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rrrr.
// Define a module for the 16-bit adder with carry and ripple and ripple, ADDER16rrrr.
// Define a module for the 32-bit adder with carry and ripple and ripple, ADDER32rrrr.
// Define a module for the 4-bit adder with carry and ripple and ripple, ADDER4rrrrr.
// Define a module for the 8-bit adder with carry and ripple and ripple, ADDER8rrrrr.
//"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Use the FSM and state_table to implement the state machine below.
    // Once the state_table is set up, it can be used by the state_FFs.
    // The state_FFs are combinational logic, which can be synthesized
    // by the program, and can be parameterized.
    //
    // In this problem, a procedural (or combinational) always block
    // is used to implement the state_table.
    //
    // When the clock toggles, the value of the counter is reset to 0.
    // When the resetn (KEY[0]) is asserted, the value of the counter
    // is set to 0.
    //
    // The value of the counter is incremented when the clock toggles.
    // When it is 10, the counter value is set to 0.
    //
    // The counter is set to the value of the counter when the
    // counter reaches 9, and the clock toggles.
    //
    // When the counter is 9, the state_FFs are asserted.
    // When the counter is 10, the state_FFs are de-asserted.
    //
    // The value of the counter is incremented when the counter
    // reaches 9, and the clock toggles.
    //
    // When the counter is 9, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 0.
    //
    // When the counter is 0, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 10.
    //
    // The counter is set to the value of the counter when the
    // counter reaches 9, and the clock toggles.
    //
    // When the counter is 9, and the resetn (KEY[0]) is asserted,
    // the state_FFs are de-asserted.
    //
    // When the counter is 10, and the resetn (KEY[0]) is asserted,
    // the state_FFs are asserted.
    //
    // The value of the counter is incremented when the counter
    // reaches 9, and the clock toggles.
    //
    // When the counter is 9, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 0.
    //
    // When the counter is 0, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 10.
    
    reg [3:0] state;
    reg [3:0] next_state;
    reg [3:0] counter;
    reg [3:0] next_counter;
    reg [7:0] a;
    reg [7:0] b;
    reg [7:0] c;
    reg [7:0] d;
    reg [7:0] e;
    reg [7:0] f;
    reg [7:0] g;
    reg [7:0] h;
    reg [3:0] w;
    reg [3:0] next_w;
    reg [2:0] x;
    reg [2:0] next_x;
    reg [2:0] y;
    reg [2:0] next_y;
    reg [2:0] z;
    reg [2:0] next_z;
    reg [2:0] n;
    reg [2:0] next_n;
    reg start_timer;
    reg start_play_timer;
    reg start_recorder;
    reg start_game_title;
    reg start_game_start;
    reg start_vga_counters;
    reg start_vga_game;
    reg start_vga_counters_game;
    reg start_vga_title;
    reg start_vga_game_start;
    reg start_vga_counters_game_start;
    reg game_over_done;
    reg [2:0] next_card_data_output;
    reg [2:0] next_card_data_output_reg;
    reg next_card_data_done;
    reg next_card_data_done_reg;
    reg [2:0] next_card_pixels;
    reg [2:0] next_card_pixels_reg;
    reg next_card_done;
    reg next_",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Use the FSM and state_table to implement the state machine below.
    // Once the state_table is set up, it can be used by the state_FFs.
    // The state_FFs are combinational logic, which can be synthesized
    // by the program, and can be parameterized.
    //
    // In this problem, a procedural (or combinational) always block
    // is used to implement the state_table.
    //
    // When the clock toggles, the value of the counter is reset to 0.
    // When the resetn (KEY[0]) is asserted, the value of the counter
    // is set to 0.
    //
    // The value of the counter is incremented when the clock toggles.
    // When it is 10, the counter value is set to 0.
    //
    // The counter is set to the value of the counter when the
    // counter reaches 9, and the clock toggles.
    //
    // When the counter is 9, the state_FFs are asserted.
    // When the counter is 10, the state_FFs are de-asserted.
    //
    // The value of the counter is incremented when the counter
    // reaches 9, and the clock toggles.
    //
    // When the counter is 9, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 0.
    //
    // When the counter is 0, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 10.
    //
    // The counter is set to the value of the counter when the
    // counter reaches 9, and the clock toggles.
    //
    // When the counter is 9, and the resetn (KEY[0]) is asserted,
    // the state_FFs are de-asserted.
    //
    // When the counter is 10, and the resetn (KEY[0]) is asserted,
    // the state_FFs are asserted.
    //
    // The value of the counter is incremented when the counter
    // reaches 9, and the clock toggles.
    //
    // When the counter is 9, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 0.
    //
    // When the counter is 0, and the resetn (KEY[0]) is asserted,
    // the counter value is set to 10.
    
    reg [3:0] state;
    reg [3:0] next_state;
    reg [3:0] counter;
    reg [3:0] next_counter;
    reg [7:0] a;
    reg [7:0] b;
    reg [7:0] c;
    reg [7:0] d;
    reg [7:0] e;
    reg [7:0] f;
    reg [7:0] g;
    reg [7:0] h;
    reg [3:0] w;
    reg [3:0] next_w;
    reg [2:0] x;
    reg [2:0] next_x;
    reg [2:0] y;
    reg [2:0] next_y;
    reg [2:0] z;
    reg [2:0] next_z;
    reg [2:0] n;
    reg [2:0] next_n;
    reg start_timer;
    reg start_play_timer;
    reg start_recorder;
    reg start_game_title;
    reg start_game_start;
    reg start_vga_counters;
    reg start_vga_game;
    reg start_vga_counters_game;
    reg start_vga_title;
    reg start_vga_game_start;
    reg start_vga_counters_game_start;
    reg game_over_done;
    reg [2:0] next_card_data_output;
    reg [2:0] next_card_data_output_reg;
    reg next_card_data_done;
    reg next_card_data_done_reg;
    reg [2:0] next_card_pixels;
    reg [2:0] next_card_pixels_reg;
    reg next_card_done;
    reg next_"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Use the FSM named state_table to initialize
    // three of the registers in the shift_register 
    // module. You can use other finite state machines.
    // You may need to add additional ports to the 
    // shift_register module.
    
    // You can use the module in the FSM style shown in
    // the state_table.
    
    // You can use the module in the FSM style or
    // in the procedural block style.
    
    // You may need to add additional ports to the
    // muxdff_8x8 module.
    
    // Declare the register that will store the current
    // state input.
    reg [3:0] state;
    
    // Declare the register that will store the input
    // to be shifted through the shift register.
    reg [3:0] in;
    
    // Declare the register that will store the input
    // to be compared in the mux.
    reg [3:0] comp_in;
    
    // Declare the register that will store the
    // value of the input to be compared.
    reg [3:0] comp_val;
    
    // Declare the register that will store the
    // value of the input to be shifted.
    reg [3:0] val;
    
    // Declare the register that will store the
    // value of the input to be stored.
    reg [3:0] store_val;
    
    // Declare a 3-bit register that will be used to
    // store the input to be stored.
    reg [3:0] store_and_load_addr;
    
    // Declare a 2-bit register that will be used to
    // store the input to be loaded.
    reg [1:0] store_and_load_sel;
    
    // Declare a register that will be used to
    // store the input to be stored.
    reg store_enable;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_comp;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_shift;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux2;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux3;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux4;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux5;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux6;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux7;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux8;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux9;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux10;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux11;
    
    // Declare a register that will be used to
    // load the stored value.",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Use the FSM named state_table to initialize
    // three of the registers in the shift_register 
    // module. You can use other finite state machines.
    // You may need to add additional ports to the 
    // shift_register module.
    
    // You can use the module in the FSM style shown in
    // the state_table.
    
    // You can use the module in the FSM style or
    // in the procedural block style.
    
    // You may need to add additional ports to the
    // muxdff_8x8 module.
    
    // Declare the register that will store the current
    // state input.
    reg [3:0] state;
    
    // Declare the register that will store the input
    // to be shifted through the shift register.
    reg [3:0] in;
    
    // Declare the register that will store the input
    // to be compared in the mux.
    reg [3:0] comp_in;
    
    // Declare the register that will store the
    // value of the input to be compared.
    reg [3:0] comp_val;
    
    // Declare the register that will store the
    // value of the input to be shifted.
    reg [3:0] val;
    
    // Declare the register that will store the
    // value of the input to be stored.
    reg [3:0] store_val;
    
    // Declare a 3-bit register that will be used to
    // store the input to be stored.
    reg [3:0] store_and_load_addr;
    
    // Declare a 2-bit register that will be used to
    // store the input to be loaded.
    reg [1:0] store_and_load_sel;
    
    // Declare a register that will be used to
    // store the input to be stored.
    reg store_enable;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_comp;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_shift;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux2;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux3;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux4;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux5;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux6;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux7;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux8;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux9;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux10;
    
    // Declare a register that will be used to
    // load the stored value.
    reg load_val_store_num_mux11;
    
    // Declare a register that will be used to
    // load the stored value."
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3

    // KEY[0] is the input signal to s0
    // KEY[1] is the input signal to s1
    // KEY[2] is the input signal to s2
    // KEY[3] is the input signal to s3

    // Instantiate four instances of my_dff8, with different inputs
    // depending on the value of the control signals.
    // Connect the reset (KEY[0]) outputs to the my_dff8s RESET inputs.
    // Connect the clock (KEY[3]) outputs to the my_dff8s CLOCK_IN inputs.
    // Connect the data (SW[3:0]) outputs to the my_dff8s D input ports.
    // Connect the data (SW[3:0]) inputs to the my_dff8s Q input ports.
    // The LEDR[3:0] output is connected to the HEX0 display on the DE2-115 board.
    
    my_dff8 d0 (SW[0], KEY[0], CLOCK_50, LEDR[0], Q0);
    my_dff8 d1 (SW[1], KEY[1], CLOCK_50, LEDR[1], Q1);
    my_dff8 d2 (SW[2], KEY[2], CLOCK_50, LEDR[2], Q2);
    my_dff8 d3 (SW[3], KEY[3], CLOCK_50, LEDR[3], Q3);

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3

    // KEY[0] is the input signal to s0
    // KEY[1] is the input signal to s1
    // KEY[2] is the input signal to s2
    // KEY[3] is the input signal to s3

    // Instantiate four instances of my_dff8, with different inputs
    // depending on the value of the control signals.
    // Connect the reset (KEY[0]) outputs to the my_dff8s RESET inputs.
    // Connect the clock (KEY[3]) outputs to the my_dff8s CLOCK_IN inputs.
    // Connect the data (SW[3:0]) outputs to the my_dff8s D input ports.
    // Connect the data (SW[3:0]) inputs to the my_dff8s Q input ports.
    // The LEDR[3:0] output is connected to the HEX0 display on the DE2-115 board.
    
    my_dff8 d0 (SW[0], KEY[0], CLOCK_50, LEDR[0], Q0);
    my_dff8 d1 (SW[1], KEY[1], CLOCK_50, LEDR[1], Q1);
    my_dff8 d2 (SW[2], KEY[2], CLOCK_50, LEDR[2], Q2);
    my_dff8 d3 (SW[3], KEY[3], CLOCK_50, LEDR[3], Q3);

endmodule"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3
    
    // KEY[0] is the input signal x
    // KEY[1] is the input signal y
    // KEY[2] is the input signal z
    // KEY[3] is the input signal x
    
    // LEDR[0] is the output signal s0
    // LEDR[1] is the output signal s1
    // LEDR[2] is the output signal s2
    // LEDR[3] is the output signal s3
    
    // Instantiating four 1-bit full adders in Verilog
    //...

endmodule",-0.5,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3
    
    // KEY[0] is the input signal x
    // KEY[1] is the input signal y
    // KEY[2] is the input signal z
    // KEY[3] is the input signal x
    
    // LEDR[0] is the output signal s0
    // LEDR[1] is the output signal s1
    // LEDR[2] is the output signal s2
    // LEDR[3] is the output signal s3
    
    // Instantiating four 1-bit full adders in Verilog
    //...

endmodule"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3
    
    // KEY[0] is the input signal to s0
    // KEY[1] is the input signal to s1
    // KEY[2] is the input signal to s2
    // KEY[3] is the input signal to s3
    
    // LEDR[0] is the output of s0
    // LEDR[1] is the output of s1
    // LEDR[2] is the output of s2
    // LEDR[3] is the output of s3
    
    // Instantiate four instances of my_dff8s, with different inputs and outputs
    // Each instance is given a unique name (my_dff8_1, my_dff8_2, etc)
    // Connect ports by name: (output port on my_dff8_1 is connected to input port on my_dff8_2)
    
    my_dff8 d1 (SW[0], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[0]);
    my_dff8 d2 (SW[1], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[1]);
    my_dff8 d3 (SW[2], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[2]);
    my_dff8 d4 (SW[3], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[3]);
    
endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // SW[0] is the control signal s0
    // SW[1] is the control signal s1
    // SW[2] is the control signal s2
    // SW[3] is the control signal s3
    
    // KEY[0] is the input signal to s0
    // KEY[1] is the input signal to s1
    // KEY[2] is the input signal to s2
    // KEY[3] is the input signal to s3
    
    // LEDR[0] is the output of s0
    // LEDR[1] is the output of s1
    // LEDR[2] is the output of s2
    // LEDR[3] is the output of s3
    
    // Instantiate four instances of my_dff8s, with different inputs and outputs
    // Each instance is given a unique name (my_dff8_1, my_dff8_2, etc)
    // Connect ports by name: (output port on my_dff8_1 is connected to input port on my_dff8_2)
    
    my_dff8 d1 (SW[0], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[0]);
    my_dff8 d2 (SW[1], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[1]);
    my_dff8 d3 (SW[2], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[2]);
    my_dff8 d4 (SW[3], ~KEY[0], ~KEY[3], ~KEY[1], ~KEY[2], LEDR[3]);
    
endmodule"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    // instantiate four 1-bit full adders in Verilog
    // and connect the adders to the
    // three-bit switches
    
    wire [3:0] A, B;
    wire [2:0] C;
    
    assign A = SW[3:0];
    assign B = SW[7:4];
    assign C[0] = KEY[0];
    assign C[1] = KEY[1];
    assign C[2] = KEY[2];
    
    full_adder_1bit f0 (A[0], B[0], C[0], LEDR[0], c0);
    full_adder_1bit f1 (A[1], B[1], c0, LEDR[1], c1);
    full_adder_1bit f2 (A[2], B[2], c1, LEDR[2], c2);
    full_adder_1bit f3 (A[3], B[3], c2, LEDR[3], LEDR[7]);
    
endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    // instantiate four 1-bit full adders in Verilog
    // and connect the adders to the
    // three-bit switches
    
    wire [3:0] A, B;
    wire [2:0] C;
    
    assign A = SW[3:0];
    assign B = SW[7:4];
    assign C[0] = KEY[0];
    assign C[1] = KEY[1];
    assign C[2] = KEY[2];
    
    full_adder_1bit f0 (A[0], B[0], C[0], LEDR[0], c0);
    full_adder_1bit f1 (A[1], B[1], c0, LEDR[1], c1);
    full_adder_1bit f2 (A[2], B[2], c1, LEDR[2], c2);
    full_adder_1bit f3 (A[3], B[3], c2, LEDR[3], LEDR[7]);
    
endmodule"
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    
    //
    // 
    //
    
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    //",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    
    //
    // 
    //
    
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    // 
    //"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-to-1 mux
    mux_8_to_1 inst1(.A(A),.B(B),.C(C),.D(4'b0000),.E(4'b0000),.F(4'b0000),.G(4'b0000),.H(4'b0000),.I(4'b0000),.J(4'b0000),.K(4'b0000),.L(4'b0000),.M(4'b0000),.N(4'b0000),.O(4'b0000),.P(4'b0000),.S(S),.Z(sel[0]));
    
    // Create a 3-to-1 mux
    mux_3_to_1 inst2(.A(sel[0]),.B(sel[1]),.C(sel[2]),.D(sel[3]),.Y(sel[3]));
    
    // Create a 4-to-1 mux
    mux_4_to_1 inst3(.A(sel[0]),.B(sel[1]),.C(sel[2]),.D(sel[3]),.Y(sel[4]));
    
    // Create a 2-to-1 mux
    mux_2_to_1 inst4(.A(sel[0]),.B(sel[1]),.Y(sel[2]));
    
    // Create a 1-to-1 mux
    mux_1_to_1 inst5(.A(sel[0]),.B(sel[1]),.Y(sel[1]));
    
    // Create a 8-to-1 mux
    mux_8_to_1 inst6(.A(A),.B(B),.C(C),.D(4'b0000),.E(4'b0000),.F(4'b0000),.G(4'b0000),.H(4'b0000),.I(4'b0000),.J(4'b0000),.K(4'b0000),.L(4'b0000),.M(4'b0000),.N(4'b0000),.O(4'b0000),.P(4'b0000),.S(S),.Z(Z));
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-to-1 mux
    mux_8_to_1 inst1(.A(A),.B(B),.C(C),.D(4'b0000),.E(4'b0000),.F(4'b0000),.G(4'b0000),.H(4'b0000),.I(4'b0000),.J(4'b0000),.K(4'b0000),.L(4'b0000),.M(4'b0000),.N(4'b0000),.O(4'b0000),.P(4'b0000),.S(S),.Z(sel[0]));
    
    // Create a 3-to-1 mux
    mux_3_to_1 inst2(.A(sel[0]),.B(sel[1]),.C(sel[2]),.D(sel[3]),.Y(sel[3]));
    
    // Create a 4-to-1 mux
    mux_4_to_1 inst3(.A(sel[0]),.B(sel[1]),.C(sel[2]),.D(sel[3]),.Y(sel[4]));
    
    // Create a 2-to-1 mux
    mux_2_to_1 inst4(.A(sel[0]),.B(sel[1]),.Y(sel[2]));
    
    // Create a 1-to-1 mux
    mux_1_to_1 inst5(.A(sel[0]),.B(sel[1]),.Y(sel[1]));
    
    // Create a 8-to-1 mux
    mux_8_to_1 inst6(.A(A),.B(B),.C(C),.D(4'b0000),.E(4'b0000),.F(4'b0000),.G(4'b0000),.H(4'b0000),.I(4'b0000),.J(4'b0000),.K(4'b0000),.L(4'b0000),.M(4'b0000),.N(4'b0000),.O(4'b0000),.P(4'b0000),.S(S),.Z(Z));
    
endmodule"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-bit shift register with 8 D-type flip-flops.
    //   Create a 3-input mux with a 3-input logic function (3-1 mux)
    //   Create a 3-input mux with a 3-input logic function (3-1 mux)
    
    //   The register should have a clock, a reset, and an enable.",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-bit shift register with 8 D-type flip-flops.
    //   Create a 3-input mux with a 3-input logic function (3-1 mux)
    //   Create a 3-input mux with a 3-input logic function (3-1 mux)
    
    //   The register should have a clock, a reset, and an enable."
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Instantiate a 8-to-1 mux
    mux_8_to_1 inst_mux_8_to_1(.A(A),.B(B),.C(C),.D(4'h0),.sel(sel[2:0]),.Y(Q[7]));
    
    // Instantiating a 8-bit register with initial value of 8'h00
    register_8bit register_8bit_0(.clk(clk),.reset(1'b0),.D(Q[0]),.Q(Q[7:1]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_1(.clk(clk),.reset(1'b0),.D(Q[1]),.Q(Q[7:2]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_2(.clk(clk),.reset(1'b0),.D(Q[2]),.Q(Q[7:3]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_3(.clk(clk),.reset(1'b0),.D(Q[3]),.Q(Q[7:4]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_4(.clk(clk),.reset(1'b0),.D(Q[4]),.Q(Q[7:5]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_5(.clk(clk),.reset(1'b0),.D(Q[5]),.Q(Q[7:6]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_6(.clk(clk),.reset(1'b0),.D(Q[6]),.Q(Q[7:7]));
    
    // The value of the other register is the input from register_8bit_0
    assign sel[0] = S;
    assign sel[1] = Q[0];
    assign sel[2] = Q[1];
    
    // The value of the other register is the input from register_8bit_1
    assign sel[3] = Q[2];
    assign sel[4] = Q[3];
    assign sel[5] = Q[4];
    assign sel[6] = Q[5];
    assign sel[7] = Q[6];
    
    // The value of the other register is the input from register_8bit_2
    assign sel[8] = Q[7];
    assign sel[9] = Q[8];
    assign sel[10] = Q[9];
    assign sel[11] = Q[10];
    assign sel[12] = Q[11];
    assign sel[13] = Q[12];
    assign sel[14] = Q[13];
    assign sel[15] = Q[14];
    assign sel[16] = Q[15];
    
    // The value of the other register is the input from register_8bit_3
    assign sel[17] = Q[16];
    assign sel[18] = Q[17];
    assign sel[19] = Q[18];
    assign sel[20] = Q[19];
    assign sel[21] = Q[20];
    assign sel[22] = Q[21];
    assign sel[23] = Q[22];
    assign sel[24] = Q[23];
    assign sel[25] = Q[24];
    assign sel[26] = Q[25];
    assign sel[27] = Q[26];
    assign sel[28] = Q[27];
    assign sel[29] = Q[28];",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Instantiate a 8-to-1 mux
    mux_8_to_1 inst_mux_8_to_1(.A(A),.B(B),.C(C),.D(4'h0),.sel(sel[2:0]),.Y(Q[7]));
    
    // Instantiating a 8-bit register with initial value of 8'h00
    register_8bit register_8bit_0(.clk(clk),.reset(1'b0),.D(Q[0]),.Q(Q[7:1]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_1(.clk(clk),.reset(1'b0),.D(Q[1]),.Q(Q[7:2]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_2(.clk(clk),.reset(1'b0),.D(Q[2]),.Q(Q[7:3]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_3(.clk(clk),.reset(1'b0),.D(Q[3]),.Q(Q[7:4]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_4(.clk(clk),.reset(1'b0),.D(Q[4]),.Q(Q[7:5]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_5(.clk(clk),.reset(1'b0),.D(Q[5]),.Q(Q[7:6]));
    
    // For the other register, use the same mechanism
    register_8bit register_8bit_6(.clk(clk),.reset(1'b0),.D(Q[6]),.Q(Q[7:7]));
    
    // The value of the other register is the input from register_8bit_0
    assign sel[0] = S;
    assign sel[1] = Q[0];
    assign sel[2] = Q[1];
    
    // The value of the other register is the input from register_8bit_1
    assign sel[3] = Q[2];
    assign sel[4] = Q[3];
    assign sel[5] = Q[4];
    assign sel[6] = Q[5];
    assign sel[7] = Q[6];
    
    // The value of the other register is the input from register_8bit_2
    assign sel[8] = Q[7];
    assign sel[9] = Q[8];
    assign sel[10] = Q[9];
    assign sel[11] = Q[10];
    assign sel[12] = Q[11];
    assign sel[13] = Q[12];
    assign sel[14] = Q[13];
    assign sel[15] = Q[14];
    assign sel[16] = Q[15];
    
    // The value of the other register is the input from register_8bit_3
    assign sel[17] = Q[16];
    assign sel[18] = Q[17];
    assign sel[19] = Q[18];
    assign sel[20] = Q[19];
    assign sel[21] = Q[20];
    assign sel[22] = Q[21];
    assign sel[23] = Q[22];
    assign sel[24] = Q[23];
    assign sel[25] = Q[24];
    assign sel[26] = Q[25];
    assign sel[27] = Q[26];
    assign sel[28] = Q[27];
    assign sel[29] = Q[28];"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-entry 3-input LUT
    //   input clk,
    //   input [2:0] S,
    //   input [7:0] A,
    //   input [7:0] B,
    //   output reg [7:0] Z
    //   
    //   reg [7:0] LUT [0:7];
    //   
    //   always @(posedge clk)
    //   begin
    //       if (S == 3'b000)
    //           LUT[0] <= A + B;
    //       else if (S == 3'b001)
    //           LUT[0] <= A - B;
    //       else if (S == 3'b010)
    //           LUT[0] <= A & B;
    //       else if (S == 3'b011)
    //           LUT[0] <= A | B;
    //       else if (S == 3'b100)
    //           LUT[0] <= A ^ B;
    //       else
    //           LUT[0] <= 8'b0;
    //   end
    
    //   always @(*)
    //   begin
    //       case (S)
    //           3'b000:  Z = LUT[0];
    //           3'b001:  Z = LUT[1];
    //           3'b010:  Z = LUT[2];
    //           3'b011:  Z = LUT[3];
    //           3'b100:  Z = LUT[4];
    //           3'b101:  Z = LUT[5];
    //           3'b110:  Z = LUT[6];
    //           3'b111:  Z = LUT[7];
    //           default: Z = 8'b0;
    //       endcase
    //   end
    
endmodule",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-entry 3-input LUT
    //   input clk,
    //   input [2:0] S,
    //   input [7:0] A,
    //   input [7:0] B,
    //   output reg [7:0] Z
    //   
    //   reg [7:0] LUT [0:7];
    //   
    //   always @(posedge clk)
    //   begin
    //       if (S == 3'b000)
    //           LUT[0] <= A + B;
    //       else if (S == 3'b001)
    //           LUT[0] <= A - B;
    //       else if (S == 3'b010)
    //           LUT[0] <= A & B;
    //       else if (S == 3'b011)
    //           LUT[0] <= A | B;
    //       else if (S == 3'b100)
    //           LUT[0] <= A ^ B;
    //       else
    //           LUT[0] <= 8'b0;
    //   end
    
    //   always @(*)
    //   begin
    //       case (S)
    //           3'b000:  Z = LUT[0];
    //           3'b001:  Z = LUT[1];
    //           3'b010:  Z = LUT[2];
    //           3'b011:  Z = LUT[3];
    //           3'b100:  Z = LUT[4];
    //           3'b101:  Z = LUT[5];
    //           3'b110:  Z = LUT[6];
    //           3'b111:  Z = LUT[7];
    //           default: Z = 8'b0;
    //       endcase
    //   end
    
endmodule"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // If the MSB of the input is a one, interpret the input value as a negative number.
    assign sel[0] = (A[7] == 1'b1)? 1'b1 : 1'b0;
    assign sel[1] = (B[7] == 1'b1)? 1'b1 : 1'b0;
    assign sel[2] = (C[7] == 1'b1)? 1'b1 : 1'b0;
    
    // shift left: {A,Q} = {S,Q} << 1
    // {A,Q} = {S,Q} * 2
    // {S,Q} = {A,Q} >> 1
    // {S,Q} = {A,Q} * 2
    assign sel[3] = {A,Q} = {S,Q} * 2;
    assign sel[4] = {S,Q} = {A,Q} >> 1;
    assign sel[5] = {S,Q} = {A,Q} * 2;
    assign sel[6] = {A,Q} = {S,Q} * 2;
    
    // The input value is interpreted as a negative number, but the output is a positive number.
    // This is correct, and the output is {S,Q} = {A,Q} * 2.
    assign sel[7] = (A[7] == 1'b1)? 1'b0 : 1'b1;
    
    // Multiplexer selects.
    // {S,A,Q} = {A,Q} * {S,Q}
    // {S,A,Q} = {A,Q} * {S,Q} * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2 * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2 * 2 * 2 * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // If the MSB of the input is a one, interpret the input value as a negative number.
    assign sel[0] = (A[7] == 1'b1)? 1'b1 : 1'b0;
    assign sel[1] = (B[7] == 1'b1)? 1'b1 : 1'b0;
    assign sel[2] = (C[7] == 1'b1)? 1'b1 : 1'b0;
    
    // shift left: {A,Q} = {S,Q} << 1
    // {A,Q} = {S,Q} * 2
    // {S,Q} = {A,Q} >> 1
    // {S,Q} = {A,Q} * 2
    assign sel[3] = {A,Q} = {S,Q} * 2;
    assign sel[4] = {S,Q} = {A,Q} >> 1;
    assign sel[5] = {S,Q} = {A,Q} * 2;
    assign sel[6] = {A,Q} = {S,Q} * 2;
    
    // The input value is interpreted as a negative number, but the output is a positive number.
    // This is correct, and the output is {S,Q} = {A,Q} * 2.
    assign sel[7] = (A[7] == 1'b1)? 1'b0 : 1'b1;
    
    // Multiplexer selects.
    // {S,A,Q} = {A,Q} * {S,Q}
    // {S,A,Q} = {A,Q} * {S,Q} * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2 * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2 * 2 * 2 * 2
    // {S,A,Q} = {A,Q} * {S,Q} * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign sel[0] = enable && S && Q[0];
    // assign sel[1] = enable && S && Q[1];
    // assign sel[2] = enable && S && Q[2];
    
    assign sel[0] = enable && S;
    assign sel[1] = enable;
    assign sel[2] = enable;
    
    // 2-input mux
    mux2to1 m1(Q[0], Q[1], sel[0], Z);
    mux2to1 m2(Q[2], Q[3], sel[0], Z);
    mux2to1 m3(Q[4], Q[5], sel[0], Z);
    mux2to1 m4(Q[6], Q[7], sel[0], Z);
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign sel[0] = enable && S && Q[0];
    // assign sel[1] = enable && S && Q[1];
    // assign sel[2] = enable && S && Q[2];
    
    assign sel[0] = enable && S;
    assign sel[1] = enable;
    assign sel[2] = enable;
    
    // 2-input mux
    mux2to1 m1(Q[0], Q[1], sel[0], Z);
    mux2to1 m2(Q[2], Q[3], sel[0], Z);
    mux2to1 m3(Q[4], Q[5], sel[0], Z);
    mux2to1 m4(Q[6], Q[7], sel[0], Z);
    
endmodule"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-entry 3-entry LUT
    //   Inputs are asserted one-by-one, in the order given above
    //   Output is asserted only when ALL input are asserted
    
    // LUT entry 0
    assign sel[0] = ~A & ~B & ~C;
    assign Q[0] = {S,Q[7:1]};
    
    // LUT entry 1
    assign sel[1] = ~A & ~B & C;
    assign Q[1] = {S,Q[7:1]};
    
    // LUT entry 2
    assign sel[2] = ~A & B & ~C;
    assign Q[2] = {S,Q[7:1]};
    
    // LUT entry 3
    assign sel[3] = ~A & B & C;
    assign Q[3] = {S,Q[7:1]};
    
    // LUT entry 4
    assign sel[4] = A & ~B & ~C;
    assign Q[4] = {Q[0][7:1],S};
    
    // LUT entry 5
    assign sel[5] = A & ~B & C;
    assign Q[5] = {Q[1][7:1],S};
    
    // LUT entry 6
    assign sel[6] = A & B & ~C;
    assign Q[6] = {Q[2][7:1],S};
    
    // LUT entry 7
    assign sel[7] = A & B & C;
    assign Q[7] = {Q[3][7:1],S};
    
    
    // MUX stage 1
    assign Z[0] = sel[0]? Q[0] : 8'b00000000;
    
    // MUX stage 2
    generate
        for (k = 1; k < 8; k = k + 1) begin : S2
            assign Z[k] = sel[1]? Q[k] : Z[k-1];
        end
    endgenerate
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // Create a 8-entry 3-entry LUT
    //   Inputs are asserted one-by-one, in the order given above
    //   Output is asserted only when ALL input are asserted
    
    // LUT entry 0
    assign sel[0] = ~A & ~B & ~C;
    assign Q[0] = {S,Q[7:1]};
    
    // LUT entry 1
    assign sel[1] = ~A & ~B & C;
    assign Q[1] = {S,Q[7:1]};
    
    // LUT entry 2
    assign sel[2] = ~A & B & ~C;
    assign Q[2] = {S,Q[7:1]};
    
    // LUT entry 3
    assign sel[3] = ~A & B & C;
    assign Q[3] = {S,Q[7:1]};
    
    // LUT entry 4
    assign sel[4] = A & ~B & ~C;
    assign Q[4] = {Q[0][7:1],S};
    
    // LUT entry 5
    assign sel[5] = A & ~B & C;
    assign Q[5] = {Q[1][7:1],S};
    
    // LUT entry 6
    assign sel[6] = A & B & ~C;
    assign Q[6] = {Q[2][7:1],S};
    
    // LUT entry 7
    assign sel[7] = A & B & C;
    assign Q[7] = {Q[3][7:1],S};
    
    
    // MUX stage 1
    assign Z[0] = sel[0]? Q[0] : 8'b00000000;
    
    // MUX stage 2
    generate
        for (k = 1; k < 8; k = k + 1) begin : S2
            assign Z[k] = sel[1]? Q[k] : Z[k-1];
        end
    endgenerate
    
endmodule"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign Z = Q[2:0];
    
    mux2to1 m0 (Q[0], Q[1], S, Z);
    mux2to1 m1 (Q[2], Q[3], S, sel[0]);
    mux2to1 m2 (Q[4], Q[5], S, sel[1]);
    mux2to1 m3 (Q[6], Q[7], S, sel[2]);
    
    
    // assign sel = {A,B,C};",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign Z = Q[2:0];
    
    mux2to1 m0 (Q[0], Q[1], S, Z);
    mux2to1 m1 (Q[2], Q[3], S, sel[0]);
    mux2to1 m2 (Q[4], Q[5], S, sel[1]);
    mux2to1 m3 (Q[6], Q[7], S, sel[2]);
    
    
    // assign sel = {A,B,C};"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign 
    assign sel = {S,A,B,C};
    assign Z = Q[0];
    
    // counter
    counter c0(clk,enable,Q);
    
    // MUX
    mux8to1 m1(Q[0],Q[1],Q[2],Q[3],Q[4],Q[5],Q[6],Q[7],sel,Z);
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign 
    assign sel = {S,A,B,C};
    assign Z = Q[0];
    
    // counter
    counter c0(clk,enable,Q);
    
    // MUX
    mux8to1 m1(Q[0],Q[1],Q[2],Q[3],Q[4],Q[5],Q[6],Q[7],sel,Z);
    
endmodule"
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign Z = Q[2:0];
    
    mux2to1 m0 (Q[0], Q[1], Q[2], S, sel[0]);
    mux2to1 m1 (Q[3], Q[4], Q[5], S, sel[1]);
    mux2to1 m2 (Q[6], Q[7], 0, S, sel[2]);
    
    latch latch0 (Q[0], clk, enable, A);
    latch latch1 (Q[1], clk, enable, B);
    latch latch2 (Q[2], clk, enable, C);
    latch latch3 (Q[3], clk, enable, sel[0]);
    latch latch4 (Q[4], clk, enable, sel[1]);
    latch latch5 (Q[5], clk, enable, sel[2]);
    latch latch6 (Q[6], clk, enable, Q[7]);
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );",N/A,"module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 
    
    wire [2:0] sel;
    wire [7:0] Q;
    
    // assign Z = Q[2:0];
    
    mux2to1 m0 (Q[0], Q[1], Q[2], S, sel[0]);
    mux2to1 m1 (Q[3], Q[4], Q[5], S, sel[1]);
    mux2to1 m2 (Q[6], Q[7], 0, S, sel[2]);
    
    latch latch0 (Q[0], clk, enable, A);
    latch latch1 (Q[1], clk, enable, B);
    latch latch2 (Q[2], clk, enable, C);
    latch latch3 (Q[3], clk, enable, sel[0]);
    latch latch4 (Q[4], clk, enable, sel[1]);
    latch latch5 (Q[5], clk, enable, sel[2]);
    latch latch6 (Q[6], clk, enable, Q[7]);
    
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule"
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule",1,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (c&d) | (~a&~b&c);
    assign out_pos = out_sop;
    
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
	
	
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.	
	always @(posedge clk) begin
		if (reset) state <= A2;
		else state <= next_state;
	end
	
	
	// Combinational always block for state transition logic. Given the current state and inputs,
	// what should the next state be?
	// Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			A2: next_state = s[1]? B1 : A2;
			B1: next_state = s[2]? C1 : (s[1]? B1 : A2);
			B2: next_state = s[2]? C1 : (s[1]? B2 : A2);
			C1: next_state = s[3]? D1 : (s[2]? C1 : B2);
			C2: next_state = s[3]? D1 : (s[2]? C2 : B2);
			D1: next_state = s[3]? D1 : C2;
			default: next_state = 3'bxxx;
		endcase
	end
	
	
	
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign fr3 = (state == D1) && s[3];
	assign fr2 = (state == C2) && s[2];
	assign fr1 = (state == B1) && s[1];
	assign dfr = (state == A2) && s[0];

endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
	
	
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.	
	always @(posedge clk) begin
		if (reset) state <= A2;
		else state <= next_state;
	end
	
	
	// Combinational always block for state transition logic. Given the current state and inputs,
	// what should the next state be?
	// Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			A2: next_state = s[1]? B1 : A2;
			B1: next_state = s[2]? C1 : (s[1]? B1 : A2);
			B2: next_state = s[2]? C1 : (s[1]? B2 : A2);
			C1: next_state = s[3]? D1 : (s[2]? C1 : B2);
			C2: next_state = s[3]? D1 : (s[2]? C2 : B2);
			D1: next_state = s[3]? D1 : C2;
			default: next_state = 3'bxxx;
		endcase
	end
	
	
	
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign fr3 = (state == D1) && s[3];
	assign fr2 = (state == C2) && s[2];
	assign fr1 = (state == B1) && s[1];
	assign dfr = (state == A2) && s[0];

endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter
        S0 = 0,
        S1 = 1,
        S2 = 2,
        S3 = 3,
        S4 = 4,
        S5 = 5;
    
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Completes state
    // assignment for next_state.
    always @(posedge clk) begin
        if (reset) state <= S0;
        else state <= next_state;
    end
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Completes state assignment for next_state.
    //
    // It is considered good practice by many designers to seperate the combinatorial
    // and sequential aspects of state registers, and often registers in general.
    //
    // It is also a very common ""missing port"" in state-transition logic (usually
    // due to a missed input edge), and is often the most ""problematic"" state
    // transition in a FSM.
    //
    // It is also a very common ""missing port"" in state-transition logic (usually
    // due to a missed input edge), and is often the most ""problematic"" state
    // transition in a FSM.
    always @(*) begin
        case (state)
            S0: next_state = s[1]? S1 : S0;
            S1: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S2: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S3: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S4: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S5: next_state = s[2]? S2 : (s[1]? S1 : S0);
            default: next_state = S0;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S3) || (state == S4);
    assign fr2 = (state == S4);
    assign fr1 = (state == S4) || (state == S5);
    assign dfr = (state == S5);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter
        S0 = 0,
        S1 = 1,
        S2 = 2,
        S3 = 3,
        S4 = 4,
        S5 = 5;
    
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Completes state
    // assignment for next_state.
    always @(posedge clk) begin
        if (reset) state <= S0;
        else state <= next_state;
    end
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Completes state assignment for next_state.
    //
    // It is considered good practice by many designers to seperate the combinatorial
    // and sequential aspects of state registers, and often registers in general.
    //
    // It is also a very common ""missing port"" in state-transition logic (usually
    // due to a missed input edge), and is often the most ""problematic"" state
    // transition in a FSM.
    //
    // It is also a very common ""missing port"" in state-transition logic (usually
    // due to a missed input edge), and is often the most ""problematic"" state
    // transition in a FSM.
    always @(*) begin
        case (state)
            S0: next_state = s[1]? S1 : S0;
            S1: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S2: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S3: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S4: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S5: next_state = s[2]? S2 : (s[1]? S1 : S0);
            default: next_state = S0;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S3) || (state == S4);
    assign fr2 = (state == S4);
    assign fr1 = (state == S4) || (state == S5);
    assign dfr = (state == S5);
    
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
	
	
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
	always @(posedge clk, posedge reset) begin
		if(reset) state <= A2;
		else state <= next_state;
	end
	
	
	// Combinational always block for state transition logic. Given the current state and inputs,
	// what should the next state be?
	// Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			A2: next_state = s[1]? B1 : A2;
			B1: next_state = s[2]? C1 : (s[1]? B1 : A2);
			B2: next_state = s[2]? C1 : (s[1]? B2 : A2);
			C1: next_state = s[3]? D1 : (s[2]? C1 : B2);
			C2: next_state = s[3]? D1 : (s[2]? C2 : B2);
			D1: next_state = s[3]? D1 : C2;
			default: next_state = 3'bxxx;
		endcase
	end
	
	
	
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign fr3 = (state == D1) && s[3];
	assign fr2 = (state == C2) && s[2];
	assign fr1 = (state == B1) && s[1];
	assign dfr = (state == A2) && s[0];
	
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
	
	
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
	always @(posedge clk, posedge reset) begin
		if(reset) state <= A2;
		else state <= next_state;
	end
	
	
	// Combinational always block for state transition logic. Given the current state and inputs,
	// what should the next state be?
	// Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			A2: next_state = s[1]? B1 : A2;
			B1: next_state = s[2]? C1 : (s[1]? B1 : A2);
			B2: next_state = s[2]? C1 : (s[1]? B2 : A2);
			C1: next_state = s[3]? D1 : (s[2]? C1 : B2);
			C2: next_state = s[3]? D1 : (s[2]? C2 : B2);
			D1: next_state = s[3]? D1 : C2;
			default: next_state = 3'bxxx;
		endcase
	end
	
	
	
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign fr3 = (state == D1) && s[3];
	assign fr2 = (state == C2) && s[2];
	assign fr1 = (state == B1) && s[1];
	assign dfr = (state == A2) && s[0];
	
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4, S_5 = 5;
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk) begin
        if (reset) state <= S_0;
        else state <= next_state;
    end
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            S_0: next_state = s[1]? S_1 : S_0;
            S_1: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_2: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_3: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_4: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_5: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            default: next_state = S_0;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S_3) || (state == S_4) || (state == S_5);
    assign fr2 = (state == S_2) || (state == S_4) || (state == S_5);
    assign fr1 = (state == S_1) || (state == S_4) || (state == S_5);
    assign dfr = (state == S_0) || (state == S_1) || (state == S_2) || (state == S_3) || (state == S_4) || (state == S_5);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter S_0 = 0, S_1 = 1, S_2 = 2, S_3 = 3, S_4 = 4, S_5 = 5;
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk) begin
        if (reset) state <= S_0;
        else state <= next_state;
    end
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            S_0: next_state = s[1]? S_1 : S_0;
            S_1: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_2: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_3: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_4: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            S_5: next_state = s[2]? S_2 : (s[1]? S_1 : S_0);
            default: next_state = S_0;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S_3) || (state == S_4) || (state == S_5);
    assign fr2 = (state == S_2) || (state == S_4) || (state == S_5);
    assign fr1 = (state == S_1) || (state == S_4) || (state == S_5);
    assign dfr = (state == S_0) || (state == S_1) || (state == S_2) || (state == S_3) || (state == S_4) || (state == S_5);
    
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk) begin
        if (reset) state <= A2;
        else state <= next_state;
    end
 
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            A2: next_state = s[1]? B1 : A2;
            B1: next_state = s[2]? B2 : (s[1]? B1 : A2);
            B2: next_state = s[2]? B2 : (s[1]? B1 : A2);
            C1: next_state = s[2]? C2 : (s[1]? C1 : A2);
            C2: next_state = s[2]? C2 : (s[1]? C1 : A2);
            D1: next_state = s[2]? D2 : (s[1]? D1 : A2);
            D2: next_state = s[2]? D2 : (s[1]? D1 : A2);
            default: next_state = 3'bxxx;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == D1) || (state == C1) || (state == B1);
    assign fr2 = (state == D2) || (state == C2) || (state == B2);
    assign fr1 = (state == D2) || (state == C2) || (state == B2) || (state == C1);
    assign dfr = (state == D2) || (state == C2);
    
endmodule",-1,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk) begin
        if (reset) state <= A2;
        else state <= next_state;
    end
 
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            A2: next_state = s[1]? B1 : A2;
            B1: next_state = s[2]? B2 : (s[1]? B1 : A2);
            B2: next_state = s[2]? B2 : (s[1]? B1 : A2);
            C1: next_state = s[2]? C2 : (s[1]? C1 : A2);
            C2: next_state = s[2]? C2 : (s[1]? C1 : A2);
            D1: next_state = s[2]? D2 : (s[1]? D1 : A2);
            D2: next_state = s[2]? D2 : (s[1]? D1 : A2);
            default: next_state = 3'bxxx;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == D1) || (state == C1) || (state == B1);
    assign fr2 = (state == D2) || (state == C2) || (state == B2);
    assign fr1 = (state == D2) || (state == C2) || (state == B2) || (state == C1);
    assign dfr = (state == D2) || (state == C2);
    
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter S0=0, S1=1, S2=2, S3=3, S4=4, S5=5;
    reg [2:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.
    always @(posedge clk) begin
        if (reset) state <= S0;
        else state <= next_state;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            S0: next_state = s[1]? S1 : S0;
            S1: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S2: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S3: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S4: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S5: next_state = s[2]? S2 : (s[1]? S1 : S0);
            default: next_state = S0;
        endcase
    end
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S3) || (state == S4);
    assign fr2 = (state == S3) || (state == S4) || (state == S5);
    assign fr1 = (state == S5);
    assign dfr = (state == S0) || (state == S1) || (state == S2) || (state == S3) || (state == S4) || (state == S5);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter S0=0, S1=1, S2=2, S3=3, S4=4, S5=5;
    reg [2:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.
    always @(posedge clk) begin
        if (reset) state <= S0;
        else state <= next_state;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            S0: next_state = s[1]? S1 : S0;
            S1: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S2: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S3: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S4: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S5: next_state = s[2]? S2 : (s[1]? S1 : S0);
            default: next_state = S0;
        endcase
    end
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S3) || (state == S4);
    assign fr2 = (state == S3) || (state == S4) || (state == S5);
    assign fr1 = (state == S5);
    assign dfr = (state == S0) || (state == S1) || (state == S2) || (state == S3) || (state == S4) || (state == S5);
    
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter
        S0 = 0,
        S1 = 1,
        S2 = 2,
        S3 = 3,
        S4 = 4,
        S5 = 5;
        
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk) begin
        if (reset) state <= S0;
        else state <= next_state;
    end
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            S0: next_state = s[1]? S1 : S0;
            S1: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S2: next_state = s[3]? S3 : (s[2]? S2 : S0);
            S3: next_state = s[3]? S3 : (s[2]? S2 : S0);
            S4: next_state = s[3]? S3 : (s[2]? S2 : S0);
            S5: next_state = s[3]? S3 : (s[2]? S2 : S0);
            default: next_state = S0;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S3) || (state == S4);
    assign fr2 = (state == S3) || (state == S4) || (state == S5);
    assign fr1 = (state == S5) || (state == S2) || (state == S1);
    assign dfr = (state == S0) || (state == S1) || (state == S2) || (state == S3) || (state == S4) || (state == S5);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter
        S0 = 0,
        S1 = 1,
        S2 = 2,
        S3 = 3,
        S4 = 4,
        S5 = 5;
        
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk) begin
        if (reset) state <= S0;
        else state <= next_state;
    end
    
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            S0: next_state = s[1]? S1 : S0;
            S1: next_state = s[2]? S2 : (s[1]? S1 : S0);
            S2: next_state = s[3]? S3 : (s[2]? S2 : S0);
            S3: next_state = s[3]? S3 : (s[2]? S2 : S0);
            S4: next_state = s[3]? S3 : (s[2]? S2 : S0);
            S5: next_state = s[3]? S3 : (s[2]? S2 : S0);
            default: next_state = S0;
        endcase
    end
    
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == S3) || (state == S4);
    assign fr2 = (state == S3) || (state == S4) || (state == S5);
    assign fr1 = (state == S5) || (state == S2) || (state == S1);
    assign dfr = (state == S0) || (state == S1) || (state == S2) || (state == S3) || (state == S4) || (state == S5);
    
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter
        S0 = 0,
        S1 = 1,
        S2 = 2,
        S3 = 3,
        S4 = 4,
        S5 = 5,
        S6 = 6;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk, posedge reset)
    begin
        if (reset)
            state_reg <= S0;
        else
            state_reg <= state_next;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*)
    begin
        state_next = state_reg;         // Default state assignment; use blocking assignment
        case (state_reg)
            S0: if (s[0])
                    if (s[1])
                        if (s[2])
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                        else
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                            else
                                state_next = S3;
                    else
                        if (s[1])
                            if (s[2])
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                            else
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                        else
                            if (s[2])
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                            else
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                        
            S1: if (s[0])
                    if (s[1])
                        if (s[2])
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                        else
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                            else
                                state_next = S3;
                    else
                        if (s[1])
                            if (s[2])
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;",-1,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    parameter
        S0 = 0,
        S1 = 1,
        S2 = 2,
        S3 = 3,
        S4 = 4,
        S5 = 5,
        S6 = 6;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Asynchronous reset.
    always @(posedge clk, posedge reset)
    begin
        if (reset)
            state_reg <= S0;
        else
            state_reg <= state_next;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*)
    begin
        state_next = state_reg;         // Default state assignment; use blocking assignment
        case (state_reg)
            S0: if (s[0])
                    if (s[1])
                        if (s[2])
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                        else
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                            else
                                state_next = S3;
                    else
                        if (s[1])
                            if (s[2])
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                            else
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                        else
                            if (s[2])
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                            else
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;
                                else
                                    state_next = S3;
                        
            S1: if (s[0])
                    if (s[1])
                        if (s[2])
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                        else
                            if (s[3])
                                if (s[4])
                                    if (s[5])
                                        state_next = S6;
                                    else
                                        state_next = S5;
                                else
                                    state_next = S4;
                            else
                                state_next = S3;
                    else
                        if (s[1])
                            if (s[2])
                                if (s[3])
                                    if (s[4])
                                        if (s[5])
                                            state_next = S6;
                                        else
                                            state_next = S5;
                                    else
                                        state_next = S4;"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
	
	
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.	
	always @(posedge clk) begin
		if (reset) state <= A2;
		else state <= next_state;
	end
	
	
	// Combinational always block for state transition logic. Given the current state and inputs,
	// what should the next state be?
	// Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			A2: next_state = s[1]? B1 : A2;
			B1: next_state = s[2]? C1 : (s[1]? B1 : A2);
			B2: next_state = s[2]? C1 : (s[1]? B2 : A2);
			C1: next_state = s[3]? D1 : (s[2]? C1 : B2);
			C2: next_state = s[3]? D1 : (s[2]? C2 : B2);
			D1: next_state = s[3]? D1 : C2;
			default: next_state = 3'bxxx;
		endcase
	end
	
	
	
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign fr3 = (state == D1) && s[3];
	assign fr2 = (state == C2) && s[2];
	assign fr1 = (state == B1) && s[1];
	assign dfr = (state == A2) && s[0];
	
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
	
	parameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;
	reg [2:0] state, next_state;
	
	
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.	
	always @(posedge clk) begin
		if (reset) state <= A2;
		else state <= next_state;
	end
	
	
	// Combinational always block for state transition logic. Given the current state and inputs,
	// what should the next state be?
	// Combinational always block: Use blocking assignments.    
	always@(*) begin
		case (state)
			A2: next_state = s[1]? B1 : A2;
			B1: next_state = s[2]? C1 : (s[1]? B1 : A2);
			B2: next_state = s[2]? C1 : (s[1]? B2 : A2);
			C1: next_state = s[3]? D1 : (s[2]? C1 : B2);
			C2: next_state = s[3]? D1 : (s[2]? C2 : B2);
			D1: next_state = s[3]? D1 : C2;
			default: next_state = 3'bxxx;
		endcase
	end
	
	
	
	// Combinational output logic. In this problem, an assign statement is the simplest.
	// In more complex circuits, a combinational always block may be more suitable.
	assign fr3 = (state == D1) && s[3];
	assign fr2 = (state == C2) && s[2];
	assign fr1 = (state == B1) && s[1];
	assign dfr = (state == A2) && s[0];
	
endmodule"
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    
    parameter
        state_0 = 0,
        state_1 = 1,
        state_2 = 2,
        state_3 = 3,
        state_4 = 4,
        state_5 = 5;
        
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.    
    always @(posedge clk) begin
        if (reset) state <= 0;
        else state <= next_state;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            state_0: next_state = s[1]? state_1 : state_0;
            state_1: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_2: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_3: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_4: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_5: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            default: next_state = state_0;
        endcase
    end
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == state_3) || (state == state_4) || (state == state_5);
    assign fr2 = (state == state_2) || (state == state_4) || (state == state_5);
    assign fr1 = (state == state_1) || (state == state_4) || (state == state_5);
    assign dfr = (state == state_0) || (state == state_1) || (state == state_2) || (state == state_3) || (state == state_4) || (state == state_5);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
	// It doesn't really matter what assignment is used, as long as they're unique.
	// We have 6 states here.
    
    parameter
        state_0 = 0,
        state_1 = 1,
        state_2 = 2,
        state_3 = 3,
        state_4 = 4,
        state_5 = 5;
        
    reg [4:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.    
    always @(posedge clk) begin
        if (reset) state <= 0;
        else state <= next_state;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            state_0: next_state = s[1]? state_1 : state_0;
            state_1: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_2: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_3: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_4: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            state_5: next_state = s[2]? state_2 : (s[1]? state_1 : state_0);
            default: next_state = state_0;
        endcase
    end
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign fr3 = (state == state_3) || (state == state_4) || (state == state_5);
    assign fr2 = (state == state_2) || (state == state_4) || (state == state_5);
    assign fr1 = (state == state_1) || (state == state_4) || (state == state_5);
    assign dfr = (state == state_0) || (state == state_1) || (state == state_2) || (state == state_3) || (state == state_4) || (state == state_5);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, t4;
    
    assign t1 = (j & ~k) | (~j & k);
    assign t2 = (j & k) | (j & ~k) | (~j & ~k);
    
    JKFF jk1(clk, t1, Q, Qbar);
    JKFF jk2(clk, t2, Q, Qbar);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, t4;
    
    assign t1 = (j & ~k) | (~j & k);
    assign t2 = (j & k) | (j & ~k) | (~j & ~k);
    
    JKFF jk1(clk, t1, Q, Qbar);
    JKFF jk2(clk, t2, Q, Qbar);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~k;
    assign t2 = ~j & k;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~k;
    assign t2 = ~j & k;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~k;
    assign t2 = ~j & k;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~k;
    assign t2 = ~j & k;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~k & Q;
    assign t2 = ~j & k | ~Q;
    
    JKFF ins1(clk, t1, Q);
    JKFF ins2(clk, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~k & Q;
    assign t2 = ~j & k | ~Q;
    
    JKFF ins1(clk, t1, Q);
    JKFF ins2(clk, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~Q;
    assign t2 = k & Q;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j & ~Q;
    assign t2 = k & Q;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = (j & ~k) | (~j & k);
    assign t2 = (j & k) | (j & ~k) | (~j & ~k);
    
    JKFF ins1 (clk, t1, Q);
    JKFF ins2 (clk, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = (j & ~k) | (~j & k);
    assign t2 = (j & k) | (j & ~k) | (~j & ~k);
    
    JKFF ins1 (clk, t1, Q);
    JKFF ins2 (clk, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j ^ Q;
    assign t2 = k ^ Q;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = j ^ Q;
    assign t2 = k ^ Q;
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = (j & ~Q) | (~j & Q);
    assign t2 = (k & ~Q) | (~k & Q);
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2;
    
    assign t1 = (j & ~Q) | (~j & Q);
    assign t2 = (k & ~Q) | (~k & Q);
    
    JKFF ins1 (clk, t1, t2, Q);
    
endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, t4, t5, t6;
    
    assign t1 = (j & ~Q) | (~j & Q);
    assign t2 = (k & ~Q) | (~k & Q);
    assign t3 = t1 | t2;
    assign t4 = t3 & j;
    assign t5 = t3 & ~k;
    assign t6 = t4 | t5;
    
    JKFF ins1 (clk, t6, Q, Qbar);

endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, t4, t5, t6;
    
    assign t1 = (j & ~Q) | (~j & Q);
    assign t2 = (k & ~Q) | (~k & Q);
    assign t3 = t1 | t2;
    assign t4 = t3 & j;
    assign t5 = t3 & ~k;
    assign t6 = t4 | t5;
    
    JKFF ins1 (clk, t6, Q, Qbar);

endmodule"
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, t4, t5, t6, Qbar;
    
    assign t1 = j & ~k & Q;
    assign t2 = ~j & k & Q;
    assign t3 = t1 | t2;
    assign t4 = t3 & ~Q;
    assign t5 = t4 | t3;
    assign t6 = t5 | t1;
    assign Q = ~t6 & Qbar;
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, t4, t5, t6, Qbar;
    
    assign t1 = j & ~k & Q;
    assign t2 = ~j & k & Q;
    assign t3 = t1 | t2;
    assign t4 = t3 & ~Q;
    assign t5 = t4 | t3;
    assign t6 = t5 | t1;
    assign Q = ~t6 & Qbar;
    
endmodule"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

// the value of overflow can be seen from the output. 

// method 03

// the value of overflow can be seen from the output. 

// method 04

// the value of overflow can be seen from the output. 

// method 05

// the value of overflow can be seen from the output. 

// method 06

// the value of overflow can be seen from the output. 

// method 07

// the value of overflow can be seen from the output. 

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

// the value of overflow can be seen from the output. 

// method 03

// the value of overflow can be seen from the output. 

// method 04

// the value of overflow can be seen from the output. 

// method 05

// the value of overflow can be seen from the output. 

// method 06

// the value of overflow can be seen from the output. 

// method 07

// the value of overflow can be seen from the output. 

endmodule"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// Method 01:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 02:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 03:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 04:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 05:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 06:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 07:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 08:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 09:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 10:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 11:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 12:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 13:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 14:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 15:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 16:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 17:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 18:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 19:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 20:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 21:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 22:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 23:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 24:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 25:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 26:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 27:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 28:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 29:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 30:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 31:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 32:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 33:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 34:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 35:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 36:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 37:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 38:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 39:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 40:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 41:
// The 8-bit adder can be replaced by a 1-bit adder",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// Method 01:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 02:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 03:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 04:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 05:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 06:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 07:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 08:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 09:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 10:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 11:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 12:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 13:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 14:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 15:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 16:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 17:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 18:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 19:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 20:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 21:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 22:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 23:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 24:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 25:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 26:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 27:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 28:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 29:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 30:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 31:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 32:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 33:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 34:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 35:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 36:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 37:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 38:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 39:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 40:
// The 8-bit adder can be replaced by a 1-bit adder.

// Method 41:
// The 8-bit adder can be replaced by a 1-bit adder"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// Method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// Method 02

//wire [7:0] overflow;

assign s = a + b;

//wire c = (a[7] == b[7])? 1 : 0;
//assign overflow = a[7]!= s[7]? 1 : 0;

// Method 03

//wire overflow;

assign s = a + b;

//wire c = (a[7] == b[7])? 1 : 0;
//assign overflow = a[7]!= s[7]? 1 : 0;

// Method 04

//wire overflow;

assign s = a + b;

//wire c = (a[7] == b[7])? 1 : 0;
//assign overflow = a[7]!= s[7]? 1 : 0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// Method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// Method 02

//wire [7:0] overflow;

assign s = a + b;

//wire c = (a[7] == b[7])? 1 : 0;
//assign overflow = a[7]!= s[7]? 1 : 0;

// Method 03

//wire overflow;

assign s = a + b;

//wire c = (a[7] == b[7])? 1 : 0;
//assign overflow = a[7]!= s[7]? 1 : 0;

// Method 04

//wire overflow;

assign s = a + b;

//wire c = (a[7] == b[7])? 1 : 0;
//assign overflow = a[7]!= s[7]? 1 : 0;

endmodule"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 03

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 04

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 05

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 06

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 07

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 08

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 09

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 10

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 11

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 12

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 13

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 14

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 15

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 16

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 17

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 18

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 19

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 20

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 21

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 22

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 23

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 03

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 04

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 05

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 06

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 07

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 08

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 09

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 10

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 11

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 12

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 13

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 14

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 15

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 16

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 17

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 18

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 19

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 20

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 21

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 22

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 23

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

// the following code has an error. Fix it.

reg [8:0] temp;

always @(*)
begin
    temp = a+b;
    overflow = (temp[7] == b[7] && temp[7]!= s[7])?1:0;
end

// method 03

// the following code has an error. Fix it.

reg [8:0] temp;

always @(*)
begin
    if(a[7] == b[7])
        temp = a+b;
    else
        temp = a-b;
    overflow = (temp[7] == a[7] && temp[7]!= s[7])?1:0;
end

endmodule",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

// the following code has an error. Fix it.

reg [8:0] temp;

always @(*)
begin
    temp = a+b;
    overflow = (temp[7] == b[7] && temp[7]!= s[7])?1:0;
end

// method 03

// the following code has an error. Fix it.

reg [8:0] temp;

always @(*)
begin
    if(a[7] == b[7])
        temp = a+b;
    else
        temp = a-b;
    overflow = (temp[7] == a[7] && temp[7]!= s[7])?1:0;
end

endmodule"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;

// method 02

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7] == b[7] && a[7]!= s[7] ;

// method 03

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7]!= b[7] && a[7] == b[7] ;

// method 04

assign overflow = (a[7] == b[7] && a[7]!= s[7]) |
//                    (a[7]!= b[7] && a[7] == b[7]);

// method 05

assign s = a + (~b + 1'b1);

// method 06

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7] == b[7] && a[7]!= s[7] ;

// method 07

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7]!= b[7] && a[7] == b[7];

// method 08

assign s = a + b;

// method 09

assign s = a + b;

// method 10

reg [7:0] s;

always @(*)
    s = a + b;

// method 11

reg [7:0] s;

always @(*)
    s = a + b;

// method 12

reg [7:0] s;

always @(s)
    s = a + b;

// method 13

reg [7:0] s;

always @(s)
    s = a + b;

// method 14

reg [7:0] s;

always @(s)
    s = a + b;

// method 15

reg [7:0] s;

always @(s)
    s = a + b;

// method 16

reg [7:0] s;

always @(s)
    s = a + b;

// method 17

reg [7:0] s;

always @(s)
    s = a + b;

// method 18

reg [7:0] s;

always @(s)
    s = a + b;

// method 19

reg [7:0] s;

always @(s)
    s = a + b;

// method 20

reg [7:0] s;

always @(s)
    s = a + b;

// method 21

reg [7:0] s;

always @(s)
    s = a + b;

// method 22

reg [7:0] s;

always @(s)
    s = a + b;

// method 23

reg [7:0] s;

always @(s)
    s = a + b;

// method 24

reg [7:0] s;

always @(s)
    s = a + b;

// method 25

reg [7:0] s;

always @(s)
    s = a + b;

// method 26

reg [7:0] s;

always @(s)
    s = a + b;

// method 27

reg [7:0] s;

always @(s)
    s = a + b;

// method 28

reg [7:0] s;

always @(s)
    s = a + b;

// method 29

reg [7:0] s;

always @(s)
    s = a + b;

// method 30

reg [7:0] s;

always @(s)
    s = a + b;

// method 31

reg [7:0] s;

always @(s)
    s = a + b;",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;

// method 02

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7] == b[7] && a[7]!= s[7] ;

// method 03

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7]!= b[7] && a[7] == b[7] ;

// method 04

assign overflow = (a[7] == b[7] && a[7]!= s[7]) |
//                    (a[7]!= b[7] && a[7] == b[7]);

// method 05

assign s = a + (~b + 1'b1);

// method 06

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7] == b[7] && a[7]!= s[7] ;

// method 07

// the value of overflow is 0 because the value is assigned to a register

reg overflow;

always @(a or b)
    overflow <= a[7]!= b[7] && a[7] == b[7];

// method 08

assign s = a + b;

// method 09

assign s = a + b;

// method 10

reg [7:0] s;

always @(*)
    s = a + b;

// method 11

reg [7:0] s;

always @(*)
    s = a + b;

// method 12

reg [7:0] s;

always @(s)
    s = a + b;

// method 13

reg [7:0] s;

always @(s)
    s = a + b;

// method 14

reg [7:0] s;

always @(s)
    s = a + b;

// method 15

reg [7:0] s;

always @(s)
    s = a + b;

// method 16

reg [7:0] s;

always @(s)
    s = a + b;

// method 17

reg [7:0] s;

always @(s)
    s = a + b;

// method 18

reg [7:0] s;

always @(s)
    s = a + b;

// method 19

reg [7:0] s;

always @(s)
    s = a + b;

// method 20

reg [7:0] s;

always @(s)
    s = a + b;

// method 21

reg [7:0] s;

always @(s)
    s = a + b;

// method 22

reg [7:0] s;

always @(s)
    s = a + b;

// method 23

reg [7:0] s;

always @(s)
    s = a + b;

// method 24

reg [7:0] s;

always @(s)
    s = a + b;

// method 25

reg [7:0] s;

always @(s)
    s = a + b;

// method 26

reg [7:0] s;

always @(s)
    s = a + b;

// method 27

reg [7:0] s;

always @(s)
    s = a + b;

// method 28

reg [7:0] s;

always @(s)
    s = a + b;

// method 29

reg [7:0] s;

always @(s)
    s = a + b;

// method 30

reg [7:0] s;

always @(s)
    s = a + b;

// method 31

reg [7:0] s;

always @(s)
    s = a + b;"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 03

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 04

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 05

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 06

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 07

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 08

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 09

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 10

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 11

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 12

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 03

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 04

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 05

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 06

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 07

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 08

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 09

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 10

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 11

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 12

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

endmodule"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 03

assign s = a + b;

// method 04

assign s = a + b;

// method 05

assign s = a + b;

// method 06

assign s = a + b;

// method 07

assign s = a + b;

// method 08

assign s = a + b;

// method 09

assign s = a + b;

// method 10

assign s = a + b;

// method 11

assign s = a + b;

// method 12

assign s = a + b;

// method 13

assign s = a + b;

// method 14

assign s = a + b;

// method 15

assign s = a + b;

// method 16

assign s = a + b;

// method 17

assign s = a + b;

// method 18

assign s = a + b;

// method 19

assign s = a + b;

// method 20

assign s = a + b;

// method 21

assign s = a + b;

// method 22

assign s = a + b;

// method 23

assign s = a + b;

// method 24

assign s = a + b;

// method 25

assign s = a + b;

// method 26

assign s = a + b;

// method 27

assign s = a + b;

// method 28

assign s = a + b;

// method 29

assign s = a + b;

// method 30

assign s = a + b;

// method 31

assign s = a + b;

// method 32

assign s = a + b;

// method 33

assign s = a + b;

// method 34

assign s = a + b;

// method 35

assign s = a + b;

// method 36

assign s = a + b;

// method 37

assign s = a + b;

// method 38

assign s = a + b;

// method 39

assign s = a + b;

// method 40

assign s = a + b;

// method 41

assign s = a + b;

// method 42

assign s = a + b;

// method 43

assign s = a + b;

// method 44

assign s = a + b;

// method 45

assign s = a + b;

// method 46

assign s = a + b;

// method 47

assign s = a + b;

// method 48

assign s = a + b;

// method 49

assign s = a + b;

// method 50

assign s = a + b;

// method 51

assign s = a + b;

// method 52

assign s = a + b;

// method 53

assign s = a + b;

// method 54

assign s = a + b;

// method 55

assign s = a + b;

// method 56

assign s = a + b;

// method 57

assign s = a + b;

// method 58

assign s = a + b;

// method 59

assign s = a + b;

// method 60

assign s = a + b;

// method 61

assign s = a + b;

// method 62

assign s = a + b;

// method 63

assign s = a + b;

// method 64

assign s = a + b;

// method",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01

assign s = a + b;
assign overflow = (a[7] == b[7] && a[7]!= s[7])?1:0;

// method 02

assign s = a + b;
assign overflow = (a[7]!= b[7] && a[7] == s[7])?1:0;

// method 03

assign s = a + b;

// method 04

assign s = a + b;

// method 05

assign s = a + b;

// method 06

assign s = a + b;

// method 07

assign s = a + b;

// method 08

assign s = a + b;

// method 09

assign s = a + b;

// method 10

assign s = a + b;

// method 11

assign s = a + b;

// method 12

assign s = a + b;

// method 13

assign s = a + b;

// method 14

assign s = a + b;

// method 15

assign s = a + b;

// method 16

assign s = a + b;

// method 17

assign s = a + b;

// method 18

assign s = a + b;

// method 19

assign s = a + b;

// method 20

assign s = a + b;

// method 21

assign s = a + b;

// method 22

assign s = a + b;

// method 23

assign s = a + b;

// method 24

assign s = a + b;

// method 25

assign s = a + b;

// method 26

assign s = a + b;

// method 27

assign s = a + b;

// method 28

assign s = a + b;

// method 29

assign s = a + b;

// method 30

assign s = a + b;

// method 31

assign s = a + b;

// method 32

assign s = a + b;

// method 33

assign s = a + b;

// method 34

assign s = a + b;

// method 35

assign s = a + b;

// method 36

assign s = a + b;

// method 37

assign s = a + b;

// method 38

assign s = a + b;

// method 39

assign s = a + b;

// method 40

assign s = a + b;

// method 41

assign s = a + b;

// method 42

assign s = a + b;

// method 43

assign s = a + b;

// method 44

assign s = a + b;

// method 45

assign s = a + b;

// method 46

assign s = a + b;

// method 47

assign s = a + b;

// method 48

assign s = a + b;

// method 49

assign s = a + b;

// method 50

assign s = a + b;

// method 51

assign s = a + b;

// method 52

assign s = a + b;

// method 53

assign s = a + b;

// method 54

assign s = a + b;

// method 55

assign s = a + b;

// method 56

assign s = a + b;

// method 57

assign s = a + b;

// method 58

assign s = a + b;

// method 59

assign s = a + b;

// method 60

assign s = a + b;

// method 61

assign s = a + b;

// method 62

assign s = a + b;

// method 63

assign s = a + b;

// method 64

assign s = a + b;

// method"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// Method 01

assign s = a + b;

// Method 02

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 03

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 04

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 05

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 06

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 07

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 08

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 09

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 10

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 11

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 12

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 13

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 14

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 15

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 16

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 17

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 18

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 19

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 20

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 21

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 22

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 23

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 24

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 25

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 26

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 27

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 28

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 29

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 30

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 31

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 32

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 33

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 34

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 35

// The value of's' is not defined if any",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// Method 01

assign s = a + b;

// Method 02

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 03

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 04

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 05

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 06

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 07

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 08

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 09

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 10

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 11

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 12

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 13

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 14

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 15

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 16

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 17

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 18

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 19

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 20

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 21

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 22

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 23

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 24

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 25

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 26

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 27

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 28

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 29

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 30

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 31

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 32

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 33

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 34

// The value of's' is not defined if any of the two input operands is a signed value.

// Method 35

// The value of's' is not defined if any"
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01
assign s = a + b;

// method 02
// the value of overflow is given by the 4th to last bit
// of the 8-bit sum
assign overflow = s[7:4];

// method 03
// the value of overflow is given by the 4th to last
// bit of the 8-bit sum.
// assign overflow = (s[7:4] == 4'b1111)? 1'b1 : 1'b0;

// method 04
// The value of overflow is given by the
// 4th to last bit of the 8-bit sum
// assign overflow = (s[7:4] == 4'b1111)? 1'b1 : 1'b0;

endmodule",-0.5,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

// method 01
assign s = a + b;

// method 02
// the value of overflow is given by the 4th to last bit
// of the 8-bit sum
assign overflow = s[7:4];

// method 03
// the value of overflow is given by the 4th to last
// bit of the 8-bit sum.
// assign overflow = (s[7:4] == 4'b1111)? 1'b1 : 1'b0;

// method 04
// The value of overflow is given by the
// 4th to last bit of the 8-bit sum
// assign overflow = (s[7:4] == 4'b1111)? 1'b1 : 1'b0;

endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = c|d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c&d;
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == E))? 1:0;
    
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? B:C;
            D: NS = (x)? C:B;
            E: NS = (x)? E:D;
            default: NS = PS;
        endcase
    
    always @(posedge clk or posedge areset)
        if(areset)
            PS = A;
    	else
            PS = NS;
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == E))? 1:0;
    
    always @(*)
        case(PS)
            A: NS = (x)? B:A;
            B: NS = (x)? E:B;
            C: NS = (x)? B:C;
            D: NS = (x)? C:B;
            E: NS = (x)? E:D;
            default: NS = PS;
        endcase
    
    always @(posedge clk or posedge areset)
        if(areset)
            PS = A;
    	else
            PS = NS;
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [0:1] state, next_state;
    
    always@(*) begin
        case(state)
            S0: begin
                next_state = x?S1:S0;
                z = 0;
            end
            S1: begin
                next_state = x?S2:S1;
                z = 0;
            end
            S2: begin
                next_state = x?S3:S2;
                z = 0;
            end
            S3: begin
                next_state = x?S0:S3;
                z = 1;
            end
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    localparam S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [0:1] state, next_state;
    
    always@(*) begin
        case(state)
            S0: begin
                next_state = x?S1:S0;
                z = 0;
            end
            S1: begin
                next_state = x?S2:S1;
                z = 0;
            end
            S2: begin
                next_state = x?S3:S2;
                z = 0;
            end
            S3: begin
                next_state = x?S0:S3;
                z = 1;
            end
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0=0, S1=1, S2=2, S3=3;
    reg [0:1] state, next_state;
    
    always@(*) begin
        case(state)
            S0: begin
                next_state = x?S1:S0;
                z = 0;
            end
            S1: begin
                next_state = x?S2:S1;
                z = 0;
            end
            S2: begin
                next_state = x?S3:S2;
                z = 0;
            end
            S3: begin
                next_state = x?S0:S3;
                z = 1;
            end
        endcase
    end
    
    always@(posedge clk, posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0=0, S1=1, S2=2, S3=3;
    reg [0:1] state, next_state;
    
    always@(*) begin
        case(state)
            S0: begin
                next_state = x?S1:S0;
                z = 0;
            end
            S1: begin
                next_state = x?S2:S1;
                z = 0;
            end
            S2: begin
                next_state = x?S3:S2;
                z = 0;
            end
            S3: begin
                next_state = x?S0:S3;
                z = 1;
            end
        endcase
    end
    
    always@(posedge clk, posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: next_state = x?B:A;
            B: next_state = x?C:A;
            C: next_state = x?C:D;
            D: next_state = x?C:A;
            default: next_state = 2'bxx;
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == D)?1:0;
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: next_state = x?B:A;
            B: next_state = x?C:A;
            C: next_state = x?C:D;
            D: next_state = x?C:A;
            default: next_state = 2'bxx;
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == D)?1:0;
    
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0] PS, NS;
    
    always @(PS, x)
        case (PS)
            A: begin
                z <= (x)? 0:1;
                NS <= (x)? B:A;
            end
            
            B: begin
                z <= (x)? 1:0;
                NS <= (x)? B:C;
            end
            
            C: begin
                z <= (x)? 0:1;
                NS <= (x)? D:A;
            end
            
            D: begin
                z <= (x)? 1:0;
                NS <= (x)? D:C;
            end
            
            default: NS <= PS;
        endcase
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0] PS, NS;
    
    always @(PS, x)
        case (PS)
            A: begin
                z <= (x)? 0:1;
                NS <= (x)? B:A;
            end
            
            B: begin
                z <= (x)? 1:0;
                NS <= (x)? B:C;
            end
            
            C: begin
                z <= (x)? 0:1;
                NS <= (x)? D:A;
            end
            
            D: begin
                z <= (x)? 1:0;
                NS <= (x)? D:C;
            end
            
            default: NS <= PS;
        endcase
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0=2'b00, S1=2'b01, S2=2'b10, S3=2'b11;
    reg [1:0] state, next_state;
    
    always@(*) begin
        case(state)
            S0: begin
                if(x==1'b1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(x==1'b1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(x==1'b1)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(x==1'b1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
    assign z = (state == S3);
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0=2'b00, S1=2'b01, S2=2'b10, S3=2'b11;
    reg [1:0] state, next_state;
    
    always@(*) begin
        case(state)
            S0: begin
                if(x==1'b1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(x==1'b1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(x==1'b1)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(x==1'b1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
    assign z = (state == S3);
    
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0]	state, next_state;
    
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = B;
            {A, 1'b1}:	next_state = A;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = D;
            {C, 1'b0}:	next_state = B;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == D);
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0]	state, next_state;
    
    always@(*) begin
        case({state, x})
            {A, 1'b0}:	next_state = B;
            {A, 1'b1}:	next_state = A;
            {B, 1'b0}:	next_state = C;
            {B, 1'b1}:	next_state = D;
            {C, 1'b0}:	next_state = B;
            {C, 1'b1}:	next_state = D;
            {D, 1'b0}:	next_state = C;
            {D, 1'b1}:	next_state = B;
        endcase
    end
    
    always@(posedge clk or posedge areset) begin
        if(areset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == D);
    
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] PS, NS;
    
    always @(*)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                z <= 0;
            end
            
            B: begin
                NS <= (x)? E:B;
                z <= (x)? 1:0;
            end
            
            C: begin
                NS <= (x)? B:C;
                z <= 0;
            end
            
            D: begin
                NS <= (x)? C:B;
                z <= (x)? 0:1;
            end
            
            E: begin
                NS <= (x)? E:A;
                z <= 0;
            end
            default: NS <= PS;
        endcase
    
    always @(posedge clk or posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] PS, NS;
    
    always @(*)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                z <= 0;
            end
            
            B: begin
                NS <= (x)? E:B;
                z <= (x)? 1:0;
            end
            
            C: begin
                NS <= (x)? B:C;
                z <= 0;
            end
            
            D: begin
                NS <= (x)? C:B;
                z <= (x)? 0:1;
            end
            
            E: begin
                NS <= (x)? E:A;
                z <= 0;
            end
            default: NS <= PS;
        endcase
    
    always @(posedge clk or posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [0:1] state, next_state;
    
    always @(*) begin
        case(state)
            S0: begin
                next_state = x? S1 : S0;
                z = 0;
            end
            S1: begin
                next_state = x? S2 : S1;
                z = 0;
            end
            S2: begin
                next_state = x? S2 : S3;
                z = 0;
            end
            S3: begin
                next_state = x? S2 : S3;
                z = 0;
            end
            default: begin
                next_state = S0;
                z = 0;
            end
        endcase
    end
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [0:1] state, next_state;
    
    always @(*) begin
        case(state)
            S0: begin
                next_state = x? S1 : S0;
                z = 0;
            end
            S1: begin
                next_state = x? S2 : S1;
                z = 0;
            end
            S2: begin
                next_state = x? S2 : S3;
                z = 0;
            end
            S3: begin
                next_state = x? S2 : S3;
                z = 0;
            end
            default: begin
                next_state = S0;
                z = 0;
            end
        endcase
    end
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= S0;
        else
            state <= next_state;
    end
    
endmodule"
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0] PS, NS;
    
    always @(*)
        case(PS)
            A: begin
                if(x == 1'b1)
                    NS = B;
                else
                    NS = A;
            end
            B: begin
                if(x == 1'b1)
                    NS = C;
                else
                    NS = A;
            end
            C: begin
                if(x == 1'b1)
                    NS = D;
                else
                    NS = A;
            end
            D: begin
                if(x == 1'b1)
                    NS = C;
                else
                    NS = A;
            end
            default: NS = PS;
        endcase
    
    always @(posedge clk or posedge areset)
        if(areset)
            PS = A;
    	else
            PS = NS;
    
    assign z = (PS == D)?1:0;
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=2'b00, B=2'b01, C=2'b10, D=2'b11;
    reg [1:0] PS, NS;
    
    always @(*)
        case(PS)
            A: begin
                if(x == 1'b1)
                    NS = B;
                else
                    NS = A;
            end
            B: begin
                if(x == 1'b1)
                    NS = C;
                else
                    NS = A;
            end
            C: begin
                if(x == 1'b1)
                    NS = D;
                else
                    NS = A;
            end
            D: begin
                if(x == 1'b1)
                    NS = C;
                else
                    NS = A;
            end
            default: NS = PS;
        endcase
    
    always @(posedge clk or posedge areset)
        if(areset)
            PS = A;
    	else
            PS = NS;
    
    assign z = (PS == D)?1:0;
    
endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //top module
    
    //fsm the_fsm (clk, reset, enable, Q, c_enable, c_load, c_d);

endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //top module
    
    //fsm the_fsm (clk, reset, enable, Q, c_enable, c_load, c_d);

endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    // Define the logic of the counter
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    // Define the logic of the counter
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop""
    // It has no ""initial"" statement
    // It only uses the for-loop counter variable
    // It is a combinational always block
    // It is a ""generate-for loop"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = count4;
    
    
    
endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = count4;
    
    
    
endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, c_enable, c_load, c_d, reset, Q[3:0]
    
    // use count4 to have a counter that goes to 4, 8, 12, or 16
    // In this problem, I'm using a counter with a 16-bit value,
    // but you can change it to a 8, 12, or 16-bit value.
    // You'll need to change the line below to select the
    // appropriate counter.
    count4 the_counter (clk, c_enable, c_load, c_d, reset, Q[3:0]);
    
    // use a flip-flop to hold the counter's value
    // You may need to change the line below to select the
    // appropriate flip-flop type.
    flipflop count_FF (Q[3:0], clk, c_enable, c_load, c_d);
    
endmodule",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, c_enable, c_load, c_d, reset, Q[3:0]
    
    // use count4 to have a counter that goes to 4, 8, 12, or 16
    // In this problem, I'm using a counter with a 16-bit value,
    // but you can change it to a 8, 12, or 16-bit value.
    // You'll need to change the line below to select the
    // appropriate counter.
    count4 the_counter (clk, c_enable, c_load, c_d, reset, Q[3:0]);
    
    // use a flip-flop to hold the counter's value
    // You may need to change the line below to select the
    // appropriate flip-flop type.
    flipflop count_FF (Q[3:0], clk, c_enable, c_load, c_d);
    
endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    assign c_enable = enable & Q[0];
    assign c_load = Q[3] & Q[0];
    assign c_d[3] = Q[3] & ~Q[0];
    assign c_d[2] = Q[3] & Q[0];
    assign c_d[1] = Q[2] & Q[0];
    assign c_d[0] = Q[1] & Q[0];
    
endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    assign c_enable = enable & Q[0];
    assign c_load = Q[3] & Q[0];
    assign c_d[3] = Q[3] & ~Q[0];
    assign c_d[2] = Q[3] & Q[0];
    assign c_d[1] = Q[2] & Q[0];
    assign c_d[0] = Q[1] & Q[0];
    
endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //module1 the_counter (clk, reset, c_enable, c_load, c_d, Q[3:0]
    
    
    
endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //module1 the_counter (clk, reset, c_enable, c_load, c_d, Q[3:0]
    
    
    
endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
endmodule"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //module1 the_counter (clk, reset, c_enable, c_load, c_d,...);
    
    // Define the counter
    
    // Define the output
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //module1 the_counter (clk, reset, c_enable, c_load, c_d,...);
    
    // Define the counter
    
    // Define the output
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter
    
    // Define the input
    
    // Define the counter"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk,",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //assign {c_enable, c_load, c_d} = {1'b1, 1'b0, 1'b0};
    
    //count4 the_counter (clk,"
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    // Define the counter
    
    // Define the output
    assign c_enable = enable;
    assign c_load = reset | (Q[3] & Q[0]);
    assign c_d[3] = Q[3] & Q[0];
    assign c_d[2] = Q[3] & ~Q[0] & Q[1] | ~Q[3] & Q[0] & Q[1];
    assign c_d[1] = ~Q[3] & Q[0] & Q[1] | Q[3] & ~Q[0] & Q[1] | Q[3] & Q[0] & ~Q[1];
    assign c_d[0] = ~Q[3] & ~Q[0] & Q[1] | Q[3] & Q[0] & ~Q[1] | Q[3] & ~Q[0] & ~Q[1];
    
    // Next, count with a 1-bit synchronous counter
    
    // Define the counter
    
    // Define the output
    
    
    
endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    // Define the counter
    
    // Define the output
    assign c_enable = enable;
    assign c_load = reset | (Q[3] & Q[0]);
    assign c_d[3] = Q[3] & Q[0];
    assign c_d[2] = Q[3] & ~Q[0] & Q[1] | ~Q[3] & Q[0] & Q[1];
    assign c_d[1] = ~Q[3] & Q[0] & Q[1] | Q[3] & ~Q[0] & Q[1] | Q[3] & Q[0] & ~Q[1];
    assign c_d[0] = ~Q[3] & ~Q[0] & Q[1] | Q[3] & Q[0] & ~Q[1] | Q[3] & ~Q[0] & ~Q[1];
    
    // Next, count with a 1-bit synchronous counter
    
    // Define the counter
    
    // Define the output
    
    
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    // Define a 1 Hz pulse (OneHertz)
    //assign OneHertz = clk;
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    // Define a 1 Hz pulse (OneHertz)
    //assign OneHertz = clk;
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */);
    
    //provide a 1hz clock
    
    
    //with a 10us increment, and a ref_delay of 200h
    
    
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */);
    
    //provide a 1hz clock
    
    
    //with a 10us increment, and a ref_delay of 200h
    
    
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */);
    
    //provide a 1hz clock
    
    
    // other options are possible as well, such as a 10 MHz to 1Hz
    // frequency divider, a system counter, etc.
    
    
    // model min-max clock to output delay as a function of 
    // input range in order to create a more accurate
    // 1hz signal
    
    reg [8:0] min_pulse_width;
    reg [8:0] max_pulse_width;
    
    //this should be a fairly simple function, once we have the
    //two aforementioned counters, we can determine the
    //width of the pulse from the formula below
    
    assign c_enable[0] = (Q[3:0] == 4'd9 && Q[7:4] == 4'd5 && enable == 1'b1)? 1'b1 : 1'b0;
    assign c_enable[1] = (Q[3:0] == 4'd9 && Q[7:4] == 4'd5 && enable == 1'b1)? 1'b1 : 1'b0;
    assign c_enable[2] = (Q[3:0] == 4'd9 && Q[7:4] == 4'd5 && enable == 1'b1)? 1'b1 : 1'b0;
    
    
    
    always @(posedge clk)
    begin
        if(reset == 1'b1)
        begin
            min_pulse_width <= {(min_pulse_width_hex[3:0] > 4'd4)? 4'd4 : min_pulse_width_hex[3:0], 1'b0};
            max_pulse_width <= {(max_pulse_width_hex[3:0] < 4'd9)? 4'd9 : max_pulse_width_hex[3:0], 1'b1};
        end
        else
        begin
            min_pulse_width <= {(min_pulse_width_hex[3:0] > 4'd4)? 4'd4 : min_pulse_width_hex[3:0], 1'b0};
            max_pulse_width <= {(max_pulse_width_hex[3:0] < 4'd9)? 4'd9 : max_pulse_width_hex[3:0], 1'b1};
        end
    end
    
    // at each positive edge of the clock, output a 1
    // if the counter is between the min and the max
    // otherwise output a 0
    
    always @(posedge clk)
    begin
        if(reset == 1'b1)
        begin
            Q <= {(Q[3:0] < min_pulse_width)? min_pulse_width - Q[3:0] : Q[3:0], Q[7:4]};
        end
        else
        begin
            Q <= {(Q[3:0] < min_pulse_width)? min_pulse_width - Q[3:0] : Q[3:0], Q[7:4]};
        end
    end
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */);
    
    //provide a 1hz clock
    
    
    // other options are possible as well, such as a 10 MHz to 1Hz
    // frequency divider, a system counter, etc.
    
    
    // model min-max clock to output delay as a function of 
    // input range in order to create a more accurate
    // 1hz signal
    
    reg [8:0] min_pulse_width;
    reg [8:0] max_pulse_width;
    
    //this should be a fairly simple function, once we have the
    //two aforementioned counters, we can determine the
    //width of the pulse from the formula below
    
    assign c_enable[0] = (Q[3:0] == 4'd9 && Q[7:4] == 4'd5 && enable == 1'b1)? 1'b1 : 1'b0;
    assign c_enable[1] = (Q[3:0] == 4'd9 && Q[7:4] == 4'd5 && enable == 1'b1)? 1'b1 : 1'b0;
    assign c_enable[2] = (Q[3:0] == 4'd9 && Q[7:4] == 4'd5 && enable == 1'b1)? 1'b1 : 1'b0;
    
    
    
    always @(posedge clk)
    begin
        if(reset == 1'b1)
        begin
            min_pulse_width <= {(min_pulse_width_hex[3:0] > 4'd4)? 4'd4 : min_pulse_width_hex[3:0], 1'b0};
            max_pulse_width <= {(max_pulse_width_hex[3:0] < 4'd9)? 4'd9 : max_pulse_width_hex[3:0], 1'b1};
        end
        else
        begin
            min_pulse_width <= {(min_pulse_width_hex[3:0] > 4'd4)? 4'd4 : min_pulse_width_hex[3:0], 1'b0};
            max_pulse_width <= {(max_pulse_width_hex[3:0] < 4'd9)? 4'd9 : max_pulse_width_hex[3:0], 1'b1};
        end
    end
    
    // at each positive edge of the clock, output a 1
    // if the counter is between the min and the max
    // otherwise output a 0
    
    always @(posedge clk)
    begin
        if(reset == 1'b1)
        begin
            Q <= {(Q[3:0] < min_pulse_width)? min_pulse_width - Q[3:0] : Q[3:0], Q[7:4]};
        end
        else
        begin
            Q <= {(Q[3:0] < min_pulse_width)? min_pulse_width - Q[3:0] : Q[3:0], Q[7:4]};
        end
    end
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    // Define a 1 Hz pulse (one_hertz)
    //one_hertz_pulse one_hertz_pulse0 (clk, reset, one_hertz, one_hertz_pulse);
    
    // Define a 10-bit counter with a 2 Hz period (ten_bits)
    //ten_bits_counter ten_bits_counter0 (clk, reset, c_enable[0], Q[7:0]/*,... */);
    //ten_bits_counter ten_bits_counter1 (clk, reset, c_enable[1], Q[15:8]/*,... */);
    // Define an 8-bit counter with a 1 Hz period (eight_bits)
    //eight_bits_counter eight_bits_counter0 (clk, reset, c_enable[2], Q[7:0]/*,... */);
    //eight_bits_counter eight_bits_counter1 (clk, reset, c_enable[2], Q[15:8]/*,... */);
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    // Define a 1 Hz pulse (one_hertz)
    //one_hertz_pulse one_hertz_pulse0 (clk, reset, one_hertz, one_hertz_pulse);
    
    // Define a 10-bit counter with a 2 Hz period (ten_bits)
    //ten_bits_counter ten_bits_counter0 (clk, reset, c_enable[0], Q[7:0]/*,... */);
    //ten_bits_counter ten_bits_counter1 (clk, reset, c_enable[1], Q[15:8]/*,... */);
    // Define an 8-bit counter with a 1 Hz period (eight_bits)
    //eight_bits_counter eight_bits_counter0 (clk, reset, c_enable[2], Q[7:0]/*,... */);
    //eight_bits_counter eight_bits_counter1 (clk, reset, c_enable[2], Q[15:8]/*,... */);
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    //bcd_fadd f1(clk, reset, c_enable[0], {0,0,1,1,0,1,0,0}, {0,0,0,1,1,0,0,1});
    
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    //bcd_fadd f1(clk, reset, c_enable[0], {0,0,1,1,0,1,0,0}, {0,0,0,1,1,0,0,1});
    
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    // Define a 1 Hz pulse (OneHertz)
    //assign OneHertz = clk;
    
    // Define a 3-digit bcd counter
    //bcd_counter counter0 (clk, reset, c_enable[0],...);
    //bcd_counter counter1 (clk, reset, c_enable[1],...);
    //bcd_counter counter2 (clk, reset, c_enable[2],...);
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    // Define a 1 Hz pulse (OneHertz)
    //assign OneHertz = clk;
    
    // Define a 3-digit bcd counter
    //bcd_counter counter0 (clk, reset, c_enable[0],...);
    //bcd_counter counter1 (clk, reset, c_enable[1],...);
    //bcd_counter counter2 (clk, reset, c_enable[2],...);
    
endmodule"
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //provide a 1hz clock
    
    
    
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);

endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);

endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[2] & x[4]);
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    // Give the initial value and the clock
    reg q_reg;
    always @(posedge ena)
        q_reg <= d;
    
    // Output the value
    assign q = q_reg;
endmodule",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    // Give the initial value and the clock
    reg q_reg;
    always @(posedge ena)
        q_reg <= d;
    
    // Output the value
    assign q = q_reg;
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(ena)
        if(ena)
            q <= d;
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    always @(ena)
        if(ena)
            q <= d;
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    dff_latch d1(d, clk, 1'b1, q1, qb1);
    dff_latch d2(q1, clk, 1'b1, q2, qb2);
    dff_latch d3(q2, clk, 1'b1, q3, qb3);
    dff_latch d4(q3, clk, 1'b1, q, qb);
    
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    dff_latch d1(d, clk, 1'b1, q1, qb1);
    dff_latch d2(q1, clk, 1'b1, q2, qb2);
    dff_latch d3(q2, clk, 1'b1, q3, qb3);
    dff_latch d4(q3, clk, 1'b1, q, qb);
    
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    assign q = (ena)? d : q;
endmodule",1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    assign q = (ena)? d : q;
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;

endmodule",1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;

endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    wire t1;
    wire t2;
    wire t3;
    
    assign t1 = d & ena;
    assign t2 = t1 | q;
    assign t3 = t1 & ~q;
    assign q = t2 | t3;
    
endmodule",-0.5,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    wire t1;
    wire t2;
    wire t3;
    
    assign t1 = d & ena;
    assign t2 = t1 | q;
    assign t3 = t1 & ~q;
    assign q = t2 | t3;
    
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;

endmodule",1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;

endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;

endmodule",1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;

endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;
endmodule",1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    assign q = d & ena;
endmodule"
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    dff_latch d1(d, clk, rst, q_d);
    dff_latch d2(q_d, clk, rst, q);

endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);

    dff_latch d1(d, clk, rst, q_d);
    dff_latch d2(q_d, clk, rst, q);

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    d_ff d1 (clk, d, q1, q2, q3);
    d_ff d2 (clk, q1, q2, q3, q);

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    d_ff d1 (clk, d, q1, q2, q3);
    d_ff d2 (clk, q1, q2, q3, q);

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    always @(posedge clk, posedge ar)
        if(ar)
            q <= 0;
   		else
            q <= t;

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    always @(posedge clk, posedge ar)
        if(ar)
            q <= 0;
   		else
            q <= t;

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    d_ff_t ins1(clk, t, q, ar);

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    d_ff_t ins1(clk, t, q, ar);

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    dff_t ins1(clk, d, q1);
    dff_t ins2(clk, q1, q2);
    dff_t ins3(clk, q2, q3);
    dff_t ins4(clk, q3, q);

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    dff_t ins1(clk, d, q1);
    dff_t ins2(clk, q1, q2);
    dff_t ins3(clk, q2, q3);
    dff_t ins4(clk, q3, q);

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    always @(posedge clk, posedge ar)
        if(ar)
            q <= 1'b0;
   		else
            q <= t;

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    always @(posedge clk, posedge ar)
        if(ar)
            q <= 1'b0;
   		else
            q <= t;

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    d_ff d1 (clk, d, q1, q2, q3, q4, q5, q6);
    d_ff d2 (clk, q1, q2, q3, q4, q5, q6, q7);
    d_ff d3 (clk, q2, q3, q4, q5, q6, q7, q8);
    d_ff d4 (clk, q3, q4, q5, q6, q7, q8, q9);
    d_ff d5 (clk, q4, q5, q6, q7, q8, q9, q10);
    d_ff d6 (clk, q5, q6, q7, q8, q9, q10, q11);
    d_ff d7 (clk, q6, q7, q8, q9, q10, q11, q12);
    d_ff d8 (clk, q7, q8, q9, q10, q11, q12, q13);
    d_ff d9 (clk, q8, q9, q10, q11, q12, q13, q14);
    d_ff d10 (clk, q9, q10, q11, q12, q13, q14, q15);
    d_ff d11 (clk, q10, q11, q12, q13, q14, q15, q16);
    d_ff d12 (clk, q11, q12, q13, q14, q15, q16, q17);
    d_ff d13 (clk, q12, q13, q14, q15, q16, q17, q18);
    d_ff d14 (clk, q13, q14, q15, q16, q17, q18, q19);
    d_ff d15 (clk, q14, q15, q16, q17, q18, q19, q20);
    d_ff d16 (clk, q15, q16, q17, q18, q19, q20, q21);
    d_ff d17 (clk, q16, q17, q18, q19, q20, q21, q22);
    d_ff d18 (clk, q17, q18, q19, q20, q21, q22, q23);
    d_ff d19 (clk, q18, q19, q20, q21, q22, q23, q24);
    d_ff d20 (clk, q19, q20, q21, q22, q23, q24, q25);
    d_ff d21 (clk, q20, q21, q22, q23, q24, q25, q26);
    d_ff d22 (clk, q21, q22, q23, q24, q25, q26, q27);
    d_ff d23 (clk, q22, q23, q24, q25, q26, q27, q28);
    d_ff d24 (clk, q23, q24, q25, q26, q27, q28, q29);
    d_ff d25 (clk, q24, q25, q26, q27, q28, q29, q30);
    d_ff d26 (clk, q25, q26, q27, q28, q29, q30, q31);
    d_ff d27 (clk, q26, q27, q28, q29, q30, q31, q32);
    d_ff d28 (clk, q27, q28, q29, q30, q31, q32, q33);
    d_ff d29 (clk, q28, q29, q30, q31, q32, q33, q34);
    d_ff d30 (clk, q29, q30, q31, q32, q33, q34, q35);
    d_ff d31 (clk, q30, q31, q32, q33, q34, q35, q36);
    d_ff d32 (clk, q31, q32, q33, q34, q35, q36, q37);",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    d_ff d1 (clk, d, q1, q2, q3, q4, q5, q6);
    d_ff d2 (clk, q1, q2, q3, q4, q5, q6, q7);
    d_ff d3 (clk, q2, q3, q4, q5, q6, q7, q8);
    d_ff d4 (clk, q3, q4, q5, q6, q7, q8, q9);
    d_ff d5 (clk, q4, q5, q6, q7, q8, q9, q10);
    d_ff d6 (clk, q5, q6, q7, q8, q9, q10, q11);
    d_ff d7 (clk, q6, q7, q8, q9, q10, q11, q12);
    d_ff d8 (clk, q7, q8, q9, q10, q11, q12, q13);
    d_ff d9 (clk, q8, q9, q10, q11, q12, q13, q14);
    d_ff d10 (clk, q9, q10, q11, q12, q13, q14, q15);
    d_ff d11 (clk, q10, q11, q12, q13, q14, q15, q16);
    d_ff d12 (clk, q11, q12, q13, q14, q15, q16, q17);
    d_ff d13 (clk, q12, q13, q14, q15, q16, q17, q18);
    d_ff d14 (clk, q13, q14, q15, q16, q17, q18, q19);
    d_ff d15 (clk, q14, q15, q16, q17, q18, q19, q20);
    d_ff d16 (clk, q15, q16, q17, q18, q19, q20, q21);
    d_ff d17 (clk, q16, q17, q18, q19, q20, q21, q22);
    d_ff d18 (clk, q17, q18, q19, q20, q21, q22, q23);
    d_ff d19 (clk, q18, q19, q20, q21, q22, q23, q24);
    d_ff d20 (clk, q19, q20, q21, q22, q23, q24, q25);
    d_ff d21 (clk, q20, q21, q22, q23, q24, q25, q26);
    d_ff d22 (clk, q21, q22, q23, q24, q25, q26, q27);
    d_ff d23 (clk, q22, q23, q24, q25, q26, q27, q28);
    d_ff d24 (clk, q23, q24, q25, q26, q27, q28, q29);
    d_ff d25 (clk, q24, q25, q26, q27, q28, q29, q30);
    d_ff d26 (clk, q25, q26, q27, q28, q29, q30, q31);
    d_ff d27 (clk, q26, q27, q28, q29, q30, q31, q32);
    d_ff d28 (clk, q27, q28, q29, q30, q31, q32, q33);
    d_ff d29 (clk, q28, q29, q30, q31, q32, q33, q34);
    d_ff d30 (clk, q29, q30, q31, q32, q33, q34, q35);
    d_ff d31 (clk, q30, q31, q32, q33, q34, q35, q36);
    d_ff d32 (clk, q31, q32, q33, q34, q35, q36, q37);"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    d_ff_t ins1(clk, t, q, ar);

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t;
    assign t = d ^ q;
    
    d_ff_t ins1(clk, t, q, ar);

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    d_ff d1(clk, d, q1, q2);
    d_ff d2(clk, q1, q3, q4);
    d_ff d3(clk, q2, q5, q6);
    d_ff d4(clk, q3, q7, q);

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    d_ff d1(clk, d, q1, q2);
    d_ff d2(clk, q1, q3, q4);
    d_ff d3(clk, q2, q5, q6);
    d_ff d4(clk, q3, q7, q);

endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t1, t2, t3, t4, t5, t6;
    
    assign t1 = ~(ar)&d;
    assign t2 = ~(ar)&t1;
    assign t3 = ~(d)&ar;
    assign t4 = ~(d)&t3;
    assign t5 = ~(t1)&t4;
    assign t6 = ~(t2)&t5;
    
    assign q = ~(t6);
    
endmodule",-0.5,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    wire t1, t2, t3, t4, t5, t6;
    
    assign t1 = ~(ar)&d;
    assign t2 = ~(ar)&t1;
    assign t3 = ~(d)&ar;
    assign t4 = ~(d)&t3;
    assign t5 = ~(t1)&t4;
    assign t6 = ~(t2)&t5;
    
    assign q = ~(t6);
    
endmodule"
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk, posedge ar)
        if(ar)
            q <= 0;
   		else
            q <= d;

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk, posedge ar)
        if(ar)
            q <= 0;
   		else
            q <= d;

endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    reg q;
    
    always @(posedge clk)
        if(r)
            q <= 1'b0;
    	else
            q <= d;

endmodule",-0.5,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    reg q;
    
    always @(posedge clk)
        if(r)
            q <= 1'b0;
    	else
            q <= d;

endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        begin
            if(r==1'b1)
                q<=1'b0;
            else 
                q<=d;
        end
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        begin
            if(r==1'b1)
                q<=1'b0;
            else 
                q<=d;
        end
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    d_ff inst1 (clk, d, q1);
    d_ff inst2 (clk, q1, q2);
    d_ff inst3 (clk, q2, q);

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    d_ff inst1 (clk, d, q1);
    d_ff inst2 (clk, q1, q2);
    d_ff inst3 (clk, q2, q);

endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r)
            q <= 1'b0;
    	else
            q <= d;
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r)
            q <= 1'b0;
    	else
            q <= d;
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        begin
            if(r==1'b1)
                q<=1'b0;
            else
                q<=d;
        end
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        begin
            if(r==1'b1)
                q<=1'b0;
            else
                q<=d;
        end
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r == 1'b1)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r == 1'b1)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule"
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk)
        if(r==1'b1)
            q<=1'b0;
    	else
            q<=d;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = ~in;
endmodule",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = ~in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = ~in;
endmodule",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = ~in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = ~in;
endmodule",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    assign out = ~in;
endmodule"
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
        else
            q <= 10'd0;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
        else
            q <= 10'd0;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else if(q <= 10'd999)
                q <= q + 1'b1;
            else
                q <= 10'd0;
        end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else if(q <= 10'd999)
                q <= q + 1'b1;
            else
                q <= 10'd0;
        end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else if(q <= 10'd999)
                q <= q + 1'b1;
            else
                q <= 10'd0;
        end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else if(q <= 10'd999)
                q <= q + 1'b1;
            else
                q <= 10'd0;
        end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q == 10'd999)
            q <= 10'd0;
        else
            q <= q + 1'b1;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q == 10'd999)
            q <= 10'd0;
        else
            q <= q + 1'b1;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 999)
            q <= q + 1'b1;
        else
            q <= 10'd0;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 999)
            q <= q + 1'b1;
        else
            q <= 10'd0;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
        else
            q <= 10'd0;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else if(q <= 10'd999)
            q <= q + 1'b1;
        else
            q <= 10'd0;
    end
    
endmodule"
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;
    end
    
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;
    end
    
endmodule"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s1101111=4'd12, s1101111=4'd13, s1101111=4'd14, s1101111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s1101111=4'd12, s1101111=4'd13, s1101111=4'd14, s1101111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s11101111=4'd17, s111011101=4'd18, s111011110=4'd19, s111011111=4'd20, s11101111=4'd21, s111011101=4'd22, s111011110=4'd23, s111011111=4'd24, s11101111=4'd25, s111011101=4'd26, s111011110=4'd27, s111011111=4'd28, s11101111=4'd29, s111011101=4'd30, s111011110=4'd31, s111011111=4'd32, s11101111=4'd33, s111011101=4'd34, s111011110=4'd35, s111011111=4'd36, s11101111=4'd37, s111011101=4'd38, s111011110=4'd39, s111011111=4'd40, s11101111=4'd41, s111011101=4'd42, s111011110=4'd43, s111011111=4'd44, s11101111=4'd45, s111011101=4'd46, s111011110=4'd47, s111011111=4'd48, s11101111=4'd49, s111011101=4'd50, s111011110=4'd51, s111011111=4'd52, s11101111=4'd53, s111011101=4'd54, s111011110=4'd55, s111011111=4'd56, s11101111=4'd57, s111011101=4'd58, s111011110=4'd59, s111011111=4'd60, s11101111=4'd61, s111011101=4'd62, s111011110=4'd63, s111011111=4'd64, s11101111=4'd65, s111011101=4'd66, s111011110=4'd67, s111011111=4'd68, s11101111=4'd69, s111011101=4'd70, s111011110=4'd71, s111011111=4'd72, s11101111=4'd73, s111011101=4'd74, s111011110=4'd75, s111011111=4'd76, s11101111=4'd77, s111011101=4'd78, s111011110=4'd79, s111011111=4'd80, s11101111=4'd81, s111011101=4'd82, s111011110=4'd83, s111011111=4'd84, s11101111=4'd85, s111011101=4'd86, s111011110=4'd87, s111011111=4'd88, s11101111=4'd89, s111011101=4'd90, s111011110=4'd91, s111011111=4'd92, s11101111=4'd93, s111011101=4'd94, s111011110=4'd95, s111011111=4'd96, s11101111=4'd97, s111011101=4'd98, s111011110=4'd99, s111011111=4'd100, s11101111=4'd101, s111011101=4'd102, s111011110=4'd103, s111011111=4'd104, s11101111=4'd105, s111011101=4'd106, s111011110=4'd107, s111011111=4'd108, s",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s11101111=4'd17, s111011101=4'd18, s111011110=4'd19, s111011111=4'd20, s11101111=4'd21, s111011101=4'd22, s111011110=4'd23, s111011111=4'd24, s11101111=4'd25, s111011101=4'd26, s111011110=4'd27, s111011111=4'd28, s11101111=4'd29, s111011101=4'd30, s111011110=4'd31, s111011111=4'd32, s11101111=4'd33, s111011101=4'd34, s111011110=4'd35, s111011111=4'd36, s11101111=4'd37, s111011101=4'd38, s111011110=4'd39, s111011111=4'd40, s11101111=4'd41, s111011101=4'd42, s111011110=4'd43, s111011111=4'd44, s11101111=4'd45, s111011101=4'd46, s111011110=4'd47, s111011111=4'd48, s11101111=4'd49, s111011101=4'd50, s111011110=4'd51, s111011111=4'd52, s11101111=4'd53, s111011101=4'd54, s111011110=4'd55, s111011111=4'd56, s11101111=4'd57, s111011101=4'd58, s111011110=4'd59, s111011111=4'd60, s11101111=4'd61, s111011101=4'd62, s111011110=4'd63, s111011111=4'd64, s11101111=4'd65, s111011101=4'd66, s111011110=4'd67, s111011111=4'd68, s11101111=4'd69, s111011101=4'd70, s111011110=4'd71, s111011111=4'd72, s11101111=4'd73, s111011101=4'd74, s111011110=4'd75, s111011111=4'd76, s11101111=4'd77, s111011101=4'd78, s111011110=4'd79, s111011111=4'd80, s11101111=4'd81, s111011101=4'd82, s111011110=4'd83, s111011111=4'd84, s11101111=4'd85, s111011101=4'd86, s111011110=4'd87, s111011111=4'd88, s11101111=4'd89, s111011101=4'd90, s111011110=4'd91, s111011111=4'd92, s11101111=4'd93, s111011101=4'd94, s111011110=4'd95, s111011111=4'd96, s11101111=4'd97, s111011101=4'd98, s111011110=4'd99, s111011111=4'd100, s11101111=4'd101, s111011101=4'd102, s111011110=4'd103, s111011111=4'd104, s11101111=4'd105, s111011101=4'd106, s111011110=4'd107, s111011111=4'd108, s"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s11101111=4'd17, s111011101=4'd18, s111011110=4'd19, s111011111=4'd20, s11101111=4'd21, s111011101=4'd22, s111011110=4'd23, s111011111=4'd24, s11101111=4'd25, s111011101=4'd26, s111011110=4'd27, s111011111=4'd28, s11101111=4'd29, s111011101=4'd30, s111011110=4'd31, s111011111=4'd32, s11101111=4'd33, s111011101=4'd34, s111011110=4'd35, s111011111=4'd36, s11101111=4'd37, s111011101=4'd38, s111011110=4'd39, s111011111=4'd40, s11101111=4'd41, s111011101=4'd42, s111011110=4'd43, s111011111=4'd44, s11101111=4'd45, s111011101=4'd46, s111011110=4'd47, s111011111=4'd48, s11101111=4'd49, s111011101=4'd50, s111011110=4'd51, s111011111=4'd52, s11101111=4'd53, s111011101=4'd54, s111011110=4'd55, s111011111=4'd56, s11101111=4'd57, s111011101=4'd58, s111011110=4'd59, s111011111=4'd60, s11101111=4'd61, s111011101=4'd62, s111011110=4'd63, s111011111=4'd64, s11101111=4'd65, s111011101=4'd66, s111011110=4'd67, s111011111=4'd68, s11101111=4'd69, s111011101=4'd70, s111011110=4'd71, s111011111=4'd72, s11101111=4'd73, s111011101=4'd74, s111011110=4'd75, s111011111=4'd76, s11101111=4'd77, s111011101=4'd78, s111011110=4'd79, s111011111=4'd80, s11101111=4'd81, s111011101=4'd82, s111011110=4'd83, s111011111=4'd84, s11101111=4'd85, s111011101=4'd86, s111011110=4'd87, s111011111=4'd88, s11101111=4'd89, s111011101=4'd90, s111011110=4'd91, s111011111=4'd92, s11101111=4'd93, s111011101=4'd94, s111011110=4'd95, s111011111=4'd96, s11101111=4'd97, s111011101=4'd98, s111011110=4'd99, s111011111=4'd100, s11101111=4'd101, s111011101=4'd102, s111011110=4'd103, s111011111=4'd104, s11101111=4'd105, s111011101=4'd106, s111011110=4'd107, s111011111=4'd108, s",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s11101111=4'd17, s111011101=4'd18, s111011110=4'd19, s111011111=4'd20, s11101111=4'd21, s111011101=4'd22, s111011110=4'd23, s111011111=4'd24, s11101111=4'd25, s111011101=4'd26, s111011110=4'd27, s111011111=4'd28, s11101111=4'd29, s111011101=4'd30, s111011110=4'd31, s111011111=4'd32, s11101111=4'd33, s111011101=4'd34, s111011110=4'd35, s111011111=4'd36, s11101111=4'd37, s111011101=4'd38, s111011110=4'd39, s111011111=4'd40, s11101111=4'd41, s111011101=4'd42, s111011110=4'd43, s111011111=4'd44, s11101111=4'd45, s111011101=4'd46, s111011110=4'd47, s111011111=4'd48, s11101111=4'd49, s111011101=4'd50, s111011110=4'd51, s111011111=4'd52, s11101111=4'd53, s111011101=4'd54, s111011110=4'd55, s111011111=4'd56, s11101111=4'd57, s111011101=4'd58, s111011110=4'd59, s111011111=4'd60, s11101111=4'd61, s111011101=4'd62, s111011110=4'd63, s111011111=4'd64, s11101111=4'd65, s111011101=4'd66, s111011110=4'd67, s111011111=4'd68, s11101111=4'd69, s111011101=4'd70, s111011110=4'd71, s111011111=4'd72, s11101111=4'd73, s111011101=4'd74, s111011110=4'd75, s111011111=4'd76, s11101111=4'd77, s111011101=4'd78, s111011110=4'd79, s111011111=4'd80, s11101111=4'd81, s111011101=4'd82, s111011110=4'd83, s111011111=4'd84, s11101111=4'd85, s111011101=4'd86, s111011110=4'd87, s111011111=4'd88, s11101111=4'd89, s111011101=4'd90, s111011110=4'd91, s111011111=4'd92, s11101111=4'd93, s111011101=4'd94, s111011110=4'd95, s111011111=4'd96, s11101111=4'd97, s111011101=4'd98, s111011110=4'd99, s111011111=4'd100, s11101111=4'd101, s111011101=4'd102, s111011110=4'd103, s111011111=4'd104, s11101111=4'd105, s111011101=4'd106, s111011110=4'd107, s111011111=4'd108, s"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s1110111=4'd17, s11101111=4'd18, s111011101=4'd19, s111011110=4'd20, s111011111=4'd21, s11101111=4'd22, s111011101=4'd23, s111011110=4'd24, s111011111=4'd25, s11101111=4'd26, s111011101=4'd27, s111011110=4'd28, s111011111=4'd29, s11101111=4'd30, s111011101=4'd31, s111011110=4'd32, s111011111=4'd33, s11101111=4'd34, s111011101=4'd35, s111011110=4'd36, s111011111=4'd37, s11101111=4'd38, s111011101=4'd39, s111011110=4'd40, s111011111=4'd41, s11101111=4'd42, s111011101=4'd43, s111011110=4'd44, s111011111=4'd45, s11101111=4'd46, s111011101=4'd47, s111011110=4'd48, s111011111=4'd49, s11101111=4'd50, s111011101=4'd51, s111011110=4'd52, s111011111=4'd53, s11101111=4'd54, s111011101=4'd55, s111011110=4'd56, s111011111=4'd57, s11101111=4'd58, s111011101=4'd59, s111011110=4'd60, s111011111=4'd61, s11101111=4'd62, s111011101=4'd63, s111011110=4'd64, s111011111=4'd65, s11101111=4'd66, s111011101=4'd67, s111011110=4'd68, s111011111=4'd69, s11101111=4'd70, s111011101=4'd71, s111011110=4'd72, s111011111=4'd73, s11101111=4'd74, s111011101=4'd75, s111011110=4'd76, s111011111=4'd77, s11101111=4'd78, s111011101=4'd79, s111011110=4'd80, s111011111=4'd81, s11101111=4'd82, s111011101=4'd83, s111011110=4'd84, s111011111=4'd85, s11101111=4'd86, s111011101=4'd87, s111011110=4'd88, s111011111=4'd89, s11101111=4'd90, s111011101=4'd91, s111011110=4'd92, s111011111=4'd93, s11101111=4'd94, s111011101=4'd95, s111011110=4'd96, s111011111=4'd97, s11101111=4'd98, s111011101=4'd99, s111011110=4'd100, s111011111=4'd101, s11101111=4'd102, s111011101=4'd103, s111011110=4'd104, s111011111=4'd105, s11101111=4'd106, s111011101=4'd107, s111011110=4'd108, s",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s1110111=4'd17, s11101111=4'd18, s111011101=4'd19, s111011110=4'd20, s111011111=4'd21, s11101111=4'd22, s111011101=4'd23, s111011110=4'd24, s111011111=4'd25, s11101111=4'd26, s111011101=4'd27, s111011110=4'd28, s111011111=4'd29, s11101111=4'd30, s111011101=4'd31, s111011110=4'd32, s111011111=4'd33, s11101111=4'd34, s111011101=4'd35, s111011110=4'd36, s111011111=4'd37, s11101111=4'd38, s111011101=4'd39, s111011110=4'd40, s111011111=4'd41, s11101111=4'd42, s111011101=4'd43, s111011110=4'd44, s111011111=4'd45, s11101111=4'd46, s111011101=4'd47, s111011110=4'd48, s111011111=4'd49, s11101111=4'd50, s111011101=4'd51, s111011110=4'd52, s111011111=4'd53, s11101111=4'd54, s111011101=4'd55, s111011110=4'd56, s111011111=4'd57, s11101111=4'd58, s111011101=4'd59, s111011110=4'd60, s111011111=4'd61, s11101111=4'd62, s111011101=4'd63, s111011110=4'd64, s111011111=4'd65, s11101111=4'd66, s111011101=4'd67, s111011110=4'd68, s111011111=4'd69, s11101111=4'd70, s111011101=4'd71, s111011110=4'd72, s111011111=4'd73, s11101111=4'd74, s111011101=4'd75, s111011110=4'd76, s111011111=4'd77, s11101111=4'd78, s111011101=4'd79, s111011110=4'd80, s111011111=4'd81, s11101111=4'd82, s111011101=4'd83, s111011110=4'd84, s111011111=4'd85, s11101111=4'd86, s111011101=4'd87, s111011110=4'd88, s111011111=4'd89, s11101111=4'd90, s111011101=4'd91, s111011110=4'd92, s111011111=4'd93, s11101111=4'd94, s111011101=4'd95, s111011110=4'd96, s111011111=4'd97, s11101111=4'd98, s111011101=4'd99, s111011110=4'd100, s111011111=4'd101, s11101111=4'd102, s111011101=4'd103, s111011110=4'd104, s111011111=4'd105, s11101111=4'd106, s111011101=4'd107, s111011110=4'd108, s"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s1101;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1101;
            end
            s1101: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(reset)
            count <= 4'd0;
        else if(next_state==s1101)
            count <= count + 4'd1;
        else if(next_state==s1101 && count==9)
            count <= 4'd0;
    end
    
    always@(posedge clk) begin
        if(reset)
            done <= 1'b0;
        else if(next_state==s1101)
            done <= 1'b1;
        else if(next_state==s1101 && count==9)
            done <= 1'b0;
    end
    
    always@(posedge clk) begin
        if(reset)
            counting <= 1'b0;
        else if(next_state==s1101)
            counting <= 1'b1;
        else if(next_state==s1101 && count==9)
            counting <= 1'b0;
    end
    
    assign	count = count_reg;
    assign	counting = counting_reg;
    
endmodule",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s1101;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1101;
            end
            s1101: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(reset)
            count <= 4'd0;
        else if(next_state==s1101)
            count <= count + 4'd1;
        else if(next_state==s1101 && count==9)
            count <= 4'd0;
    end
    
    always@(posedge clk) begin
        if(reset)
            done <= 1'b0;
        else if(next_state==s1101)
            done <= 1'b1;
        else if(next_state==s1101 && count==9)
            done <= 1'b0;
    end
    
    always@(posedge clk) begin
        if(reset)
            counting <= 1'b0;
        else if(next_state==s1101)
            counting <= 1'b1;
        else if(next_state==s1101 && count==9)
            counting <= 1'b0;
    end
    
    assign	count = count_reg;
    assign	counting = counting_reg;
    
endmodule"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s11010111=4'd7, s110111=4'd8, s1101111=4'd9, s11011111=4'd10, s111=4'd11, s11101=4'd12, s111011=4'd13, s11101111=4'd14, s111011111=4'd15, s1111=4'd16, s111101=4'd17, s1111011=4'd18, s11110111=4'd19, s111111=4'd20, s1111111=4'd21, s11111111=4'd22, s11101111=4'd23, s111011111=4'd24, s111111111=4'd25, s111111111111=4'd26, s111111101111=4'd27, s1111111011111=4'd28, s1111111110000=4'd29, s1111111111111=4'd30, s111111111111111=4'd31, s1111111111111111=4'd32, s1111111111111111111=4'd33, s1111111111111111111=4'd34, s1111111111111111111=4'd35, s1111111111111111111=4'd36, s1111111111111111111=4'd37, s1111111111111111111=4'd38, s1111111111111111111=4'd39, s1111111111111111111=4'd40, s1111111111111111111=4'd41, s1111111111111111111=4'd42, s1111111111111111111=4'd43, s1111111111111111111=4'd44, s1111111111111111111=4'd45, s1111111111111111111=4'd46, s1111111111111111111=4'd47, s1111111111111111111=4'd48, s1111111111111111111=4'd49, s1111111111111111111=4'd50, s1111111111111111111=4'd51, s1111111111111111111=4'd52, s1111111111111111111=4'd53, s1111111111111111111=4'd54, s1111111111111111111=4'd55, s1111111111111111111=4'd56, s1111111111111111111=4'd57, s1111111111111111111=4'd58, s1111111111111111111=4'd59, s1111111111111111111=4'd60, s1111111111111111111=4'd61, s1111111111111111111=4'd62, s1111111111111111111=4'd63, s1111111111111111111=4'd64, s1111111111111111111=4'd65, s1111111111111111111=4'd66, s1111111111111111111=4'd67, s1111111111111111111=4'd68, s1111111111111111111=4'd69, s1111111111111111111=4'd70, s1111111111111111111=4'd71, s1111111111111111111=4'd72, s1111111111111111111=4'd73, s1111111111111111111=4'd74, s1111111111111111111=4'd75, s1111111111111111111=4'd76, s1111111111111111111=4'd77, s1111111111111111111=4'd78, s1111111111111111111=4'd79, s1111111111111111111=4'd80, s1111111111111111111=4'd81, s1111111111111111111=4'd82, s1111111111111111111=4'd83, s1111111111111111111=4'd84, s1111111111111111111=4'd85, s1111111111111111111=4'd86, s1111111111111111111=4'd87, s1111111111111111111=4'd88, s1111111111111111111=4'd89, s1111111111111111111=4'd90, s1111111111111111111=4'd91, s1111111111111111111=4'd92, s1111111111111111111=4'd93, s1111111111111111111=4'd94, s1111111111111111111=4'd95, s1111111111111111111=4'd96, s1111111111111111111=4'd97, s1111111111111111111=4'd98, s1111111111111111111=4'd99",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s11010111=4'd7, s110111=4'd8, s1101111=4'd9, s11011111=4'd10, s111=4'd11, s11101=4'd12, s111011=4'd13, s11101111=4'd14, s111011111=4'd15, s1111=4'd16, s111101=4'd17, s1111011=4'd18, s11110111=4'd19, s111111=4'd20, s1111111=4'd21, s11111111=4'd22, s11101111=4'd23, s111011111=4'd24, s111111111=4'd25, s111111111111=4'd26, s111111101111=4'd27, s1111111011111=4'd28, s1111111110000=4'd29, s1111111111111=4'd30, s111111111111111=4'd31, s1111111111111111=4'd32, s1111111111111111111=4'd33, s1111111111111111111=4'd34, s1111111111111111111=4'd35, s1111111111111111111=4'd36, s1111111111111111111=4'd37, s1111111111111111111=4'd38, s1111111111111111111=4'd39, s1111111111111111111=4'd40, s1111111111111111111=4'd41, s1111111111111111111=4'd42, s1111111111111111111=4'd43, s1111111111111111111=4'd44, s1111111111111111111=4'd45, s1111111111111111111=4'd46, s1111111111111111111=4'd47, s1111111111111111111=4'd48, s1111111111111111111=4'd49, s1111111111111111111=4'd50, s1111111111111111111=4'd51, s1111111111111111111=4'd52, s1111111111111111111=4'd53, s1111111111111111111=4'd54, s1111111111111111111=4'd55, s1111111111111111111=4'd56, s1111111111111111111=4'd57, s1111111111111111111=4'd58, s1111111111111111111=4'd59, s1111111111111111111=4'd60, s1111111111111111111=4'd61, s1111111111111111111=4'd62, s1111111111111111111=4'd63, s1111111111111111111=4'd64, s1111111111111111111=4'd65, s1111111111111111111=4'd66, s1111111111111111111=4'd67, s1111111111111111111=4'd68, s1111111111111111111=4'd69, s1111111111111111111=4'd70, s1111111111111111111=4'd71, s1111111111111111111=4'd72, s1111111111111111111=4'd73, s1111111111111111111=4'd74, s1111111111111111111=4'd75, s1111111111111111111=4'd76, s1111111111111111111=4'd77, s1111111111111111111=4'd78, s1111111111111111111=4'd79, s1111111111111111111=4'd80, s1111111111111111111=4'd81, s1111111111111111111=4'd82, s1111111111111111111=4'd83, s1111111111111111111=4'd84, s1111111111111111111=4'd85, s1111111111111111111=4'd86, s1111111111111111111=4'd87, s1111111111111111111=4'd88, s1111111111111111111=4'd89, s1111111111111111111=4'd90, s1111111111111111111=4'd91, s1111111111111111111=4'd92, s1111111111111111111=4'd93, s1111111111111111111=4'd94, s1111111111111111111=4'd95, s1111111111111111111=4'd96, s1111111111111111111=4'd97, s1111111111111111111=4'd98, s1111111111111111111=4'd99"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s1101111=4'd12, s1101111=4'd13, s1101111=4'd14, s1101111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s1101111=4'd12, s1101111=4'd13, s1101111=4'd14, s1101111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s111=4'd12, s111=4'd13, s111=4'd14, s111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101111=4'd114, s11",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s111=4'd12, s111=4'd13, s111=4'd14, s111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101111=4'd114, s11"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s111=4'd12, s111=4'd13, s111=4'd14, s111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101111=4'd114, s11",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s1101111=4'd11, s111=4'd12, s111=4'd13, s111=4'd14, s111=4'd15, s1101111=4'd16, s1101111=4'd17, s1101111=4'd18, s1101111=4'd19, s1101111=4'd20, s1101111=4'd21, s1101111=4'd22, s1101111=4'd23, s1101111=4'd24, s1101111=4'd25, s1101111=4'd26, s1101111=4'd27, s1101111=4'd28, s1101111=4'd29, s1101111=4'd30, s1101111=4'd31, s1101111=4'd32, s1101111=4'd33, s1101111=4'd34, s1101111=4'd35, s1101111=4'd36, s1101111=4'd37, s1101111=4'd38, s1101111=4'd39, s1101111=4'd40, s1101111=4'd41, s1101111=4'd42, s1101111=4'd43, s1101111=4'd44, s1101111=4'd45, s1101111=4'd46, s1101111=4'd47, s1101111=4'd48, s1101111=4'd49, s1101111=4'd50, s1101111=4'd51, s1101111=4'd52, s1101111=4'd53, s1101111=4'd54, s1101111=4'd55, s1101111=4'd56, s1101111=4'd57, s1101111=4'd58, s1101111=4'd59, s1101111=4'd60, s1101111=4'd61, s1101111=4'd62, s1101111=4'd63, s1101111=4'd64, s1101111=4'd65, s1101111=4'd66, s1101111=4'd67, s1101111=4'd68, s1101111=4'd69, s1101111=4'd70, s1101111=4'd71, s1101111=4'd72, s1101111=4'd73, s1101111=4'd74, s1101111=4'd75, s1101111=4'd76, s1101111=4'd77, s1101111=4'd78, s1101111=4'd79, s1101111=4'd80, s1101111=4'd81, s1101111=4'd82, s1101111=4'd83, s1101111=4'd84, s1101111=4'd85, s1101111=4'd86, s1101111=4'd87, s1101111=4'd88, s1101111=4'd89, s1101111=4'd90, s1101111=4'd91, s1101111=4'd92, s1101111=4'd93, s1101111=4'd94, s1101111=4'd95, s1101111=4'd96, s1101111=4'd97, s1101111=4'd98, s1101111=4'd99, s1101111=4'd100, s1101111=4'd101, s1101111=4'd102, s1101111=4'd103, s1101111=4'd104, s1101111=4'd105, s1101111=4'd106, s1101111=4'd107, s1101111=4'd108, s1101111=4'd109, s1101111=4'd110, s1101111=4'd111, s1101111=4'd112, s1101111=4'd113, s1101111=4'd114, s11"
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s11101111=4'd17, s111011101=4'd18, s111011110=4'd19, s111011111=4'd20, s1110111111=4'd21, s1110101111=4'd22, s1110111111=4'd23, s111010111111=4'd24, s1110111111=4'd25, s111010101111=4'd26, s1110111111=4'd27, s111010111111=4'd28, s1110111111=4'd29, s111010101111=4'd30, s1110111111=4'd31, s111010111111=4'd32, s1110111111=4'd33, s111010101111=4'd34, s1110111111=4'd35, s111010111111=4'd36, s1110111111=4'd37, s111010101111=4'd38, s1110111111=4'd39, s111010111111=4'd40, s1110111111=4'd41, s111010101111=4'd42, s1110111111=4'd43, s111010111111=4'd44, s1110111111=4'd45, s111010101111=4'd46, s1110111111=4'd47, s111010111111=4'd48, s1110111111=4'd49, s111010101111=4'd50, s1110111111=4'd51, s111010111111=4'd52, s1110111111=4'd53, s111010101111=4'd54, s1110111111=4'd55, s111010111111=4'd56, s1110111111=4'd57, s111010101111=4'd58, s1110111111=4'd59, s111010111111=4'd60, s1110111111=4'd61, s111010101111=4'd62, s1110111111=4'd63, s111010111111=4'd64, s1110111111=4'd65, s111010101111=4'd66, s1110111111=4'd67, s111010111111=4'd68, s1110111111=4'd69, s111010101111=4'd70, s1110111111=4'd71, s111010111111=4'd72, s1110111111=4'd73, s111010101111=4'd74, s1110111111=4'd75, s111010111111=4'd76, s1110111111=4'd77, s111010101111=4'd78, s1110111111=4'd79, s111010111111=4'd80, s1110111111=4'd81, s111010101111=4'd82, s1110111111=4'd83, s111010111111=4'd84, s1110111111=4'd85, s111010101111=4'd86, s1110111111=4'd87, s111010111111=4'd88, s1110111111=4'd89, s111010101111=4'd90, s1110111111=4'd91, s111010111111=4'd92, s1110111111=4'd93, s111010101111=4'd94, s1110111111=4'd95, s111010111111=4'd96, s1110111111=4'd97, s111010101111=4'd98, s1110111111=4'd99, s111010111111=4'd",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s1101010=4'd7, s11010111=4'd8, s110111=4'd9, s1101111=4'd10, s11011101=4'd11, s11011110=4'd12, s11011111=4'd13, s11101=4'd14, s1110101=4'd15, s1110110=4'd16, s11101111=4'd17, s111011101=4'd18, s111011110=4'd19, s111011111=4'd20, s1110111111=4'd21, s1110101111=4'd22, s1110111111=4'd23, s111010111111=4'd24, s1110111111=4'd25, s111010101111=4'd26, s1110111111=4'd27, s111010111111=4'd28, s1110111111=4'd29, s111010101111=4'd30, s1110111111=4'd31, s111010111111=4'd32, s1110111111=4'd33, s111010101111=4'd34, s1110111111=4'd35, s111010111111=4'd36, s1110111111=4'd37, s111010101111=4'd38, s1110111111=4'd39, s111010111111=4'd40, s1110111111=4'd41, s111010101111=4'd42, s1110111111=4'd43, s111010111111=4'd44, s1110111111=4'd45, s111010101111=4'd46, s1110111111=4'd47, s111010111111=4'd48, s1110111111=4'd49, s111010101111=4'd50, s1110111111=4'd51, s111010111111=4'd52, s1110111111=4'd53, s111010101111=4'd54, s1110111111=4'd55, s111010111111=4'd56, s1110111111=4'd57, s111010101111=4'd58, s1110111111=4'd59, s111010111111=4'd60, s1110111111=4'd61, s111010101111=4'd62, s1110111111=4'd63, s111010111111=4'd64, s1110111111=4'd65, s111010101111=4'd66, s1110111111=4'd67, s111010111111=4'd68, s1110111111=4'd69, s111010101111=4'd70, s1110111111=4'd71, s111010111111=4'd72, s1110111111=4'd73, s111010101111=4'd74, s1110111111=4'd75, s111010111111=4'd76, s1110111111=4'd77, s111010101111=4'd78, s1110111111=4'd79, s111010111111=4'd80, s1110111111=4'd81, s111010101111=4'd82, s1110111111=4'd83, s111010111111=4'd84, s1110111111=4'd85, s111010101111=4'd86, s1110111111=4'd87, s111010111111=4'd88, s1110111111=4'd89, s111010101111=4'd90, s1110111111=4'd91, s111010111111=4'd92, s1110111111=4'd93, s111010101111=4'd94, s1110111111=4'd95, s111010111111=4'd96, s1110111111=4'd97, s111010101111=4'd98, s1110111111=4'd99, s111010111111=4'd"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // Define states
    localparam  IDLE = 1'b0,
                START_1 = 1'b1;
    
    // Define the counter
    
    localparam  DELAY = 5,
                DELAY_RANGE = 5;
    
    // Define the shift register
    
    localparam  PATTERN = 11'b10101010101010101,
                PATTERN_LENGTH = 17,
                PATTERN_WIDTH = 8,
                PATTERN_COUNT = PATTERN_LENGTH - 1,
                START_IDLE = {PATTERN_LENGTH{1'b0}},
                START_1 = {PATTERN_LENGTH{1'b1}},
                DELAY_RANGE = {(DELAY_RANGE){1'b0}};
    
    // Define the counter
    
    reg [PATTERN_COUNT:0] count;
    reg [PATTERN_WIDTH:0] bit_count;
    reg [PATTERN_LENGTH:0] bit_count_r;
    
    // Define the shift register
    
    reg [PATTERN_WIDTH:0] shift_reg;
    reg [PATTERN_LENGTH:0] shift_reg_r;
    
    // Define the outputs
    
    reg shift_ena;
    reg counting;
    reg done;
    reg ack_count;
    reg ack_done;
    
    // Define the states
    
    reg [1:0] state;
    reg [1:0] state_next;
    
    // Define the variables
    
    reg [PATTERN_LENGTH:0] index;
    reg [PATTERN_WIDTH:0] i;
    reg [PATTERN_WIDTH:0] j;
    reg [PATTERN_LENGTH:0] bit_index;
    reg [PATTERN_WIDTH:0] bit_count_r_next;
    reg [PATTERN_WIDTH:0] bit_count_r_r;
    reg [PATTERN_LENGTH:0] index_next;
    reg [PATTERN_WIDTH:0] i_next;
    reg [PATTERN_WIDTH:0] j_next;
    reg [PATTERN_LENGTH:0] bit_index_next;
    reg [PATTERN_WIDTH:0] bit_count_r_next_int;
    reg [PATTERN_WIDTH:0] bit_count_r_int;
    reg [PATTERN_LENGTH:0] index_int;
    reg [PATTERN_WIDTH:0] i_int;
    reg [PATTERN_WIDTH:0] j_int;
    reg [PATTERN_LENGTH:0] bit_index_int;
    reg [PATTERN_WIDTH:0] bit_count_r_next_r;
    reg [PATTERN_WIDTH:0] bit_count_r_int_r;
    reg [PATTERN_LENGTH:0] index_int_r;
    reg [PATTERN_WIDTH:0] i_int_r;
    reg [PATTERN_WIDTH:0] j_int_r;
    reg [PATTERN_LENGTH:0] bit_index_int_r;
    reg [PATTERN_WIDTH:0] bit_count_r_next_rr;
    reg [PATTERN_WIDTH:0] bit_count_r_int_rr;
    reg [PATTERN_LENGTH:0] index_int_r_r;
    reg [PATTERN_WIDTH:0] i_int_r_r;
    reg [PATTERN_WIDTH:0] j_int_r_r;
    reg [PATTERN_LENGTH:0] bit_index_int_r_r;
    reg [PATTERN_WIDTH:0] bit_count_r_next_rrr;
    reg [PATTERN_WIDTH:0] bit_count_r_int_rrr;
    reg [PATTERN",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // Define states
    localparam  IDLE = 1'b0,
                START_1 = 1'b1;
    
    // Define the counter
    
    localparam  DELAY = 5,
                DELAY_RANGE = 5;
    
    // Define the shift register
    
    localparam  PATTERN = 11'b10101010101010101,
                PATTERN_LENGTH = 17,
                PATTERN_WIDTH = 8,
                PATTERN_COUNT = PATTERN_LENGTH - 1,
                START_IDLE = {PATTERN_LENGTH{1'b0}},
                START_1 = {PATTERN_LENGTH{1'b1}},
                DELAY_RANGE = {(DELAY_RANGE){1'b0}};
    
    // Define the counter
    
    reg [PATTERN_COUNT:0] count;
    reg [PATTERN_WIDTH:0] bit_count;
    reg [PATTERN_LENGTH:0] bit_count_r;
    
    // Define the shift register
    
    reg [PATTERN_WIDTH:0] shift_reg;
    reg [PATTERN_LENGTH:0] shift_reg_r;
    
    // Define the outputs
    
    reg shift_ena;
    reg counting;
    reg done;
    reg ack_count;
    reg ack_done;
    
    // Define the states
    
    reg [1:0] state;
    reg [1:0] state_next;
    
    // Define the variables
    
    reg [PATTERN_LENGTH:0] index;
    reg [PATTERN_WIDTH:0] i;
    reg [PATTERN_WIDTH:0] j;
    reg [PATTERN_LENGTH:0] bit_index;
    reg [PATTERN_WIDTH:0] bit_count_r_next;
    reg [PATTERN_WIDTH:0] bit_count_r_r;
    reg [PATTERN_LENGTH:0] index_next;
    reg [PATTERN_WIDTH:0] i_next;
    reg [PATTERN_WIDTH:0] j_next;
    reg [PATTERN_LENGTH:0] bit_index_next;
    reg [PATTERN_WIDTH:0] bit_count_r_next_int;
    reg [PATTERN_WIDTH:0] bit_count_r_int;
    reg [PATTERN_LENGTH:0] index_int;
    reg [PATTERN_WIDTH:0] i_int;
    reg [PATTERN_WIDTH:0] j_int;
    reg [PATTERN_LENGTH:0] bit_index_int;
    reg [PATTERN_WIDTH:0] bit_count_r_next_r;
    reg [PATTERN_WIDTH:0] bit_count_r_int_r;
    reg [PATTERN_LENGTH:0] index_int_r;
    reg [PATTERN_WIDTH:0] i_int_r;
    reg [PATTERN_WIDTH:0] j_int_r;
    reg [PATTERN_LENGTH:0] bit_index_int_r;
    reg [PATTERN_WIDTH:0] bit_count_r_next_rr;
    reg [PATTERN_WIDTH:0] bit_count_r_int_rr;
    reg [PATTERN_LENGTH:0] index_int_r_r;
    reg [PATTERN_WIDTH:0] i_int_r_r;
    reg [PATTERN_WIDTH:0] j_int_r_r;
    reg [PATTERN_LENGTH:0] bit_index_int_r_r;
    reg [PATTERN_WIDTH:0] bit_count_r_next_rrr;
    reg [PATTERN_WIDTH:0] bit_count_r_int_rrr;
    reg [PATTERN"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // Define states
    localparam state_idle = 1'b0,
                state_shift = 1'b1;
    
    // Define counters
    localparam counter_bits = $clog2(`PATTERN_SIZE);
    
    // Define regs
    reg [counter_bits:0] counter;
    reg [2:0] state, next_state;
    
    // Define outputs
    assign shift_ena = (state == state_shift);
    assign counting = (state == state_idle) &&!done_counting;
    
    // Define the next state
    always @(*) begin
        case(state)
            state_idle: next_state <= state_shift;
            state_shift: next_state <= done_counting? state_idle : state_shift;
        endcase
    end
    
    // Define the counter
    always @(posedge clk) begin
        if(reset)
            counter <= `PATTERN_SIZE - 1;
        else if(next_state == state_shift)
            counter <= counter - 1;
    end
    
    // Define the done signal
    always @(posedge clk) begin
        if(reset)
            done <= 1'b0;
        else if(next_state == state_shift)
            done <= 1'b1;
        else if(done_counting)
            done <= 1'b0;
    end
    
    // Define the ack signal
    always @(posedge clk) begin
        if(reset)
            ack <= 1'b0;
        else if(next_state == state_shift)
            ack <= 1'b1;
        else if(done_counting)
            ack <= 1'b0;
    end
    
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // Define states
    localparam state_idle = 1'b0,
                state_shift = 1'b1;
    
    // Define counters
    localparam counter_bits = $clog2(`PATTERN_SIZE);
    
    // Define regs
    reg [counter_bits:0] counter;
    reg [2:0] state, next_state;
    
    // Define outputs
    assign shift_ena = (state == state_shift);
    assign counting = (state == state_idle) &&!done_counting;
    
    // Define the next state
    always @(*) begin
        case(state)
            state_idle: next_state <= state_shift;
            state_shift: next_state <= done_counting? state_idle : state_shift;
        endcase
    end
    
    // Define the counter
    always @(posedge clk) begin
        if(reset)
            counter <= `PATTERN_SIZE - 1;
        else if(next_state == state_shift)
            counter <= counter - 1;
    end
    
    // Define the done signal
    always @(posedge clk) begin
        if(reset)
            done <= 1'b0;
        else if(next_state == state_shift)
            done <= 1'b1;
        else if(done_counting)
            done <= 1'b0;
    end
    
    // Define the ack signal
    always @(posedge clk) begin
        if(reset)
            ack <= 1'b0;
        else if(next_state == state_shift)
            ack <= 1'b1;
        else if(done_counting)
            ack <= 1'b0;
    end
    
endmodule"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=4'd0, S1=4'd1, S2=4'd2, S3=4'd3, S4=4'd4, S5=4'd5, S6=4'd6, S7=4'd7, S8=4'd8, S9=4'd9, S10=4'd10, S11=4'd11, S12=4'd12, S13=4'd13, S14=4'd14, S15=4'd15, S16=4'd16, S17=4'd17, S18=4'd18, S19=4'd19, S20=4'd20, S21=4'd21, S22=4'd22, S23=4'd23, S24=4'd24, S25=4'd25, S26=4'd26, S27=4'd27, S28=4'd28, S29=4'd29, S30=4'd30, S31=4'd31, S32=4'd32, S33=4'd33, S34=4'd34, S35=4'd35, S36=4'd36, S37=4'd37, S38=4'd38, S39=4'd39, S40=4'd40, S41=4'd41, S42=4'd42, S43=4'd43, S44=4'd44, S45=4'd45, S46=4'd46, S47=4'd47, S48=4'd48, S49=4'd49, S50=4'd50, S51=4'd51, S52=4'd52, S53=4'd53, S54=4'd54, S55=4'd55, S56=4'd56, S57=4'd57, S58=4'd58, S59=4'd59, S60=4'd60, S61=4'd61, S62=4'd62, S63=4'd63, S64=4'd64, S65=4'd65, S66=4'd66, S67=4'd67, S68=4'd68, S69=4'd69, S70=4'd70, S71=4'd71, S72=4'd72, S73=4'd73, S74=4'd74, S75=4'd75, S76=4'd76, S77=4'd77, S78=4'd78, S79=4'd79, S80=4'd80, S81=4'd81, S82=4'd82, S83=4'd83, S84=4'd84, S85=4'd85, S86=4'd86, S87=4'd87, S88=4'd88, S89=4'd89, S90=4'd90, S91=4'd91, S92=4'd92, S93=4'd93, S94=4'd94, S95=4'd95, S96=4'd96, S97=4'd97, S98=4'd98, S99=4'd99, S100=4'd100, S101=4'd101, S102=4'd102, S103=4'd103, S104=4'd104, S105=4'd105, S106=4'd106, S107=4'd107, S108=4'd108, S109=4'd109, S110=4'd110, S111=4'd111, S112=4'd112, S113=4'd113, S114=4'd114, S115=4'd115, S116=4'd116, S117=4'd117, S118=4'd118, S119=4'd119, S120=4'd120, S121=4'd121, S122=4'd122, S123=4'd123, S124=4'd124, S125=4'd125, S126=4'd126, S127=4'd127, S128=4'd128, S129=4'd129, S130=4'd130, S131=4'd131, S132=4'd132, S133=4'd133, S134=4'd134, S135=4'd135, S136=4'd136, S137=4'd137, S138=4'd138, S139=4'd139, S140=4'd140, S141=4'd141, S142=4'd142, S143=4'd143, S144=4'd144, S145=4'd",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=4'd0, S1=4'd1, S2=4'd2, S3=4'd3, S4=4'd4, S5=4'd5, S6=4'd6, S7=4'd7, S8=4'd8, S9=4'd9, S10=4'd10, S11=4'd11, S12=4'd12, S13=4'd13, S14=4'd14, S15=4'd15, S16=4'd16, S17=4'd17, S18=4'd18, S19=4'd19, S20=4'd20, S21=4'd21, S22=4'd22, S23=4'd23, S24=4'd24, S25=4'd25, S26=4'd26, S27=4'd27, S28=4'd28, S29=4'd29, S30=4'd30, S31=4'd31, S32=4'd32, S33=4'd33, S34=4'd34, S35=4'd35, S36=4'd36, S37=4'd37, S38=4'd38, S39=4'd39, S40=4'd40, S41=4'd41, S42=4'd42, S43=4'd43, S44=4'd44, S45=4'd45, S46=4'd46, S47=4'd47, S48=4'd48, S49=4'd49, S50=4'd50, S51=4'd51, S52=4'd52, S53=4'd53, S54=4'd54, S55=4'd55, S56=4'd56, S57=4'd57, S58=4'd58, S59=4'd59, S60=4'd60, S61=4'd61, S62=4'd62, S63=4'd63, S64=4'd64, S65=4'd65, S66=4'd66, S67=4'd67, S68=4'd68, S69=4'd69, S70=4'd70, S71=4'd71, S72=4'd72, S73=4'd73, S74=4'd74, S75=4'd75, S76=4'd76, S77=4'd77, S78=4'd78, S79=4'd79, S80=4'd80, S81=4'd81, S82=4'd82, S83=4'd83, S84=4'd84, S85=4'd85, S86=4'd86, S87=4'd87, S88=4'd88, S89=4'd89, S90=4'd90, S91=4'd91, S92=4'd92, S93=4'd93, S94=4'd94, S95=4'd95, S96=4'd96, S97=4'd97, S98=4'd98, S99=4'd99, S100=4'd100, S101=4'd101, S102=4'd102, S103=4'd103, S104=4'd104, S105=4'd105, S106=4'd106, S107=4'd107, S108=4'd108, S109=4'd109, S110=4'd110, S111=4'd111, S112=4'd112, S113=4'd113, S114=4'd114, S115=4'd115, S116=4'd116, S117=4'd117, S118=4'd118, S119=4'd119, S120=4'd120, S121=4'd121, S122=4'd122, S123=4'd123, S124=4'd124, S125=4'd125, S126=4'd126, S127=4'd127, S128=4'd128, S129=4'd129, S130=4'd130, S131=4'd131, S132=4'd132, S133=4'd133, S134=4'd134, S135=4'd135, S136=4'd136, S137=4'd137, S138=4'd138, S139=4'd139, S140=4'd140, S141=4'd141, S142=4'd142, S143=4'd143, S144=4'd144, S145=4'd"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=2'd0, counting=2'd1, done=2'd2, done_counting=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = counting;
            {counting, 1'b0}:next_state = counting;
            {counting, 1'b1}:next_state = done_counting;
            {done_counting, 1'b0}:next_state = idle;
            {done_counting, 1'b1}:next_state = done;
            {done, 1'b0}:	next_state = idle;
            {done, 1'b1}:	next_state = done;
            {done, 1'b1}:	next_state = done;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign	shift_ena = (state == done) || (state == done_counting);
    assign	counting = (state == counting);
    
    // New: Add parity checking.
    parity par_mod(clk, reset, data, parity_error, parity_good);
    
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=2'd0, counting=2'd1, done=2'd2, done_counting=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = counting;
            {counting, 1'b0}:next_state = counting;
            {counting, 1'b1}:next_state = done_counting;
            {done_counting, 1'b0}:next_state = idle;
            {done_counting, 1'b1}:next_state = done;
            {done, 1'b0}:	next_state = idle;
            {done, 1'b1}:	next_state = done;
            {done, 1'b1}:	next_state = done;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign	shift_ena = (state == done) || (state == done_counting);
    assign	counting = (state == counting);
    
    // New: Add parity checking.
    parity par_mod(clk, reset, data, parity_error, parity_good);
    
endmodule"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s11010111=4'd7, s110111=4'd8, s1101111=4'd9, s11011111=4'd10, s111=4'd11, s1111=4'd12, s111111=4'd13, s1111111=4'd14, s11111111=4'd15, s111111111=4'd16, s111111111111=4'd17, s1111111111111=4'd18, s1111111111111111=4'd19, s11111111111110000=4'd20, s11111111111111111=4'd21, s111111111111111110000=4'd22, s111111111111111111111=4'd23, s1111111111111111111111111=4'd24, s11111111111111111111111111111=4'd25, s11111111111111111111111111111=4'd26, s11111111111111111111111111111=4'd27, s11111111111111111111111111111=4'd28, s11111111111111111111111111111=4'd29, s11111111111111111111111111111=4'd30, s11111111111111111111111111111=4'd31, s11111111111111111111111111111=4'd32, s11111111111111111111111111111=4'd33, s11111111111111111111111111111=4'd34, s11111111111111111111111111111=4'd35, s11111111111111111111111111111=4'd36, s11111111111111111111111111111=4'd37, s11111111111111111111111111111=4'd38, s11111111111111111111111111111=4'd39, s11111111111111111111111111111=4'd40, s11111111111111111111111111111=4'd41, s11111111111111111111111111111=4'd42, s11111111111111111111111111111=4'd43, s11111111111111111111111111111=4'd44, s11111111111111111111111111111=4'd45, s11111111111111111111111111111=4'd46, s11111111111111111111111111111=4'd47, s11111111111111111111111111111=4'd48, s11111111111111111111111111111=4'd49, s11111111111111111111111111111=4'd50, s11111111111111111111111111111=4'd51, s11111111111111111111111111111=4'd52, s11111111111111111111111111111=4'd53, s11111111111111111111111111111=4'd54, s11111111111111111111111111111=4'd55, s11111111111111111111111111111=4'd56, s11111111111111111111111111111=4'd57, s11111111111111111111111111111=4'd58, s11111111111111111111111111111=4'd59, s11111111111111111111111111111=4'd60, s11111111111111111111111111111=4'd61, s11111111111111111111111111111=4'd62, s11111111111111111111111111111=4'd63, s11111111111111111111111111111=4'd64, s11111111111111111111111111111=4'd65, s11111111111111111111111111111=4'd66, s11111111111111111111111111111=4'd67, s11111111111111111111111111111=4'd68, s11111111111111111111111111111=4'd69, s11111111111111111111111111111=4'd70, s11111111111111111111111111111=4'd71, s11111111111111111111111111111=4'd72, s11111111111111111111111111111=4'd73, s11111111111111111111111111111=4'd74, s11111111111111111111111111111=4'd75, s11111111111111111111111111111=4'd76, s11111111111111111111111111111=4'd77, s11111111111111111111111111111=4'd78, s11111111111111111111111111111=4'd79, s11111111111111111111111111111=4'd80, s11111111111111111111111111111=4",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4, s11010=4'd5, s110101=4'd6, s11010111=4'd7, s110111=4'd8, s1101111=4'd9, s11011111=4'd10, s111=4'd11, s1111=4'd12, s111111=4'd13, s1111111=4'd14, s11111111=4'd15, s111111111=4'd16, s111111111111=4'd17, s1111111111111=4'd18, s1111111111111111=4'd19, s11111111111110000=4'd20, s11111111111111111=4'd21, s111111111111111110000=4'd22, s111111111111111111111=4'd23, s1111111111111111111111111=4'd24, s11111111111111111111111111111=4'd25, s11111111111111111111111111111=4'd26, s11111111111111111111111111111=4'd27, s11111111111111111111111111111=4'd28, s11111111111111111111111111111=4'd29, s11111111111111111111111111111=4'd30, s11111111111111111111111111111=4'd31, s11111111111111111111111111111=4'd32, s11111111111111111111111111111=4'd33, s11111111111111111111111111111=4'd34, s11111111111111111111111111111=4'd35, s11111111111111111111111111111=4'd36, s11111111111111111111111111111=4'd37, s11111111111111111111111111111=4'd38, s11111111111111111111111111111=4'd39, s11111111111111111111111111111=4'd40, s11111111111111111111111111111=4'd41, s11111111111111111111111111111=4'd42, s11111111111111111111111111111=4'd43, s11111111111111111111111111111=4'd44, s11111111111111111111111111111=4'd45, s11111111111111111111111111111=4'd46, s11111111111111111111111111111=4'd47, s11111111111111111111111111111=4'd48, s11111111111111111111111111111=4'd49, s11111111111111111111111111111=4'd50, s11111111111111111111111111111=4'd51, s11111111111111111111111111111=4'd52, s11111111111111111111111111111=4'd53, s11111111111111111111111111111=4'd54, s11111111111111111111111111111=4'd55, s11111111111111111111111111111=4'd56, s11111111111111111111111111111=4'd57, s11111111111111111111111111111=4'd58, s11111111111111111111111111111=4'd59, s11111111111111111111111111111=4'd60, s11111111111111111111111111111=4'd61, s11111111111111111111111111111=4'd62, s11111111111111111111111111111=4'd63, s11111111111111111111111111111=4'd64, s11111111111111111111111111111=4'd65, s11111111111111111111111111111=4'd66, s11111111111111111111111111111=4'd67, s11111111111111111111111111111=4'd68, s11111111111111111111111111111=4'd69, s11111111111111111111111111111=4'd70, s11111111111111111111111111111=4'd71, s11111111111111111111111111111=4'd72, s11111111111111111111111111111=4'd73, s11111111111111111111111111111=4'd74, s11111111111111111111111111111=4'd75, s11111111111111111111111111111=4'd76, s11111111111111111111111111111=4'd77, s11111111111111111111111111111=4'd78, s11111111111111111111111111111=4'd79, s11111111111111111111111111111=4'd80, s11111111111111111111111111111=4"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // We want to create a shift register of length 4.
    // We also want to create a counter to count the input value.
    // We also want to create a finite state machine that controls the shift register.
    // We also want to create a module that computes the value of the counter.
    
    // Define the states of the finite state machine
    localparam Shift = 0, Count = 1, Done = 2;
    
    // Define the state of the counter
    reg [1:0] state, next_state;
    
    // Define the output of the counter
    reg [3:0] count;
    
    // Define the output of the shift register
    reg [3:0] shift_reg;
    
    // Define the output of the state machine
    reg [1:0] state_reg;
    
    // Define the input of the state machine
    reg [1:0] state_next;
    
    // Define the output of the module
    reg done_counting_reg;
    
    // Define the input of the module
    reg [3:0] data_reg;
    
    // Define the counter input
    reg [3:0] data_next;
    
    // Define the shift register input
    reg [3:0] data_shift;
    
    // Define the counter output
    reg [3:0] count_next;
    
    // Define the shift register output
    reg [3:0] shift_reg_next;
    
    // Define the state register
    reg [1:0] state_next_reg;
    
    // Define the outputs of the module
    reg done_counting_next;
    reg shift_ena_next;
    reg counting_next;
    reg [3:0] count_next;
    reg [3:0] shift_reg_next;
    reg [1:0] state_next_next;
    reg [3:0] data_next_next;
    
    // Define the inputs of the module
    reg clk_next;
    reg reset_next;
    reg start_next;
    reg [3:0] data_next;
    
    // Define the wires of the module
    wire counting;
    wire done_counting;
    wire shift_ena;
    wire [3:0] count;
    wire [3:0] shift_reg;
    wire done;
    
    // Define the registers of the module
    reg [3:0] count_reg;
    reg [3:0] shift_reg_reg;
    reg [1:0] state_reg;
    reg [3:0] data_reg;
    reg done_counting_reg;
    reg shift_ena_reg;
    reg counting_reg;
    reg [3:0] count_next;
    reg [3:0] shift_reg_next;
    reg [1:0] state_next;
    reg [3:0] data_next;
    
    // Define the wires of the module
    wire [3:0] data_next_wire;
    
    // Define the outputs of the module
    wire done_counting_next_wire;
    wire shift_ena_next_wire;
    wire counting_next_wire;
    wire [3:0] count_next_wire;
    wire [3:0] shift_reg_next_wire;
    
    // Define the inputs of the module
    wire clk_next_wire;
    wire reset_next_wire;
    wire start_next_wire;
    wire [3:0] data_next_wire;
    
    // Define the wires of the module
    wire [3:0] data_shift_wire;
    
    // Define the outputs of the module
    wire done_counting_next_reg;
    wire shift_ena_next_reg;
    wire counting_next_reg;
    wire [3:0] count_next_reg;
    wire [3:0] shift_reg_next_reg;
    
    // Define the inputs of the module
    wire done_counting_reg;
    wire shift_ena_reg;
    wire counting_reg;
    wire [3:0] count_reg;",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // We want to create a shift register of length 4.
    // We also want to create a counter to count the input value.
    // We also want to create a finite state machine that controls the shift register.
    // We also want to create a module that computes the value of the counter.
    
    // Define the states of the finite state machine
    localparam Shift = 0, Count = 1, Done = 2;
    
    // Define the state of the counter
    reg [1:0] state, next_state;
    
    // Define the output of the counter
    reg [3:0] count;
    
    // Define the output of the shift register
    reg [3:0] shift_reg;
    
    // Define the output of the state machine
    reg [1:0] state_reg;
    
    // Define the input of the state machine
    reg [1:0] state_next;
    
    // Define the output of the module
    reg done_counting_reg;
    
    // Define the input of the module
    reg [3:0] data_reg;
    
    // Define the counter input
    reg [3:0] data_next;
    
    // Define the shift register input
    reg [3:0] data_shift;
    
    // Define the counter output
    reg [3:0] count_next;
    
    // Define the shift register output
    reg [3:0] shift_reg_next;
    
    // Define the state register
    reg [1:0] state_next_reg;
    
    // Define the outputs of the module
    reg done_counting_next;
    reg shift_ena_next;
    reg counting_next;
    reg [3:0] count_next;
    reg [3:0] shift_reg_next;
    reg [1:0] state_next_next;
    reg [3:0] data_next_next;
    
    // Define the inputs of the module
    reg clk_next;
    reg reset_next;
    reg start_next;
    reg [3:0] data_next;
    
    // Define the wires of the module
    wire counting;
    wire done_counting;
    wire shift_ena;
    wire [3:0] count;
    wire [3:0] shift_reg;
    wire done;
    
    // Define the registers of the module
    reg [3:0] count_reg;
    reg [3:0] shift_reg_reg;
    reg [1:0] state_reg;
    reg [3:0] data_reg;
    reg done_counting_reg;
    reg shift_ena_reg;
    reg counting_reg;
    reg [3:0] count_next;
    reg [3:0] shift_reg_next;
    reg [1:0] state_next;
    reg [3:0] data_next;
    
    // Define the wires of the module
    wire [3:0] data_next_wire;
    
    // Define the outputs of the module
    wire done_counting_next_wire;
    wire shift_ena_next_wire;
    wire counting_next_wire;
    wire [3:0] count_next_wire;
    wire [3:0] shift_reg_next_wire;
    
    // Define the inputs of the module
    wire clk_next_wire;
    wire reset_next_wire;
    wire start_next_wire;
    wire [3:0] data_next_wire;
    
    // Define the wires of the module
    wire [3:0] data_shift_wire;
    
    // Define the outputs of the module
    wire done_counting_next_reg;
    wire shift_ena_next_reg;
    wire counting_next_reg;
    wire [3:0] count_next_reg;
    wire [3:0] shift_reg_next_reg;
    
    // Define the inputs of the module
    wire done_counting_reg;
    wire shift_ena_reg;
    wire counting_reg;
    wire [3:0] count_reg;"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // Modify FSM and datapath from Fsm_serialdata
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11;
    reg [3:0]   state, next_state;
    reg [7:0]   data_reg;
    reg         data_parity;
    reg [3:0]   data_bit_count;
    reg [7:0]   data_stop_count;
    reg [3:0]   data_stop_parity;
    reg [7:0]   data_parity_count;
    reg [7:0]   data_parity_errors;
    reg [7:0]   data_stop_errors;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // Modify FSM and datapath from Fsm_serialdata
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11;
    reg [3:0]   state, next_state;
    reg [7:0]   data_reg;
    reg         data_parity;
    reg [3:0]   data_bit_count;
    reg [7:0]   data_stop_count;
    reg [3:0]   data_stop_parity;
    reg [7:0]   data_parity_count;
    reg [7:0]   data_parity_errors;
    reg [7:0]   data_stop_errors;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;
    reg [3:0]   data_stop_parity_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_errors_reg;
    reg [7:0]   data_stop_errors_reg;
    reg [7:0]   data_parity_count_reg;
    reg [3:0]   data_bit_count_reg;
    reg [3:0]   data_stop_count_reg;"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // We want to count the number of times the input sequence (data) is seen.
    // To do this, we will set up a 16-bit counter, and increase the counter whenever
    // data is seen. When the counter reaches the value 65535, we will set shift_ena to 1.
    // We will also set up a 16-bit counter for the acknowledgement, and increment
    // it whenever we see a new value of data.
    // When the acknowledgement counter reaches the value 65535, we can safely
    // assume that we have seen 65535 values of data.
    
    // Declare the counter for the number of times we see the input sequence.
    reg [15:0] i_count;
    
    // Declare the counter for the number of times we see the input sequence.
    reg [15:0] a_count;
    
    // Set up the states.
    reg [1:0] state;
    
    // Set up the outputs.
    reg shift_ena_internal;
    reg counting_internal;
    reg done_counting_internal;
    reg done_internal;
    reg ack_internal;
    
    // Start off by setting up the internal signals to 0.
    initial begin
        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    end
    
    // On clk, start the state machine.
    // The machine does the following:
    //   Set up the internal signals to start the state machine.
    //   Check the input data to see if it is the start sequence.
    //   If it is, start counting.
    //   If counting is done, start shifting.
    //   If shifting is done, start acknowledging the done signal.
    //   If the acknowledgement is done, return to the idle state.
    //   If any of the above conditions are not met, keep counting.
    //   Once done counting, go to the start state.
    
    always @(posedge clk) begin
        if (reset) begin
            {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
        end
        else begin
            case (state)
                2'b00: begin
                    if (data == 1'b0) begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b01;
                    end
                    else begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b00;
                    end
                end
                2'b01: begin
                    if (data == 1'b1) begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b1, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b10;
                    end
                    else begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b01;
                    end
                end
                2'b10: begin
                    if (data == 1'b1) begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b1, 1'b1, 1'b0, 1'b0, 1'b0};
                        state <= 2'b11;
                    end
                    else begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    // We want to count the number of times the input sequence (data) is seen.
    // To do this, we will set up a 16-bit counter, and increase the counter whenever
    // data is seen. When the counter reaches the value 65535, we will set shift_ena to 1.
    // We will also set up a 16-bit counter for the acknowledgement, and increment
    // it whenever we see a new value of data.
    // When the acknowledgement counter reaches the value 65535, we can safely
    // assume that we have seen 65535 values of data.
    
    // Declare the counter for the number of times we see the input sequence.
    reg [15:0] i_count;
    
    // Declare the counter for the number of times we see the input sequence.
    reg [15:0] a_count;
    
    // Set up the states.
    reg [1:0] state;
    
    // Set up the outputs.
    reg shift_ena_internal;
    reg counting_internal;
    reg done_counting_internal;
    reg done_internal;
    reg ack_internal;
    
    // Start off by setting up the internal signals to 0.
    initial begin
        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} = {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
    end
    
    // On clk, start the state machine.
    // The machine does the following:
    //   Set up the internal signals to start the state machine.
    //   Check the input data to see if it is the start sequence.
    //   If it is, start counting.
    //   If counting is done, start shifting.
    //   If shifting is done, start acknowledging the done signal.
    //   If the acknowledgement is done, return to the idle state.
    //   If any of the above conditions are not met, keep counting.
    //   Once done counting, go to the start state.
    
    always @(posedge clk) begin
        if (reset) begin
            {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
        end
        else begin
            case (state)
                2'b00: begin
                    if (data == 1'b0) begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b01;
                    end
                    else begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b00;
                    end
                end
                2'b01: begin
                    if (data == 1'b1) begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b1, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b10;
                    end
                    else begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                        state <= 2'b01;
                    end
                end
                2'b10: begin
                    if (data == 1'b1) begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'b1, 1'b1, 1'b0, 1'b0, 1'b0};
                        state <= 2'b11;
                    end
                    else begin
                        {shift_ena_internal, counting_internal, done_counting_internal, done_internal, ack_internal} <= {1'"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=2'd0, counting=2'd1, done=2'd2, done_counting=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = counting;
            {counting, 1'b0}:next_state = counting;
            {counting, 1'b1}:next_state = done_counting;
            {done_counting, 1'b0}:next_state = idle;
            {done_counting, 1'b1}:next_state = done;
            {done, 1'b0}:	next_state = idle;
            {done, 1'b1}:	next_state = done;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == done) || (state == done_counting);
    assign counting = (state == counting) || (state == done_counting);
    
    // New: Add parity checking.
    parity par_mod(clk, reset, data, parity_err);
    
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=2'd0, counting=2'd1, done=2'd2, done_counting=2'd3;
    reg	[1:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = counting;
            {counting, 1'b0}:next_state = counting;
            {counting, 1'b1}:next_state = done_counting;
            {done_counting, 1'b0}:next_state = idle;
            {done_counting, 1'b1}:next_state = done;
            {done, 1'b0}:	next_state = idle;
            {done, 1'b1}:	next_state = done;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == done) || (state == done_counting);
    assign counting = (state == counting) || (state == done_counting);
    
    // New: Add parity checking.
    parity par_mod(clk, reset, data, parity_err);
    
endmodule"
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == s1101);
    assign counting = (state == s11 || state == s110);
    assign done = (state == idle);
    
    // New: Add parity checking.
    parity par(.clk(clk),.data(data),.odd(odd));
    
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, s1101=4'd4;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == s1101);
    assign counting = (state == s11 || state == s110);
    assign done = (state == idle);
    
    // New: Add parity checking.
    parity par(.clk(clk),.data(data),.odd(odd));
    
endmodule"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
            default:			next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
            default:			next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=0, s1=1, s11=2, s110=3, s1101=4, s11010=5, s110101=6, s11010111=7, s11011011=8, s11011101=9, s11011110=10, s11011111=11, s11100011=12, s11100101=13, s11100111=14, s11101011=15, s11101101=16, s11101111=17, s111011111=18, s111011101=19, s111011110=20, s111011111=21, s1110111111=22, s11101111111=23, s1110111111=24, s111011111111=25, s1110111111111=26, s11101111111111=27, s111011111111111=28, s1110111111111111=29, s1110111111111111=30, s1110111111111111=31, s1110111111111111=32, s1110111111111111=33, s1110111111111111=34, s1110111111111111=35, s1110111111111111=36, s1110111111111111=37, s1110111111111111=38, s1110111111111111=39, s1110111111111111=40, s1110111111111111=41, s1110111111111111=42, s1110111111111111=43, s1110111111111111=44, s1110111111111111=45, s1110111111111111=46, s1110111111111111=47, s1110111111111111=48, s1110111111111111=49, s1110111111111111=50, s1110111111111111=51, s1110111111111111=52, s1110111111111111=53, s1110111111111111=54, s1110111111111111=55, s1110111111111111=56, s1110111111111111=57, s1110111111111111=58, s1110111111111111=59, s1110111111111111=60, s1110111111111111=61, s1110111111111111=62, s1110111111111111=63, s1110111111111111=64, s1110111111111111=65, s1110111111111111=66, s1110111111111111=67, s1110111111111111=68, s1110111111111111=69, s1110111111111111=70, s1110111111111111=71, s1110111111111111=72, s1110111111111111=73, s1110111111111111=74, s1110111111111111=75, s1110111111111111=76, s1110111111111111=77, s1110111111111111=78, s1110111111111111=79, s1110111111111111=80, s1110111111111111=81, s1110111111111111=82, s1110111111111111=83, s1110111111111111=84, s1110111111111111=85, s1110111111111111=86, s1110111111111111=87, s1110111111111111=88, s1110111111111111=89, s1110111111111111=90, s1110111111111111=91, s1110111111111111=92, s1110111111111111=93, s1110111111111111=94, s1110111111111111=95, s1110111111111111=96, s1110111111111111=97, s1110111111111111=98, s1110111111111111=99, s1110111111111111=100, s1110111111111111=101, s1110111111111111=102, s1110111111111111=103, s1110111111111111=104, s1110111111111111=105, s1110111111111111=106, s1110111111111111=107, s1110111111111111=108, s1110111111111111=109, s1110111111111111=110, s1110111111111111=111, s1110111111111111=112, s1110111111111111=113, s1110111111111111=114, s1110111111111111=115, s1110111111111111=116, s1110111111111111=117, s1110111111111111=118, s",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=0, s1=1, s11=2, s110=3, s1101=4, s11010=5, s110101=6, s11010111=7, s11011011=8, s11011101=9, s11011110=10, s11011111=11, s11100011=12, s11100101=13, s11100111=14, s11101011=15, s11101101=16, s11101111=17, s111011111=18, s111011101=19, s111011110=20, s111011111=21, s1110111111=22, s11101111111=23, s1110111111=24, s111011111111=25, s1110111111111=26, s11101111111111=27, s111011111111111=28, s1110111111111111=29, s1110111111111111=30, s1110111111111111=31, s1110111111111111=32, s1110111111111111=33, s1110111111111111=34, s1110111111111111=35, s1110111111111111=36, s1110111111111111=37, s1110111111111111=38, s1110111111111111=39, s1110111111111111=40, s1110111111111111=41, s1110111111111111=42, s1110111111111111=43, s1110111111111111=44, s1110111111111111=45, s1110111111111111=46, s1110111111111111=47, s1110111111111111=48, s1110111111111111=49, s1110111111111111=50, s1110111111111111=51, s1110111111111111=52, s1110111111111111=53, s1110111111111111=54, s1110111111111111=55, s1110111111111111=56, s1110111111111111=57, s1110111111111111=58, s1110111111111111=59, s1110111111111111=60, s1110111111111111=61, s1110111111111111=62, s1110111111111111=63, s1110111111111111=64, s1110111111111111=65, s1110111111111111=66, s1110111111111111=67, s1110111111111111=68, s1110111111111111=69, s1110111111111111=70, s1110111111111111=71, s1110111111111111=72, s1110111111111111=73, s1110111111111111=74, s1110111111111111=75, s1110111111111111=76, s1110111111111111=77, s1110111111111111=78, s1110111111111111=79, s1110111111111111=80, s1110111111111111=81, s1110111111111111=82, s1110111111111111=83, s1110111111111111=84, s1110111111111111=85, s1110111111111111=86, s1110111111111111=87, s1110111111111111=88, s1110111111111111=89, s1110111111111111=90, s1110111111111111=91, s1110111111111111=92, s1110111111111111=93, s1110111111111111=94, s1110111111111111=95, s1110111111111111=96, s1110111111111111=97, s1110111111111111=98, s1110111111111111=99, s1110111111111111=100, s1110111111111111=101, s1110111111111111=102, s1110111111111111=103, s1110111111111111=104, s1110111111111111=105, s1110111111111111=106, s1110111111111111=107, s1110111111111111=108, s1110111111111111=109, s1110111111111111=110, s1110111111111111=111, s1110111111111111=112, s1110111111111111=113, s1110111111111111=114, s1110111111111111=115, s1110111111111111=116, s1110111111111111=117, s1110111111111111=118, s"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
            default:		next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule",-0.5,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, data})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = s1;
            {s1, 1'b0}:		next_state = idle;
            {s1, 1'b1}:		next_state = s11;
            {s11, 1'b0}:	next_state = s110;
            {s11, 1'b1}:	next_state = s1101;
            {s110, 1'b0}:	next_state = idle;
            {s110, 1'b1}:	next_state = s1101;
            {s1101, 1'b0}:	next_state = idle;
            {s1101, 1'b1}:	next_state = s1101;
            default:		next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	start_shifting = (state == s1101);
    
endmodule"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=0, s1=1, s11=2, s110=3, s1101=4, s11010=5, s110101=6, s11010111=7, s11011011=8, s11011101=9, s11011110=10, s11011111=11, s11101011=12, s111010111=13, s111011011=14, s111011101=15, s111011110=16, s111011111=17, s11101111111=18, s1111010111=19, s1111011011=20, s1111011101=21, s1111011110=22, s1111011111=23, s1111101011=24, s11111010111=25, s11111011011=26, s11111011101=27, s11111011110=28, s11111011111=29, s11111101011=30, s111111011011=31, s111111011111=32, s111111101011=33, s1111111011011=34, s1111111011111=35, s111111110101=36, s111111111011=37, s111111111101=38, s111111111111=39, s11111111111111=40, s111111111111111=41, s1111111111111111=42, s1111111111111111=43, s1111111111111111=44, s1111111111111111=45, s1111111111111111=46, s1111111111111111=47, s1111111111111111=48, s1111111111111111=49, s1111111111111111=50, s1111111111111111=51, s1111111111111111=52, s1111111111111111=53, s1111111111111111=54, s1111111111111111=55, s1111111111111111=56, s1111111111111111=57, s1111111111111111=58, s1111111111111111=59, s1111111111111111=60, s1111111111111111=61, s1111111111111111=62, s1111111111111111=63, s1111111111111111=64, s1111111111111111=65, s1111111111111111=66, s1111111111111111=67, s1111111111111111=68, s1111111111111111=69, s1111111111111111=70, s1111111111111111=71, s1111111111111111=72, s1111111111111111=73, s1111111111111111=74, s1111111111111111=75, s1111111111111111=76, s1111111111111111=77, s1111111111111111=78, s1111111111111111=79, s1111111111111111=80, s1111111111111111=81, s1111111111111111=82, s1111111111111111=83, s1111111111111111=84, s1111111111111111=85, s1111111111111111=86, s1111111111111111=87, s1111111111111111=88, s1111111111111111=89, s1111111111111111=90, s1111111111111111=91, s1111111111111111=92, s1111111111111111=93, s1111111111111111=94, s1111111111111111=95, s1111111111111111=96, s1111111111111111=97, s1111111111111111=98, s1111111111111111=99, s1111111111111111=100, s1111111111111111=101, s1111111111111111=102, s1111111111111111=103, s1111111111111111=104, s1111111111111111=105, s1111111111111111=106, s1111111111111111=107, s1111111111111111=108, s1111111111111111=109, s1111111111111111=110, s1111111111111111=111, s1111111111111111=112, s1111111111111111=113, s1111111111111111=114, s1111111111111111=115, s1111111111111111=116, s1111111111111111=117, s1111111111111111=118, s1111111111111111=119, s1111111111111111=120, s1111111111111111=121, s1111111111111111=122, s1111111111111111=123, s1111111111111111=124, s1111111111111111=125, s1111111111111111=126, s1111111111111111=127, s1111111111111111=128, s1111111111111111=129, s",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=0, s1=1, s11=2, s110=3, s1101=4, s11010=5, s110101=6, s11010111=7, s11011011=8, s11011101=9, s11011110=10, s11011111=11, s11101011=12, s111010111=13, s111011011=14, s111011101=15, s111011110=16, s111011111=17, s11101111111=18, s1111010111=19, s1111011011=20, s1111011101=21, s1111011110=22, s1111011111=23, s1111101011=24, s11111010111=25, s11111011011=26, s11111011101=27, s11111011110=28, s11111011111=29, s11111101011=30, s111111011011=31, s111111011111=32, s111111101011=33, s1111111011011=34, s1111111011111=35, s111111110101=36, s111111111011=37, s111111111101=38, s111111111111=39, s11111111111111=40, s111111111111111=41, s1111111111111111=42, s1111111111111111=43, s1111111111111111=44, s1111111111111111=45, s1111111111111111=46, s1111111111111111=47, s1111111111111111=48, s1111111111111111=49, s1111111111111111=50, s1111111111111111=51, s1111111111111111=52, s1111111111111111=53, s1111111111111111=54, s1111111111111111=55, s1111111111111111=56, s1111111111111111=57, s1111111111111111=58, s1111111111111111=59, s1111111111111111=60, s1111111111111111=61, s1111111111111111=62, s1111111111111111=63, s1111111111111111=64, s1111111111111111=65, s1111111111111111=66, s1111111111111111=67, s1111111111111111=68, s1111111111111111=69, s1111111111111111=70, s1111111111111111=71, s1111111111111111=72, s1111111111111111=73, s1111111111111111=74, s1111111111111111=75, s1111111111111111=76, s1111111111111111=77, s1111111111111111=78, s1111111111111111=79, s1111111111111111=80, s1111111111111111=81, s1111111111111111=82, s1111111111111111=83, s1111111111111111=84, s1111111111111111=85, s1111111111111111=86, s1111111111111111=87, s1111111111111111=88, s1111111111111111=89, s1111111111111111=90, s1111111111111111=91, s1111111111111111=92, s1111111111111111=93, s1111111111111111=94, s1111111111111111=95, s1111111111111111=96, s1111111111111111=97, s1111111111111111=98, s1111111111111111=99, s1111111111111111=100, s1111111111111111=101, s1111111111111111=102, s1111111111111111=103, s1111111111111111=104, s1111111111111111=105, s1111111111111111=106, s1111111111111111=107, s1111111111111111=108, s1111111111111111=109, s1111111111111111=110, s1111111111111111=111, s1111111111111111=112, s1111111111111111=113, s1111111111111111=114, s1111111111111111=115, s1111111111111111=116, s1111111111111111=117, s1111111111111111=118, s1111111111111111=119, s1111111111111111=120, s1111111111111111=121, s1111111111111111=122, s1111111111111111=123, s1111111111111111=124, s1111111111111111=125, s1111111111111111=126, s1111111111111111=127, s1111111111111111=128, s1111111111111111=129, s"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4, s11010=2'd5, s110101=2'd6, s11010111=2'd7, s110101111=2'd8, s11011101=2'd9, s110111111=2'd10, s110111111=2'd11, s1101111=2'd12, s1101111=2'd13, s1101111=2'd14, s1101111=2'd15, s1101111=2'd16, s1101111=2'd17, s1101111=2'd18, s1101111=2'd19, s1101111=2'd20, s1101111=2'd21, s1101111=2'd22, s1101111=2'd23, s1101111=2'd24, s1101111=2'd25, s1101111=2'd26, s1101111=2'd27, s1101111=2'd28, s1101111=2'd29, s1101111=2'd30, s1101111=2'd31, s1101111=2'd32, s1101111=2'd33, s1101111=2'd34, s1101111=2'd35, s1101111=2'd36, s1101111=2'd37, s1101111=2'd38, s1101111=2'd39, s1101111=2'd40, s1101111=2'd41, s1101111=2'd42, s1101111=2'd43, s1101111=2'd44, s1101111=2'd45, s1101111=2'd46, s1101111=2'd47, s1101111=2'd48, s1101111=2'd49, s1101111=2'd50, s1101111=2'd51, s1101111=2'd52, s1101111=2'd53, s1101111=2'd54, s1101111=2'd55, s1101111=2'd56, s1101111=2'd57, s1101111=2'd58, s1101111=2'd59, s1101111=2'd60, s1101111=2'd61, s1101111=2'd62, s1101111=2'd63, s1101111=2'd64, s1101111=2'd65, s1101111=2'd66, s1101111=2'd67, s1101111=2'd68, s1101111=2'd69, s1101111=2'd70, s1101111=2'd71, s1101111=2'd72, s1101111=2'd73, s1101111=2'd74, s1101111=2'd75, s1101111=2'd76, s1101111=2'd77, s1101111=2'd78, s1101111=2'd79, s1101111=2'd80, s1101111=2'd81, s1101111=2'd82, s1101111=2'd83, s1101111=2'd84, s1101111=2'd85, s1101111=2'd86, s1101111=2'd87, s1101111=2'd88, s1101111=2'd89, s1101111=2'd90, s1101111=2'd91, s1101111=2'd92, s1101111=2'd93, s1101111=2'd94, s1101111=2'd95, s1101111=2'd96, s1101111=2'd97, s1101111=2'd98, s1101111=2'd99, s1101111=2'd100, s1101111=2'd101, s1101111=2'd102, s1101111=2'd103, s1101111=2'd104, s1101111=2'd105, s1101111=2'd106, s1101111=2'd107, s1101111=2'd108, s1101111=2'd109, s1101111=2'd110, s1101111=2'd111, s1101111=2'd112, s1101111=2'd",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=2'd0, s1=2'd1, s11=2'd2, s110=2'd3, s1101=2'd4, s11010=2'd5, s110101=2'd6, s11010111=2'd7, s110101111=2'd8, s11011101=2'd9, s110111111=2'd10, s110111111=2'd11, s1101111=2'd12, s1101111=2'd13, s1101111=2'd14, s1101111=2'd15, s1101111=2'd16, s1101111=2'd17, s1101111=2'd18, s1101111=2'd19, s1101111=2'd20, s1101111=2'd21, s1101111=2'd22, s1101111=2'd23, s1101111=2'd24, s1101111=2'd25, s1101111=2'd26, s1101111=2'd27, s1101111=2'd28, s1101111=2'd29, s1101111=2'd30, s1101111=2'd31, s1101111=2'd32, s1101111=2'd33, s1101111=2'd34, s1101111=2'd35, s1101111=2'd36, s1101111=2'd37, s1101111=2'd38, s1101111=2'd39, s1101111=2'd40, s1101111=2'd41, s1101111=2'd42, s1101111=2'd43, s1101111=2'd44, s1101111=2'd45, s1101111=2'd46, s1101111=2'd47, s1101111=2'd48, s1101111=2'd49, s1101111=2'd50, s1101111=2'd51, s1101111=2'd52, s1101111=2'd53, s1101111=2'd54, s1101111=2'd55, s1101111=2'd56, s1101111=2'd57, s1101111=2'd58, s1101111=2'd59, s1101111=2'd60, s1101111=2'd61, s1101111=2'd62, s1101111=2'd63, s1101111=2'd64, s1101111=2'd65, s1101111=2'd66, s1101111=2'd67, s1101111=2'd68, s1101111=2'd69, s1101111=2'd70, s1101111=2'd71, s1101111=2'd72, s1101111=2'd73, s1101111=2'd74, s1101111=2'd75, s1101111=2'd76, s1101111=2'd77, s1101111=2'd78, s1101111=2'd79, s1101111=2'd80, s1101111=2'd81, s1101111=2'd82, s1101111=2'd83, s1101111=2'd84, s1101111=2'd85, s1101111=2'd86, s1101111=2'd87, s1101111=2'd88, s1101111=2'd89, s1101111=2'd90, s1101111=2'd91, s1101111=2'd92, s1101111=2'd93, s1101111=2'd94, s1101111=2'd95, s1101111=2'd96, s1101111=2'd97, s1101111=2'd98, s1101111=2'd99, s1101111=2'd100, s1101111=2'd101, s1101111=2'd102, s1101111=2'd103, s1101111=2'd104, s1101111=2'd105, s1101111=2'd106, s1101111=2'd107, s1101111=2'd108, s1101111=2'd109, s1101111=2'd110, s1101111=2'd111, s1101111=2'd112, s1101111=2'd"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=3'd0, s1=3'd1, s11=3'd2, s110=3'd3, s1101=3'd4, s11010=3'd5, s110101=3'd6, s11010111=3'd7, s110101111=3'd8, s1101011111=3'd9, s11010111111=3'd10, s110101111111=3'd11, s1101011111111=3'd12, s11010111111111=3'd13, s110101111111111=3'd14, s1101011111111111=3'd15, s11010111111111111=3'd16, s110101111111111111=3'd17, s110101111111111111=3'd18, s110101111111111111=3'd19, s110101111111111111=3'd20, s110101111111111111=3'd21, s110101111111111111=3'd22, s110101111111111111=3'd23, s110101111111111111=3'd24, s110101111111111111=3'd25, s110101111111111111=3'd26, s110101111111111111=3'd27, s110101111111111111=3'd28, s110101111111111111=3'd29, s110101111111111111=3'd30, s110101111111111111=3'd31, s110101111111111111=3'd32, s110101111111111111=3'd33, s110101111111111111=3'd34, s110101111111111111=3'd35, s110101111111111111=3'd36, s110101111111111111=3'd37, s110101111111111111=3'd38, s110101111111111111=3'd39, s110101111111111111=3'd40, s110101111111111111=3'd41, s110101111111111111=3'd42, s110101111111111111=3'd43, s110101111111111111=3'd44, s110101111111111111=3'd45, s110101111111111111=3'd46, s110101111111111111=3'd47, s110101111111111111=3'd48, s110101111111111111=3'd49, s110101111111111111=3'd50, s110101111111111111=3'd51, s110101111111111111=3'd52, s110101111111111111=3'd53, s110101111111111111=3'd54, s110101111111111111=3'd55, s110101111111111111=3'd56, s110101111111111111=3'd57, s110101111111111111=3'd58, s110101111111111111=3'd59, s110101111111111111=3'd60, s110101111111111111=3'd61, s110101111111111111=3'd62, s110101111111111111=3'd63, s110101111111111111=3'd64, s110101111111111111=3'd65, s110101111111111111=3'd66, s110101111111111111=3'd67, s110101111111111111=3'd68, s110101111111111111=3'd69, s110101111111111111=3'd70, s110101111111111111=3'd71, s110101111111111111=3'd72, s110101111111111111=3'd73, s110101111111111111=3'd74, s110101111111111111=3'd75, s110101111111111111=3'd76, s110101111111111111=3'd77, s110101111111111111=3'd78, s110101111111111111=3'd79, s110101111111111111=3'd80, s110101111111111111=3'd81, s110101111111111111=3'd82, s110101111111111111=3'd83, s110101111111111111=3'd84, s110101111111111111=3'd85, s110101111111111111=3'd86, s110101111111111111=3'd87, s110101",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=3'd0, s1=3'd1, s11=3'd2, s110=3'd3, s1101=3'd4, s11010=3'd5, s110101=3'd6, s11010111=3'd7, s110101111=3'd8, s1101011111=3'd9, s11010111111=3'd10, s110101111111=3'd11, s1101011111111=3'd12, s11010111111111=3'd13, s110101111111111=3'd14, s1101011111111111=3'd15, s11010111111111111=3'd16, s110101111111111111=3'd17, s110101111111111111=3'd18, s110101111111111111=3'd19, s110101111111111111=3'd20, s110101111111111111=3'd21, s110101111111111111=3'd22, s110101111111111111=3'd23, s110101111111111111=3'd24, s110101111111111111=3'd25, s110101111111111111=3'd26, s110101111111111111=3'd27, s110101111111111111=3'd28, s110101111111111111=3'd29, s110101111111111111=3'd30, s110101111111111111=3'd31, s110101111111111111=3'd32, s110101111111111111=3'd33, s110101111111111111=3'd34, s110101111111111111=3'd35, s110101111111111111=3'd36, s110101111111111111=3'd37, s110101111111111111=3'd38, s110101111111111111=3'd39, s110101111111111111=3'd40, s110101111111111111=3'd41, s110101111111111111=3'd42, s110101111111111111=3'd43, s110101111111111111=3'd44, s110101111111111111=3'd45, s110101111111111111=3'd46, s110101111111111111=3'd47, s110101111111111111=3'd48, s110101111111111111=3'd49, s110101111111111111=3'd50, s110101111111111111=3'd51, s110101111111111111=3'd52, s110101111111111111=3'd53, s110101111111111111=3'd54, s110101111111111111=3'd55, s110101111111111111=3'd56, s110101111111111111=3'd57, s110101111111111111=3'd58, s110101111111111111=3'd59, s110101111111111111=3'd60, s110101111111111111=3'd61, s110101111111111111=3'd62, s110101111111111111=3'd63, s110101111111111111=3'd64, s110101111111111111=3'd65, s110101111111111111=3'd66, s110101111111111111=3'd67, s110101111111111111=3'd68, s110101111111111111=3'd69, s110101111111111111=3'd70, s110101111111111111=3'd71, s110101111111111111=3'd72, s110101111111111111=3'd73, s110101111111111111=3'd74, s110101111111111111=3'd75, s110101111111111111=3'd76, s110101111111111111=3'd77, s110101111111111111=3'd78, s110101111111111111=3'd79, s110101111111111111=3'd80, s110101111111111111=3'd81, s110101111111111111=3'd82, s110101111111111111=3'd83, s110101111111111111=3'd84, s110101111111111111=3'd85, s110101111111111111=3'd86, s110101111111111111=3'd87, s110101"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=0, s1=1, s11=2, s110=3, s1101=4, s11010=5, s110101=6, s11010101=7, s1101010111=8, s110101011101=9, s11010101110111=10, s110101011101111=11, s110101011101111=12, s110101011101111=13, s110101011101111=14, s110101011101111=15, s110101011101111=16, s110101011101111=17, s110101011101111=18, s110101011101111=19, s110101011101111=20, s110101011101111=21, s110101011101111=22, s110101011101111=23, s110101011101111=24, s110101011101111=25, s110101011101111=26, s110101011101111=27, s110101011101111=28, s110101011101111=29, s110101011101111=30, s110101011101111=31, s110101011101111=32, s110101011101111=33, s110101011101111=34, s110101011101111=35, s110101011101111=36, s110101011101111=37, s110101011101111=38, s110101011101111=39, s110101011101111=40, s110101011101111=41, s110101011101111=42, s110101011101111=43, s110101011101111=44, s110101011101111=45, s110101011101111=46, s110101011101111=47, s110101011101111=48, s110101011101111=49, s110101011101111=50, s110101011101111=51, s110101011101111=52, s110101011101111=53, s110101011101111=54, s110101011101111=55, s110101011101111=56, s110101011101111=57, s110101011101111=58, s110101011101111=59, s110101011101111=60, s110101011101111=61, s110101011101111=62, s110101011101111=63, s110101011101111=64, s110101011101111=65, s110101011101111=66, s110101011101111=67, s110101011101111=68, s110101011101111=69, s110101011101111=70, s110101011101111=71, s110101011101111=72, s110101011101111=73, s110101011101111=74, s110101011101111=75, s110101011101111=76, s110101011101111=77, s110101011101111=78, s110101011101111=79, s110101011101111=80, s110101011101111=81, s110101011101111=82, s110101011101111=83, s110101011101111=84, s110101011101111=85, s110101011101111=86, s110101011101111=87, s110101011101111=88, s110101011101111=89, s110101011101111=90, s110101011101111=91, s110101011101111=92, s110101011101111=93, s110101011101111=94, s110101011101111=95, s110101011101",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=0, s1=1, s11=2, s110=3, s1101=4, s11010=5, s110101=6, s11010101=7, s1101010111=8, s110101011101=9, s11010101110111=10, s110101011101111=11, s110101011101111=12, s110101011101111=13, s110101011101111=14, s110101011101111=15, s110101011101111=16, s110101011101111=17, s110101011101111=18, s110101011101111=19, s110101011101111=20, s110101011101111=21, s110101011101111=22, s110101011101111=23, s110101011101111=24, s110101011101111=25, s110101011101111=26, s110101011101111=27, s110101011101111=28, s110101011101111=29, s110101011101111=30, s110101011101111=31, s110101011101111=32, s110101011101111=33, s110101011101111=34, s110101011101111=35, s110101011101111=36, s110101011101111=37, s110101011101111=38, s110101011101111=39, s110101011101111=40, s110101011101111=41, s110101011101111=42, s110101011101111=43, s110101011101111=44, s110101011101111=45, s110101011101111=46, s110101011101111=47, s110101011101111=48, s110101011101111=49, s110101011101111=50, s110101011101111=51, s110101011101111=52, s110101011101111=53, s110101011101111=54, s110101011101111=55, s110101011101111=56, s110101011101111=57, s110101011101111=58, s110101011101111=59, s110101011101111=60, s110101011101111=61, s110101011101111=62, s110101011101111=63, s110101011101111=64, s110101011101111=65, s110101011101111=66, s110101011101111=67, s110101011101111=68, s110101011101111=69, s110101011101111=70, s110101011101111=71, s110101011101111=72, s110101011101111=73, s110101011101111=74, s110101011101111=75, s110101011101111=76, s110101011101111=77, s110101011101111=78, s110101011101111=79, s110101011101111=80, s110101011101111=81, s110101011101111=82, s110101011101111=83, s110101011101111=84, s110101011101111=85, s110101011101111=86, s110101011101111=87, s110101011101111=88, s110101011101111=89, s110101011101111=90, s110101011101111=91, s110101011101111=92, s110101011101111=93, s110101011101111=94, s110101011101111=95, s110101011101"
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=3'd0, s1=3'd1, s11=3'd2, s110=3'd3, s1101=3'd4, s11010=3'd5, s110101=3'd6, s1101101=3'd7, s11011010=3'd8, s110110101=3'd9, s110110110=3'd10, s1101101101=3'd11, s11011011010=3'd12, s11011011011=3'd13, s11011011011=3'd14, s11011011011=3'd15, s11011011011=3'd16, s11011011011=3'd17, s11011011011=3'd18, s11011011011=3'd19, s11011011011=3'd20, s11011011011=3'd21, s11011011011=3'd22, s11011011011=3'd23, s11011011011=3'd24, s11011011011=3'd25, s11011011011=3'd26, s11011011011=3'd27, s11011011011=3'd28, s11011011011=3'd29, s11011011011=3'd30, s11011011011=3'd31, s11011011011=3'd32, s11011011011=3'd33, s11011011011=3'd34, s11011011011=3'd35, s11011011011=3'd36, s11011011011=3'd37, s11011011011=3'd38, s11011011011=3'd39, s11011011011=3'd40, s11011011011=3'd41, s11011011011=3'd42, s11011011011=3'd43, s11011011011=3'd44, s11011011011=3'd45, s11011011011=3'd46, s11011011011=3'd47, s11011011011=3'd48, s11011011011=3'd49, s11011011011=3'd50, s11011011011=3'd51, s11011011011=3'd52, s11011011011=3'd53, s11011011011=3'd54, s11011011011=3'd55, s11011011011=3'd56, s11011011011=3'd57, s11011011011=3'd58, s11011011011=3'd59, s11011011011=3'd60, s11011011011=3'd61, s11011011011=3'd62, s11011011011=3'd63, s11011011011=3'd64, s11011011011=3'd65, s11011011011=3'd66, s11011011011=3'd67, s11011011011=3'd68, s11011011011=3'd69, s11011011011=3'd70, s11011011011=3'd71, s11011011011=3'd72, s11011011011=3'd73, s11011011011=3'd74, s11011011011=3'd75, s11011011011=3'd76, s11011011011=3'd77, s11011011011=3'd78, s11011011011=3'd79, s11011011011=3'd80, s11011011011=3'd81, s11011011011=3'd82, s11011011011=3'd83, s11011011011=3'd84, s11011011011=3'd85, s11011011011=3'd86, s11011011011=3'd87, s11011011011=3'd88, s11011011011=3'd89, s11011011011=3'd90, s11011011011=3'd91, s11011011011=3'd92, s11011011011=3'd93, s11011011011=3'd94, s1101101",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);
    
    parameter idle=3'd0, s1=3'd1, s11=3'd2, s110=3'd3, s1101=3'd4, s11010=3'd5, s110101=3'd6, s1101101=3'd7, s11011010=3'd8, s110110101=3'd9, s110110110=3'd10, s1101101101=3'd11, s11011011010=3'd12, s11011011011=3'd13, s11011011011=3'd14, s11011011011=3'd15, s11011011011=3'd16, s11011011011=3'd17, s11011011011=3'd18, s11011011011=3'd19, s11011011011=3'd20, s11011011011=3'd21, s11011011011=3'd22, s11011011011=3'd23, s11011011011=3'd24, s11011011011=3'd25, s11011011011=3'd26, s11011011011=3'd27, s11011011011=3'd28, s11011011011=3'd29, s11011011011=3'd30, s11011011011=3'd31, s11011011011=3'd32, s11011011011=3'd33, s11011011011=3'd34, s11011011011=3'd35, s11011011011=3'd36, s11011011011=3'd37, s11011011011=3'd38, s11011011011=3'd39, s11011011011=3'd40, s11011011011=3'd41, s11011011011=3'd42, s11011011011=3'd43, s11011011011=3'd44, s11011011011=3'd45, s11011011011=3'd46, s11011011011=3'd47, s11011011011=3'd48, s11011011011=3'd49, s11011011011=3'd50, s11011011011=3'd51, s11011011011=3'd52, s11011011011=3'd53, s11011011011=3'd54, s11011011011=3'd55, s11011011011=3'd56, s11011011011=3'd57, s11011011011=3'd58, s11011011011=3'd59, s11011011011=3'd60, s11011011011=3'd61, s11011011011=3'd62, s11011011011=3'd63, s11011011011=3'd64, s11011011011=3'd65, s11011011011=3'd66, s11011011011=3'd67, s11011011011=3'd68, s11011011011=3'd69, s11011011011=3'd70, s11011011011=3'd71, s11011011011=3'd72, s11011011011=3'd73, s11011011011=3'd74, s11011011011=3'd75, s11011011011=3'd76, s11011011011=3'd77, s11011011011=3'd78, s11011011011=3'd79, s11011011011=3'd80, s11011011011=3'd81, s11011011011=3'd82, s11011011011=3'd83, s11011011011=3'd84, s11011011011=3'd85, s11011011011=3'd86, s11011011011=3'd87, s11011011011=3'd88, s11011011011=3'd89, s11011011011=3'd90, s11011011011=3'd91, s11011011011=3'd92, s11011011011=3'd93, s11011011011=3'd94, s1101101"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c1;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c2;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c3;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c4;
            {c4, 1'b0}:	next_state = c0;
            {c4, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == c4);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c1;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c2;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c3;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c4;
            {c4, 1'b0}:	next_state = c0;
            {c4, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == c4);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c1;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c2;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c3;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c4;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c5;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c6;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c7;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c8;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c9;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = cA;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = cB;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = cC;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = cD;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = cE;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = cF;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c1;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c2;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c3;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c4;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c5;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c6;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c7;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c8;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c9;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = cA;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = cB;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = cC;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = cD;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = cE;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = cF;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter S0=0, S1=1, S2=2, S3=3;
    reg [0:1] state, next_state;
    
    always@(*) begin
        case(state)
            S0: next_state = (data_in)? S1 : S0;
            S1: next_state = (data_in)? S2 : S1;
            S2: next_state = (data_in)? S2 : S3;
            S3: next_state = (data_in)? S2 : S3;
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    assign shift_ena = (state == S2 || state == S3);
    
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter S0=0, S1=1, S2=2, S3=3;
    reg [0:1] state, next_state;
    
    always@(*) begin
        case(state)
            S0: next_state = (data_in)? S1 : S0;
            S1: next_state = (data_in)? S2 : S1;
            S2: next_state = (data_in)? S2 : S3;
            S3: next_state = (data_in)? S2 : S3;
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    assign shift_ena = (state == S2 || state == S3);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign	shift_ena = (state == cD || state == cE || state == cF);
    
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign	shift_ena = (state == cD || state == cE || state == cF);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c0;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c0;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c0;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c0;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c0;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = c0;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = c0;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = c0;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = c0;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = c0;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = c0;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c1;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c2;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c3;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c4;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c5;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c6;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c7;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c8;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c9;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = cA;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = cB;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = cC;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = cD;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = cE;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = cF;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
            {c0, 1'b0}:	next_state = c0;
            {c0, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule",-1,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4, c5=3'd5, c6=3'd6, c7=3'd7, c8=3'd8, c9=3'd9, cA=3'dA, cB=3'dB, cC=3'dC, cD=3'dD, cE=3'dE, cF=3'dF;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c1;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c2;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c3;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c4;
            {c4, 1'b0}:	next_state = c5;
            {c4, 1'b1}:	next_state = c5;
            {c5, 1'b0}:	next_state = c6;
            {c5, 1'b1}:	next_state = c6;
            {c6, 1'b0}:	next_state = c7;
            {c6, 1'b1}:	next_state = c7;
            {c7, 1'b0}:	next_state = c8;
            {c7, 1'b1}:	next_state = c8;
            {c8, 1'b0}:	next_state = c9;
            {c8, 1'b1}:	next_state = c9;
            {c9, 1'b0}:	next_state = cA;
            {c9, 1'b1}:	next_state = cA;
            {cA, 1'b0}:	next_state = cB;
            {cA, 1'b1}:	next_state = cB;
            {cB, 1'b0}:	next_state = cC;
            {cB, 1'b1}:	next_state = cC;
            {cC, 1'b0}:	next_state = cD;
            {cC, 1'b1}:	next_state = cD;
            {cD, 1'b0}:	next_state = cE;
            {cD, 1'b1}:	next_state = cE;
            {cE, 1'b0}:	next_state = cF;
            {cE, 1'b1}:	next_state = cF;
            {cF, 1'b0}:	next_state = c0;
            {cF, 1'b1}:	next_state = c0;
            {c0, 1'b0}:	next_state = c0;
            {c0, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == cD || state == cE || state == cF);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c0;
            {c4, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == c4);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg	[2:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, reset})
            {c0, 1'b0}:	next_state = c1;
            {c0, 1'b1}:	next_state = c0;
            {c1, 1'b0}:	next_state = c2;
            {c1, 1'b1}:	next_state = c0;
            {c2, 1'b0}:	next_state = c3;
            {c2, 1'b1}:	next_state = c0;
            {c3, 1'b0}:	next_state = c4;
            {c3, 1'b1}:	next_state = c0;
            {c4, 1'b0}:	next_state = c0;
            {c4, 1'b1}:	next_state = c0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= c0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == c4);
    
endmodule"
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter idle=0, ing=1, done=2;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, ing})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = ing;
            {ing, 1'b0}:	next_state = ing;
            {ing, 1'b1}:	next_state = done;
            {done, 1'b0}:	next_state = idle;
            {done, 1'b1}:	next_state = done;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	shift_ena = (state == done);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter idle=0, ing=1, done=2;
    reg	[1:0]	state, next_state;
    
    always@(*) begin
        case({state, ing})
            {idle, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = ing;
            {ing, 1'b0}:	next_state = ing;
            {ing, 1'b1}:	next_state = done;
            {done, 1'b0}:	next_state = idle;
            {done, 1'b1}:	next_state = done;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	shift_ena = (state == done);
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    // Create a shift register, q_shift, that shifts data into the registers q1, q2, and q3.
    
    shift_register_4bit q_shift (clk, shift_ena, data, q1);
    shift_register_4bit q1_shift (clk, shift_ena, q1, q2);
    shift_register_4bit q2_shift (clk, shift_ena, q2, q3);
    
    // Create a counter, q_count, that increments and decrements the registers q1, q2, and q3.
    
    counter4bit q_count (clk, count_ena, q1_count, q1);
    counter4bit q1_count (clk, count_ena, q2_count, q2);
    counter4bit q2_count (clk, count_ena, q3_count, q3);
    
    // Output the current value of each register.
    
    assign q = {q3, q2, q1};
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    // Create a shift register, q_shift, that shifts data into the registers q1, q2, and q3.
    
    shift_register_4bit q_shift (clk, shift_ena, data, q1);
    shift_register_4bit q1_shift (clk, shift_ena, q1, q2);
    shift_register_4bit q2_shift (clk, shift_ena, q2, q3);
    
    // Create a counter, q_count, that increments and decrements the registers q1, q2, and q3.
    
    counter4bit q_count (clk, count_ena, q1_count, q1);
    counter4bit q1_count (clk, count_ena, q2_count, q2);
    counter4bit q2_count (clk, count_ena, q3_count, q3);
    
    // Output the current value of each register.
    
    assign q = {q3, q2, q1};
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q0, q1, q2, q3;
    
    my_dff dff0 (clk, shift_ena, data, q0);
    my_dff dff1 (clk, shift_ena, q0, q1);
    my_dff dff2 (clk, shift_ena, q1, q2);
    my_dff dff3 (clk, shift_ena, q2, q3);
    
    always @(posedge clk)
        if(count_ena)
            q <= q + 1;
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q0, q1, q2, q3;
    
    my_dff dff0 (clk, shift_ena, data, q0);
    my_dff dff1 (clk, shift_ena, q0, q1);
    my_dff dff2 (clk, shift_ena, q1, q2);
    my_dff dff3 (clk, shift_ena, q2, q3);
    
    always @(posedge clk)
        if(count_ena)
            q <= q + 1;
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q0, q1, q2, q3;
    
    my_dff dff0 (clk, shift_ena, data, q0);
    my_dff dff1 (clk, shift_ena, q0, q1);
    my_dff dff2 (clk, shift_ena, q1, q2);
    my_dff dff3 (clk, shift_ena, q2, q3);
    
    always @(posedge clk)
        if(count_ena)
            q <= q + 1;
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q0, q1, q2, q3;
    
    my_dff dff0 (clk, shift_ena, data, q0);
    my_dff dff1 (clk, shift_ena, q0, q1);
    my_dff dff2 (clk, shift_ena, q1, q2);
    my_dff dff3 (clk, shift_ena, q2, q3);
    
    always @(posedge clk)
        if(count_ena)
            q <= q + 1;
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    // Create a shift register with q as its output and inputs as its input.
    // q1 is a copy of q, q2 is a concatenation of q and {3'b0, q[0]},
    // q3 is a concatenation of q and {3'b0, q[3]}, and the clock is always clk.
    
    shift_register #(4) shift_reg1 (.D(q),.clk(clk),.Q(q1),.reset(1'b0));
    
    // Create a counter with q1 as its output and q2 as its input.
    // Counts down when count_ena is 1 and up when it is 0.
    
    counter counter1 (.Q(q2),.clk(clk),.reset(count_ena));
    
    // Create a shift register with q1 as its output and q2 as its input.
    // Shift register shifts the most significant bit of q1 to the left when shift_ena is 1.
    
    shift_register #(4) shift_reg2 (.D(q1),.clk(clk),.Q(q3),.reset(shift_ena));
    
    // The concatenation operator is used to create a 4-bit wide vector from two 3-bit wide vectors.
    // In this case, the result is q1, which is a 4-bit wide vector.
    
    assign q = {q1, q2, q3};
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q1;
    wire [3:0] q2;
    wire [3:0] q3;
    
    // Create a shift register with q as its output and inputs as its input.
    // q1 is a copy of q, q2 is a concatenation of q and {3'b0, q[0]},
    // q3 is a concatenation of q and {3'b0, q[3]}, and the clock is always clk.
    
    shift_register #(4) shift_reg1 (.D(q),.clk(clk),.Q(q1),.reset(1'b0));
    
    // Create a counter with q1 as its output and q2 as its input.
    // Counts down when count_ena is 1 and up when it is 0.
    
    counter counter1 (.Q(q2),.clk(clk),.reset(count_ena));
    
    // Create a shift register with q1 as its output and q2 as its input.
    // Shift register shifts the most significant bit of q1 to the left when shift_ena is 1.
    
    shift_register #(4) shift_reg2 (.D(q1),.clk(clk),.Q(q3),.reset(shift_ena));
    
    // The concatenation operator is used to create a 4-bit wide vector from two 3-bit wide vectors.
    // In this case, the result is q1, which is a 4-bit wide vector.
    
    assign q = {q1, q2, q3};
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q_next;
    
    // Create a D_FF
    
    d_ff dff0 (clk, data, q[0]);
    
    // Create a register
    
    register_module reg0 (clk, q[0], q_next[0], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff1 (clk, q_next[0], q[1]);
    
    // Create a register
    
    register_module reg1 (clk, q[1], q_next[1], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff2 (clk, q_next[1], q[2]);
    
    // Create a register
    
    register_module reg2 (clk, q[2], q_next[2], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff3 (clk, q_next[2], q[3]);
    
    // Create a register
    
    register_module reg3 (clk, q[3], q_next[3], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff4 (clk, q_next[3], q[4]);
    
    // Create a register
    
    register_module reg4 (clk, q[4], q_next[4], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff5 (clk, q_next[4], q[5]);
    
    // Create a register
    
    register_module reg5 (clk, q[5], q_next[5], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff6 (clk, q_next[5], q[6]);
    
    // Create a register
    
    register_module reg6 (clk, q[6], q_next[6], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff7 (clk, q_next[6], q[7]);
    
    // Create a register
    
    register_module reg7 (clk, q[7], q_next[7], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff8 (clk, q_next[7], q[8]);
    
    // Create a register
    
    register_module reg8 (clk, q[8], q_next[8], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff9 (clk, q_next[8], q[9]);
    
    // Create a register
    
    register_module reg9 (clk, q[9], q_next[9], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff10 (clk, q_next[9], q[10]);
    
    // Create a register
    
    register_module reg10 (clk, q[10], q_next[10], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff11 (clk, q_next[10], q[11]);
    
    // Create a register
    
    register_module reg11 (clk, q[11], q_next[11], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff12 (clk, q_next[11], q[12]);
    
    // Create a register
    
    register_module reg12 (clk, q[12], q_next[12], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff13 (clk, q_next[12], q[13]);
    
    // Create a register
    
    register_module reg13 (clk, q[13], q_next[13], shift",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q_next;
    
    // Create a D_FF
    
    d_ff dff0 (clk, data, q[0]);
    
    // Create a register
    
    register_module reg0 (clk, q[0], q_next[0], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff1 (clk, q_next[0], q[1]);
    
    // Create a register
    
    register_module reg1 (clk, q[1], q_next[1], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff2 (clk, q_next[1], q[2]);
    
    // Create a register
    
    register_module reg2 (clk, q[2], q_next[2], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff3 (clk, q_next[2], q[3]);
    
    // Create a register
    
    register_module reg3 (clk, q[3], q_next[3], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff4 (clk, q_next[3], q[4]);
    
    // Create a register
    
    register_module reg4 (clk, q[4], q_next[4], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff5 (clk, q_next[4], q[5]);
    
    // Create a register
    
    register_module reg5 (clk, q[5], q_next[5], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff6 (clk, q_next[5], q[6]);
    
    // Create a register
    
    register_module reg6 (clk, q[6], q_next[6], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff7 (clk, q_next[6], q[7]);
    
    // Create a register
    
    register_module reg7 (clk, q[7], q_next[7], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff8 (clk, q_next[7], q[8]);
    
    // Create a register
    
    register_module reg8 (clk, q[8], q_next[8], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff9 (clk, q_next[8], q[9]);
    
    // Create a register
    
    register_module reg9 (clk, q[9], q_next[9], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff10 (clk, q_next[9], q[10]);
    
    // Create a register
    
    register_module reg10 (clk, q[10], q_next[10], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff11 (clk, q_next[10], q[11]);
    
    // Create a register
    
    register_module reg11 (clk, q[11], q_next[11], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff12 (clk, q_next[11], q[12]);
    
    // Create a register
    
    register_module reg12 (clk, q[12], q_next[12], shift_ena, count_ena);
    
    // Create a D_FF
    
    d_ff dff13 (clk, q_next[12], q[13]);
    
    // Create a register
    
    register_module reg13 (clk, q[13], q_next[13], shift"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q0, q1, q2, q3;
    
    my_dff dff0 (clk, shift_ena, data, q0);
    my_dff dff1 (clk, shift_ena, q0, q1);
    my_dff dff2 (clk, shift_ena, q1, q2);
    my_dff dff3 (clk, shift_ena, q2, q3);
    
    always @(posedge clk)
        if(count_ena)
            q <= q + 1;

endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q0, q1, q2, q3;
    
    my_dff dff0 (clk, shift_ena, data, q0);
    my_dff dff1 (clk, shift_ena, q0, q1);
    my_dff dff2 (clk, shift_ena, q1, q2);
    my_dff dff3 (clk, shift_ena, q2, q3);
    
    always @(posedge clk)
        if(count_ena)
            q <= q + 1;

endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q_next;
    
    assign q_next = q[3:0] + 1;
    
    always @(posedge clk)
        if(shift_ena)
            q <= {q[3:0], data};
    
    always @(posedge clk)
        if(count_ena)
            q <= q_next;
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q_next;
    
    assign q_next = q[3:0] + 1;
    
    always @(posedge clk)
        if(shift_ena)
            q <= {q[3:0], data};
    
    always @(posedge clk)
        if(count_ena)
            q <= q_next;
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q_next;
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
    // It doesn't really matter what assignment is used, as long as they're unique.
    // We have 6 states here.
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.
    always @(posedge clk) begin
        if (reset) state <= A;
        else state <= next_state;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            A: next_state <= shift_ena? B : A;
            B: next_state <= count_ena? C : B;
            C: next_state <= D;
            D: next_state <= shift_ena? E : D;
            E: next_state <= count_ena? F : E;
            F: next_state <= A;
            default: next_state <= A;
        endcase
    end
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign q = (state == F);
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    wire [3:0] q_next;
    
    // Give state names and assignments. I'm lazy, so I like to use decimal numbers.
    // It doesn't really matter what assignment is used, as long as they're unique.
    // We have 6 states here.
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] state, next_state;
    
    // Edge-triggered always block (DFFs) for state flip-flops. Synchronous reset.
    always @(posedge clk) begin
        if (reset) state <= A;
        else state <= next_state;
    end
    
    // Combinational always block for state transition logic. Given the current state and inputs,
    // what should the next state be?
    // Combinational always block: Use blocking assignments.    
    always@(*) begin
        case (state)
            A: next_state <= shift_ena? B : A;
            B: next_state <= count_ena? C : B;
            C: next_state <= D;
            D: next_state <= shift_ena? E : D;
            E: next_state <= count_ena? F : E;
            F: next_state <= A;
            default: next_state <= A;
        endcase
    end
    
    // Combinational output logic. In this problem, an assign statement is the simplest.
    // In more complex circuits, a combinational always block may be more suitable.
    assign q = (state == F);
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    reg [3:0] temp;
    
    always @(posedge clk)
        begin
            if(shift_ena)
                temp = {temp[2:0], data};
            else if(count_ena)
                temp = temp - 4'd1;
        end
    
    assign q = temp;
    
endmodule",-0.5,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    reg [3:0] temp;
    
    always @(posedge clk)
        begin
            if(shift_ena)
                temp = {temp[2:0], data};
            else if(count_ena)
                temp = temp - 4'd1;
        end
    
    assign q = temp;
    
endmodule"
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    reg [3:0] temp;
    
    always @(posedge clk)
        if(shift_ena)
            temp = {temp[2:0], data};
    
    always @(posedge clk)
        if(count_ena)
            q <= temp - 4'd1;

endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    reg [3:0] temp;
    
    always @(posedge clk)
        if(shift_ena)
            temp = {temp[2:0], data};
    
    always @(posedge clk)
        if(count_ena)
            q <= temp - 4'd1;

endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    wire w1, w2, w3;
    
    assign w1 = a ^ b;
    assign w2 = a & b;
    assign w3 = w1 | w2;
    assign sum = w3 ^ cin;
    assign cout = w3 | (w1 & cin) | (a & b);
    
endmodule",-0.5,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    wire w1, w2, w3;
    
    assign w1 = a ^ b;
    assign w2 = a & b;
    assign w3 = w1 | w2;
    assign sum = w3 ^ cin;
    assign cout = w3 | (w1 & cin) | (a & b);
    
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule"
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg state, next_state;
    reg [3:0] c, recive_c;
    reg [7:0] data;
    reg [7:0] data_next;
    reg [2:0] nibble;
    reg [3:0] nibble_error_count;
    reg done_reg;

    always @(*) begin
        case(state)
            idle:
                begin
                    done_reg = 1'b0;
                    if(~in[3] & ~in[2] & ~in[1] & in[0])
                        next_state = recive;
                	else
                        next_state = idle;
                end
            recive:
                begin
                    done_reg = 1'b1;
                    next_state = idle;
                end
            default: next_state = idle;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= idle;
    	else
            state <= next_state;

    // Output logic
    assign done = done_reg;

    // New: Add parity checking.
    parity par(.clk(clk),.in(in),.odd(odd));
    
    // New: Add counter.
    counter cnt(.clk(clk),.reset(reset),.in(in),.count(count));

    // New: Add nibble_error_count.
    always @(posedge clk)
        if(reset)
            nibble_error_count <= 0;
    	else
            nibble_error_count <= nibble_error_count + (in[3:0] == 4'hA? 1 : 0);

    // New: Add data_next.
    always @(posedge clk)
        if(reset)
            data_next <= 0;
    	else
            data_next <= data_next + 4'hA;

endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg state, next_state;
    reg [3:0] c, recive_c;
    reg [7:0] data;
    reg [7:0] data_next;
    reg [2:0] nibble;
    reg [3:0] nibble_error_count;
    reg done_reg;

    always @(*) begin
        case(state)
            idle:
                begin
                    done_reg = 1'b0;
                    if(~in[3] & ~in[2] & ~in[1] & in[0])
                        next_state = recive;
                	else
                        next_state = idle;
                end
            recive:
                begin
                    done_reg = 1'b1;
                    next_state = idle;
                end
            default: next_state = idle;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= idle;
    	else
            state <= next_state;

    // Output logic
    assign done = done_reg;

    // New: Add parity checking.
    parity par(.clk(clk),.in(in),.odd(odd));
    
    // New: Add counter.
    counter cnt(.clk(clk),.reset(reset),.in(in),.count(count));

    // New: Add nibble_error_count.
    always @(posedge clk)
        if(reset)
            nibble_error_count <= 0;
    	else
            nibble_error_count <= nibble_error_count + (in[3:0] == 4'hA? 1 : 0);

    // New: Add data_next.
    always @(posedge clk)
        if(reset)
            data_next <= 0;
    	else
            data_next <= data_next + 4'hA;

endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg state, next_state;
    reg [7:0] data;
    reg [8:0] c;
    
    always@(*) begin
        case(state)
            idle: next_state = recive;
            recive: next_state = done;
            done: next_state = idle;
            default: next_state = state;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(state==recive)
            data <= in;
        else if(state==done)
            c <= {c[0], c[8:1]};
    end
    
    assign done = (c==9'b1111_1111)?1:0;
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg state, next_state;
    reg [7:0] data;
    reg [8:0] c;
    
    always@(*) begin
        case(state)
            idle: next_state = recive;
            recive: next_state = done;
            done: next_state = idle;
            default: next_state = state;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(state==recive)
            data <= in;
        else if(state==done)
            c <= {c[0], c[8:1]};
    end
    
    assign done = (c==9'b1111_1111)?1:0;
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case(state)
            idle: begin
                if(~in[3])
                    next_state = start;
                else
                    next_state = idle;
            end
            start:  next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: begin
                if(in[3])
                    next_state = error;
                else
                    next_state = idle;
            end
            error: begin
                if(in[3])
                    next_state = error;
                else
                    next_state = idle;
            end
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case(state)
            idle: begin
                if(~in[3])
                    next_state = start;
                else
                    next_state = idle;
            end
            start:  next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: begin
                if(in[3])
                    next_state = error;
                else
                    next_state = idle;
            end
            error: begin
                if(in[3])
                    next_state = error;
                else
                    next_state = idle;
            end
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, stop=10, error=11;
    reg	[2:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, stop=10, error=11;
    reg	[2:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg	[1:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = recive;
            {idle, 1'b1}:	next_state = recive;
            {recive, 1'b0}:	next_state = idle;
            {recive, 1'b1}:	next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == recive);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg	[1:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = recive;
            {idle, 1'b1}:	next_state = recive;
            {recive, 1'b0}:	next_state = idle;
            {recive, 1'b1}:	next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == recive);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, stop=10, error=11;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, stop=10, error=11;
    reg	[2:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1, done=2;
    reg [1:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        case(state)
            idle: begin
                if(~in[3])
                    next_state = recive;
                else
                    next_state = idle;
            end
            recive: begin
                if(in[3])
                    next_state = done;
                else
                    next_state = recive;
            end
            done: begin
                if(in[3])
                    next_state = idle;
                else
                    next_state = done;
            end
            default: next_state = idle;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == done);
    
endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1, done=2;
    reg [1:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        case(state)
            idle: begin
                if(~in[3])
                    next_state = recive;
                else
                    next_state = idle;
            end
            recive: begin
                if(in[3])
                    next_state = done;
                else
                    next_state = recive;
            end
            done: begin
                if(in[3])
                    next_state = idle;
                else
                    next_state = done;
            end
            default: next_state = idle;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == done);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg state, next_state;
    reg [7:0] data;
    reg [8:0] c;
    
    assign done = (state == recive);
    
    always @(*) begin
        case(state)
            idle: next_state = recive;
            recive: next_state = done? idle : recive;
            done: next_state = done? idle : recive;
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == recive)
            data <= in;
        else if(state == done)
            c <= {c[0], c[8:1]};
    end
    
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, recive=1;
    reg state, next_state;
    reg [7:0] data;
    reg [8:0] c;
    
    assign done = (state == recive);
    
    always @(*) begin
        case(state)
            idle: next_state = recive;
            recive: next_state = done? idle : recive;
            done: next_state = done? idle : recive;
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == recive)
            data <= in;
        else if(state == done)
            c <= {c[0], c[8:1]};
    end
    
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    // State transition logic (combinational)
    always@(*) begin
        case({state, in[3]})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            default:		next_state = idle;
        endcase
    end
    // State flip-flops (sequential)
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    // Output logic
    assign	done = (state == stop);
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_MAIN_ADDR = 0;
    parameter S_MAIN_READ = 1;
    parameter S_MAIN_STORE = 2;
    parameter S_MAIN_DONE = 3;
    
    reg [3:0] state, next_state;
    reg [23:0] data;
    reg [7:0] addr;
    reg [7:0] len;
    reg [7:0] i;
    reg [23:0] out;
    reg done;
    
    initial begin
        state <= S_MAIN_ADDR;
    end
    
    always@(posedge clk) begin
        case(state)
            S_MAIN_ADDR: begin
                addr <= in[3:0];
                len <= in[7:4];
                done <= 0;
                i <= 0;
                out <= 0;
                next_state <= S_MAIN_READ;
            end
            S_MAIN_READ: begin
                if(done) begin
                    next_state <= S_MAIN_STORE;
                end
                else begin
                    next_state <= S_MAIN_READ;
                end
            end
            S_MAIN_STORE: begin
                next_state <= S_MAIN_DONE;
            end
            S_MAIN_DONE: begin
                next_state <= S_MAIN_ADDR;
            end
            default: next_state <= S_MAIN_ADDR;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset) begin
            state <= S_MAIN_ADDR;
            addr <= 0;
            len <= 0;
            done <= 0;
            i <= 0;
            out <= 0;
        end
        else begin
            state <= next_state;
            case(next_state)
                S_MAIN_ADDR: begin
                    addr <= in[3:0];
                    len <= in[7:4];
                    done <= 0;
                    i <= 0;
                    out <= 0;
                end
                S_MAIN_READ: begin
                    if(done) begin
                        out_bytes <= out;
                        done <= 0;
                        out <= 0;
                    end
                    else begin
                        out_bytes[7:0] <= data[7:0];
                        out_bytes[15:8] <= data[15:8];
                        out_bytes[23:16] <= data[23:16];
                        i <= i + 1;
                        out <= out + 1;
                    end
                end
                S_MAIN_STORE: begin
                    out_bytes[7:0] <= data[7:0];
                    out_bytes[15:8] <= data[15:8];
                    out_bytes[23:16] <= data[23:16];
                end
                S_MAIN_DONE: begin
                    done <= 1;
                end
            endcase
        end
    end
    
endmodule",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_MAIN_ADDR = 0;
    parameter S_MAIN_READ = 1;
    parameter S_MAIN_STORE = 2;
    parameter S_MAIN_DONE = 3;
    
    reg [3:0] state, next_state;
    reg [23:0] data;
    reg [7:0] addr;
    reg [7:0] len;
    reg [7:0] i;
    reg [23:0] out;
    reg done;
    
    initial begin
        state <= S_MAIN_ADDR;
    end
    
    always@(posedge clk) begin
        case(state)
            S_MAIN_ADDR: begin
                addr <= in[3:0];
                len <= in[7:4];
                done <= 0;
                i <= 0;
                out <= 0;
                next_state <= S_MAIN_READ;
            end
            S_MAIN_READ: begin
                if(done) begin
                    next_state <= S_MAIN_STORE;
                end
                else begin
                    next_state <= S_MAIN_READ;
                end
            end
            S_MAIN_STORE: begin
                next_state <= S_MAIN_DONE;
            end
            S_MAIN_DONE: begin
                next_state <= S_MAIN_ADDR;
            end
            default: next_state <= S_MAIN_ADDR;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset) begin
            state <= S_MAIN_ADDR;
            addr <= 0;
            len <= 0;
            done <= 0;
            i <= 0;
            out <= 0;
        end
        else begin
            state <= next_state;
            case(next_state)
                S_MAIN_ADDR: begin
                    addr <= in[3:0];
                    len <= in[7:4];
                    done <= 0;
                    i <= 0;
                    out <= 0;
                end
                S_MAIN_READ: begin
                    if(done) begin
                        out_bytes <= out;
                        done <= 0;
                        out <= 0;
                    end
                    else begin
                        out_bytes[7:0] <= data[7:0];
                        out_bytes[15:8] <= data[15:8];
                        out_bytes[23:16] <= data[23:16];
                        i <= i + 1;
                        out <= out + 1;
                    end
                end
                S_MAIN_STORE: begin
                    out_bytes[7:0] <= data[7:0];
                    out_bytes[15:8] <= data[15:8];
                    out_bytes[23:16] <= data[23:16];
                end
                S_MAIN_DONE: begin
                    done <= 1;
                end
            endcase
        end
    end
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter B1 = 0, B2 = 1, B3 = 2, DONE = 3;
    reg [1:0] state, next_state;
    reg [23:0] out;
    reg done_reg;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            B1: next_state = in[3]? B2 : B1;
            B2: next_state = in[4]? B3 : B2;
            B3: next_state = in[5]? DONE : B3;
            DONE: next_state = in[6]? B1 : DONE;
            default: next_state = state;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= B1;
    	else
            state <= next_state;
 
    // Output logic
    assign done = done_reg;
    
    // New: Add new state flip-flop.
    
    
    // New: Add new output flip-flop.
    
endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter B1 = 0, B2 = 1, B3 = 2, DONE = 3;
    reg [1:0] state, next_state;
    reg [23:0] out;
    reg done_reg;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            B1: next_state = in[3]? B2 : B1;
            B2: next_state = in[4]? B3 : B2;
            B3: next_state = in[5]? DONE : B3;
            DONE: next_state = in[6]? B1 : DONE;
            default: next_state = state;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= B1;
    	else
            state <= next_state;
 
    // Output logic
    assign done = done_reg;
    
    // New: Add new state flip-flop.
    
    
    // New: Add new output flip-flop.
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0, S_START = 1, S_DATA = 2, S_END = 3, S_PARSE = 4;

    reg [4:0] state, next_state;
    reg [23:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    reg [8:0] byte_counter;

    assign out_bytes = data;
    assign done = done_reg;

    always @(*) begin
        case(state)
            S_IDLE: next_state = in[3]? S_START : S_IDLE;
            S_START: next_state = in[2]? S_DATA : S_START;
            S_DATA: next_state = in[3]? S_DATA : S_END;
            S_END: next_state = S_IDLE;
            S_PARSE: next_state = in[3]? S_DATA : S_END;   // Don't go to S_END on last two bytes
            default: next_state = S_IDLE;
        endcase
    end

    always @(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end

    always @(posedge clk) begin
        if(state == S_PARSE)
            byte_counter <= byte_counter + 1;
        else
            byte_counter <= 0;
    end

    always @(posedge clk) begin
        if(state == S_DATA)
            data_byte <= in;
        else if(state == S_START)
            data <= 0;
    end

    always @(posedge clk) begin
        if(state == S_END)
            done_reg <= 1;
        else if(state == S_PARSE && byte_counter == 0)
            done_reg <= 0;
    end

endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0, S_START = 1, S_DATA = 2, S_END = 3, S_PARSE = 4;

    reg [4:0] state, next_state;
    reg [23:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    reg [8:0] byte_counter;

    assign out_bytes = data;
    assign done = done_reg;

    always @(*) begin
        case(state)
            S_IDLE: next_state = in[3]? S_START : S_IDLE;
            S_START: next_state = in[2]? S_DATA : S_START;
            S_DATA: next_state = in[3]? S_DATA : S_END;
            S_END: next_state = S_IDLE;
            S_PARSE: next_state = in[3]? S_DATA : S_END;   // Don't go to S_END on last two bytes
            default: next_state = S_IDLE;
        endcase
    end

    always @(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end

    always @(posedge clk) begin
        if(state == S_PARSE)
            byte_counter <= byte_counter + 1;
        else
            byte_counter <= 0;
    end

    always @(posedge clk) begin
        if(state == S_DATA)
            data_byte <= in;
        else if(state == S_START)
            data <= 0;
    end

    always @(posedge clk) begin
        if(state == S_END)
            done_reg <= 1;
        else if(state == S_PARSE && byte_counter == 0)
            done_reg <= 0;
    end

endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0;
    parameter S_START = 1;
    parameter S_DATA = 2;
    parameter S_END = 3;

    reg [7:0] data;
    reg [3:0] nibble;
    reg [2:0] state, next_state;
    reg [23:0] bytes;
    reg done_reg;
    
    assign out_bytes = bytes;
    assign done = done_reg;
    
    always@(*) begin
        case(state)
            S_IDLE: next_state = start_state(in);
            S_START: next_state = S_DATA;
            S_DATA: next_state = S_END;
            S_END: next_state = S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(state == S_IDLE)
            done_reg <= 0;
        else if(state == S_END)
            done_reg <= 1;
        else
            done_reg <= done;
    end
    
    // Determine the next state from the current state and the input
    function [7:0] start_state;
        input [7:0] in;
        reg [7:0] data;
        reg [3:0] nibble;
        reg [2:0] count;
        reg [23:0] bytes;
        begin
            data = in;
            nibble = data[3:0];
            count = 3'b000;
            bytes = 0;
            start_state = S_IDLE;
            case(state)
                S_IDLE: begin
                    if(start_packet(in))
                        start_state = S_START;
                end
                S_START: begin
                    bytes[23:0] = {4'b1010, nibble};
                    start_state = S_DATA;
                end
                S_DATA: begin
                    bytes[23:0] = {4'b1010, data[3:0]};
                    start_state = S_END;
                end
                S_END: begin
                    bytes[23:0] = {4'b1010, count};
                    start_state = S_IDLE;
                end
                default: start_state = S_IDLE;
            endcase
        end
    endfunction
    
    // Determine the output from the current state
    function [23:0] output_nibble;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_nibble = bytes[7:0];
        end
    endfunction
    
    // Determine the output from the current state
    function [23:0] output_byte;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_byte = bytes[15:8];
        end
    endfunction
    
    // Determine the output from the current state
    function [7:0] output_byte;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_byte = bytes[7:0];
        end
    endfunction
    
    // Determine the output from the current state
    function [7:0] output_byte;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_byte = bytes[7:0];
        end
    endfunction
    
    // Generate a nibble
    function [3:0] nibble;",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0;
    parameter S_START = 1;
    parameter S_DATA = 2;
    parameter S_END = 3;

    reg [7:0] data;
    reg [3:0] nibble;
    reg [2:0] state, next_state;
    reg [23:0] bytes;
    reg done_reg;
    
    assign out_bytes = bytes;
    assign done = done_reg;
    
    always@(*) begin
        case(state)
            S_IDLE: next_state = start_state(in);
            S_START: next_state = S_DATA;
            S_DATA: next_state = S_END;
            S_END: next_state = S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(state == S_IDLE)
            done_reg <= 0;
        else if(state == S_END)
            done_reg <= 1;
        else
            done_reg <= done;
    end
    
    // Determine the next state from the current state and the input
    function [7:0] start_state;
        input [7:0] in;
        reg [7:0] data;
        reg [3:0] nibble;
        reg [2:0] count;
        reg [23:0] bytes;
        begin
            data = in;
            nibble = data[3:0];
            count = 3'b000;
            bytes = 0;
            start_state = S_IDLE;
            case(state)
                S_IDLE: begin
                    if(start_packet(in))
                        start_state = S_START;
                end
                S_START: begin
                    bytes[23:0] = {4'b1010, nibble};
                    start_state = S_DATA;
                end
                S_DATA: begin
                    bytes[23:0] = {4'b1010, data[3:0]};
                    start_state = S_END;
                end
                S_END: begin
                    bytes[23:0] = {4'b1010, count};
                    start_state = S_IDLE;
                end
                default: start_state = S_IDLE;
            endcase
        end
    endfunction
    
    // Determine the output from the current state
    function [23:0] output_nibble;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_nibble = bytes[7:0];
        end
    endfunction
    
    // Determine the output from the current state
    function [23:0] output_byte;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_byte = bytes[15:8];
        end
    endfunction
    
    // Determine the output from the current state
    function [7:0] output_byte;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_byte = bytes[7:0];
        end
    endfunction
    
    // Determine the output from the current state
    function [7:0] output_byte;
        input [7:0] data;
        input [2:0] nibble;
        reg [23:0] bytes;
        begin
            bytes[23:0] = bytes[23:0];
            output_byte = bytes[7:0];
        end
    endfunction
    
    // Generate a nibble
    function [3:0] nibble;"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0, S_START = 1, S_DATA = 2, S_STOP = 3, S_END = 4;
    reg [4:0] state, next_state;
    reg [3:0] data_count;
    reg [7:0] data_shift;
    reg [7:0] data_parity;
    reg [23:0] bytes;
    reg done_reg;
    
    assign out_bytes = bytes;
    assign done = done_reg;
    
    always@(*) begin
        case(state)
            S_IDLE: next_state = S_START;
            S_START: next_state = S_DATA;
            S_DATA: next_state = S_STOP;
            S_STOP: next_state = S_END;
            S_END: next_state = S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(state == S_DATA)
            data_count <= data_count + 4'd1;
        else if(state == S_STOP)
            data_count <= 4'd0;
    end
    
    always@(posedge clk) begin
        if(state == S_START)
            data_shift <= in;
        else if(state == S_STOP && data_count >= 5'd2)
            data_shift <= {data_shift[6:0], 1'b0};
    end
    
    always@(posedge clk) begin
        if(state == S_START)
            data_parity <= in;
        else if(state == S_STOP && data_count >= 5'd2)
            data_parity <= data_parity ^ data_shift[7];
    end
    
    always@(posedge clk) begin
        case(state)
            S_IDLE:
                done_reg <= 1'b0;
            S_START:
                bytes <= 24'hFF;
            S_DATA:
                bytes <= bytes + 24'h01;
            S_STOP:
                bytes <= bytes + 24'hFF;
            S_END:
                done_reg <= 1'b1;
            default:
                ;
        endcase
    end
    
endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0, S_START = 1, S_DATA = 2, S_STOP = 3, S_END = 4;
    reg [4:0] state, next_state;
    reg [3:0] data_count;
    reg [7:0] data_shift;
    reg [7:0] data_parity;
    reg [23:0] bytes;
    reg done_reg;
    
    assign out_bytes = bytes;
    assign done = done_reg;
    
    always@(*) begin
        case(state)
            S_IDLE: next_state = S_START;
            S_START: next_state = S_DATA;
            S_DATA: next_state = S_STOP;
            S_STOP: next_state = S_END;
            S_END: next_state = S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        if(state == S_DATA)
            data_count <= data_count + 4'd1;
        else if(state == S_STOP)
            data_count <= 4'd0;
    end
    
    always@(posedge clk) begin
        if(state == S_START)
            data_shift <= in;
        else if(state == S_STOP && data_count >= 5'd2)
            data_shift <= {data_shift[6:0], 1'b0};
    end
    
    always@(posedge clk) begin
        if(state == S_START)
            data_parity <= in;
        else if(state == S_STOP && data_count >= 5'd2)
            data_parity <= data_parity ^ data_shift[7];
    end
    
    always@(posedge clk) begin
        case(state)
            S_IDLE:
                done_reg <= 1'b0;
            S_START:
                bytes <= 24'hFF;
            S_DATA:
                bytes <= bytes + 24'h01;
            S_STOP:
                bytes <= bytes + 24'hFF;
            S_END:
                done_reg <= 1'b1;
            default:
                ;
        endcase
    end
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter B1 = 0, B2 = 1, B3 = 2, DONE = 3;
    reg [1:0] state, next_state;
    reg [23:0] out;
    reg [3:0] n;
    
    assign out_bytes = out;
    assign done = (state == DONE)? 1 : 0;
    
    always @(*)
        case(state)
            B1: next_state = in[3]? B2 : B1;
            B2: next_state = in[2]? B3 : B2;
            B3: next_state = in[1]? DONE : B3;
            DONE: next_state = in[0]? B1 : DONE;
            default: next_state = state;
        endcase
    
    always @(posedge clk)
        if(reset)
            state <= B1;
    	else
            state <= next_state;
    
    always @(posedge clk)
    begin
        if(state == B1)
            out <= 0;
        else if(state == B2)
            out <= out + 1;
        else if(state == B3)
            out <= out + 2;
        else if(state == DONE)
            out <= out + 3;
    end
    
    
endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter B1 = 0, B2 = 1, B3 = 2, DONE = 3;
    reg [1:0] state, next_state;
    reg [23:0] out;
    reg [3:0] n;
    
    assign out_bytes = out;
    assign done = (state == DONE)? 1 : 0;
    
    always @(*)
        case(state)
            B1: next_state = in[3]? B2 : B1;
            B2: next_state = in[2]? B3 : B2;
            B3: next_state = in[1]? DONE : B3;
            DONE: next_state = in[0]? B1 : DONE;
            default: next_state = state;
        endcase
    
    always @(posedge clk)
        if(reset)
            state <= B1;
    	else
            state <= next_state;
    
    always @(posedge clk)
    begin
        if(state == B1)
            out <= 0;
        else if(state == B2)
            out <= out + 1;
        else if(state == B3)
            out <= out + 2;
        else if(state == DONE)
            out <= out + 3;
    end
    
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter B1 = 0, B2 = 1, B3 = 2, DONE = 3;
    reg [1:0] state, next_state;
    reg [23:0] out;
    reg done_reg;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            B1: next_state = (in[3] == 1)? B2:B1;
            B2: next_state = B3;
            B3: next_state = DONE;
            DONE: next_state = (in[3] == 1)? B2:B1;
            default: next_state = state;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= B1;
    	else
            state <= next_state;
 
    // Output logic
    assign done = done_reg;
    
    // New: Add new state flip-flop.
    
    // New: Add new output flip-flop.
    
    // New: Add new done flip-flop.
    
endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter B1 = 0, B2 = 1, B3 = 2, DONE = 3;
    reg [1:0] state, next_state;
    reg [23:0] out;
    reg done_reg;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            B1: next_state = (in[3] == 1)? B2:B1;
            B2: next_state = B3;
            B3: next_state = DONE;
            DONE: next_state = (in[3] == 1)? B2:B1;
            default: next_state = state;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= B1;
    	else
            state <= next_state;
 
    // Output logic
    assign done = done_reg;
    
    // New: Add new state flip-flop.
    
    // New: Add new output flip-flop.
    
    // New: Add new done flip-flop.
    
endmodule"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_MAIN_ADDR = 0;
    parameter S_MAIN_READ = 1;
    parameter S_MAIN_STORE = 2;
    parameter S_MAIN_WAIT = 3;
    
    reg [3:0] state, next_state;
    reg [23:0] data;
    reg [8:0] addr;
    reg [7:0] stored_data;
    reg done_sig;
    
    // State transition logic (combinatorial)
    always @(*) begin
        case (state)
            S_MAIN_ADDR: next_state = in[3:0] == 4'hD? S_MAIN_READ : S_MAIN_ADDR;
            S_MAIN_READ: next_state = S_MAIN_STORE;
            S_MAIN_STORE: next_state = (in[3:0] == 4'hD && in[7:4] == 4'hD)? S_MAIN_READ : S_MAIN_STORE;
            S_MAIN_WAIT: next_state = (in[3:0] == 4'hD && in[7:4] == 4'hD)? S_MAIN_READ : S_MAIN_WAIT;
            default: next_state = S_MAIN_ADDR;
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) state <= S_MAIN_ADDR;
        else state <= next_state;
    end
    
    // Output logic
    assign done = done_sig;
    
    // New: Add tri-state buffer for DDR2.
    assign out_bytes = {data, 2'b00};
    
    // New: Add tri-state buffer for DDR2.
    // DDR2 data is tri-state, but we need to send two nibbles to the DDR2 module.
    // We do not want glitches on the second nibble, so we need to buffer the data.
    // We do not want glitches on the first nibble, so we need to buffer the data.
    
    // DDR2 module
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // New: Add DDR2 module.
    
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_MAIN_ADDR = 0;
    parameter S_MAIN_READ = 1;
    parameter S_MAIN_STORE = 2;
    parameter S_MAIN_WAIT = 3;
    
    reg [3:0] state, next_state;
    reg [23:0] data;
    reg [8:0] addr;
    reg [7:0] stored_data;
    reg done_sig;
    
    // State transition logic (combinatorial)
    always @(*) begin
        case (state)
            S_MAIN_ADDR: next_state = in[3:0] == 4'hD? S_MAIN_READ : S_MAIN_ADDR;
            S_MAIN_READ: next_state = S_MAIN_STORE;
            S_MAIN_STORE: next_state = (in[3:0] == 4'hD && in[7:4] == 4'hD)? S_MAIN_READ : S_MAIN_STORE;
            S_MAIN_WAIT: next_state = (in[3:0] == 4'hD && in[7:4] == 4'hD)? S_MAIN_READ : S_MAIN_WAIT;
            default: next_state = S_MAIN_ADDR;
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) state <= S_MAIN_ADDR;
        else state <= next_state;
    end
    
    // Output logic
    assign done = done_sig;
    
    // New: Add tri-state buffer for DDR2.
    assign out_bytes = {data, 2'b00};
    
    // New: Add tri-state buffer for DDR2.
    // DDR2 data is tri-state, but we need to send two nibbles to the DDR2 module.
    // We do not want glitches on the second nibble, so we need to buffer the data.
    // We do not want glitches on the first nibble, so we need to buffer the data.
    
    // DDR2 module
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // New: Add DDR2 module.
    
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers.
    
    // DDR2 module will send us a nibble every 16th cycle.
    // We need to buffer the other nibble.
    // So we will need 4 16-cycle buffers."
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0, S_START = 1, S_DATA = 2, S_END = 3, S_PARSE = 4;
    
    reg [4:0] state, next_state;
    reg [23:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    
    // State transition logic (combinatorial)
    always @(*) begin
        case(state)
            S_IDLE: next_state = in[3]? S_START : S_IDLE;
            S_START: next_state = in[3]? S_DATA : S_START;
            S_DATA: next_state = in[3]? S_DATA : S_END;
            S_END: next_state = in[3]? S_PARSE : S_END;
            S_PARSE: next_state = in[3]? S_PARSE : S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset) state <= S_IDLE;
        else state <= next_state;
    end
    
    // Output logic
    assign done = done_reg;
    
    // New: Add parity checking.
    
    // Parity is the XOR of the input bytes (parity is delayed by one cycle).
    assign parity = in ^ {in[7:0], in[15:8], in[23:16]};
    
    // Parity should be asserted as long as we're in the S_PARSE state.
    assign done_reg = (state == S_PARSE);
    
    // New: Add a new state S_PRINT.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_LOW.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_HIGH.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_ASCII.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_ASCII_LOW.
    
    // The new state is a combinational output of the FSM",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0, S_START = 1, S_DATA = 2, S_END = 3, S_PARSE = 4;
    
    reg [4:0] state, next_state;
    reg [23:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    
    // State transition logic (combinatorial)
    always @(*) begin
        case(state)
            S_IDLE: next_state = in[3]? S_START : S_IDLE;
            S_START: next_state = in[3]? S_DATA : S_START;
            S_DATA: next_state = in[3]? S_DATA : S_END;
            S_END: next_state = in[3]? S_PARSE : S_END;
            S_PARSE: next_state = in[3]? S_PARSE : S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset) state <= S_IDLE;
        else state <= next_state;
    end
    
    // Output logic
    assign done = done_reg;
    
    // New: Add parity checking.
    
    // Parity is the XOR of the input bytes (parity is delayed by one cycle).
    assign parity = in ^ {in[7:0], in[15:8], in[23:16]};
    
    // Parity should be asserted as long as we're in the S_PARSE state.
    assign done_reg = (state == S_PARSE);
    
    // New: Add a new state S_PRINT.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_LOW.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_HIGH.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_ASCII.
    
    // The new state is a combinational output of the FSM.
    // It is delayed by one cycle cycle.
    // It is safe to set this to 0 in the S_IDLE state.
    // It is safe to set this to 0 in the S_PRINT state.
    // It is safe to set this to 0 in the S_END state.
    // It is safe to set this to 0 in the S_PARSE state.
    // It is safe to set this to 0 in the S_IDLE state.
    
    // New: Add a new state S_PRINT_ASCII_LOW.
    
    // The new state is a combinational output of the FSM"
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0;
    parameter S_START = 1;
    parameter S_DATA = 2;
    parameter S_PARITY = 3;
    parameter S_STOP = 4;
    
    reg [4:0] state, next_state;
    reg [8:0] bytes_remaining;
    reg [23:0] out_bytes;
    reg done;
    
    // State transition logic (combinatorial)
    always @(*) begin
        case(state)
            S_IDLE: next_state = in[3]? S_START : S_IDLE;
            S_START: next_state = in[3]? S_DATA : S_START;
            S_DATA: next_state = in[3]? S_DATA : S_PARITY;
            S_PARITY: next_state = in[3]? S_STOP : S_PARITY;
            S_STOP: next_state = S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end
    
    
    // Output logic
    assign done = (state == S_STOP);
    
    
    // New: Add parity checking.
    
    
endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter S_IDLE = 0;
    parameter S_START = 1;
    parameter S_DATA = 2;
    parameter S_PARITY = 3;
    parameter S_STOP = 4;
    
    reg [4:0] state, next_state;
    reg [8:0] bytes_remaining;
    reg [23:0] out_bytes;
    reg done;
    
    // State transition logic (combinatorial)
    always @(*) begin
        case(state)
            S_IDLE: next_state = in[3]? S_START : S_IDLE;
            S_START: next_state = in[3]? S_DATA : S_START;
            S_DATA: next_state = in[3]? S_DATA : S_PARITY;
            S_PARITY: next_state = in[3]? S_STOP : S_PARITY;
            S_STOP: next_state = S_IDLE;
            default: next_state = S_IDLE;
        endcase
    end
    
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset)
            state <= S_IDLE;
        else
            state <= next_state;
    end
    
    
    // Output logic
    assign done = (state == S_STOP);
    
    
    // New: Add parity checking.
    
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=2'd0, start=2'd1, trans0=2'd2, trans1=2'd3, trans2=2'd4, trans3=2'd5;
    parameter trans4=2'd6, trans5=2'd7, trans6=2'd8, trans7=2'd9, stop=2'd10, error=2'd11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, in})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = start;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=2'd0, start=2'd1, trans0=2'd2, trans1=2'd3, trans2=2'd4, trans3=2'd5;
    parameter trans4=2'd6, trans5=2'd7, trans6=2'd8, trans7=2'd9, stop=2'd10, error=2'd11;
    reg	[1:0]	state, next_state;
    
    // State transition logic
    always@(*) begin
        case({state, in})
            {idle, 1'b0}:	next_state = start;
            {start, 1'b0}:	next_state = trans0;
            {trans0, 1'b0}:	next_state = trans1;
            {trans1, 1'b0}:	next_state = trans2;
            {trans2, 1'b0}:	next_state = trans3;
            {trans3, 1'b0}:	next_state = trans4;
            {trans4, 1'b0}:	next_state = trans5;
            {trans5, 1'b0}:	next_state = trans6;
            {trans6, 1'b0}:	next_state = trans7;
            {trans7, 1'b0}:	next_state = stop;
            {stop, 1'b0}:	next_state = idle;
            {error, 1'b0}:	next_state = idle;
            {idle, 1'b1}:	next_state = start;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5, trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = trans8;
            trans8: next_state = trans9;
            trans9: next_state = trans10;
            trans10: next_state = trans11;
            trans11: next_state = trans12;
            trans12: next_state = trans13;
            trans13: next_state = trans14;
            trans14: next_state = trans15;
            trans15: next_state = trans16;
            trans16: next_state = trans17;
            trans17: next_state = trans18;
            trans18: next_state = trans19;
            trans19: next_state = trans20;
            trans20: next_state = trans21;
            trans21: next_state = trans22;
            trans22: next_state = trans23;
            trans23: next_state = trans24;
            trans24: next_state = trans25;
            trans25: next_state = trans26;
            trans26: next_state = trans27;
            trans27: next_state = trans28;
            trans28: next_state = trans29;
            trans29: next_state = trans30;
            trans30: next_state = trans31;
            trans31: next_state = trans32;
            trans32: next_state = trans33;
            trans33: next_state = trans34;
            trans34: next_state = trans35;
            trans35: next_state = trans36;
            trans36: next_state = trans37;
            trans37: next_state = trans38;
            trans38: next_state = trans39;
            trans39: next_state = trans40;
            trans40: next_state = trans41;
            trans41: next_state = trans42;
            trans42: next_state = trans43;
            trans43: next_state = trans44;
            trans44: next_state = trans45;
            trans45: next_state = trans46;
            trans46: next_state = trans47;
            trans47: next_state = trans48;
            trans48: next_state = trans49;
            trans49: next_state = trans50;
            trans50: next_state = trans51;
            trans51: next_state = trans52;
            trans52: next_state = trans53;
            trans53: next_state = trans54;
            trans54: next_state = trans55;
            trans55: next_state = trans56;
            trans56: next_state = trans57;
            trans57: next_state = trans58;
            trans58: next_state = trans59;
            trans59: next_state = trans60;
            trans60: next_state = trans61;
            trans61: next_state = trans62;
            trans62: next_state = trans63;
            trans63: next_state = trans64;
            trans64: next_state = trans65;
            trans65: next_state = trans66;
            trans66: next_state = trans67;
            trans67: next_state = trans68;
            trans68: next_state = trans69;
            trans69: next_state = trans70;
            trans70: next_state = trans71;
            trans71: next_state = trans72;
            trans72: next_state = trans73;
            trans73: next_state",-1,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5, trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = trans8;
            trans8: next_state = trans9;
            trans9: next_state = trans10;
            trans10: next_state = trans11;
            trans11: next_state = trans12;
            trans12: next_state = trans13;
            trans13: next_state = trans14;
            trans14: next_state = trans15;
            trans15: next_state = trans16;
            trans16: next_state = trans17;
            trans17: next_state = trans18;
            trans18: next_state = trans19;
            trans19: next_state = trans20;
            trans20: next_state = trans21;
            trans21: next_state = trans22;
            trans22: next_state = trans23;
            trans23: next_state = trans24;
            trans24: next_state = trans25;
            trans25: next_state = trans26;
            trans26: next_state = trans27;
            trans27: next_state = trans28;
            trans28: next_state = trans29;
            trans29: next_state = trans30;
            trans30: next_state = trans31;
            trans31: next_state = trans32;
            trans32: next_state = trans33;
            trans33: next_state = trans34;
            trans34: next_state = trans35;
            trans35: next_state = trans36;
            trans36: next_state = trans37;
            trans37: next_state = trans38;
            trans38: next_state = trans39;
            trans39: next_state = trans40;
            trans40: next_state = trans41;
            trans41: next_state = trans42;
            trans42: next_state = trans43;
            trans43: next_state = trans44;
            trans44: next_state = trans45;
            trans45: next_state = trans46;
            trans46: next_state = trans47;
            trans47: next_state = trans48;
            trans48: next_state = trans49;
            trans49: next_state = trans50;
            trans50: next_state = trans51;
            trans51: next_state = trans52;
            trans52: next_state = trans53;
            trans53: next_state = trans54;
            trans54: next_state = trans55;
            trans55: next_state = trans56;
            trans56: next_state = trans57;
            trans57: next_state = trans58;
            trans58: next_state = trans59;
            trans59: next_state = trans60;
            trans60: next_state = trans61;
            trans61: next_state = trans62;
            trans62: next_state = trans63;
            trans63: next_state = trans64;
            trans64: next_state = trans65;
            trans65: next_state = trans66;
            trans66: next_state = trans67;
            trans67: next_state = trans68;
            trans68: next_state = trans69;
            trans69: next_state = trans70;
            trans70: next_state = trans71;
            trans71: next_state = trans72;
            trans72: next_state = trans73;
            trans73: next_state"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, stop=10, error=11;
    reg	[2:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, stop=10, error=11;
    reg	[2:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11;
    reg	[3:0]	state, next_state;
    
    always@(*) begin
        case(state)
            idle: next_state = start;
            start: next_state = trans0;
            trans0: next_state = trans1;
            trans1: next_state = trans2;
            trans2: next_state = trans3;
            trans3: next_state = trans4;
            trans4: next_state = trans5;
            trans5: next_state = trans6;
            trans6: next_state = trans7;
            trans7: next_state = stop;
            stop: next_state = error;
            error: next_state = idle;
            default: next_state = idle;
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign	done = (state == stop);
    
endmodule"
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=2'd0, start=2'd1, trans0=2'd2, trans1=2'd3, trans2=2'd4, trans3=2'd5, trans4=2'd6, trans5=2'd7, trans6=2'd8, trans7=2'd9, stop=2'd10, error=2'd11;
    reg	[1:0]	state, next_state;
    
    reg	[7:0]	data;
    reg	[2:0]	bit_count;
    reg	[1:0]	parity_count;
    reg	[7:0]	shift_reg;
    reg	[2:0]	parity_reg;
    reg	[1:0]	state_reg;
    reg	[7:0]	data_reg;
    reg	[2:0]	bit_count_reg;
    reg	[1:0]	parity_count_reg;
    reg	[7:0]	shift_reg_reg;
    reg	[2:0]	parity_reg_reg;
    reg	[1:0]	state_reg_reg;
    reg	[7:0]	data_reg_reg;
    reg	[2:0]	bit_count_reg_reg;
    reg	[1:0]	parity_count_reg_reg;
    reg	[7:0]	shift_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg_reg_reg;",-1,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=2'd0, start=2'd1, trans0=2'd2, trans1=2'd3, trans2=2'd4, trans3=2'd5, trans4=2'd6, trans5=2'd7, trans6=2'd8, trans7=2'd9, stop=2'd10, error=2'd11;
    reg	[1:0]	state, next_state;
    
    reg	[7:0]	data;
    reg	[2:0]	bit_count;
    reg	[1:0]	parity_count;
    reg	[7:0]	shift_reg;
    reg	[2:0]	parity_reg;
    reg	[1:0]	state_reg;
    reg	[7:0]	data_reg;
    reg	[2:0]	bit_count_reg;
    reg	[1:0]	parity_count_reg;
    reg	[7:0]	shift_reg_reg;
    reg	[2:0]	parity_reg_reg;
    reg	[1:0]	state_reg_reg;
    reg	[7:0]	data_reg_reg;
    reg	[2:0]	bit_count_reg_reg;
    reg	[1:0]	parity_count_reg_reg;
    reg	[7:0]	shift_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg_reg_reg;
    reg	[7:0]	shift_reg_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	parity_reg_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	state_reg_reg_reg_reg_reg_reg_reg;
    reg	[7:0]	data_reg_reg_reg_reg_reg_reg_reg;
    reg	[2:0]	bit_count_reg_reg_reg_reg_reg_reg;
    reg	[1:0]	parity_count_reg_reg_reg_reg_reg_reg;"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    
    // New: Add register for input byte.
    
    always @(posedge clk) begin
        if (state == DATA) begin
            data_byte <= bytes[0];
            data <= data_byte;
            count <= count + 4'd1;
            if (count == 9) begin
                done_reg <= 1;
                next_state <= START;
            end
        end
        else if (state == START) begin
            done_reg <= 0;
            next_state <= in? START : DATA;
        end
        else if (state == STOP) begin
            done_reg <= 1;
            next_state <= in? START : DATA;
        end
        else begin
            next_state <= in? START : state;
        end
    end
    
    
    // New: Add input byte register.
    
    always @(posedge clk) begin
        if (reset) begin
            bytes <= 9'd0;
            data_byte <= 8'h00;
        end
        else begin
            bytes <= bytes + 9'd1;
            data_byte <= in? bytes[0] : data_byte;
        end
    end
    
    
    // New: Add counter for 3-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end
        else begin
            count <= count + 4'd1;
            if (count == 9) begin
                count <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 3-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done <= 1'b0;
        end
        else begin
            done <= done_reg;
        end
    end
    
    
    // New: Add counter for 4-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count2 <= 4'b0;
        end
        else begin
            count2 <= count2 + 4'd1;
            if (count2 == 9) begin
                count2 <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 4-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done2 <= 1'b0;
        end
        else begin
            done2 <= done2;
        end
    end
    
    
    // New: Add counter for 5-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count3 <= 4'b0;
        end
        else begin
            count3 <= count3 + 4'd1;
            if (count3 == 9) begin
                count3 <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 5-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done3 <= 1'b0;
        end
        else begin
            done3 <= done3;
        end
    end
    
    
    // New: Add counter for 6-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count4 <= 4'b0;
        end
        else begin
            count4 <= count4 + 4'd1;
            if (count4 == 9) begin
                count4 <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 6-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done4 <= 1'b0;
        end
        else begin
            done4 <= done4;",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    
    // New: Add register for input byte.
    
    always @(posedge clk) begin
        if (state == DATA) begin
            data_byte <= bytes[0];
            data <= data_byte;
            count <= count + 4'd1;
            if (count == 9) begin
                done_reg <= 1;
                next_state <= START;
            end
        end
        else if (state == START) begin
            done_reg <= 0;
            next_state <= in? START : DATA;
        end
        else if (state == STOP) begin
            done_reg <= 1;
            next_state <= in? START : DATA;
        end
        else begin
            next_state <= in? START : state;
        end
    end
    
    
    // New: Add input byte register.
    
    always @(posedge clk) begin
        if (reset) begin
            bytes <= 9'd0;
            data_byte <= 8'h00;
        end
        else begin
            bytes <= bytes + 9'd1;
            data_byte <= in? bytes[0] : data_byte;
        end
    end
    
    
    // New: Add counter for 3-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count <= 4'b0;
        end
        else begin
            count <= count + 4'd1;
            if (count == 9) begin
                count <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 3-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done <= 1'b0;
        end
        else begin
            done <= done_reg;
        end
    end
    
    
    // New: Add counter for 4-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count2 <= 4'b0;
        end
        else begin
            count2 <= count2 + 4'd1;
            if (count2 == 9) begin
                count2 <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 4-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done2 <= 1'b0;
        end
        else begin
            done2 <= done2;
        end
    end
    
    
    // New: Add counter for 5-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count3 <= 4'b0;
        end
        else begin
            count3 <= count3 + 4'd1;
            if (count3 == 9) begin
                count3 <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 5-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done3 <= 1'b0;
        end
        else begin
            done3 <= done3;
        end
    end
    
    
    // New: Add counter for 6-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            count4 <= 4'b0;
        end
        else begin
            count4 <= count4 + 4'd1;
            if (count4 == 9) begin
                count4 <= 4'b0;
            end
        end
    end
    
    
    // New: Add done flag for 6-letter delay.
    
    always @(posedge clk) begin
        if (reset) begin
            done4 <= 1'b0;
        end
        else begin
            done4 <= done4;"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] data;
    reg [9:0] sum;
    reg [7:0] sum_next;
    reg done_reg;
    
    // New: Add parity checking.
    
    parity par_mod(.clk(clk),.in(in),.odd(odd));
    
    // Modify FSM to count input bytes
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (done_reg)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (done_reg)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (done_reg)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DELAY: next_state = state;
            default: next_state = state;
        endcase
    end
    
    // Modify FSM to generate a serial bitstream
    
    always @(posedge clk) begin
        if (reset) begin
            bytes <= 0;
            data <= 0;
        end
        else begin
            case (state)
                START: begin
                    bytes <= 0;
                    data <= 0;
                end
                DATA: begin
                    bytes <= bytes + 1;
                    data <= in;
                end
                STOP: begin
                    bytes <= bytes + 1;
                    data <= 0;
                end
                DELAY:
                default: begin
                    bytes <= bytes + 1;
                    data <= 0;
                end
            endcase
        end
    end
    
    // Modify FSM to count input bytes
    
    always @(posedge clk) begin
        if (reset)
            done_reg <= 0;
        else if (state == STOP)
            done_reg <= 1;
        else
            done_reg <= done_reg;
    end
    
    // Modify datapath to latch input bytes
    
    always @(posedge clk) begin
        if (reset)
            data_reg <= 0;
        else
            data_reg <= data;
    end
    
    // Modify datapath to perform a shift right
    
    always @(posedge clk) begin
        if (reset)
            sum <= 0;
        else if (state == DATA)
            sum <= sum + 1;
        else if (state == START)
            sum <= 0;
    end
    
    // Modify datapath to store the result
    
    always @(posedge clk) begin
        if (reset)
            out_byte <= 0;
        else if (state == DATA)
            out_byte <= data_reg;
    end
    
    // Modify FSM to accept new input bytes
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    // Modify FSM to send out bytes
    
    always @(posedge clk) begin
        if (reset)
            done <= 0;
        else if (state == START)
            done <= 1;
        else if (state == STOP)
            done <= 0;
    end
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] data;
    reg [9:0] sum;
    reg [7:0] sum_next;
    reg done_reg;
    
    // New: Add parity checking.
    
    parity par_mod(.clk(clk),.in(in),.odd(odd));
    
    // Modify FSM to count input bytes
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            START: begin
                if (done_reg)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA: begin
                if (done_reg)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if (done_reg)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DELAY: next_state = state;
            default: next_state = state;
        endcase
    end
    
    // Modify FSM to generate a serial bitstream
    
    always @(posedge clk) begin
        if (reset) begin
            bytes <= 0;
            data <= 0;
        end
        else begin
            case (state)
                START: begin
                    bytes <= 0;
                    data <= 0;
                end
                DATA: begin
                    bytes <= bytes + 1;
                    data <= in;
                end
                STOP: begin
                    bytes <= bytes + 1;
                    data <= 0;
                end
                DELAY:
                default: begin
                    bytes <= bytes + 1;
                    data <= 0;
                end
            endcase
        end
    end
    
    // Modify FSM to count input bytes
    
    always @(posedge clk) begin
        if (reset)
            done_reg <= 0;
        else if (state == STOP)
            done_reg <= 1;
        else
            done_reg <= done_reg;
    end
    
    // Modify datapath to latch input bytes
    
    always @(posedge clk) begin
        if (reset)
            data_reg <= 0;
        else
            data_reg <= data;
    end
    
    // Modify datapath to perform a shift right
    
    always @(posedge clk) begin
        if (reset)
            sum <= 0;
        else if (state == DATA)
            sum <= sum + 1;
        else if (state == START)
            sum <= 0;
    end
    
    // Modify datapath to store the result
    
    always @(posedge clk) begin
        if (reset)
            out_byte <= 0;
        else if (state == DATA)
            out_byte <= data_reg;
    end
    
    // Modify FSM to accept new input bytes
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    // Modify FSM to send out bytes
    
    always @(posedge clk) begin
        if (reset)
            done <= 0;
        else if (state == START)
            done <= 1;
        else if (state == STOP)
            done <= 0;
    end
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    
    always @(*)
    begin
        case (state)
            START:
            begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA:
            begin
                // Count valid data bits, but don't ack until STATE2
                if (in == 1'b1)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP:
            begin
                // Count valid stop bits, ack when all bits have been received
                if (in == 1'b1)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY:
            begin
                // Wait for two stop bits, or until reset
                if (count == 4'b1111)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default:
                next_state = START;
        endcase
    end
    
    always @(posedge clk)
    begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk)
    begin
        case (next_state)
            START:
            begin
                out <= 0;
                count <= 4'b0000;
                bytes <= 9'b000000000;
            end
            DATA:
            begin
                // Data bit
                if (count < 4'b1111)
                    count <= count + 4'b0001;
                else
                    count <= 4'b0000;
                
                // Handle ACK
                if (count == 4'b1111)
                    out_byte[count] <= in;
                
                bytes <= bytes + 1'b1;
            end
            STOP:
            begin
                out <= ((bytes == 9'b111111111)? 1'b1 : 1'b0);
                count <= 4'b0000;
            end
            DELAY:
            begin
                out <= ((bytes == 9'b111111111)? 1'b1 : 1'b0);
                count <= count + 4'b0001;
            end
            default:
                out <= 1'b1;
        endcase
    end
    
    assign done = (state == STOP);
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    
    always @(*)
    begin
        case (state)
            START:
            begin
                if (in == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA:
            begin
                // Count valid data bits, but don't ack until STATE2
                if (in == 1'b1)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP:
            begin
                // Count valid stop bits, ack when all bits have been received
                if (in == 1'b1)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY:
            begin
                // Wait for two stop bits, or until reset
                if (count == 4'b1111)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default:
                next_state = START;
        endcase
    end
    
    always @(posedge clk)
    begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk)
    begin
        case (next_state)
            START:
            begin
                out <= 0;
                count <= 4'b0000;
                bytes <= 9'b000000000;
            end
            DATA:
            begin
                // Data bit
                if (count < 4'b1111)
                    count <= count + 4'b0001;
                else
                    count <= 4'b0000;
                
                // Handle ACK
                if (count == 4'b1111)
                    out_byte[count] <= in;
                
                bytes <= bytes + 1'b1;
            end
            STOP:
            begin
                out <= ((bytes == 9'b111111111)? 1'b1 : 1'b0);
                count <= 4'b0000;
            end
            DELAY:
            begin
                out <= ((bytes == 9'b111111111)? 1'b1 : 1'b0);
                count <= count + 4'b0001;
            end
            default:
                out <= 1'b1;
        endcase
    end
    
    assign done = (state == STOP);
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    
    always @(*)
        case(state)
            START: begin
                next_state <= (in)? START:DATA;
                out <= 0;
            end
            DATA: begin
                // Count valid data bits, but wait for end of byte
                if(count < 7)
                    next_state <= DATA;
                else
                    next_state <= STOP;
                out_byte[count] <= in;
                count <= count + 1;
            end
            STOP: begin
                // Check for stop bit
                if(in)
                    next_state <= DELAY;
                else
                    next_state <= START;
                out <= in;
            end
            DELAY: begin
                // Wait for two stop bits
                if(in)
                    next_state <= DELAY;
                else
                    next_state <= START;
                out <= in;
            end
            default: next_state <= state;
        endcase
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    assign done = (state == STOP);
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    
    always @(*)
        case(state)
            START: begin
                next_state <= (in)? START:DATA;
                out <= 0;
            end
            DATA: begin
                // Count valid data bits, but wait for end of byte
                if(count < 7)
                    next_state <= DATA;
                else
                    next_state <= STOP;
                out_byte[count] <= in;
                count <= count + 1;
            end
            STOP: begin
                // Check for stop bit
                if(in)
                    next_state <= DELAY;
                else
                    next_state <= START;
                out <= in;
            end
            DELAY: begin
                // Wait for two stop bits
                if(in)
                    next_state <= DELAY;
                else
                    next_state <= START;
                out <= in;
            end
            default: next_state <= state;
        endcase
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    assign done = (state == STOP);
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, prev_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    
    initial begin
        state <= START;
        count <= 4'd0;
        bytes <= 9'd0;
        data <= 8'd0;
        data_byte <= 8'd0;
        done_reg <= 1'b0;
    end
    
    
    // New: Add parity checking.
    parity par_mod(.clk(clk),.in(in),.reset(reset),.odd(odd));
    
    // New: Add FSM to handle the repeated start and stop.
    // New: Add FSM to handle the parity error.
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            count <= count + 4'd1;
        else if (state == START)
            bytes <= bytes + 9'd1;
        else if (state == STOP)
            bytes <= bytes - 9'd1;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            data <= {data[6:0], in};
    end
    
    always @(posedge clk) begin
        if (state == START)
            data_byte <= data;
    end
    
    always @(posedge clk) begin
        if (state == STOP)
            done_reg <= parity == odd;
    end
    
    always @(posedge clk)
        if (state == START)
            next_state <= DATA;
    else if (state == DATA && count < 9'd511 && next_state == DATA)
        next_state <= DATA;
    else if (state == DATA && count < 9'd511 && next_state == STOP)
        next_state <= STOP;
    else if (state == STOP && next_state == START)
        next_state <= DATA;
    else
        next_state <= state;
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, prev_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] data;
    reg [7:0] data_byte;
    reg done_reg;
    
    initial begin
        state <= START;
        count <= 4'd0;
        bytes <= 9'd0;
        data <= 8'd0;
        data_byte <= 8'd0;
        done_reg <= 1'b0;
    end
    
    
    // New: Add parity checking.
    parity par_mod(.clk(clk),.in(in),.reset(reset),.odd(odd));
    
    // New: Add FSM to handle the repeated start and stop.
    // New: Add FSM to handle the parity error.
    
    always @(posedge clk) begin
        if (reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            count <= count + 4'd1;
        else if (state == START)
            bytes <= bytes + 9'd1;
        else if (state == STOP)
            bytes <= bytes - 9'd1;
    end
    
    always @(posedge clk) begin
        if (state == DATA)
            data <= {data[6:0], in};
    end
    
    always @(posedge clk) begin
        if (state == START)
            data_byte <= data;
    end
    
    always @(posedge clk) begin
        if (state == STOP)
            done_reg <= parity == odd;
    end
    
    always @(posedge clk)
        if (state == START)
            next_state <= DATA;
    else if (state == DATA && count < 9'd511 && next_state == DATA)
        next_state <= DATA;
    else if (state == DATA && count < 9'd511 && next_state == STOP)
        next_state <= STOP;
    else if (state == STOP && next_state == START)
        next_state <= DATA;
    else
        next_state <= state;
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg out;
    
    // New: Add parity checking.
    
    parity par(.clk(clk),.in(in),.odd(out));
    
    // New: Add reset output.
    
    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else
            out <= in;
    end
    
    // New: Add byte counter.
    
    always @(posedge clk) begin
        if(state == DATA)
            bytes <= bytes + 1;
        else if(state == START)
            bytes <= 0;
    end
    
    // New: Add output byte.
    
    always @(posedge clk) begin
        if(state == DATA && count < 9)
            out_byte[count] <= out;
        else if(state == START || state == STOP)
            out_byte <= out_byte;
    end
    
    // New: Add done output.
    
    always @(posedge clk) begin
        if(state == DATA && count < 9)
            done <= 0;
        else if(state == START || state == STOP)
            done <= 1;
    end
    
    // New: Add state.
    
    always @(posedge clk) begin
        state <= next_state;
    end
    
    // New: Add counter.
    
    always @(posedge clk) begin
        if(reset)
            count <= 0;
        else if(state == DATA && count < 9)
            count <= count + 1;
        else if(state == START)
            count <= 0;
    end
    
    // New: Add next_state.
    
    always @(*) begin
        case(state)
            START: next_state <= (in)? START:DATA;
            DATA: next_state <= (count < 9)? DATA:STOP;
            STOP: next_state <= (in)? START:DELAY;
            DELAY:next_state <= (in)? START:DELAY;
            default: next_state <= state;
        endcase
    end
    
    // New: Add reset.
    
    always @(posedge clk) begin
        if(reset)
            next_state <= START;
        else
            next_state <= state;
    end
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg out;
    
    // New: Add parity checking.
    
    parity par(.clk(clk),.in(in),.odd(out));
    
    // New: Add reset output.
    
    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else
            out <= in;
    end
    
    // New: Add byte counter.
    
    always @(posedge clk) begin
        if(state == DATA)
            bytes <= bytes + 1;
        else if(state == START)
            bytes <= 0;
    end
    
    // New: Add output byte.
    
    always @(posedge clk) begin
        if(state == DATA && count < 9)
            out_byte[count] <= out;
        else if(state == START || state == STOP)
            out_byte <= out_byte;
    end
    
    // New: Add done output.
    
    always @(posedge clk) begin
        if(state == DATA && count < 9)
            done <= 0;
        else if(state == START || state == STOP)
            done <= 1;
    end
    
    // New: Add state.
    
    always @(posedge clk) begin
        state <= next_state;
    end
    
    // New: Add counter.
    
    always @(posedge clk) begin
        if(reset)
            count <= 0;
        else if(state == DATA && count < 9)
            count <= count + 1;
        else if(state == START)
            count <= 0;
    end
    
    // New: Add next_state.
    
    always @(*) begin
        case(state)
            START: next_state <= (in)? START:DATA;
            DATA: next_state <= (count < 9)? DATA:STOP;
            STOP: next_state <= (in)? START:DELAY;
            DELAY:next_state <= (in)? START:DELAY;
            default: next_state <= state;
        endcase
    end
    
    // New: Add reset.
    
    always @(posedge clk) begin
        if(reset)
            next_state <= START;
        else
            next_state <= state;
    end
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(*)
        case(state)
            START: begin
                next_state = DATA;
                out = 0;
                count = 0;
                bytes = 0;
                out_byte = 0;
                done = 0;
                if (in == 1'b0)
                    next_state = START;
            end
            
            DATA: begin
                // Wait for two consecutives id bits
                if (count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
                out = 0;
                count = 0;
                bytes = 0;
                out_byte = 0;
                if (in == 1'b1)
                    bytes = bytes + 1;
                else
                    out = 1;
            end
            
            STOP: begin
                // Wait for stop bit
                if (count < 1)
                    next_state = START;
                else
                    next_state = DELAY;
                out = 0;
                count = 0;
                bytes = 0;
                out_byte = 0;
                done = 1;
            end
            
            DELAY:
                // Wait for one clock cycle
                next_state = START;
            
            default:
                next_state = START;
        endcase
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            count <= 0;
    	else
            case(next_state)
                START:
                    count <= count + 1;
                DATA:
                    count <= count + 1;
                STOP:
                    count <= count + 1;
                DELAY:
                    count <= count + 1;
                default:
                    count <= 0;
            endcase
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            out <= 0;
    	else
            case(next_state)
                START:
                    out <= 0;
                DATA:
                    out <= data[0];
                STOP:
                    out <= 0;
                DELAY:
                    out <= 0;
                default:
                    out <= out;
            endcase
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            done <= 0;
    	else
            case(next_state)
                START:
                    done <= 0;
                DATA:
                    done <= 1;
                STOP:
                    done <= 1;
                DELAY:
                    done <= 0;
                default:
                    done <= done;
            endcase
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(*)
        case(state)
            START: begin
                next_state = DATA;
                out = 0;
                count = 0;
                bytes = 0;
                out_byte = 0;
                done = 0;
                if (in == 1'b0)
                    next_state = START;
            end
            
            DATA: begin
                // Wait for two consecutives id bits
                if (count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
                out = 0;
                count = 0;
                bytes = 0;
                out_byte = 0;
                if (in == 1'b1)
                    bytes = bytes + 1;
                else
                    out = 1;
            end
            
            STOP: begin
                // Wait for stop bit
                if (count < 1)
                    next_state = START;
                else
                    next_state = DELAY;
                out = 0;
                count = 0;
                bytes = 0;
                out_byte = 0;
                done = 1;
            end
            
            DELAY:
                // Wait for one clock cycle
                next_state = START;
            
            default:
                next_state = START;
        endcase
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            count <= 0;
    	else
            case(next_state)
                START:
                    count <= count + 1;
                DATA:
                    count <= count + 1;
                STOP:
                    count <= count + 1;
                DELAY:
                    count <= count + 1;
                default:
                    count <= 0;
            endcase
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            out <= 0;
    	else
            case(next_state)
                START:
                    out <= 0;
                DATA:
                    out <= data[0];
                STOP:
                    out <= 0;
                DELAY:
                    out <= 0;
                default:
                    out <= out;
            endcase
    
    // New: Add parity checking.
    
    // Modify FSM
    always @(posedge clk)
        if(reset)
            done <= 0;
    	else
            case(next_state)
                START:
                    done <= 0;
                DATA:
                    done <= 1;
                STOP:
                    done <= 1;
                DELAY:
                    done <= 0;
                default:
                    done <= done;
            endcase
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] byte_out;
    reg done_count;
    
    initial begin
        state <= START;
        count <= 4'd0;
        bytes <= 9'd0;
        byte_out <= 8'hff;
        done_count <= 1'b0;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9)
            count <= 4'd0;
        else
            count <= count + 4'd1;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9 && state == DATA)
            bytes <= bytes + 9'd1;
        else if (count == 4'd9 && state == START)
            bytes <= bytes - 9'd1;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9 && state == DATA)
            byte_out <= in;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9 && state == START)
            done_count <= 1'b1;
        else if (count == 4'd0 && state == START)
            done_count <= 1'b0;
    end
    
    always @(posedge clk)
        state <= next_state;
    
    always @(*)
        case (state)
            START: next_state <= (done_count)? START : DATA;
            DATA: next_state <= (done_count)? DATA : (((bytes == 9'd511 && byte_out == 8'hff) || (bytes == 9'd0 && byte_out!= 8'hff))? STOP : DATA);
            STOP: next_state <= (done_count)? START : STOP;
            DELAY: next_state <= (done_count)? START : DELAY;
            default: next_state <= state;
        endcase
    
    // New: Add a counter to the FSM to count errors.
    
    always @(posedge clk)
        if (reset)
            err_count <= 4'd0;
    
    always @(posedge clk)
        if (state == START || state == DATA)
            err_count <= err_count + 4'd1;
    
    assign done = (state == STOP);
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg [8:0] bytes;
    reg [7:0] byte_out;
    reg done_count;
    
    initial begin
        state <= START;
        count <= 4'd0;
        bytes <= 9'd0;
        byte_out <= 8'hff;
        done_count <= 1'b0;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9)
            count <= 4'd0;
        else
            count <= count + 4'd1;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9 && state == DATA)
            bytes <= bytes + 9'd1;
        else if (count == 4'd9 && state == START)
            bytes <= bytes - 9'd1;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9 && state == DATA)
            byte_out <= in;
    end
    
    always @(posedge clk) begin
        if (count == 4'd9 && state == START)
            done_count <= 1'b1;
        else if (count == 4'd0 && state == START)
            done_count <= 1'b0;
    end
    
    always @(posedge clk)
        state <= next_state;
    
    always @(*)
        case (state)
            START: next_state <= (done_count)? START : DATA;
            DATA: next_state <= (done_count)? DATA : (((bytes == 9'd511 && byte_out == 8'hff) || (bytes == 9'd0 && byte_out!= 8'hff))? STOP : DATA);
            STOP: next_state <= (done_count)? START : STOP;
            DELAY: next_state <= (done_count)? START : DELAY;
            default: next_state <= state;
        endcase
    
    // New: Add a counter to the FSM to count errors.
    
    always @(posedge clk)
        if (reset)
            err_count <= 4'd0;
    
    always @(posedge clk)
        if (state == START || state == DATA)
            err_count <= err_count + 4'd1;
    
    assign done = (state == STOP);
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    parity par_mod(.clk(clk),.in(in),.odd(out));
    
    // New: Add byte_out output.
    
    assign out_byte = bytes[7:0];
    
    // New: Add done output.
    
    assign done = (state == STOP);
    
    // Modify FSM
    
    always @(*)
        case(state)
            START: begin
                next_state <= (in)? START:DATA;
                out <= 0;
                count <= 0;
            end
            DATA: begin
                // Data bit
                if(count < 7)
                    next_state <= DATA;
                else
                    next_state <= (out)? STOP:DELAY;
                out <= in;
                count <= count + 1;
            end
            STOP: begin
                // Stop bit
                if(count < 7)
                    next_state <= STOP;
                else
                    next_state <= (out)? START:DELAY;
                out <= 0;
                count <= count + 1;
            end
            DELAY:next_state <= (out)? START:DELAY;
            default: next_state <= state;
        endcase
    
    // New: Add reset output.
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    parity par_mod(.clk(clk),.in(in),.odd(out));
    
    // New: Add byte_out output.
    
    assign out_byte = bytes[7:0];
    
    // New: Add done output.
    
    assign done = (state == STOP);
    
    // Modify FSM
    
    always @(*)
        case(state)
            START: begin
                next_state <= (in)? START:DATA;
                out <= 0;
                count <= 0;
            end
            DATA: begin
                // Data bit
                if(count < 7)
                    next_state <= DATA;
                else
                    next_state <= (out)? STOP:DELAY;
                out <= in;
                count <= count + 1;
            end
            STOP: begin
                // Stop bit
                if(count < 7)
                    next_state <= STOP;
                else
                    next_state <= (out)? START:DELAY;
                out <= 0;
                count <= count + 1;
            end
            DELAY:next_state <= (out)? START:DELAY;
            default: next_state <= state;
        endcase
    
    // New: Add reset output.
    
    always @(posedge clk)
        if(reset)
            state <= START;
    	else
            state <= next_state;
    
endmodule"
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(*)
    begin
        case(state)
            START:
            begin
                if(in == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA:
            begin
                if(count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP:
            begin
                out = bytes[0];
                next_state = DELAY;
            end
            DELAY:
            begin
                out = bytes[0];
                next_state = DATA;
            end
            default:
                next_state = state;
        endcase
    end
    
    // New: Add parity checking.
    
    // Modify datapath from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            bytes <= 9'b0;
        else
            bytes <= {out, bytes[8:1]};
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            state <= START;
        else
            state <= next_state;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            count <= 4'b0;
        else if(state == DATA)
            count <= count + 4'b1;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            out <= 1'b0;
        else if(state == STOP)
            out <= bytes[0];
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            done <= 1'b0;
        else if(state == STOP)
            done <= 1'b1;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            out_byte <= 8'b0;
        else if(state == START)
            out_byte <= bytes;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            data_in <= 8'b0;
        else if(state == DATA)
            data_in <= data_in + 1'b1;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            data_parity <= 1'b0;
        else if(state == START)
            data_parity <= bytes[0] ^ bytes[1] ^ bytes[2] ^ bytes[3] ^ bytes[4] ^ bytes[5] ^ bytes[6] ^ bytes[7] ^ bytes[8];
    end
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serialdata
    
    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state, last_state;
    reg [3:0] count;
    reg out;
    reg [8:0] bytes;
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(*)
    begin
        case(state)
            START:
            begin
                if(in == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA:
            begin
                if(count == 7)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP:
            begin
                out = bytes[0];
                next_state = DELAY;
            end
            DELAY:
            begin
                out = bytes[0];
                next_state = DATA;
            end
            default:
                next_state = state;
        endcase
    end
    
    // New: Add parity checking.
    
    // Modify datapath from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            bytes <= 9'b0;
        else
            bytes <= {out, bytes[8:1]};
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            state <= START;
        else
            state <= next_state;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            count <= 4'b0;
        else if(state == DATA)
            count <= count + 4'b1;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            out <= 1'b0;
        else if(state == STOP)
            out <= bytes[0];
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            done <= 1'b0;
        else if(state == STOP)
            done <= 1'b1;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            out_byte <= 8'b0;
        else if(state == START)
            out_byte <= bytes;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            data_in <= 8'b0;
        else if(state == DATA)
            data_in <= data_in + 1'b1;
    end
    
    // New: Add parity checking.
    
    // Modify FSM from Fsm_serialdata
    always @(posedge clk)
    begin
        if(reset == 1'b1)
            data_parity <= 1'b0;
        else if(state == START)
            data_parity <= bytes[0] ^ bytes[1] ^ bytes[2] ^ bytes[3] ^ bytes[4] ^ bytes[5] ^ bytes[6] ^ bytes[7] ^ bytes[8];
    end
    
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 0;
                else
                    next_state = 1;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 1;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 0;
                else
                    next_state = 1;
            end
            default: next_state = state;
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign out = (state == 2);
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 0;
                else
                    next_state = 1;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 1;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 0;
                else
                    next_state = 1;
            end
            default: next_state = state;
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign out = (state == 2);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [1:0] state, next_state;
    always@(*) begin
        // State transition logic
        case({state, in})
            {2'b00, 1'b0}: next_state = 2'b01;
            {2'b00, 1'b1}: next_state = 2'b10;
            {2'b01, 1'b0}: next_state = 2'b00;
            {2'b01, 1'b1}: next_state = 2'b11;
            {2'b10, 1'b0}: next_state = 2'b00;
            {2'b10, 1'b1}: next_state = 2'b11;
            {2'b11, 1'b0}: next_state = 2'b01;
            {2'b11, 1'b1}: next_state = 2'b10;
        endcase
    end
    always@(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 2'b00;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 2'b11);
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [1:0] state, next_state;
    always@(*) begin
        // State transition logic
        case({state, in})
            {2'b00, 1'b0}: next_state = 2'b01;
            {2'b00, 1'b1}: next_state = 2'b10;
            {2'b01, 1'b0}: next_state = 2'b00;
            {2'b01, 1'b1}: next_state = 2'b11;
            {2'b10, 1'b0}: next_state = 2'b00;
            {2'b10, 1'b1}: next_state = 2'b11;
            {2'b11, 1'b0}: next_state = 2'b01;
            {2'b11, 1'b1}: next_state = 2'b10;
        endcase
    end
    always@(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 2'b00;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 2'b11);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    
    reg [2:0] state;
    reg out;
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= 0;
            out <= 0;
        end
        else begin
            case(state)
                0: begin
                    if(in == 0) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                1: begin
                    if(in == 1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                2: begin
                    if(in == 1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                3: begin
                    if(in == 1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                default: begin
                    state <= 0;
                    out <= 0;
                end
            endcase
        end
    end
    
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    
    reg [2:0] state;
    reg out;
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= 0;
            out <= 0;
        end
        else begin
            case(state)
                0: begin
                    if(in == 0) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                1: begin
                    if(in == 1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                2: begin
                    if(in == 1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                3: begin
                    if(in == 1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 1;
                    end
                end
                default: begin
                    state <= 0;
                    out <= 0;
                end
            endcase
        end
    end
    
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state;
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            state <= 0;
        else
            begin
                case (state)
                    0: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    1: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    2: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    3: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    default:
                        state <= 0;
                endcase
            end
    end
    // Output logic
    always @(posedge clk) begin
        if(state == 0)
            out <= 0;
        else if(state == 1)
            out <= 1;
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state;
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            state <= 0;
        else
            begin
                case (state)
                    0: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    1: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    2: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    3: begin
                        if(in == 1'b1)
                            state <= 1;
                        else
                            state <= 0;
                    end
                    default:
                        state <= 0;
                endcase
            end
    end
    // Output logic
    always @(posedge clk) begin
        if(state == 0)
            out <= 0;
        else if(state == 1)
            out <= 1;
    end
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [1:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            3: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            default:
                next_state = 0;
        endcase
    end
    // State flip-flops with asynchronous reset
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 2);
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [1:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            3: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            default:
                next_state = 0;
        endcase
    end
    // State flip-flops with asynchronous reset
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 2);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 1;
                else
                    next_state = 0;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            default: next_state = 0;
        endcase
    end
    always @(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 2);
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 1;
                else
                    next_state = 0;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 2;
                else
                    next_state = 0;
            end
            default: next_state = 0;
        endcase
    end
    always @(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 2);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state <= 3'd0;
                else
                    next_state <= 3'd1;
            end
            1: begin
                if(in == 1'b1)
                    next_state <= 3'd2;
                else
                    next_state <= 3'd1;
            end
            2: begin
                if(in == 1'b1)
                    next_state <= 3'd0;
                else
                    next_state <= 3'd1;
            end
            3: begin
                if(in == 1'b1)
                    next_state <= 3'd2;
                else
                    next_state <= 3'd1;
            end
            default: next_state <= 3'd1;
        endcase
    end
    // State flip-flops with asynchronous reset
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 3'd2 || state == 3'd5);
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state <= 3'd0;
                else
                    next_state <= 3'd1;
            end
            1: begin
                if(in == 1'b1)
                    next_state <= 3'd2;
                else
                    next_state <= 3'd1;
            end
            2: begin
                if(in == 1'b1)
                    next_state <= 3'd0;
                else
                    next_state <= 3'd1;
            end
            3: begin
                if(in == 1'b1)
                    next_state <= 3'd2;
                else
                    next_state <= 3'd1;
            end
            default: next_state <= 3'd1;
        endcase
    end
    // State flip-flops with asynchronous reset
    always @(posedge clk, posedge areset) begin
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 3'd2 || state == 3'd5);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    
    reg [2:0] state;
    reg out;
    
    always @(posedge clk or posedge areset) begin
        if(areset) state <= 0;
        else state <= state + 1;
    end
    
    always @(state) begin
        // State transition logic
        case(state)
            0: out <= 0;
            1: out <= 0;
            2: out <= 1;
            3: out <= 1;
            4: out <= 1;
            5: out <= 0;
            6: out <= 1;
            7: out <= 1;
            default: out <= 0;
        endcase
    end
    
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    
    reg [2:0] state;
    reg out;
    
    always @(posedge clk or posedge areset) begin
        if(areset) state <= 0;
        else state <= state + 1;
    end
    
    always @(state) begin
        // State transition logic
        case(state)
            0: out <= 0;
            1: out <= 0;
            2: out <= 1;
            3: out <= 1;
            4: out <= 1;
            5: out <= 0;
            6: out <= 1;
            7: out <= 1;
            default: out <= 0;
        endcase
    end
    
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
        endcase
    end
    always @(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 3'b001);
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg [2:0] state, next_state;
    always @(*) begin
        // State transition logic
        case(state)
            0: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            1: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            2: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3: begin
                if(in == 1'b1)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
        endcase
    end
    always @(posedge clk or posedge areset) begin
        // State flip-flops with asynchronous reset
        if(areset)
            state <= 0;
        else
            state <= next_state;
    end
    // Output logic
    assign out = (state == 3'b001);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    
    reg [2:0] state;
    reg out;
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= 0;
            out <= 0;
        end
        else begin
            case(state)
                0: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                1: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                2: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                3: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                default: begin
                    state <= 0;
                    out <= 0;
                end
            endcase
        end
    end
    
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    
    reg [2:0] state;
    reg out;
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= 0;
            out <= 0;
        end
        else begin
            case(state)
                0: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                1: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                2: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                3: begin
                    if(in == 1'b1) begin
                        state <= 1;
                        out <= 0;
                    end
                    else begin
                        state <= 0;
                        out <= 0;
                    end
                end
                default: begin
                    state <= 0;
                    out <= 0;
                end
            endcase
        end
    end
    
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[0]&(~in) | state[1]&(~in);
    assign next_state[B] = state[0]&(in) | state[2]&(in);
    assign next_state[C] = state[1]&(in);
    assign next_state[D] = state[2]&(~in);

    // Output logic: 
    assign out = (state[2] == 1)? 1 : 0;

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[0]&(~in) | state[1]&(~in);
    assign next_state[B] = state[0]&(in) | state[2]&(in);
    assign next_state[C] = state[1]&(in);
    assign next_state[D] = state[2]&(~in);

    // Output logic: 
    assign out = (state[2] == 1)? 1 : 0;

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always @(*)
        begin
            case(state)
                A : next_state = in? B : A;
                B : next_state = in? B : C;
                C : next_state = in? D : A;
                D : next_state = in? D : C;
                default : next_state = 2'bxx;
            endcase
        end

    // Output logic
    assign out = (state == D);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always @(*)
        begin
            case(state)
                A : next_state = in? B : A;
                B : next_state = in? B : C;
                C : next_state = in? D : A;
                D : next_state = in? D : C;
                default : next_state = 2'bxx;
            endcase
        end

    // Output logic
    assign out = (state == D);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always @(*)
        case(state)
            A: begin
                if(in == 1'b1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(in == 1'b1)
                    next_state = B;
                else
                    next_state = C;
            end
            C: begin
                if(in == 1'b1)
                    next_state = D;
                else
                    next_state = A;
            end
            D: begin
                if(in == 1'b1)
                    next_state = B;
                else
                    next_state = C;
            end
            default: next_state = A;
        endcase
    // Output logic
    assign out = (state == D)?1:0;

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always @(*)
        case(state)
            A: begin
                if(in == 1'b1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(in == 1'b1)
                    next_state = B;
                else
                    next_state = C;
            end
            C: begin
                if(in == 1'b1)
                    next_state = D;
                else
                    next_state = A;
            end
            D: begin
                if(in == 1'b1)
                    next_state = B;
                else
                    next_state = C;
            end
            default: next_state = A;
        endcase
    // Output logic
    assign out = (state == D)?1:0;

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always@(*) begin
        case({state, in})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = A;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end

    // Output logic
    assign out = (state == D);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always@(*) begin
        case({state, in})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = A;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end

    // Output logic
    assign out = (state == D);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    // Output logic:  out = f(state) for a Moore state machine
    
    always @(*)
        begin
            case(state)
                A : next_state = in? B : A;
                B : next_state = in? B : C;
                C : next_state = in? D : A;
                D : next_state = in? B : C;
                default: next_state = state;
            endcase
        end
    
    // Moore output logic: out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    // Output logic:  out = f(state) for a Moore state machine
    
    always @(*)
        begin
            case(state)
                A : next_state = in? B : A;
                B : next_state = in? B : C;
                C : next_state = in? D : A;
                D : next_state = in? B : C;
                default: next_state = state;
            endcase
        end
    
    // Moore output logic: out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[0]&(~in) | state[1]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in);
    assign next_state[C] = state[0]&(in) | state[1]&(~in);
    assign next_state[D] = state[0]&(~in) | state[1]&(in);

    // Output logic: 
    assign out = (state[2]&(~in)) | (state[3]&(~in)) | (state[0]&(~in)) | (state[1]&(~in));
    
endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[0]&(~in) | state[1]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in);
    assign next_state[C] = state[0]&(in) | state[1]&(~in);
    assign next_state[D] = state[0]&(~in) | state[1]&(in);

    // Output logic: 
    assign out = (state[2]&(~in)) | (state[3]&(~in)) | (state[0]&(~in)) | (state[1]&(~in));
    
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always @(*) begin
        case({state, in})
            {A, 1'b0}: next_state = B;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = B;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = B;
            {D, 1'b1}: next_state = D;
        endcase
    end

    // Output logic
    assign out = (state == D);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always @(*) begin
        case({state, in})
            {A, 1'b0}: next_state = B;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = B;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = B;
            {D, 1'b1}: next_state = D;
        endcase
    end

    // Output logic
    assign out = (state == D);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    // Output logic:  out = f(state) for a Moore state machine
    
    always @(*)
        case(state)
            A : begin
                if(in == 1'b1)
                    next_state <= B;
                else
                    next_state <= A;
            end
            B : begin
                if(in == 1'b1)
                    next_state <= B;
                else
                    next_state <= C;
            end
            C : begin
                if(in == 1'b1)
                    next_state <= D;
                else
                    next_state <= A;
            end
            D : begin
                if(in == 1'b1)
                    next_state <= B;
                else
                    next_state <= C;
            end
            default: next_state <= A;
        endcase

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    // Output logic:  out = f(state) for a Moore state machine
    
    always @(*)
        case(state)
            A : begin
                if(in == 1'b1)
                    next_state <= B;
                else
                    next_state <= A;
            end
            B : begin
                if(in == 1'b1)
                    next_state <= B;
                else
                    next_state <= C;
            end
            C : begin
                if(in == 1'b1)
                    next_state <= D;
                else
                    next_state <= A;
            end
            D : begin
                if(in == 1'b1)
                    next_state <= B;
                else
                    next_state <= C;
            end
            default: next_state <= A;
        endcase

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    // Output logic:  out = f(state) for a Moore state machine
    
    always@(*) begin
        case({state, in})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = A;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end
    
    // Moore output logic: out = f(state)
    // assign out = (state == D)? 1 : 0;
    
    assign out = (state == D)? 1 : 0;

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    // Output logic:  out = f(state) for a Moore state machine
    
    always@(*) begin
        case({state, in})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = A;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end
    
    // Moore output logic: out = f(state)
    // assign out = (state == D)? 1 : 0;
    
    assign out = (state == D)? 1 : 0;

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always@(*) begin
        case({state, in})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = A;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end
    // Output logic
    assign out = (state == D);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic
    always@(*) begin
        case({state, in})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = A;
            {C, 1'b1}: next_state = D;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end
    // Output logic
    assign out = (state == D);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out =...;
    assign out = state[3]&(~in) | state[2]&(in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out =...;
    assign out = state[3]&(~in) | state[2]&(in);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(~in) | state[1]&(in) | state[0]&(in);
    assign out = state[3]&(~in) | state[1]&(in) | state[0]&(in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(~in) | state[1]&(in) | state[0]&(in);
    assign out = state[3]&(~in) | state[1]&(in) | state[0]&(in);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(~in) | state[2]&(in);
    assign out = state[3]&(~in) | state[2]&(in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(~in) | state[2]&(in);
    assign out = state[3]&(~in) | state[2]&(in);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out =...;
    assign out = state[3]&(~in) | state[2]&(in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out =...;
    assign out = state[3]&(~in) | state[2]&(in);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(in) | state[2]&(~in);
    assign out = state[3]&(in) | state[2]&(~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(in) | state[2]&(~in);
    assign out = state[3]&(in) | state[2]&(~in);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    
    // equivalent: assign next_state[A] = state[A]&(~in) | state[B]&(~in);
    assign next_state[B] = state[A]&(~in) | state[B]&(~in) | state[C]&(~in) | state[D]&(~in);
    assign next_state[C] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
    assign next_state[D] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
    
    // combinational logic: Derive an equation for each state flip-flop.
    assign out = state[D];
//     assign next_state[A] = state[A]&(~in) | state[B]&(~in);
//     assign next_state[B] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
//     assign next_state[C] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
//     assign next_state[D] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
    
endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    
    // equivalent: assign next_state[A] = state[A]&(~in) | state[B]&(~in);
    assign next_state[B] = state[A]&(~in) | state[B]&(~in) | state[C]&(~in) | state[D]&(~in);
    assign next_state[C] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
    assign next_state[D] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
    
    // combinational logic: Derive an equation for each state flip-flop.
    assign out = state[D];
//     assign next_state[A] = state[A]&(~in) | state[B]&(~in);
//     assign next_state[B] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
//     assign next_state[C] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
//     assign next_state[D] = state[A]&(in) | state[B]&(in) | state[C]&(in) | state[D]&(in);
    
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[B] = state[0]&(~in) | state[2]&(~in);
    assign next_state[C] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[D] = state[1]&(~in) | state[3]&(~in);
    // assign out =...;
    assign out = state[3]&(in) | state[2]&(in);
endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[B] = state[0]&(~in) | state[2]&(~in);
    assign next_state[C] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[D] = state[1]&(~in) | state[3]&(~in);
    // assign out =...;
    assign out = state[3]&(in) | state[2]&(in);
endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A]&(~in) | state[C]&(~in);
    assign next_state[B] = state[A]&(in) | state[B]&(in) | state[D]&(in);
    assign next_state[C] = state[B]&(~in) | state[D]&(~in);
    assign next_state[D] = state[C]&(in);
    // assign out = state[D]&(in);
    assign out = state[D];

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A]&(~in) | state[C]&(~in);
    assign next_state[B] = state[A]&(in) | state[B]&(in) | state[D]&(in);
    assign next_state[C] = state[B]&(~in) | state[D]&(~in);
    assign next_state[D] = state[C]&(in);
    // assign out = state[D]&(in);
    assign out = state[D];

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(in) | state[2]&(~in);
    assign out = state[3]&(in) | state[2]&(~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out = state[3]&(in) | state[2]&(~in);
    assign out = state[3]&(in) | state[2]&(~in);

endmodule"
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out =...;
    assign out = state[3]&(~in) | state[2]&(in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[0]&(~in) | state[2]&(~in);
    assign next_state[B] = state[0]&(in) | state[1]&(in) | state[3]&(in);
    assign next_state[C] = state[1]&(~in) | state[3]&(~in);
    assign next_state[D] = state[2]&(in);
    
    // assign out =...;
    assign out = state[3]&(~in) | state[2]&(in);

endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);
endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);

endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);

endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);
endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);

endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);

endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);

endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a && b;
    assign out_or = a || b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a && b);
    assign out_nor = ~(a || b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a && (~b);

endmodule"
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor=~(a ^ b);
    assign out_anotb= a & (~b);
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;

endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;

endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
    
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
    
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
    
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
    
endmodule"
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and = & in;
    assign out_or = | in;
    assign out_xor = ^ in;
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = {1'b1, in[99:1] | in[98:0]};
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = {1'b1, in[99:1] | in[98:0]};
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[99] = in[99] && in[98];
    assign out_both[98:0] = in[98:0] && in[99:1];
    assign out_any[99] = in[99] || in[98];
    assign out_any[98:0] = in[98:0] || in[99:1];
    assign out_different[99] = in[99] ^ in[98];
    assign out_different[98:0] = in[98:0] ^ in[99:1];
    
endmodule",-1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[99] = in[99] && in[98];
    assign out_both[98:0] = in[98:0] && in[99:1];
    assign out_any[99] = in[99] || in[98];
    assign out_any[98:0] = in[98:0] || in[99:1];
    assign out_different[99] = in[99] ^ in[98];
    assign out_different[98:0] = in[98:0] ^ in[99:1];
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[99:1] & in[98:0];
    assign out_any  = in[98:0] | in[99:1];
    assign out_different = in ^ {in[0], in[99:1]};   //因为out_different要求一个wrapping且xor比较左边，故采用in[99:0] ^ {in[0], in[99:1]}
    
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a && b || a && c || b && c;
endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a && b || a && c || b && c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | b | c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a && b && c;
endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a && b && c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a & b & c;
endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a & b & c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a && b && c;
endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a && b && c;
endmodule"
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | ~(a&b&c) | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | ~(a&b&c) | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | (~a&~b&c) | (~a&b&~c&d) | (a&~b&~c&d);
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | (~a&~b&c) | (~a&b&~c&d) | (a&~b&~c&d);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | (~a&~b&c) | (~a&b&~c&d) | (a&~b&~c&d);
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | (~a&~b&c) | (~a&b&~c&d) | (a&~b&~c&d);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | ~(a&b&c&d);
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | ~(a&b&c&d);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = a | b | c | d;
    
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = a | b | c | d;
    
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",1,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | ~(a&~b&c);
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | ~(a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a && b && c && d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a && b && c && d;
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c) | (~a&b&~c&d) | (a&~b&~c&d);
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c) | (~a&b&~c&d) | (a&~b&~c&d);
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | ~(a&b&c&d);
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | ~(a&b&c&d);
endmodule"
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a & b & c & d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a & b & c & d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | (~a&~b&c);
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    wire [31:0] d, r_val;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[21] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[22] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    generate
        for(i = 0; i < 32; i = i + 1) begin
            assign d[i] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[22] ^ q[23] ^ 1'b0 ^ r_val[i];
        end
    endgenerate
    
    dff_t ins1(clk, reset, d[31], q[31]);
    dff_t ins2(clk, reset, d[21], q[21]);
    dff_t ins3(clk, reset, d[1], q[1]);
    dff_t ins4(clk, reset, d[0], q[0]);
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    wire [31:0] d, r_val;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[21] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[22] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    generate
        for(i = 0; i < 32; i = i + 1) begin
            assign d[i] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[22] ^ q[23] ^ 1'b0 ^ r_val[i];
        end
    endgenerate
    
    dff_t ins1(clk, reset, d[31], q[31]);
    dff_t ins2(clk, reset, d[21], q[21]);
    dff_t ins3(clk, reset, d[1], q[1]);
    dff_t ins4(clk, reset, d[0], q[0]);
    
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    
    assign r_val = 32'h1;
    assign d[31] = clk & r_val[31];
    assign d[21] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[22] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30];
    assign d[23] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[24] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[25] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[26] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    
    assign r_val = 32'h1;
    assign d[31] = clk & r_val[31];
    assign d[21] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[22] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30];
    assign d[23] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[24] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[25] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    assign d[26] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    assign r_val = 32'h1;
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    generate
        for(i = 0; i < 32; i = i + 1) begin
            assign d[i] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31] ^ r_val[31];
        end
    endgenerate
    
    d_ff dff0(clk, reset, r_val[0], q[0]);
    d_ff dff1(clk, reset, r_val[1], q[1]);
    d_ff dff2(clk, reset, r_val[2], q[2]);
    d_ff dff3(clk, reset, r_val[3], q[3]);
    d_ff dff4(clk, reset, r_val[4], q[4]);
    d_ff dff5(clk, reset, r_val[5], q[5]);
    d_ff dff6(clk, reset, r_val[6], q[6]);
    d_ff dff7(clk, reset, r_val[7], q[7]);
    d_ff dff8(clk, reset, r_val[8], q[8]);
    d_ff dff9(clk, reset, r_val[9], q[9]);
    d_ff dff10(clk, reset, r_val[10], q[10]);
    d_ff dff11(clk, reset, r_val[11], q[11]);
    d_ff dff12(clk, reset, r_val[12], q[12]);
    d_ff dff13(clk, reset, r_val[13], q[13]);
    d_ff dff14(clk, reset, r_val[14], q[14]);
    d_ff dff15(clk, reset, r_val[15], q[15]);
    d_ff dff16(clk, reset, r_val[16], q[16]);
    d_ff dff17(clk, reset, r_val[17], q[17]);
    d_ff dff18(clk, reset, r_val[18], q[18]);
    d_ff dff19(clk, reset, r_val[19], q[19]);
    d_ff dff20(clk, reset, r_val[20], q[20]);
    d_ff dff21(clk, reset, r_val[21], q[21]);
    d_ff dff22(clk, reset, r_val[22], q[22]);
    d_ff dff23(clk, reset, r_val[23], q[23]);
    d_ff dff24(clk, reset, r_val[24], q[24]);
    d_ff dff25(clk, reset, r_val[25], q[25]);
    d_ff dff26(clk, reset, r_val[26], q[26]);
    d_ff",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    assign r_val = 32'h1;
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    generate
        for(i = 0; i < 32; i = i + 1) begin
            assign d[i] = q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31] ^ r_val[31];
        end
    endgenerate
    
    d_ff dff0(clk, reset, r_val[0], q[0]);
    d_ff dff1(clk, reset, r_val[1], q[1]);
    d_ff dff2(clk, reset, r_val[2], q[2]);
    d_ff dff3(clk, reset, r_val[3], q[3]);
    d_ff dff4(clk, reset, r_val[4], q[4]);
    d_ff dff5(clk, reset, r_val[5], q[5]);
    d_ff dff6(clk, reset, r_val[6], q[6]);
    d_ff dff7(clk, reset, r_val[7], q[7]);
    d_ff dff8(clk, reset, r_val[8], q[8]);
    d_ff dff9(clk, reset, r_val[9], q[9]);
    d_ff dff10(clk, reset, r_val[10], q[10]);
    d_ff dff11(clk, reset, r_val[11], q[11]);
    d_ff dff12(clk, reset, r_val[12], q[12]);
    d_ff dff13(clk, reset, r_val[13], q[13]);
    d_ff dff14(clk, reset, r_val[14], q[14]);
    d_ff dff15(clk, reset, r_val[15], q[15]);
    d_ff dff16(clk, reset, r_val[16], q[16]);
    d_ff dff17(clk, reset, r_val[17], q[17]);
    d_ff dff18(clk, reset, r_val[18], q[18]);
    d_ff dff19(clk, reset, r_val[19], q[19]);
    d_ff dff20(clk, reset, r_val[20], q[20]);
    d_ff dff21(clk, reset, r_val[21], q[21]);
    d_ff dff22(clk, reset, r_val[22], q[22]);
    d_ff dff23(clk, reset, r_val[23], q[23]);
    d_ff dff24(clk, reset, r_val[24], q[24]);
    d_ff dff25(clk, reset, r_val[25], q[25]);
    d_ff dff26(clk, reset, r_val[26], q[26]);
    d_ff"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    assign d[0] = 32'h14A7D678;
    assign d[1] = 32'h18CA18AD;
    assign d[2] = 32'h1C6A1C2C;
    assign d[3] = 32'h20E7E7A8;
    assign d[4] = 32'h24CFF24D;
    assign d[5] = 32'h28A5728A;
    assign d[6] = 32'h2C8E2C8E;
    assign d[7] = 32'h2F8A1F8A;
    assign d[8] = 32'h3A8A3A8A;
    assign d[9] = 32'h3CCC3CCD;
    assign d[10] = 32'h4D4F4D4F;
    assign d[11] = 32'h50A0A0A0;
    assign d[12] = 32'h52A4A4A4;
    assign d[13] = 32'h5A8E5A8E;
    assign d[14] = 32'h5DCE5DCE;
    assign d[15] = 32'h5F3F3F3F;
    assign d[16] = 32'h619E619E;
    assign d[17] = 32'h63C6A63C;
    assign d[18] = 32'h67D967D9;
    assign d[19] = 32'h6B8E6B8E;
    assign d[20] = 32'h6FDE6FDE;
    assign d[21] = 32'h719E719E;
    assign d[22] = 32'h73C738C7;
    assign d[23] = 32'h769E7679;
    assign d[24] = 32'h7B8C7B8C;
    assign d[25] = 32'h7FDF7FDF;
    assign d[26] = 32'h7A8E7A8E;
    assign d[27] = 32'h7D9C7D9C;
    assign d[28] = 32'h7A8E7A8E;
    assign d[29] = 32'h7D9C7D9C;
    assign d[30] = 32'h7A8E7A8E;
    assign d[31] = 32'h7D9C7D9C;
    
    
    assign q = {d[31], d[31:1]};
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    assign d[0] = 32'h14A7D678;
    assign d[1] = 32'h18CA18AD;
    assign d[2] = 32'h1C6A1C2C;
    assign d[3] = 32'h20E7E7A8;
    assign d[4] = 32'h24CFF24D;
    assign d[5] = 32'h28A5728A;
    assign d[6] = 32'h2C8E2C8E;
    assign d[7] = 32'h2F8A1F8A;
    assign d[8] = 32'h3A8A3A8A;
    assign d[9] = 32'h3CCC3CCD;
    assign d[10] = 32'h4D4F4D4F;
    assign d[11] = 32'h50A0A0A0;
    assign d[12] = 32'h52A4A4A4;
    assign d[13] = 32'h5A8E5A8E;
    assign d[14] = 32'h5DCE5DCE;
    assign d[15] = 32'h5F3F3F3F;
    assign d[16] = 32'h619E619E;
    assign d[17] = 32'h63C6A63C;
    assign d[18] = 32'h67D967D9;
    assign d[19] = 32'h6B8E6B8E;
    assign d[20] = 32'h6FDE6FDE;
    assign d[21] = 32'h719E719E;
    assign d[22] = 32'h73C738C7;
    assign d[23] = 32'h769E7679;
    assign d[24] = 32'h7B8C7B8C;
    assign d[25] = 32'h7FDF7FDF;
    assign d[26] = 32'h7A8E7A8E;
    assign d[27] = 32'h7D9C7D9C;
    assign d[28] = 32'h7A8E7A8E;
    assign d[29] = 32'h7D9C7D9C;
    assign d[30] = 32'h7A8E7A8E;
    assign d[31] = 32'h7D9C7D9C;
    
    
    assign q = {d[31], d[31:1]};
    
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    wire [31:0] q_reg;
    
    assign r_val = 32'h1;
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ 1'b0 ^ r_val[0];
    
    assign q_next[31] = q[31] ^ d[31];
    assign q_next[21] = q[21] ^ d[21];
    assign q_next[1] = q[1] ^ d[1];
    assign q_next[0] = q[0] ^ d[0];
    
    // Calculate new value of q
    assign q_reg = q_next;
    
    // Flip 32 bits of q_reg, store in output q
    assign q = q_reg;
    
endmodule",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    wire [31:0] q_reg;
    
    assign r_val = 32'h1;
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ 1'b0 ^ r_val[0];
    
    assign q_next[31] = q[31] ^ d[31];
    assign q_next[21] = q[21] ^ d[21];
    assign q_next[1] = q[1] ^ d[1];
    assign q_next[0] = q[0] ^ d[0];
    
    // Calculate new value of q
    assign q_reg = q_next;
    
    // Flip 32 bits of q_reg, store in output q
    assign q = q_reg;
    
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    wire [31:0] d, r_val;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[21] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[22] ^ q[23] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin : r_loop
            dff_t ins(clk, reset, r_val[i], d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    wire [31:0] d, r_val;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[21] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[22] ^ q[23] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin : r_loop
            dff_t ins(clk, reset, r_val[i], d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[21] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[20] ^ 1'b0 ^ r_val[0];
    
    assign d[30:22] = q[31:23];
    assign d[23:2] = q[23:3];
    
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin
            DFF DFF(d[i], clk, rst, q_next[i]);
        end
    endgenerate
    
    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            for (i = 0; i < 32; i = i + 1) begin
                q[i] <= 0;
            end
        end
        else begin
            q <= q_next;
        end
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[21] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[21] ^ q[20] ^ 1'b0 ^ r_val[0];
    
    assign d[30:22] = q[31:23];
    assign d[23:2] = q[23:3];
    
    genvar i;
    generate
        for (i = 0; i < 32; i = i + 1) begin
            DFF DFF(d[i], clk, rst, q_next[i]);
        end
    endgenerate
    
    always @(posedge clk or negedge rst) begin
        if (!rst) begin
            for (i = 0; i < 32; i = i + 1) begin
                q[i] <= 0;
            end
        end
        else begin
            q <= q_next;
        end
    end
    
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ 1'b0 ^ r_val[0];
    
    assign q_next[31] = q[31] ^ 1'b0 ^ r_val[31];
    assign q_next[21] = q[22] ^ q[21] ^ 1'b0 ^ r_val[21];
    assign q_next[1] = q[2] ^ q[1] ^ 1'b0 ^ r_val[1];
    assign q_next[0] = q[1] ^ q[0] ^ 1'b0 ^ r_val[0];
    
    // calculate the value of each bit of q based on the values of the input bit
    // and the values of the bits above it.
    //
    // For example, if q[1] is 1'b1, then q[0] is 1'b1, and q[2] is 1'b0, then
    // q[1] is 1'b1 and q[2] is 1'b1.
    // These are just the values of the input bit and the bit above it,
    // respectively.
    //
    // Also note that the value of q[0] is independent of the value of q[1],
    // but the value of q[2] is dependent on the value of q[1].
    //
    // These values are stored in a vector.
    //
    // The value of each bit is stored in a vector that is indexed by the
    // position of the bit in the register, as shown below.
    //
    // Since q is a 32-bit register, there is a total of 128 values to store.
    // These values are initialized to 0 (zero) when reset is asserted.
    //
    // Note that the value of q changes at the positive edge of clk.
    //
    // These values are used to calculate the new value of q, which is
    // stored in the output register.
    //
    // The calculation of the new value of q is shown below.
    //
    // Since the value of each bit is stored in a vector, the calculation
    // of the new value of q can be done in a vector.
    //
    // The value of each bit is calculated as a function of the other bits.
    //
    // In order to calculate the value of each bit, the value of each bit
    // in the register is used as a input to a function that computes
    // a value for a given input.
    //
    // The value of each bit is stored in a vector, as shown below.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    wire [31:0] q_next;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ 1'b0 ^ r_val[0];
    
    assign q_next[31] = q[31] ^ 1'b0 ^ r_val[31];
    assign q_next[21] = q[22] ^ q[21] ^ 1'b0 ^ r_val[21];
    assign q_next[1] = q[2] ^ q[1] ^ 1'b0 ^ r_val[1];
    assign q_next[0] = q[1] ^ q[0] ^ 1'b0 ^ r_val[0];
    
    // calculate the value of each bit of q based on the values of the input bit
    // and the values of the bits above it.
    //
    // For example, if q[1] is 1'b1, then q[0] is 1'b1, and q[2] is 1'b0, then
    // q[1] is 1'b1 and q[2] is 1'b1.
    // These are just the values of the input bit and the bit above it,
    // respectively.
    //
    // Also note that the value of q[0] is independent of the value of q[1],
    // but the value of q[2] is dependent on the value of q[1].
    //
    // These values are stored in a vector.
    //
    // The value of each bit is stored in a vector that is indexed by the
    // position of the bit in the register, as shown below.
    //
    // Since q is a 32-bit register, there is a total of 128 values to store.
    // These values are initialized to 0 (zero) when reset is asserted.
    //
    // Note that the value of q changes at the positive edge of clk.
    //
    // These values are used to calculate the new value of q, which is
    // stored in the output register.
    //
    // The calculation of the new value of q is shown below.
    //
    // Since the value of each bit is stored in a vector, the calculation
    // of the new value of q can be done in a vector.
    //
    // The value of each bit is calculated as a function of the other bits.
    //
    // In order to calculate the value of each bit, the value of each bit
    // in the register is used as a input to a function that computes
    // a value for a given input.
    //
    // The value of each bit is stored in a vector, as shown below.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is computed as a function of the other bits.
    //
    // The value of each bit is"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    assign d[31] = clk;
    assign d[21] = q[0];
    assign d[1] = q[21];
    assign d[0] = q[20];
    
    genvar i;
    generate
        for(i=0; i<32; i=i+1) begin
            dff_t ins(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    assign d[31] = clk;
    assign d[21] = q[0];
    assign d[1] = q[21];
    assign d[0] = q[20];
    
    genvar i;
    generate
        for(i=0; i<32; i=i+1) begin
            dff_t ins(clk, reset, d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    wire [31:0] d, r_val;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[23] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[23] ^ q[24] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    
    generate for (i = 0; i < 32; i = i + 1)
        begin: r_loop
            dff_t ins(clk, reset, r_val[i], d[i], q[i]);
        end
    endgenerate
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    wire [31:0] d, r_val;
    
    assign r_val = 32'h1;
    
    assign d[31] = q[0] ^ 1'b0 ^ r_val[31];
    assign d[21] = q[0] ^ q[22] ^ 1'b0 ^ r_val[21];
    assign d[1] = q[0] ^ q[2] ^ q[22] ^ q[23] ^ 1'b0 ^ r_val[1];
    assign d[0] = q[0] ^ q[1] ^ q[2] ^ q[23] ^ q[24] ^ 1'b0 ^ r_val[0];
    
    genvar i;
    
    generate for (i = 0; i < 32; i = i + 1)
        begin: r_loop
            dff_t ins(clk, reset, r_val[i], d[i], q[i]);
        end
    endgenerate
    
endmodule"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49, b50, b51, b52, b53, b54, b55, b56, b57, b58, b59, b60, b61, b62, b63, b64, b65, b66, b67, b68, b69, b70, b71, b72, b73, b74, b75, b76, b77, b78, b79, b80, b81, b82, b83, b84, b85, b86, b87, b88, b89, b90, b91, b92, b93, b94, b95, b96, b97, b98, b99, b100, b101, b102, b103, b104, b105, b106, b107, b108, b109, b110, b111, b112, b113, b114, b115, b116, b117, b118, b119, b120, b121, b122, b123, b124, b125, b126, b127, b128, b129, b130, b131, b132, b133, b134, b135, b136, b137, b138, b139, b140, b141, b142, b143, b144, b145, b146, b147, b148, b149, b150, b151, b152, b153, b154, b155, b156, b157, b158, b159, b160, b161, b162, b163, b164, b165, b166, b167, b168, b169, b170, b171, b172, b173, b174, b175, b176, b177, b178, b179, b180, b181, b182, b183, b184, b185, b186, b187, b188, b189, b190, b191, b192, b193, b194, b195, b196, b197, b198, b199, b200, b201, b202, b203, b204, b205, b206, b207, b208, b209, b210, b211, b212, b213, b214, b215, b216, b217, b218, b219, b220, b221, b222, b223, b224, b225, b226, b227, b228, b229, b230, b231, b232, b233, b234, b235, b236, b237, b238, b239, b240, b241, b242, b243, b244, b245, b246, b247, b248, b249, b250, b251, b252, b253, b254, b255, Cout[0], Cout[1], Cout[2], Cout[3], Cout[4], Cout[5], Cout[6], Cout[7], Cout[8], Cout[9], Cout[10], Cout[11], Cout[12], Cout[13], Cout[14], Cout[15], Cout[16], Cout[17], Cout[18], Cout[19], Cout[20], Cout[21], Cout[22], Cout[23], Cout[24], Cout[25], Cout[26], Cout[27], Cout[28], Cout[29], Cout[30], Cout[31], Cout[32], Cout[33], Cout[34], Cout[35], Cout[36], Cout[37], Cout[38], Cout[39], Cout[40], Cout[41], Cout[42], Cout[43], Cout[44], Cout[45], Cout[46], Cout[47], Cout[48], Cout[49], Cout[50], Cout[51], Cout[52], Cout[53], Cout[54], Cout[55], Cout[56], Cout[57], Cout[58], Cout[59], Cout[",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49, b50, b51, b52, b53, b54, b55, b56, b57, b58, b59, b60, b61, b62, b63, b64, b65, b66, b67, b68, b69, b70, b71, b72, b73, b74, b75, b76, b77, b78, b79, b80, b81, b82, b83, b84, b85, b86, b87, b88, b89, b90, b91, b92, b93, b94, b95, b96, b97, b98, b99, b100, b101, b102, b103, b104, b105, b106, b107, b108, b109, b110, b111, b112, b113, b114, b115, b116, b117, b118, b119, b120, b121, b122, b123, b124, b125, b126, b127, b128, b129, b130, b131, b132, b133, b134, b135, b136, b137, b138, b139, b140, b141, b142, b143, b144, b145, b146, b147, b148, b149, b150, b151, b152, b153, b154, b155, b156, b157, b158, b159, b160, b161, b162, b163, b164, b165, b166, b167, b168, b169, b170, b171, b172, b173, b174, b175, b176, b177, b178, b179, b180, b181, b182, b183, b184, b185, b186, b187, b188, b189, b190, b191, b192, b193, b194, b195, b196, b197, b198, b199, b200, b201, b202, b203, b204, b205, b206, b207, b208, b209, b210, b211, b212, b213, b214, b215, b216, b217, b218, b219, b220, b221, b222, b223, b224, b225, b226, b227, b228, b229, b230, b231, b232, b233, b234, b235, b236, b237, b238, b239, b240, b241, b242, b243, b244, b245, b246, b247, b248, b249, b250, b251, b252, b253, b254, b255, Cout[0], Cout[1], Cout[2], Cout[3], Cout[4], Cout[5], Cout[6], Cout[7], Cout[8], Cout[9], Cout[10], Cout[11], Cout[12], Cout[13], Cout[14], Cout[15], Cout[16], Cout[17], Cout[18], Cout[19], Cout[20], Cout[21], Cout[22], Cout[23], Cout[24], Cout[25], Cout[26], Cout[27], Cout[28], Cout[29], Cout[30], Cout[31], Cout[32], Cout[33], Cout[34], Cout[35], Cout[36], Cout[37], Cout[38], Cout[39], Cout[40], Cout[41], Cout[42], Cout[43], Cout[44], Cout[45], Cout[46], Cout[47], Cout[48], Cout[49], Cout[50], Cout[51], Cout[52], Cout[53], Cout[54], Cout[55], Cout[56], Cout[57], Cout[58], Cout[59], Cout["
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [32:0] ca;
    wire [32:0] ca_d;
    wire [32:0] sum_d;
    wire cout;
    wire cout_d;
    
    assign ca[0] = 0;
    assign ca[1] = 0;
    assign ca[2] = 0;
    assign ca[3] = 0;
    assign ca[4] = 0;
    assign ca[5] = 0;
    assign ca[6] = 0;
    assign ca[7] = 0;
    assign ca[8] = 0;
    assign ca[9] = 0;
    assign ca[10] = 0;
    assign ca[11] = 0;
    assign ca[12] = 0;
    assign ca[13] = 0;
    assign ca[14] = 0;
    assign ca[15] = 0;
    assign ca[16] = 0;
    assign ca[17] = 0;
    assign ca[18] = 0;
    assign ca[19] = 0;
    assign ca[20] = 0;
    assign ca[21] = 0;
    assign ca[22] = 0;
    assign ca[23] = 0;
    assign ca[24] = 0;
    assign ca[25] = 0;
    assign ca[26] = 0;
    assign ca[27] = 0;
    assign ca[28] = 0;
    assign ca[29] = 0;
    assign ca[30] = 0;
    assign ca[31] = 0;
    
    add16 a1(a[15:0], b[15:0], ca[31], sum[15:0], ca_d[31]);
    add16 a2(a[31:16], b[31:16], ca_d[31], sum[31:16], ca_d[32]);
    add16 a3(a[47:32], b[47:32], ca_d[32], sum[47:32], ca_d[33]);
    add16 a4(a[63:48], b[63:48], ca_d[33], sum[63:48], ca_d[34]);
    add16 a5(a[79:64], b[79:64], ca_d[34], sum[79:64], ca_d[35]);
    add16 a6(a[95:80], b[95:80], ca_d[35], sum[95:80], ca_d[36]);
    add16 a7(a[111:96], b[111:96], ca_d[36], sum[111:96], ca_d[37]);
    add16 a8(a[127:112], b[127:112], ca_d[37], sum[127:112], ca_d[38]);
    add16 a9(a[143:128], b[143:128], ca_d[38], sum[143:128], ca_d[39]);
    add16 a10(a[159:144], b[159:144], ca_d[39], sum[159:144], ca_d[40]);
    add16 a11(a[175:160], b[175:160], ca_d[40], sum[175:160], ca_d[41]);
    add16 a12(a[191:176], b[191:176], ca_d[41], sum[191:176], ca_d[42]);
    add16 a13(a[207:192], b[207:192], ca_d[42], sum[207:192], ca_d[43]);
    add16 a14(a[223:208], b[223:208], ca_d[43], sum[223:208], ca_d[44]);
    add16 a15(a[239:224], b[239:224], ca_d[44], sum[239:224], ca_d[45]);
    add16 a16(a[255:240], b[255:240], ca_d[45], sum[255:240], ca_d[46]);
    add16 a17(a[271:256], b[271:256], ca_d[46], sum[271:256], ca",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [32:0] ca;
    wire [32:0] ca_d;
    wire [32:0] sum_d;
    wire cout;
    wire cout_d;
    
    assign ca[0] = 0;
    assign ca[1] = 0;
    assign ca[2] = 0;
    assign ca[3] = 0;
    assign ca[4] = 0;
    assign ca[5] = 0;
    assign ca[6] = 0;
    assign ca[7] = 0;
    assign ca[8] = 0;
    assign ca[9] = 0;
    assign ca[10] = 0;
    assign ca[11] = 0;
    assign ca[12] = 0;
    assign ca[13] = 0;
    assign ca[14] = 0;
    assign ca[15] = 0;
    assign ca[16] = 0;
    assign ca[17] = 0;
    assign ca[18] = 0;
    assign ca[19] = 0;
    assign ca[20] = 0;
    assign ca[21] = 0;
    assign ca[22] = 0;
    assign ca[23] = 0;
    assign ca[24] = 0;
    assign ca[25] = 0;
    assign ca[26] = 0;
    assign ca[27] = 0;
    assign ca[28] = 0;
    assign ca[29] = 0;
    assign ca[30] = 0;
    assign ca[31] = 0;
    
    add16 a1(a[15:0], b[15:0], ca[31], sum[15:0], ca_d[31]);
    add16 a2(a[31:16], b[31:16], ca_d[31], sum[31:16], ca_d[32]);
    add16 a3(a[47:32], b[47:32], ca_d[32], sum[47:32], ca_d[33]);
    add16 a4(a[63:48], b[63:48], ca_d[33], sum[63:48], ca_d[34]);
    add16 a5(a[79:64], b[79:64], ca_d[34], sum[79:64], ca_d[35]);
    add16 a6(a[95:80], b[95:80], ca_d[35], sum[95:80], ca_d[36]);
    add16 a7(a[111:96], b[111:96], ca_d[36], sum[111:96], ca_d[37]);
    add16 a8(a[127:112], b[127:112], ca_d[37], sum[127:112], ca_d[38]);
    add16 a9(a[143:128], b[143:128], ca_d[38], sum[143:128], ca_d[39]);
    add16 a10(a[159:144], b[159:144], ca_d[39], sum[159:144], ca_d[40]);
    add16 a11(a[175:160], b[175:160], ca_d[40], sum[175:160], ca_d[41]);
    add16 a12(a[191:176], b[191:176], ca_d[41], sum[191:176], ca_d[42]);
    add16 a13(a[207:192], b[207:192], ca_d[42], sum[207:192], ca_d[43]);
    add16 a14(a[223:208], b[223:208], ca_d[43], sum[223:208], ca_d[44]);
    add16 a15(a[239:224], b[239:224], ca_d[44], sum[239:224], ca_d[45]);
    add16 a16(a[255:240], b[255:240], ca_d[45], sum[255:240], ca_d[46]);
    add16 a17(a[271:256], b[271:256], ca_d[46], sum[271:256], ca"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [32:0] sum_w;
    wire [32:0] c_w;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum_w[15:0], c_w[1]);
    add16 a2(a[31:16], b[31:16], c_w[1], sum_w[31:16], c_w[2]);
    add16 a3(a[47:32], b[47:32], c_w[2], sum_w[47:32], c_w[3]);
    add16 a4(a[63:48], b[63:48], c_w[3], sum_w[63:48], c_w[4]);
    add16 a5(a[79:64], b[79:64], c_w[4], sum_w[79:64], c_w[5]);
    add16 a6(a[95:80], b[95:80], c_w[5], sum_w[95:80], c_w[6]);
    add16 a7(a[111:96], b[111:96], c_w[6], sum_w[111:96], c_w[7]);
    add16 a8(a[127:112], b[127:112], c_w[7], sum_w[127:112], c_w[8]);
    add16 a9(a[143:128], b[143:128], c_w[8], sum_w[143:128], c_w[9]);
    add16 a10(a[159:144], b[159:144], c_w[9], sum_w[159:144], c_w[10]);
    add16 a11(a[175:160], b[175:160], c_w[10], sum_w[175:160], c_w[11]);
    add16 a12(a[191:176], b[191:176], c_w[11], sum_w[191:176], c_w[12]);
    add16 a13(a[207:192], b[207:192], c_w[12], sum_w[207:192], c_w[13]);
    add16 a14(a[223:208], b[223:208], c_w[13], sum_w[223:208], c_w[14]);
    add16 a15(a[239:224], b[239:224], c_w[14], sum_w[239:224], c_w[15]);
    add16 a16(a[255:240], b[255:240], c_w[15], sum_w[255:240], c_w[16]);
    add16 a17(a[271:256], b[271:256], c_w[16], sum_w[271:256], c_w[17]);
    add16 a18(a[287:272], b[287:272], c_w[17], sum_w[287:272], c_w[18]);
    add16 a19(a[303:288], b[303:288], c_w[18], sum_w[303:288], c_w[19]);
    add16 a20(a[319:304], b[319:304], c_w[19], sum_w[319:304], c_w[20]);
    add16 a21(a[335:320], b[335:320], c_w[20], sum_w[335:320], c_w[21]);
    add16 a22(a[351:336], b[351:336], c_w[21], sum_w[351:336], c_w[22]);
    add16 a23(a[367:352], b[367:352], c_w[22], sum_w[367:352], c_w[23]);
    add16 a24(a[383:368], b[383:368], c_w[23], sum_w[383:368], c_w[24]);
    add16 a25(a[399:384], b[399:384], c_w[24], sum_w[399:384], c_w[25]);
    add16 a26(a[415:400], b[415:400], c_w[",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [32:0] sum_w;
    wire [32:0] c_w;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum_w[15:0], c_w[1]);
    add16 a2(a[31:16], b[31:16], c_w[1], sum_w[31:16], c_w[2]);
    add16 a3(a[47:32], b[47:32], c_w[2], sum_w[47:32], c_w[3]);
    add16 a4(a[63:48], b[63:48], c_w[3], sum_w[63:48], c_w[4]);
    add16 a5(a[79:64], b[79:64], c_w[4], sum_w[79:64], c_w[5]);
    add16 a6(a[95:80], b[95:80], c_w[5], sum_w[95:80], c_w[6]);
    add16 a7(a[111:96], b[111:96], c_w[6], sum_w[111:96], c_w[7]);
    add16 a8(a[127:112], b[127:112], c_w[7], sum_w[127:112], c_w[8]);
    add16 a9(a[143:128], b[143:128], c_w[8], sum_w[143:128], c_w[9]);
    add16 a10(a[159:144], b[159:144], c_w[9], sum_w[159:144], c_w[10]);
    add16 a11(a[175:160], b[175:160], c_w[10], sum_w[175:160], c_w[11]);
    add16 a12(a[191:176], b[191:176], c_w[11], sum_w[191:176], c_w[12]);
    add16 a13(a[207:192], b[207:192], c_w[12], sum_w[207:192], c_w[13]);
    add16 a14(a[223:208], b[223:208], c_w[13], sum_w[223:208], c_w[14]);
    add16 a15(a[239:224], b[239:224], c_w[14], sum_w[239:224], c_w[15]);
    add16 a16(a[255:240], b[255:240], c_w[15], sum_w[255:240], c_w[16]);
    add16 a17(a[271:256], b[271:256], c_w[16], sum_w[271:256], c_w[17]);
    add16 a18(a[287:272], b[287:272], c_w[17], sum_w[287:272], c_w[18]);
    add16 a19(a[303:288], b[303:288], c_w[18], sum_w[303:288], c_w[19]);
    add16 a20(a[319:304], b[319:304], c_w[19], sum_w[319:304], c_w[20]);
    add16 a21(a[335:320], b[335:320], c_w[20], sum_w[335:320], c_w[21]);
    add16 a22(a[351:336], b[351:336], c_w[21], sum_w[351:336], c_w[22]);
    add16 a23(a[367:352], b[367:352], c_w[22], sum_w[367:352], c_w[23]);
    add16 a24(a[383:368], b[383:368], c_w[23], sum_w[383:368], c_w[24]);
    add16 a25(a[399:384], b[399:384], c_w[24], sum_w[399:384], c_w[25]);
    add16 a26(a[415:400], b[415:400], c_w["
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1, cout2);
    add16 a3(a[31:16], b[31:16], 1'b1, sum2, cout2);
    assign sum = {sum1, sum2};
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1, cout2);
    add16 a3(a[31:16], b[31:16], 1'b1, sum2, cout2);
    assign sum = {sum1, sum2};
endmodule"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [32:0] sum_w;
    wire cout_w;
    
    add16 a0(
       .a(a[15:0]),
       .b(b[15:0]),
       .cin(1'b0),
       .sum(sum_w[31:0]),
       .cout(cout_w)
    );
    
    add16 a1(
       .a(a[31:16]),
       .b(b[31:16]),
       .cin(cout_w),
       .sum(sum_w[32:0]),
       .cout(cout_w)
    );
    
    assign sum = sum_w[31:0];
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [32:0] sum_w;
    wire cout_w;
    
    add16 a0(
       .a(a[15:0]),
       .b(b[15:0]),
       .cin(1'b0),
       .sum(sum_w[31:0]),
       .cout(cout_w)
    );
    
    add16 a1(
       .a(a[31:16]),
       .b(b[31:16]),
       .cin(cout_w),
       .sum(sum_w[32:0]),
       .cout(cout_w)
    );
    
    assign sum = sum_w[31:0];
    
endmodule"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15;

    assign b1 = { {24{b[31]}}, b[31:24] };
    assign b2 = { {16{b[31]}}, b[31:16] };
    assign b3 = { {8{b[31]}}, b[31:8] };
    assign b4 = { {b[31]}, {8{b[7]}}, {16{b[15]}}, {24{b[23]}}, b[7:0] };
    assign b5 = { {16{b[31]}}, b[31:16] };
    assign b6 = { {8{b[31]}}, b[31:8] };
    assign b7 = { {b[31]}, {16{b[15]}}, {8{b[7]}}, {b[7:0]} };
    assign b8 = { {24{b[31]}}, b[31:24] };
    assign b9 = { {16{b[31]}}, b[31:16] };
    assign b10 = { {8{b[31]}}, b[31:8] };
    assign b11 = { {b[31]}, {24{b[23]}}, {16{b[15]}}, {8{b[7]}}, {b[7:0]} };
    assign b12 = { {16{b[31]}}, b[31:16] };
    assign b13 = { {8{b[31]}}, b[31:8] };
    assign b14 = { {b[31]}, {24{b[23]}}, {16{b[15]}}, {8{b[7]}}, {b[7:0]} };
    assign b15 = { {8{b[31]}}, b[31:8] };

    add16 a0(a, b1, c1, sum1, c2);
    add16 a1(a, b2, c2, sum2, c3);
    add16 a2(a, b3, c3, sum3, c4);
    add16 a3(a, b4, c4, sum4, c5);
    add16 a4(a, b5, c5, sum5, c6);
    add16 a5(a, b6, c6, sum6, c7);
    add16 a6(a, b7, c7, sum7, c8);
    add16 a7(a, b8, c8, sum8, c9);
    add16 a8(a, b9, c9, sum9, c10);
    add16 a9(a, b10, c10, sum10, c11);
    add16 a10(a, b11, c11, sum11, c12);
    add16 a11(a, b12, c12, sum12, c13);
    add16 a12(a, b13, c13, sum13, c14);
    add16 a13(a, b14, c14, sum14, c15);
    add16 a14(a, b15, c15, sum15, cout);


endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15;

    assign b1 = { {24{b[31]}}, b[31:24] };
    assign b2 = { {16{b[31]}}, b[31:16] };
    assign b3 = { {8{b[31]}}, b[31:8] };
    assign b4 = { {b[31]}, {8{b[7]}}, {16{b[15]}}, {24{b[23]}}, b[7:0] };
    assign b5 = { {16{b[31]}}, b[31:16] };
    assign b6 = { {8{b[31]}}, b[31:8] };
    assign b7 = { {b[31]}, {16{b[15]}}, {8{b[7]}}, {b[7:0]} };
    assign b8 = { {24{b[31]}}, b[31:24] };
    assign b9 = { {16{b[31]}}, b[31:16] };
    assign b10 = { {8{b[31]}}, b[31:8] };
    assign b11 = { {b[31]}, {24{b[23]}}, {16{b[15]}}, {8{b[7]}}, {b[7:0]} };
    assign b12 = { {16{b[31]}}, b[31:16] };
    assign b13 = { {8{b[31]}}, b[31:8] };
    assign b14 = { {b[31]}, {24{b[23]}}, {16{b[15]}}, {8{b[7]}}, {b[7:0]} };
    assign b15 = { {8{b[31]}}, b[31:8] };

    add16 a0(a, b1, c1, sum1, c2);
    add16 a1(a, b2, c2, sum2, c3);
    add16 a2(a, b3, c3, sum3, c4);
    add16 a3(a, b4, c4, sum4, c5);
    add16 a4(a, b5, c5, sum5, c6);
    add16 a5(a, b6, c6, sum6, c7);
    add16 a6(a, b7, c7, sum7, c8);
    add16 a7(a, b8, c8, sum8, c9);
    add16 a8(a, b9, c9, sum9, c10);
    add16 a9(a, b10, c10, sum10, c11);
    add16 a10(a, b11, c11, sum11, c12);
    add16 a11(a, b12, c12, sum12, c13);
    add16 a12(a, b13, c13, sum13, c14);
    add16 a13(a, b14, c14, sum14, c15);
    add16 a14(a, b15, c15, sum15, cout);


endmodule"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire cout1, cout2, cout3, cout4, cout5, cout6, cout7, cout8, cout9, cout10, cout11, cout12, cout13, cout14, cout15;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1, cout2);
    add16 a3(a[47:32], b[47:32], cout2, sum2, cout3);
    add16 a4(a[63:48], b[63:48], cout3, sum3, cout4);
    add16 a5(a[79:64], b[79:64], cout4, sum4, cout5);
    add16 a6(a[95:80], b[95:80], cout5, sum5, cout6);
    add16 a7(a[111:96], b[111:96], cout6, sum6, cout7);
    add16 a8(a[127:112], b[127:112], cout7, sum7, cout8);
    add16 a9(a[143:128], b[143:128], cout8, sum8, cout9);
    add16 a10(a[159:144], b[159:144], cout9, sum9, cout10);
    add16 a11(a[175:160], b[175:160], cout10, sum10, cout11);
    add16 a12(a[191:176], b[191:176], cout11, sum11, cout12);
    add16 a13(a[207:192], b[207:192], cout12, sum12, cout13);
    add16 a14(a[223:208], b[223:208], cout13, sum13, cout14);
    add16 a15(a[239:224], b[239:224], cout14, sum14, cout15);
    add16 a16(a[255:240], b[255:240], cout15, sum15, cout);
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire cout1, cout2, cout3, cout4, cout5, cout6, cout7, cout8, cout9, cout10, cout11, cout12, cout13, cout14, cout15;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1, cout2);
    add16 a3(a[47:32], b[47:32], cout2, sum2, cout3);
    add16 a4(a[63:48], b[63:48], cout3, sum3, cout4);
    add16 a5(a[79:64], b[79:64], cout4, sum4, cout5);
    add16 a6(a[95:80], b[95:80], cout5, sum5, cout6);
    add16 a7(a[111:96], b[111:96], cout6, sum6, cout7);
    add16 a8(a[127:112], b[127:112], cout7, sum7, cout8);
    add16 a9(a[143:128], b[143:128], cout8, sum8, cout9);
    add16 a10(a[159:144], b[159:144], cout9, sum9, cout10);
    add16 a11(a[175:160], b[175:160], cout10, sum10, cout11);
    add16 a12(a[191:176], b[191:176], cout11, sum11, cout12);
    add16 a13(a[207:192], b[207:192], cout12, sum12, cout13);
    add16 a14(a[223:208], b[223:208], cout13, sum13, cout14);
    add16 a15(a[239:224], b[239:224], cout14, sum14, cout15);
    add16 a16(a[255:240], b[255:240], cout15, sum15, cout);
    
endmodule"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31;
    
    assign b1 = { {24{b[31]}}, b[31:24] };
    assign b2 = { {23{b[31]}}, b[31:23] };
    assign b3 = { {22{b[31]}}, b[31:22] };
    assign b4 = { {21{b[31]}}, b[31:21] };
    assign b5 = { {20{b[31]}}, b[31:20] };
    assign b6 = { {19{b[31]}}, b[31:19] };
    assign b7 = { {18{b[31]}}, b[31:18] };
    assign b8 = { {17{b[31]}}, b[31:17] };
    assign b9 = { {16{b[31]}}, b[31:16] };
    assign b10 = { {15{b[31]}}, b[31:15] };
    assign b11 = { {14{b[31]}}, b[31:14] };
    assign b12 = { {13{b[31]}}, b[31:13] };
    assign b13 = { {12{b[31]}}, b[31:12] };
    assign b14 = { {11{b[31]}}, b[31:11] };
    assign b15 = { {10{b[31]}}, b[31:10] };
    assign b16 = { {9{b[31]}}, b[31:9] };
    assign b17 = { {8{b[31]}}, b[31:8] };
    assign b18 = { {7{b[31]}}, b[31:7] };
    assign b19 = { {6{b[31]}}, b[31:6] };
    assign b20 = { {5{b[31]}}, b[31:5] };
    assign b21 = { {4{b[31]}}, b[31:4] };
    assign b22 = { {3{b[31]}}, b[31:3] };
    assign b23 = { {2{b[31]}}, b[31:2] };
    assign b24 = { {1{b[31]}}, b[31:1] };
    assign b25 = { {0{b[31]}}, b[31:0] };
    
    add16 a1(a, b1, 1'b0, sum1, cout1);
    add16 a2(a, b2, cout1, sum2, cout2);
    add16 a3(a, b3, cout2, sum3, cout3);
    add16 a4(a, b4, cout3, sum4, cout4);
    add16 a5(a, b5, cout4, sum5, cout5);
    add16 a6(a, b6, cout5, sum6, cout6);
    add16 a7(a, b7, cout6, sum7, cout7);
    add16 a8(a, b8, cout7, sum8, cout8);
    add16 a9(a, b9, cout8, sum9, cout9);
    add16 a10(a, b10, cout9, sum10, cout10);
    add16 a11(a, b11, cout10, sum11, cout11);
    add16 a12(a, b12, cout11, sum12, cout12);
    add16 a13(a, b13, cout12, sum13, cout13);
    add16 a14(a, b14, cout13, sum14, cout14);
    add16 a15(a, b15, cout14, sum15, cout15);
    add16 a16(a, b16, cout15, sum16,",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31;
    
    assign b1 = { {24{b[31]}}, b[31:24] };
    assign b2 = { {23{b[31]}}, b[31:23] };
    assign b3 = { {22{b[31]}}, b[31:22] };
    assign b4 = { {21{b[31]}}, b[31:21] };
    assign b5 = { {20{b[31]}}, b[31:20] };
    assign b6 = { {19{b[31]}}, b[31:19] };
    assign b7 = { {18{b[31]}}, b[31:18] };
    assign b8 = { {17{b[31]}}, b[31:17] };
    assign b9 = { {16{b[31]}}, b[31:16] };
    assign b10 = { {15{b[31]}}, b[31:15] };
    assign b11 = { {14{b[31]}}, b[31:14] };
    assign b12 = { {13{b[31]}}, b[31:13] };
    assign b13 = { {12{b[31]}}, b[31:12] };
    assign b14 = { {11{b[31]}}, b[31:11] };
    assign b15 = { {10{b[31]}}, b[31:10] };
    assign b16 = { {9{b[31]}}, b[31:9] };
    assign b17 = { {8{b[31]}}, b[31:8] };
    assign b18 = { {7{b[31]}}, b[31:7] };
    assign b19 = { {6{b[31]}}, b[31:6] };
    assign b20 = { {5{b[31]}}, b[31:5] };
    assign b21 = { {4{b[31]}}, b[31:4] };
    assign b22 = { {3{b[31]}}, b[31:3] };
    assign b23 = { {2{b[31]}}, b[31:2] };
    assign b24 = { {1{b[31]}}, b[31:1] };
    assign b25 = { {0{b[31]}}, b[31:0] };
    
    add16 a1(a, b1, 1'b0, sum1, cout1);
    add16 a2(a, b2, cout1, sum2, cout2);
    add16 a3(a, b3, cout2, sum3, cout3);
    add16 a4(a, b4, cout3, sum4, cout4);
    add16 a5(a, b5, cout4, sum5, cout5);
    add16 a6(a, b6, cout5, sum6, cout6);
    add16 a7(a, b7, cout6, sum7, cout7);
    add16 a8(a, b8, cout7, sum8, cout8);
    add16 a9(a, b9, cout8, sum9, cout9);
    add16 a10(a, b10, cout9, sum10, cout10);
    add16 a11(a, b11, cout10, sum11, cout11);
    add16 a12(a, b12, cout11, sum12, cout12);
    add16 a13(a, b13, cout12, sum13, cout13);
    add16 a14(a, b14, cout13, sum14, cout14);
    add16 a15(a, b15, cout14, sum15, cout15);
    add16 a16(a, b16, cout15, sum16,"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31;
    
    assign b1 = { {24{b[31]}}, b[31:24] };
    assign b2 = { {23{b[31]}}, b[31:23] };
    assign b3 = { {22{b[31]}}, b[31:22] };
    assign b4 = { {21{b[31]}}, b[31:21] };
    assign b5 = { {20{b[31]}}, b[31:20] };
    assign b6 = { {19{b[31]}}, b[31:19] };
    assign b7 = { {18{b[31]}}, b[31:18] };
    assign b8 = { {17{b[31]}}, b[31:17] };
    assign b9 = { {16{b[31]}}, b[31:16] };
    assign b10 = { {15{b[31]}}, b[31:15] };
    assign b11 = { {14{b[31]}}, b[31:14] };
    assign b12 = { {13{b[31]}}, b[31:13] };
    assign b13 = { {12{b[31]}}, b[31:12] };
    assign b14 = { {11{b[31]}}, b[31:11] };
    assign b15 = { {10{b[31]}}, b[31:10] };
    assign b16 = { {9{b[31]}}, b[31:9] };
    assign b17 = { {8{b[31]}}, b[31:8] };
    assign b18 = { {7{b[31]}}, b[31:7] };
    assign b19 = { {6{b[31]}}, b[31:6] };
    assign b20 = { {5{b[31]}}, b[31:5] };
    assign b21 = { {4{b[31]}}, b[31:4] };
    assign b22 = { {3{b[31]}}, b[31:3] };
    assign b23 = { {2{b[31]}}, b[31:2] };
    assign b24 = { {1{b[31]}}, b[31:1] };
    assign b25 = { {0{b[31]}}, b[31:0] };
    
    add16 a1(a, b1, b2, sum1, cout1);
    add16 a2(a, b3, b4, sum2, cout2);
    add16 a3(a, b5, b6, sum3, cout3);
    add16 a4(a, b7, b8, sum4, cout4);
    add16 a5(a, b9, b10, sum5, cout5);
    add16 a6(a, b11, b12, sum6, cout6);
    add16 a7(a, b13, b14, sum7, cout7);
    add16 a8(a, b15, b16, sum8, cout8);
    add16 a9(a, b17, b18, sum9, cout9);
    add16 a10(a, b19, b20, sum10, cout10);
    add16 a11(a, b21, b22, sum11, cout11);
    add16 a12(a, b23, b24, sum12, cout12);
    add16 a13(a, b25, b26, sum13, cout13);
    add16 a14(a, b27, b28, sum14, cout14);
    add16 a15(a, b29, b30, sum15, cout15);
    add16 a16(a, b31, b32, sum16, cout",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31;
    
    assign b1 = { {24{b[31]}}, b[31:24] };
    assign b2 = { {23{b[31]}}, b[31:23] };
    assign b3 = { {22{b[31]}}, b[31:22] };
    assign b4 = { {21{b[31]}}, b[31:21] };
    assign b5 = { {20{b[31]}}, b[31:20] };
    assign b6 = { {19{b[31]}}, b[31:19] };
    assign b7 = { {18{b[31]}}, b[31:18] };
    assign b8 = { {17{b[31]}}, b[31:17] };
    assign b9 = { {16{b[31]}}, b[31:16] };
    assign b10 = { {15{b[31]}}, b[31:15] };
    assign b11 = { {14{b[31]}}, b[31:14] };
    assign b12 = { {13{b[31]}}, b[31:13] };
    assign b13 = { {12{b[31]}}, b[31:12] };
    assign b14 = { {11{b[31]}}, b[31:11] };
    assign b15 = { {10{b[31]}}, b[31:10] };
    assign b16 = { {9{b[31]}}, b[31:9] };
    assign b17 = { {8{b[31]}}, b[31:8] };
    assign b18 = { {7{b[31]}}, b[31:7] };
    assign b19 = { {6{b[31]}}, b[31:6] };
    assign b20 = { {5{b[31]}}, b[31:5] };
    assign b21 = { {4{b[31]}}, b[31:4] };
    assign b22 = { {3{b[31]}}, b[31:3] };
    assign b23 = { {2{b[31]}}, b[31:2] };
    assign b24 = { {1{b[31]}}, b[31:1] };
    assign b25 = { {0{b[31]}}, b[31:0] };
    
    add16 a1(a, b1, b2, sum1, cout1);
    add16 a2(a, b3, b4, sum2, cout2);
    add16 a3(a, b5, b6, sum3, cout3);
    add16 a4(a, b7, b8, sum4, cout4);
    add16 a5(a, b9, b10, sum5, cout5);
    add16 a6(a, b11, b12, sum6, cout6);
    add16 a7(a, b13, b14, sum7, cout7);
    add16 a8(a, b15, b16, sum8, cout8);
    add16 a9(a, b17, b18, sum9, cout9);
    add16 a10(a, b19, b20, sum10, cout10);
    add16 a11(a, b21, b22, sum11, cout11);
    add16 a12(a, b23, b24, sum12, cout12);
    add16 a13(a, b25, b26, sum13, cout13);
    add16 a14(a, b27, b28, sum14, cout14);
    add16 a15(a, b29, b30, sum15, cout15);
    add16 a16(a, b31, b32, sum16, cout"
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire cout1, cout2, cout3, cout4, cout5, cout6, cout7, cout8, cout9, cout10, cout11, cout12, cout13, cout14, cout15;
    
    add16 a1 ( a[15:0], b[15:0], 1'b0, sum[15:0], cout1 );
    add16 a2 ( a[31:16], b[31:16], cout1, sum1[31:16], cout2 );
    add16 a3 ( a[47:32], b[47:32], cout2, sum2[47:32], cout3 );
    add16 a4 ( a[63:48], b[63:48], cout3, sum3[63:48], cout4 );
    add16 a5 ( a[79:64], b[79:64], cout4, sum4[79:64], cout5 );
    add16 a6 ( a[95:80], b[95:80], cout5, sum5[95:80], cout6 );
    add16 a7 ( a[111:96], b[111:96], cout6, sum6[111:96], cout7 );
    add16 a8 ( a[127:112], b[127:112], cout7, sum7[127:112], cout8 );
    add16 a9 ( a[143:128], b[143:128], cout8, sum8[143:128], cout9 );
    add16 a10 ( a[159:144], b[159:144], cout9, sum9[159:144], cout10 );
    add16 a11 ( a[175:160], b[175:160], cout10, sum10[175:160], cout11 );
    add16 a12 ( a[191:176], b[191:176], cout11, sum11[191:176], cout12 );
    add16 a13 ( a[207:192], b[207:192], cout12, sum12[207:192], cout13 );
    add16 a14 ( a[223:208], b[223:208], cout13, sum13[223:208], cout14 );
    add16 a15 ( a[239:224], b[239:224], cout14, sum14[239:224], cout15 );
    add16 a16 ( a[255:240], b[255:240], cout15, sum15[255:240], cout );
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire cout1, cout2, cout3, cout4, cout5, cout6, cout7, cout8, cout9, cout10, cout11, cout12, cout13, cout14, cout15;
    
    add16 a1 ( a[15:0], b[15:0], 1'b0, sum[15:0], cout1 );
    add16 a2 ( a[31:16], b[31:16], cout1, sum1[31:16], cout2 );
    add16 a3 ( a[47:32], b[47:32], cout2, sum2[47:32], cout3 );
    add16 a4 ( a[63:48], b[63:48], cout3, sum3[63:48], cout4 );
    add16 a5 ( a[79:64], b[79:64], cout4, sum4[79:64], cout5 );
    add16 a6 ( a[95:80], b[95:80], cout5, sum5[95:80], cout6 );
    add16 a7 ( a[111:96], b[111:96], cout6, sum6[111:96], cout7 );
    add16 a8 ( a[127:112], b[127:112], cout7, sum7[127:112], cout8 );
    add16 a9 ( a[143:128], b[143:128], cout8, sum8[143:128], cout9 );
    add16 a10 ( a[159:144], b[159:144], cout9, sum9[159:144], cout10 );
    add16 a11 ( a[175:160], b[175:160], cout10, sum10[175:160], cout11 );
    add16 a12 ( a[191:176], b[191:176], cout11, sum11[191:176], cout12 );
    add16 a13 ( a[207:192], b[207:192], cout12, sum12[207:192], cout13 );
    add16 a14 ( a[223:208], b[223:208], cout13, sum13[223:208], cout14 );
    add16 a15 ( a[239:224], b[239:224], cout14, sum14[239:224], cout15 );
    add16 a16 ( a[255:240], b[255:240], cout15, sum15[255:240], cout );
    
endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;
add16 a1(a, bsub, sub, sum, cout);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;
add16 a1(a, bsub, sub, sum, cout);

endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;
add16 a1(a, bsub, sub, sum, cout);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;
add16 a1(a, bsub, sub, sum, cout);

endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [32:0] sum_ext;
    
    assign sum_ext = {sub, sum[31:0]};
    
    add16 a1(a[15:0], b[15:0], sub, sum[31:0], sum_ext[31:0]);
    add16 a2(a[31:16], b[31:16], sum_ext[31], sum_ext[32:1], sum_ext[31:0]);
    
endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [32:0] sum_ext;
    
    assign sum_ext = {sub, sum[31:0]};
    
    add16 a1(a[15:0], b[15:0], sub, sum[31:0], sum_ext[31:0]);
    add16 a2(a[31:16], b[31:16], sum_ext[31], sum_ext[32:1], sum_ext[31:0]);
    
endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [32:0] sum_ext;
    
    add16 a0(a[15:0], b[15:0], sub, sum_ext[15:0], sum_ext[31:16]);
    add16 a1(a[31:16], b[31:16], sub, sum_ext[31:16], sum_ext[47:32]);
    
    assign sum = sum_ext[47:32];
    
endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [32:0] sum_ext;
    
    add16 a0(a[15:0], b[15:0], sub, sum_ext[15:0], sum_ext[31:16]);
    add16 a1(a[31:16], b[31:16], sub, sum_ext[31:16], sum_ext[47:32]);
    
    assign sum = sum_ext[47:32];
    
endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = b^{32{sub}};
add16 a1(a, bsub, sub, sum, cout);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = b^{32{sub}};
add16 a1(a, bsub, sub, sum, cout);

endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = b^{32{sub}};
add16 a1(a, bsub, sub, sum, cout);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = b^{32{sub}};
add16 a1(a, bsub, sub, sum, cout);

endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [31:0] bsub;
    wire [31:0] sum1;
    wire [31:0] sum2;
    
    assign bsub = b^{32{sub}};
    add16 a1(a, bsub, sub, sum1, cout1);
    add16 a2(sum1, sum2, cout1, sum, cout2);
    
endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [31:0] bsub;
    wire [31:0] sum1;
    wire [31:0] sum2;
    
    assign bsub = b^{32{sub}};
    add16 a1(a, bsub, sub, sum1, cout1);
    add16 a2(sum1, sum2, cout1, sum, cout2);
    
endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;

add16 a0(a[15:0], bsub[15:0], sub, sum[15:0], cout);
add16 a1(a[31:16], bsub[31:16], cout, sum[31:16], cout1);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;

add16 a0(a[15:0], bsub[15:0], sub, sum[15:0], cout);
add16 a1(a[31:16], bsub[31:16], cout, sum[31:16], cout1);

endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [31:0] bsub;
    wire [31:0] sum1;
    wire [31:0] sum2;
    
    assign bsub = b^{32{sub}};
    add16 a1(a, bsub, sub, sum1, cout1);
    add16 a2(sum1, {16'b0, b[15:0]}, sub, sum2, cout2);
    
    assign sum = sum2;
    
endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    
    wire [31:0] bsub;
    wire [31:0] sum1;
    wire [31:0] sum2;
    
    assign bsub = b^{32{sub}};
    add16 a1(a, bsub, sub, sum1, cout1);
    add16 a2(sum1, {16'b0, b[15:0]}, sub, sum2, cout2);
    
    assign sum = sum2;
    
endmodule"
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;

add16 a1(a[15:0], bsub[15:0], sub, sum[15:0], cout);
add16 a2(a[31:16], bsub[31:16], cout, sum[31:16], cout1);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] bsub;
wire cout;

assign bsub = sub? ~b : b;

add16 a1(a[15:0], bsub[15:0], sub, sum[15:0], cout);
add16 a2(a[31:16], bsub[31:16], cout, sum[31:16], cout1);

endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum1, cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum2, cout2);
    assign sum = {sum2, 16'b0} + {sum1, 16'b0};
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum1, cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum2, cout2);
    assign sum = {sum2, 16'b0} + {sum1, 16'b0};
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum1, cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum2, cout2);
    assign sum = {16'b0, sum2[31:16], sum1[31:16]};
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum1, cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum2, cout2);
    assign sum = {16'b0, sum2[31:16], sum1[31:16]};
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire [32:0] sum_w;
    wire cout;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum_w[15:0], cout);
    add16 a2(a[31:16], b[31:16], cout, sum_w[31:16], cout1);
    add16 a3(a[47:32], b[47:32], cout1, sum_w[47:32], cout2);
    add16 a4(a[63:48], b[63:48], cout2, sum_w[63:48], cout);
    
    assign sum = sum_w[31:0];
    
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire [32:0] sum_w;
    wire cout;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum_w[15:0], cout);
    add16 a2(a[31:16], b[31:16], cout, sum_w[31:16], cout1);
    add16 a3(a[47:32], b[47:32], cout1, sum_w[47:32], cout2);
    add16 a4(a[63:48], b[63:48], cout2, sum_w[63:48], cout);
    
    assign sum = sum_w[31:0];
    
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [32:0] sum_w;
    wire cout;
    add16 a1(a[15:0], b[15:0], 1'b0, sum_w[15:0], cout);
    add16 a2(a[31:16], b[31:16], cout, sum_w[31:16], cout1);
    add16 a3(a[31:16], b[31:16], 1'b1, sum_w[31:16], cout2);
    assign sum = sum_w[31:0];
    
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [32:0] sum_w;
    wire cout;
    add16 a1(a[15:0], b[15:0], 1'b0, sum_w[15:0], cout);
    add16 a2(a[31:16], b[31:16], cout, sum_w[31:16], cout1);
    add16 a3(a[31:16], b[31:16], 1'b1, sum_w[31:16], cout2);
    assign sum = sum_w[31:0];
    
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31;
    
    assign b1 = { {31{a[31]}}, a};
    assign b2 = { {31{b[31]}}, b};
    assign b3 = { {31{a[31]}}, a};
    assign b4 = { {31{b[31]}}, b};
    assign b5 = { {31{a[31]}}, a};
    assign b6 = { {31{b[31]}}, b};
    assign b7 = { {31{a[31]}}, a};
    assign b8 = { {31{b[31]}}, b};
    assign b9 = { {31{a[31]}}, a};
    assign b10 = { {31{b[31]}}, b};
    assign b11 = { {31{a[31]}}, a};
    assign b12 = { {31{b[31]}}, b};
    assign b13 = { {31{a[31]}}, a};
    assign b14 = { {31{b[31]}}, b};
    assign b15 = { {31{a[31]}}, a};
    assign b16 = { {31{b[31]}}, b};
    assign b17 = { {31{a[31]}}, a};
    assign b18 = { {31{b[31]}}, b};
    assign b19 = { {31{a[31]}}, a};
    assign b20 = { {31{b[31]}}, b};
    assign b21 = { {31{a[31]}}, a};
    assign b22 = { {31{b[31]}}, b};
    assign b23 = { {31{a[31]}}, a};
    assign b24 = { {31{b[31]}}, b};
    assign b25 = { {31{a[31]}}, a};
    assign b26 = { {31{b[31]}}, b};
    assign b27 = { {31{a[31]}}, a};
    assign b28 = { {31{b[31]}}, b};
    assign b29 = { {31{a[31]}}, a};
    assign b30 = { {31{b[31]}}, b};
    assign b31 = { {31{a[31]}}, a};
    
    add16 a0(.a(a),.b(b1),.sum(sum1),.cout(c1));
    add16 a1(.a(a),.b(b2),.sum(sum2),.cout(c2));
    add16 a2(.a(a),.b(b3),.sum(sum3),.cout(c3));
    add16 a3(.a(a),.b(b4),.sum(sum4),.cout(c4));
    add16 a4(.a(a),.b(b5),.sum(sum5),.cout(c5));
    add16 a5(.a(a),.b(b6),.sum(sum6),.cout(c6));
    add16 a6(.a(a),.b(b7),.sum(sum7),.cout(c7));
    add16 a7(.a(a),.b(b8),.sum(sum8),.cout(c8));
    add16 a8(.a(a),.b(b9),.sum(sum9),.cout(c9));
    add16 a9(.a(a),.b(b10),.sum(sum10),.cout(c10));
    add16 a10(.a(a),.b(b11),.sum(sum11),.cout(c11));
    add16 a11(.a(a",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31;
    
    assign b1 = { {31{a[31]}}, a};
    assign b2 = { {31{b[31]}}, b};
    assign b3 = { {31{a[31]}}, a};
    assign b4 = { {31{b[31]}}, b};
    assign b5 = { {31{a[31]}}, a};
    assign b6 = { {31{b[31]}}, b};
    assign b7 = { {31{a[31]}}, a};
    assign b8 = { {31{b[31]}}, b};
    assign b9 = { {31{a[31]}}, a};
    assign b10 = { {31{b[31]}}, b};
    assign b11 = { {31{a[31]}}, a};
    assign b12 = { {31{b[31]}}, b};
    assign b13 = { {31{a[31]}}, a};
    assign b14 = { {31{b[31]}}, b};
    assign b15 = { {31{a[31]}}, a};
    assign b16 = { {31{b[31]}}, b};
    assign b17 = { {31{a[31]}}, a};
    assign b18 = { {31{b[31]}}, b};
    assign b19 = { {31{a[31]}}, a};
    assign b20 = { {31{b[31]}}, b};
    assign b21 = { {31{a[31]}}, a};
    assign b22 = { {31{b[31]}}, b};
    assign b23 = { {31{a[31]}}, a};
    assign b24 = { {31{b[31]}}, b};
    assign b25 = { {31{a[31]}}, a};
    assign b26 = { {31{b[31]}}, b};
    assign b27 = { {31{a[31]}}, a};
    assign b28 = { {31{b[31]}}, b};
    assign b29 = { {31{a[31]}}, a};
    assign b30 = { {31{b[31]}}, b};
    assign b31 = { {31{a[31]}}, a};
    
    add16 a0(.a(a),.b(b1),.sum(sum1),.cout(c1));
    add16 a1(.a(a),.b(b2),.sum(sum2),.cout(c2));
    add16 a2(.a(a),.b(b3),.sum(sum3),.cout(c3));
    add16 a3(.a(a),.b(b4),.sum(sum4),.cout(c4));
    add16 a4(.a(a),.b(b5),.sum(sum5),.cout(c5));
    add16 a5(.a(a),.b(b6),.sum(sum6),.cout(c6));
    add16 a6(.a(a),.b(b7),.sum(sum7),.cout(c7));
    add16 a7(.a(a),.b(b8),.sum(sum8),.cout(c8));
    add16 a8(.a(a),.b(b9),.sum(sum9),.cout(c9));
    add16 a9(.a(a),.b(b10),.sum(sum10),.cout(c10));
    add16 a10(.a(a),.b(b11),.sum(sum11),.cout(c11));
    add16 a11(.a(a"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1, cout2);
    add16 a3(a[31:16], b[31:16], 1'b1, sum2, cout2);
    assign sum = {sum1, sum2};
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout1, cout2;
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1, cout2);
    add16 a3(a[31:16], b[31:16], 1'b1, sum2, cout2);
    assign sum = {sum1, sum2};
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    assign b1 = { {16{b[15]}}, b[15:0] };
    assign b2 = { {16{b[31]}}, b[31:16] };
    assign b3 = { {16{a[15]}}, a[15:0] };
    assign b4 = { {16{a[31]}}, a[31:16] };
    assign b5 = { {16{b[31]}}, b[31:16] };
    assign b6 = { {16{a[31]}}, a[31:16] };
    assign b7 = { {16{b[15]}}, b[15:0] };
    assign b8 = { {16{b[31]}}, b[31:16] };
    assign b9 = { {16{a[31]}}, a[31:16] };
    assign b10 = { {16{a[15]}}, a[15:0] };
    assign b11 = { {16{a[31]}}, a[31:16] };
    assign b12 = { {16{b[15]}}, b[15:0] };
    assign b13 = { {16{b[31]}}, b[31:16] };
    assign b14 = { {16{a[31]}}, a[31:16] };
    assign b15 = { {16{b[31]}}, b[31:16] };
    assign sum1 = a + b1;
    assign sum2 = a + b2;
    assign sum3 = a + b3;
    assign sum4 = a + b4;
    assign sum5 = a + b5;
    assign sum6 = a + b6;
    assign sum7 = a + b7;
    assign sum8 = a + b8;
    assign sum9 = a + b9;
    assign sum10 = a + b10;
    assign sum11 = a + b11;
    assign sum12 = a + b12;
    assign sum13 = a + b13;
    assign sum14 = a + b14;
    assign sum15 = a + b15;
    assign sum16 = a + b16;
    assign sum17 = a + b17;
    assign sum18 = a + b18;
    assign sum19 = a + b19;
    assign sum20 = a + b20;
    assign sum21 = a + b21;
    assign sum22 = a + b22;
    assign sum23 = a + b23;
    assign sum24 = a + b24;
    assign sum25 = a + b25;
    assign sum26 = a + b26;
    assign sum27 = a + b27;
    assign sum28 = a + b28;
    assign sum29 = a + b29;
    assign sum30 = a + b30;
    assign sum31 = a + b31;
    assign sum32 = a + b32;
    assign sum33 = a + b33;
    assign sum34 = a + b34;
    assign sum35 = a + b35;
    assign sum36 = a + b36;
    assign sum37 = a + b37;
    assign sum38 = a + b38;
    assign sum39 = a + b39;
    assign sum40 = a + b40;
    assign sum41 = a + b41;
    assign sum42 = a + b42;
    assign sum43 = a + b43;
    assign sum44 = a + b44;
    assign sum45 = a + b45;
    assign sum46 = a + b46;
    assign sum47 = a + b47;
    assign sum48 = a + b48;
    assign sum49 = a + b49;
    assign sum50 = a + b50;
    assign sum51 = a + b51;
    assign sum",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    assign b1 = { {16{b[15]}}, b[15:0] };
    assign b2 = { {16{b[31]}}, b[31:16] };
    assign b3 = { {16{a[15]}}, a[15:0] };
    assign b4 = { {16{a[31]}}, a[31:16] };
    assign b5 = { {16{b[31]}}, b[31:16] };
    assign b6 = { {16{a[31]}}, a[31:16] };
    assign b7 = { {16{b[15]}}, b[15:0] };
    assign b8 = { {16{b[31]}}, b[31:16] };
    assign b9 = { {16{a[31]}}, a[31:16] };
    assign b10 = { {16{a[15]}}, a[15:0] };
    assign b11 = { {16{a[31]}}, a[31:16] };
    assign b12 = { {16{b[15]}}, b[15:0] };
    assign b13 = { {16{b[31]}}, b[31:16] };
    assign b14 = { {16{a[31]}}, a[31:16] };
    assign b15 = { {16{b[31]}}, b[31:16] };
    assign sum1 = a + b1;
    assign sum2 = a + b2;
    assign sum3 = a + b3;
    assign sum4 = a + b4;
    assign sum5 = a + b5;
    assign sum6 = a + b6;
    assign sum7 = a + b7;
    assign sum8 = a + b8;
    assign sum9 = a + b9;
    assign sum10 = a + b10;
    assign sum11 = a + b11;
    assign sum12 = a + b12;
    assign sum13 = a + b13;
    assign sum14 = a + b14;
    assign sum15 = a + b15;
    assign sum16 = a + b16;
    assign sum17 = a + b17;
    assign sum18 = a + b18;
    assign sum19 = a + b19;
    assign sum20 = a + b20;
    assign sum21 = a + b21;
    assign sum22 = a + b22;
    assign sum23 = a + b23;
    assign sum24 = a + b24;
    assign sum25 = a + b25;
    assign sum26 = a + b26;
    assign sum27 = a + b27;
    assign sum28 = a + b28;
    assign sum29 = a + b29;
    assign sum30 = a + b30;
    assign sum31 = a + b31;
    assign sum32 = a + b32;
    assign sum33 = a + b33;
    assign sum34 = a + b34;
    assign sum35 = a + b35;
    assign sum36 = a + b36;
    assign sum37 = a + b37;
    assign sum38 = a + b38;
    assign sum39 = a + b39;
    assign sum40 = a + b40;
    assign sum41 = a + b41;
    assign sum42 = a + b42;
    assign sum43 = a + b43;
    assign sum44 = a + b44;
    assign sum45 = a + b45;
    assign sum46 = a + b46;
    assign sum47 = a + b47;
    assign sum48 = a + b48;
    assign sum49 = a + b49;
    assign sum50 = a + b50;
    assign sum51 = a + b51;
    assign sum"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout;
    add16 a1(a[15:0], b[15:0], 1'b0, sum1, cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum2, cout2);
    assign sum = {32{sum2[31:16]}};
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2;
    wire cout;
    add16 a1(a[15:0], b[15:0], 1'b0, sum1, cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum2, cout2);
    assign sum = {32{sum2[31:16]}};
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire cout1, cout2, cout3, cout4, cout5, cout6, cout7, cout8, cout9, cout10, cout11, cout12, cout13, cout14, cout15;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1[31:16], cout2);
    add16 a3(a[47:32], b[47:32], cout2, sum2[47:32], cout3);
    add16 a4(a[63:48], b[63:48], cout3, sum3[63:48], cout4);
    add16 a5(a[79:64], b[79:64], cout4, sum4[79:64], cout5);
    add16 a6(a[95:80], b[95:80], cout5, sum5[95:80], cout6);
    add16 a7(a[111:96], b[111:96], cout6, sum6[111:96], cout7);
    add16 a8(a[127:112], b[127:112], cout7, sum7[127:112], cout8);
    add16 a9(a[143:128], b[143:128], cout8, sum8[143:128], cout9);
    add16 a10(a[159:144], b[159:144], cout9, sum9[159:144], cout10);
    add16 a11(a[175:160], b[175:160], cout10, sum10[175:160], cout11);
    add16 a12(a[191:176], b[191:176], cout11, sum11[191:176], cout12);
    add16 a13(a[207:192], b[207:192], cout12, sum12[207:192], cout13);
    add16 a14(a[223:208], b[223:208], cout13, sum13[223:208], cout14);
    add16 a15(a[239:224], b[239:224], cout14, sum14[239:224], cout15);
    add16 a16(a[255:240], b[255:240], cout15, sum15[255:240], cout);
    
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [31:0] sum1, sum2, sum3, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;
    wire cout1, cout2, cout3, cout4, cout5, cout6, cout7, cout8, cout9, cout10, cout11, cout12, cout13, cout14, cout15;
    
    add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], cout1);
    add16 a2(a[31:16], b[31:16], cout1, sum1[31:16], cout2);
    add16 a3(a[47:32], b[47:32], cout2, sum2[47:32], cout3);
    add16 a4(a[63:48], b[63:48], cout3, sum3[63:48], cout4);
    add16 a5(a[79:64], b[79:64], cout4, sum4[79:64], cout5);
    add16 a6(a[95:80], b[95:80], cout5, sum5[95:80], cout6);
    add16 a7(a[111:96], b[111:96], cout6, sum6[111:96], cout7);
    add16 a8(a[127:112], b[127:112], cout7, sum7[127:112], cout8);
    add16 a9(a[143:128], b[143:128], cout8, sum8[143:128], cout9);
    add16 a10(a[159:144], b[159:144], cout9, sum9[159:144], cout10);
    add16 a11(a[175:160], b[175:160], cout10, sum10[175:160], cout11);
    add16 a12(a[191:176], b[191:176], cout11, sum11[191:176], cout12);
    add16 a13(a[207:192], b[207:192], cout12, sum12[207:192], cout13);
    add16 a14(a[223:208], b[223:208], cout13, sum13[223:208], cout14);
    add16 a15(a[239:224], b[239:224], cout14, sum14[239:224], cout15);
    add16 a16(a[255:240], b[255:240], cout15, sum15[255:240], cout);
    
endmodule"
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [32:0] sum_w;
    wire [32:0] temp_1, temp_2, temp_3;
    wire cout_1, cout_2;
    
    add16 a1 (a[15:0], b[15:0], 0, sum_w[15:0], cout_1);
    add16 a2 (a[31:16], b[31:16], cout_1, sum_w[31:16], cout_2);
    
    assign temp_1 = {16'b0, a[31:16]};
    assign temp_2 = {16'b0, b[31:16]};
    assign sum = sum_w[31:0];
    
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//

    wire [32:0] sum_w;
    wire [32:0] temp_1, temp_2, temp_3;
    wire cout_1, cout_2;
    
    add16 a1 (a[15:0], b[15:0], 0, sum_w[15:0], cout_1);
    add16 a2 (a[31:16], b[31:16], cout_1, sum_w[31:16], cout_2);
    
    assign temp_1 = {16'b0, a[31:16]};
    assign temp_2 = {16'b0, b[31:16]};
    assign sum = sum_w[31:0];
    
endmodule"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// When the user inputs a 32-bit number, 
// the adder will automatically figure out which operation to do (addition or subtraction)
// and return the result.

// The adder does not need to figure out the operation, 
// it just does the operation.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative,",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// When the user inputs a 32-bit number, 
// the adder will automatically figure out which operation to do (addition or subtraction)
// and return the result.

// The adder does not need to figure out the operation, 
// it just does the operation.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative, 
// it just handles it internally.

// The adder does not need to figure out the zero, 
// it just handles it internally.

// The adder does not need to figure out the overflow, 
// it just handles it internally.

// The adder does not need to figure out the carry-in, 
// it just handles it internally.

// The adder does not need to figure out the carry-out, 
// it just handles it internally.

// The adder does not need to figure out the negative,"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// You can use the following code to instantiate two 16-bit adders in a module.

// add16 adder_16bit1( a[15:0], b[15:0], 1'b0, sum[15:0], cin );
// add16 adder_16bit2( a[31:16], b[31:16], cin, sum[31:16], cout );

// You can use the following code to instantiate two 1-bit adders in a module.

// add1 adder_1bit1( a[0], b[0], 1'b0, sum[0], cout );
// add1 adder_1bit2( a[1], b[1], cout, sum[1], cout );
// add1 adder_1bit3( a[2], b[2], cout, sum[2], cout );
// add1 adder_1bit4( a[3], b[3], cout, sum[3], cout );
// add1 adder_1bit5( a[4], b[4], cout, sum[4], cout );
// add1 adder_1bit6( a[5], b[5], cout, sum[5], cout );
// add1 adder_1bit7( a[6], b[6], cout, sum[6], cout );
// add1 adder_1bit8( a[7], b[7], cout, sum[7], cout );
// add1 adder_1bit9( a[8], b[8], cout, sum[8], cout );
// add1 adder_1bit10( a[9], b[9], cout, sum[9], cout );
// add1 adder_1bit11( a[10], b[10], cout, sum[10], cout );
// add1 adder_1bit12( a[11], b[11], cout, sum[11], cout );
// add1 adder_1bit13( a[12], b[12], cout, sum[12], cout );
// add1 adder_1bit14( a[13], b[13], cout, sum[13], cout );
// add1 adder_1bit15( a[14], b[14], cout, sum[14], cout );
// add1 adder_1bit16( a[15], b[15], cout, sum[15], cout );
// add1 adder_1bit17( a[16], b[16], cout, sum[16], cout );
// add1 adder_1bit18( a[17], b[17], cout, sum[17], cout );
// add1 adder_1bit19( a[18], b[18], cout, sum[18], cout );
// add1 adder_1bit20( a[19], b[19], cout, sum[19], cout );
// add1 adder_1bit21( a[20], b[20], cout, sum[20], cout );
// add1 adder_1bit22( a[21], b[21], cout, sum[21], cout );
// add1 adder_1bit23( a[22], b[22], cout, sum[22], cout );
// add1 adder_1bit24( a[23], b[23], cout, sum[23], cout );
// add1 adder_1bit25( a[24], b[24], cout, sum[24], cout );
// add1 adder_1bit26( a[25], b[25], cout, sum[25], cout );
// add1 adder_1bit27( a[26], b[26], cout, sum[26], cout );
// add1 adder_1bit28( a[27], b[27], cout, sum[27], cout );
// add1 adder_1bit29( a[28], b[28], cout, sum[28], cout );
// add1 adder_1bit30( a[29], b[29], cout, sum[29], cout );
// add1 adder_1bit31( a[30], b[30], cout, sum[30], cout );
// add1 adder_1bit32( a[31], b[31], cout, sum[31], cout );

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// You can use the following code to instantiate two 16-bit adders in a module.

// add16 adder_16bit1( a[15:0], b[15:0], 1'b0, sum[15:0], cin );
// add16 adder_16bit2( a[31:16], b[31:16], cin, sum[31:16], cout );

// You can use the following code to instantiate two 1-bit adders in a module.

// add1 adder_1bit1( a[0], b[0], 1'b0, sum[0], cout );
// add1 adder_1bit2( a[1], b[1], cout, sum[1], cout );
// add1 adder_1bit3( a[2], b[2], cout, sum[2], cout );
// add1 adder_1bit4( a[3], b[3], cout, sum[3], cout );
// add1 adder_1bit5( a[4], b[4], cout, sum[4], cout );
// add1 adder_1bit6( a[5], b[5], cout, sum[5], cout );
// add1 adder_1bit7( a[6], b[6], cout, sum[6], cout );
// add1 adder_1bit8( a[7], b[7], cout, sum[7], cout );
// add1 adder_1bit9( a[8], b[8], cout, sum[8], cout );
// add1 adder_1bit10( a[9], b[9], cout, sum[9], cout );
// add1 adder_1bit11( a[10], b[10], cout, sum[10], cout );
// add1 adder_1bit12( a[11], b[11], cout, sum[11], cout );
// add1 adder_1bit13( a[12], b[12], cout, sum[12], cout );
// add1 adder_1bit14( a[13], b[13], cout, sum[13], cout );
// add1 adder_1bit15( a[14], b[14], cout, sum[14], cout );
// add1 adder_1bit16( a[15], b[15], cout, sum[15], cout );
// add1 adder_1bit17( a[16], b[16], cout, sum[16], cout );
// add1 adder_1bit18( a[17], b[17], cout, sum[17], cout );
// add1 adder_1bit19( a[18], b[18], cout, sum[18], cout );
// add1 adder_1bit20( a[19], b[19], cout, sum[19], cout );
// add1 adder_1bit21( a[20], b[20], cout, sum[20], cout );
// add1 adder_1bit22( a[21], b[21], cout, sum[21], cout );
// add1 adder_1bit23( a[22], b[22], cout, sum[22], cout );
// add1 adder_1bit24( a[23], b[23], cout, sum[23], cout );
// add1 adder_1bit25( a[24], b[24], cout, sum[24], cout );
// add1 adder_1bit26( a[25], b[25], cout, sum[25], cout );
// add1 adder_1bit27( a[26], b[26], cout, sum[26], cout );
// add1 adder_1bit28( a[27], b[27], cout, sum[27], cout );
// add1 adder_1bit29( a[28], b[28], cout, sum[28], cout );
// add1 adder_1bit30( a[29], b[29], cout, sum[29], cout );
// add1 adder_1bit31( a[30], b[30], cout, sum[30], cout );
// add1 adder_1bit32( a[31], b[31], cout, sum[31], cout );

endmodule"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// You can use the following code to instantiate two 16-bit adders in a module.
// You do not need to change the instantiation of the module,
// nor the port declarations.

// The add16 module instantiates two 16-bit adders.
// The add16 module has the following declaration:

module add16 ( input[15:0] a, input[15:"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// When the above code is run, the program will first create two 32-bit adders, a and b.
// It will then call these adders in series, until it reaches the 32-bit adder at the end.
// It will then return the 32-bit sum of all the adders.

// Note that the above code will run for a total of 64 clocks (32 clocks for the two adders, 32 clocks for the final adder).

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Note: The above code will run for a total of 128 clocks (64 clocks for the two adders, 32 clocks for the final adder).

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit add",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// When the above code is run, the program will first create two 32-bit adders, a and b.
// It will then call these adders in series, until it reaches the 32-bit adder at the end.
// It will then return the 32-bit sum of all the adders.

// Note that the above code will run for a total of 64 clocks (32 clocks for the two adders, 32 clocks for the final adder).

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Note: The above code will run for a total of 128 clocks (64 clocks for the two adders, 32 clocks for the final adder).

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit adder.

// Hint: You can use the provided module add1 to create a 1-bit full adder.

// Hint: You can use the provided module add16 to create a 16-bit add"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code will instantiate two of the modules shown in this diagram
// It will also instantiate a 16-bit adder module shown in the diagram
// It will instantiate a 1-bit adder shown in the diagram

// The modules shown in the diagram are:
// add16, add1, and add1

// The add16 module is a 16-bit adder with the following declaration:

module add16 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// The following code will instantiate two of the modules shown in the diagram
// It will also instantiate a 16-bit adder module shown in the diagram
// It will instantiate a 1-bit adder shown in the diagram

// The modules shown in the diagram are:
// add16, add1, and add1

// The add16 module is a 16-bit adder with the following declaration:

module add16 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// The following code will instantiate two of the modules shown in the diagram
// It will also instantiate a 16-bit adder module shown in the diagram
// It will instantiate a 1-bit adder shown in the diagram

// The modules shown in the diagram are:
// add16, add1, and add1

// The add16 module is a 16-bit adder with the following declaration:

module add16 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// The following code will instantiate two of the modules shown in the diagram
// It will also instantiate a 16",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code will instantiate two of the modules shown in this diagram
// It will also instantiate a 16-bit adder module shown in the diagram
// It will instantiate a 1-bit adder shown in the diagram

// The modules shown in the diagram are:
// add16, add1, and add1

// The add16 module is a 16-bit adder with the following declaration:

module add16 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// The following code will instantiate two of the modules shown in the diagram
// It will also instantiate a 16-bit adder module shown in the diagram
// It will instantiate a 1-bit adder shown in the diagram

// The modules shown in the diagram are:
// add16, add1, and add1

// The add16 module is a 16-bit adder with the following declaration:

module add16 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// The following code will instantiate two of the modules shown in the diagram
// It will also instantiate a 16-bit adder module shown in the diagram
// It will instantiate a 1-bit adder shown in the diagram

// The modules shown in the diagram are:
// add16, add1, and add1

// The add16 module is a 16-bit adder with the following declaration:

module add16 ( input [15:0] a, input [15:0] b, input cin, output [15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

// The following code will instantiate two of the modules shown in the diagram
// It will also instantiate a 16"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

wire [31:0] top_wire;

assign top_wire = a ^ b;
assign sum = top_wire;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

wire [31:0] top_wire;

assign top_wire = a ^ b;
assign sum = top_wire;

endmodule"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code will instantiate two add16 modules
// and then add them together

add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], c1);
add16 a2(a[31:16], b[31:16], c1, sum[31:16], c2);

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code will instantiate two add16 modules
// and then add them together

add16 a1(a[15:0], b[15:0], 1'b0, sum[15:0], c1);
add16 a2(a[31:16], b[31:16], c1, sum[31:16], c2);

endmodule"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code computes the 32-bit addition of a and b.

assign sum = a + b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code computes the 32-bit addition of a and b.

assign sum = a + b;

endmodule"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code will instantiate three modules:
// 32-bit adder add1, 16-bit adder add16, and 1-bit adder add1.

assign sum = a + b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// The following code will instantiate three modules:
// 32-bit adder add1, 16-bit adder add16, and 1-bit adder add1.

assign sum = a + b;

endmodule"
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// When the user inputs a 32-bit number, 
// the adder will automatically figure out which module to instantiate,
// based on the value of the 32-bit number.

// The adder will also figure out the module based on the value of the input.

// In other words, the adder will instantiate the module that is appropriate for the input value.

// You can change the instantiation of the adder based on the input value.
// However, the adder will always choose the same module,
// regardless of the input value.

// The adder is a module, and it can be a single module,
// or a multiple-module adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

// When the user inputs a 32-bit number, 
// the adder will automatically figure out which module to instantiate,
// based on the value of the 32-bit number.

// The adder will also figure out the module based on the value of the input.

// In other words, the adder will instantiate the module that is appropriate for the input value.

// You can change the instantiation of the adder based on the input value.
// However, the adder will always choose the same module,
// regardless of the input value.

// The adder is a module, and it can be a single module,
// or a multiple-module adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full adder.
// The adder can be a combinational logic adder or a full"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1,out2,a,b,c,d);

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1,out2,a,b,c,d);

endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a,b,c,d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a,b,c,d);
endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );

endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );

endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a,b,c,d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a,b,c,d);
endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a, b, c, d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a, b, c, d);
endmodule"
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a, b, c, d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa (out1, out2, a, b, c, d);
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a,b,c,d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a aa ( out1, out2, a, b, c, d );
endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));
    
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));
    
endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u1(clk, d, q1);
    my_dff u2(clk, q1, q2);
    my_dff u3(clk, q2, q);

endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u1(clk, d, q1);
    my_dff u2(clk, q1, q2);
    my_dff u3(clk, q2, q);

endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));

endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));

endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff d1 ( clk, d, q1 );
    my_dff d2 ( clk, q1, q2 );
    my_dff d3 ( clk, q2, q );
    
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff d1 ( clk, d, q1 );
    my_dff d2 ( clk, q1, q2 );
    my_dff d3 ( clk, q2, q );
    
endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff d1 ( clk, d, q1 );
    my_dff d2 ( clk, q1, q2 );
    my_dff d3 ( clk, q2, q );
    
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff d1 ( clk, d, q1 );
    my_dff d2 ( clk, q1, q2 );
    my_dff d3 ( clk, q2, q );
    
endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u1(clk, d, q1);
    my_dff u2(clk, q1, q2);
    my_dff u3(clk, q2, q);

endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u1(clk, d, q1);
    my_dff u2(clk, q1, q2);
    my_dff u3(clk, q2, q);

endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff d1(clk, d, q1);
    my_dff d2(clk, q1, q2);
    my_dff d3(clk, q2, q);

endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff d1(clk, d, q1);
    my_dff d2(clk, q1, q2);
    my_dff d3(clk, q2, q);

endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));
    
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );
    
    wire q1, q2;
    
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));
    
endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

    wire q1, q2, q3;
    my_dff u1(clk, d, q1);
    my_dff u2(clk, q1, q2);
    my_dff u3(clk, q2, q3);
    always @(*)
        case({q2, q1})
            2'b00: q<=q;
            2'b01: q<=1'b0;
            2'b10: q<=1'b1;
            2'b11: q<=1'bz;
        endcase
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );

    wire q1, q2, q3;
    my_dff u1(clk, d, q1);
    my_dff u2(clk, q1, q2);
    my_dff u3(clk, q2, q3);
    always @(*)
        case({q2, q1})
            2'b00: q<=q;
            2'b01: q<=1'b0;
            2'b10: q<=1'b1;
            2'b11: q<=1'bz;
        endcase
endmodule"
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));

endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule","module top_module ( input clk, input d, output q );

    wire q1, q2;
    my_dff u0(.clk(clk),.d(d),.q(q1));
    my_dff u1(.clk(clk),.d(q1),.q(q2));
    my_dff u2(.clk(clk),.d(q2),.q(q));

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q_1 );
    my_dff8 d2 ( clk, q_1, q_2 );
    my_dff8 d3 ( clk, q_2, q_3 );
    my_dff8 d4 ( clk, q_3, q );

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q_1 );
    my_dff8 d2 ( clk, q_1, q_2 );
    my_dff8 d3 ( clk, q_2, q_3 );
    my_dff8 d4 ( clk, q_3, q );

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 dff8_0 ( clk, d, q_0 );
    my_dff8 dff8_1 ( clk, q_0, q_1 );
    my_dff8 dff8_2 ( clk, q_1, q_2 );
    my_dff8 dff8_3 ( clk, q_2, q );

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 dff8_0 ( clk, d, q_0 );
    my_dff8 dff8_1 ( clk, q_0, q_1 );
    my_dff8 dff8_2 ( clk, q_1, q_2 );
    my_dff8 dff8_3 ( clk, q_2, q );

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q_1 );
    my_dff8 d2 ( clk, q_1, q_2 );
    my_dff8 d3 ( clk, q_2, q );

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q_1 );
    my_dff8 d2 ( clk, q_1, q_2 );
    my_dff8 d3 ( clk, q_2, q );

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    wire [7:0] q1, q2;
    my_dff8 dff8_0(clk, d, q1);
    my_dff8 dff8_1(clk, q1, q2);
    my_dff8 dff8_2(clk, q2, q);

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    wire [7:0] q1, q2;
    my_dff8 dff8_0(clk, d, q1);
    my_dff8 dff8_1(clk, q1, q2);
    my_dff8 dff8_2(clk, q2, q);

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[0] );
    my_dff8 d2 ( clk, q[0], q[1] );
    my_dff8 d3 ( clk, q[1], q[2] );
    my_dff8 d4 ( clk, q[2], q[3] );
    my_dff8 d5 ( clk, q[3], q[4] );
    my_dff8 d6 ( clk, q[4], q[5] );
    my_dff8 d7 ( clk, q[5], q[6] );
    my_dff8 d8 ( clk, q[6], q[7] );
    
endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[0] );
    my_dff8 d2 ( clk, q[0], q[1] );
    my_dff8 d3 ( clk, q[1], q[2] );
    my_dff8 d4 ( clk, q[2], q[3] );
    my_dff8 d5 ( clk, q[3], q[4] );
    my_dff8 d6 ( clk, q[4], q[5] );
    my_dff8 d7 ( clk, q[5], q[6] );
    my_dff8 d8 ( clk, q[6], q[7] );
    
endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 dff8_0 ( clk, d, q_0 );
    my_dff8 dff8_1 ( clk, q_0, q_1 );
    my_dff8 dff8_2 ( clk, q_1, q_2 );
    my_dff8 dff8_3 ( clk, q_2, q );

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 dff8_0 ( clk, d, q_0 );
    my_dff8 dff8_1 ( clk, q_0, q_1 );
    my_dff8 dff8_2 ( clk, q_1, q_2 );
    my_dff8 dff8_3 ( clk, q_2, q );

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    wire [7:0] q1, q2, q3;
    
    my_dff8 d1(clk, d, q1);
    my_dff8 d2(clk, q1, q2);
    my_dff8 d3(clk, q2, q3);
    
    always @(*)
        case(sel)
            2'd0 : q = d;
            2'd1 : q = q1;
            2'd2 : q = q2;
            2'd3 : q = q3;
            default: q = 8'b0;
        endcase
    
endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    wire [7:0] q1, q2, q3;
    
    my_dff8 d1(clk, d, q1);
    my_dff8 d2(clk, q1, q2);
    my_dff8 d3(clk, q2, q3);
    
    always @(*)
        case(sel)
            2'd0 : q = d;
            2'd1 : q = q1;
            2'd2 : q = q2;
            2'd3 : q = q3;
            default: q = 8'b0;
        endcase
    
endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[0] );
    my_dff8 d2 ( clk, q[0], q[1] );
    my_dff8 d3 ( clk, q[1], q[2] );
    my_dff8 d4 ( clk, q[2], q[3] );
    my_dff8 d5 ( clk, q[3], q[4] );
    my_dff8 d6 ( clk, q[4], q[5] );
    my_dff8 d7 ( clk, q[5], q[6] );
    my_dff8 d8 ( clk, q[6], q[7] );
    
endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[0] );
    my_dff8 d2 ( clk, q[0], q[1] );
    my_dff8 d3 ( clk, q[1], q[2] );
    my_dff8 d4 ( clk, q[2], q[3] );
    my_dff8 d5 ( clk, q[3], q[4] );
    my_dff8 d6 ( clk, q[4], q[5] );
    my_dff8 d7 ( clk, q[5], q[6] );
    my_dff8 d8 ( clk, q[6], q[7] );
    
endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[0] );
    my_dff8 d2 ( clk, q[0], q[1] );
    my_dff8 d3 ( clk, q[1], q[2] );
    my_dff8 d4 ( clk, q[2], q[3] );
    my_dff8 d5 ( clk, q[3], q[4] );
    my_dff8 d6 ( clk, q[4], q[5] );
    my_dff8 d7 ( clk, q[5], q[6] );
    my_dff8 d8 ( clk, q[6], q[7] );

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[0] );
    my_dff8 d2 ( clk, q[0], q[1] );
    my_dff8 d3 ( clk, q[1], q[2] );
    my_dff8 d4 ( clk, q[2], q[3] );
    my_dff8 d5 ( clk, q[3], q[4] );
    my_dff8 d6 ( clk, q[4], q[5] );
    my_dff8 d7 ( clk, q[5], q[6] );
    my_dff8 d8 ( clk, q[6], q[7] );

endmodule"
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[7:0] );
    my_dff8 d2 ( clk, q[7:0], q[15:8] );
    my_dff8 d3 ( clk, q[15:8], q[23:16] );
    my_dff8 d4 ( clk, q[23:16], q[31:24] );
    
endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    my_dff8 d1 ( clk, d, q[7:0] );
    my_dff8 d2 ( clk, q[7:0], q[15:8] );
    my_dff8 d3 ( clk, q[15:8], q[23:16] );
    my_dff8 d4 ( clk, q[23:16], q[31:24] );
    
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
    mod_a aa ( a, b, out );
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
	assign out = a && b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
	assign out = a && b;
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

//module instantiation
module mod_a (out, in1, in2);

output out;
input in1, in2;

wire a, b;

//module instantiation

assign a = in1;
assign b = in2;

//assign the values of in1 and in2 to the module's ports.
//Note that the module is declared as a ""module"" and not a ""primitive.""
//This is because we want to be able to declare the inputs and outputs ports
//without using the ""input"" or ""output"" keywords.

assign out = a & b;

endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );

//module instantiation
module mod_a (out, in1, in2);

output out;
input in1, in2;

wire a, b;

//module instantiation

assign a = in1;
assign b = in2;

//assign the values of in1 and in2 to the module's ports.
//Note that the module is declared as a ""module"" and not a ""primitive.""
//This is because we want to be able to declare the inputs and outputs ports
//without using the ""input"" or ""output"" keywords.

assign out = a & b;

endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
	assign out = a && b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
	assign out = a && b;
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
	assign out = a && b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );
	assign out = a && b;
endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

// Define the port functionality and external wires here. 
// The module port 'in1' connects to the top-level module's port 'a'. 
// The module port 'in2' connects to the top-level module's port 'b'. 
// The module port 'out' connects to the top-level module's port 'out'. 

assign out = a & b;

endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );

// Define the port functionality and external wires here. 
// The module port 'in1' connects to the top-level module's port 'a'. 
// The module port 'in2' connects to the top-level module's port 'b'. 
// The module port 'out' connects to the top-level module's port 'out'. 

assign out = a & b;

endmodule"
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

// Define an instance of the module mod_a. 
// The instance is created by the keyword instance.
// The instance name (a, b, and out) are specified in a module body. 
// The module body is a block.
// The block is a list of statements.
// The module instantiates the module mod_a.
// The module mod_a has one port (out).
// The module instantiates two modules: mod_a and mod_b.
// The port of mod_a is connected to the port of mod_b.
// The port of mod_b is not connected.

//instance

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates two modules

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule","module top_module ( input a, input b, output out );

// Define an instance of the module mod_a. 
// The instance is created by the keyword instance.
// The instance name (a, b, and out) are specified in a module body. 
// The module body is a block.
// The block is a list of statements.
// The module instantiates the module mod_a.
// The module mod_a has one port (out).
// The module instantiates two modules: mod_a and mod_b.
// The port of mod_a is connected to the port of mod_b.
// The port of mod_b is not connected.

//instance

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates two modules

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);
//module mod_b (out, in1, in2);

//module instantiates one module

//module mod_a (out, in1, in2);"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A == B);
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule",1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );
    
    assign out = in[sel*4+3 -: 4];
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );//

    assign out = sel? b : a;

endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out );//

    assign out = sel? b : a;

endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );//

    assign out = sel? b : a;

endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out );//

    assign out = sel? b : a;

endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );//

    assign out = sel? b : a;

endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out );//

    assign out = sel? b : a;

endmodule"
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 
    
    assign out = sel? b : a;
    
endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;

endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;

endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a ;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a ;

endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a;

endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a;

endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a;
endmodule"
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a ;
endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel? b : a ;
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
    
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
    
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*)
    begin
        if(sel==4'b0000)
            out = a;
        else if(sel==4'b0001)
            out = b;
        else if(sel==4'b0010)
            out = c;
        else if(sel==4'b0011)
            out = d;
        else if(sel==4'b0100)
            out = e;
        else if(sel==4'b0101)
            out = f;
        else if(sel==4'b0110)
            out = g;
        else if(sel==4'b0111)
            out = h;
        else if(sel==4'b1000)
            out = i;
        else
            out = 16'hffff;
    end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*)
    begin
        if(sel==4'b0000)
            out = a;
        else if(sel==4'b0001)
            out = b;
        else if(sel==4'b0010)
            out = c;
        else if(sel==4'b0011)
            out = d;
        else if(sel==4'b0100)
            out = e;
        else if(sel==4'b0101)
            out = f;
        else if(sel==4'b0110)
            out = g;
        else if(sel==4'b0111)
            out = h;
        else if(sel==4'b1000)
            out = i;
        else
            out = 16'hffff;
    end
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
    
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
    
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*)
        begin
            case (sel)
                4'd0: out = a;
                4'd1: out = b;
                4'd2: out = c;
                4'd3: out = d;
                4'd4: out = e;
                4'd5: out = f;
                4'd6: out = g;
                4'd7: out = h;
                4'd8: out = i;
                default: out = 16'hffff;
            endcase
        end
    
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*)
        begin
            case (sel)
                4'd0: out = a;
                4'd1: out = b;
                4'd2: out = c;
                4'd3: out = d;
                4'd4: out = e;
                4'd5: out = f;
                4'd6: out = g;
                4'd7: out = h;
                4'd8: out = i;
                default: out = 16'hffff;
            endcase
        end
    
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*)
    begin
        if(sel==4'b0000)
            out = a;
        else if(sel==4'b0001)
            out = b;
        else if(sel==4'b0010)
            out = c;
        else if(sel==4'b0011)
            out = d;
        else if(sel==4'b0100)
            out = e;
        else if(sel==4'b0101)
            out = f;
        else if(sel==4'b0110)
            out = g;
        else if(sel==4'b0111)
            out = h;
        else if(sel==4'b1000)
            out = i;
        else
            out = 16'b11111111111111111111111111111111;
    end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*)
    begin
        if(sel==4'b0000)
            out = a;
        else if(sel==4'b0001)
            out = b;
        else if(sel==4'b0010)
            out = c;
        else if(sel==4'b0011)
            out = d;
        else if(sel==4'b0100)
            out = e;
        else if(sel==4'b0101)
            out = f;
        else if(sel==4'b0110)
            out = g;
        else if(sel==4'b0111)
            out = h;
        else if(sel==4'b1000)
            out = i;
        else
            out = 16'b11111111111111111111111111111111;
    end
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule"
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always@(sel)
        begin
            case(sel)
                4'd0: out=a;
                4'd1: out=b;
                4'd2: out=c;
                4'd3: out=d;
                4'd4: out=e;
                4'd5: out=f;
                4'd6: out=g;
                4'd7: out=h;
                4'd8: out=i;
                default: out=16'hffff;
            endcase
        end
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",-0.5,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );//

    // assign out = {in[7:0],in[15:8],in[23:16],in[31:24],in[39:32],in[47:40],in[55:48],in[63:56],in[71:64],in[79:72],in[87:80],in[95:88],in[103:96],in[111:104],in[119:112],in[127:120],in[135:128],in[143:136],in[151:144],in[159:152],in[167:160],in[175:168],in[183:176],in[191:184],in[199:192],in[207:200],in[215:208],in[223:216],in[231:224],in[239:232],in[247:240],in[255:248] };
    
    assign out = {in[7:0],in[15:8],in[23:16],in[31:24],in[39:32],in[47:40],in[55:48],in[63:56],in[71:64],in[79:72],in[87:80],in[95:88],in[103:96],in[111:104],in[119:112],in[127:120],in[135:128],in[143:136],in[151:144],in[159:152],in[167:160],in[175:168],in[183:176],in[191:184],in[199:192],in[207:200],in[215:208],in[223:216],in[231:224],in[239:232],in[247:240],in[255:248] };
    
endmodule",-0.5,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );//

    // assign out = {in[7:0],in[15:8],in[23:16],in[31:24],in[39:32],in[47:40],in[55:48],in[63:56],in[71:64],in[79:72],in[87:80],in[95:88],in[103:96],in[111:104],in[119:112],in[127:120],in[135:128],in[143:136],in[151:144],in[159:152],in[167:160],in[175:168],in[183:176],in[191:184],in[199:192],in[207:200],in[215:208],in[223:216],in[231:224],in[239:232],in[247:240],in[255:248] };
    
    assign out = {in[7:0],in[15:8],in[23:16],in[31:24],in[39:32],in[47:40],in[55:48],in[63:56],in[71:64],in[79:72],in[87:80],in[95:88],in[103:96],in[111:104],in[119:112],in[127:120],in[135:128],in[143:136],in[151:144],in[159:152],in[167:160],in[175:168],in[183:176],in[191:184],in[199:192],in[207:200],in[215:208],in[223:216],in[231:224],in[239:232],in[247:240],in[255:248] };
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end

endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end

endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end

endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end

endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[254]}}, in};

endmodule",-0.5,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[254]}}, in};

endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule",1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i, count;
    
    assign out = count;
    
    always @(*)
    begin
        count = 0;
        for(i=0; i<255; i=i+1)
            if(in[i])
                count = count + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = {in[2] & in[1] & in[0], in[1] & in[0]};
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = {in[2] & in[1] & in[0], in[1] & in[0]};
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    assign out = 0;
    
    always @(*)
    begin
        for(i=0; i<3; i=i+1)
            if(in[i])
                out = out + 1;
    end
    
endmodule",-1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    assign out = 0;
    
    always @(*)
    begin
        for(i=0; i<3; i=i+1)
            if(in[i])
                out = out + 1;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = {in[2] & in[1] & in[0], in[2] | in[1] | in[0]};
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = {in[2] & in[1] & in[0], in[2] | in[1] | in[0]};
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    assign out = 2'b00;
    
    always @(*)
    begin
        for(i=0; i<3; i=i+1)
        begin
            if(in[i])
                out = out + 1'b1;
        end
    end
    
endmodule",-1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    assign out = 2'b00;
    
    always @(*)
    begin
        for(i=0; i<3; i=i+1)
        begin
            if(in[i])
                out = out + 1'b1;
        end
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    assign out = 2'b00;
    
    always @(*)
    begin
        for(i=0; i<3; i=i+1)
        begin
            if(in[i] == 1'b1)
                out = out + 1'b1;
        end
    end
    
endmodule",-1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    assign out = 2'b00;
    
    always @(*)
    begin
        for(i=0; i<3; i=i+1)
        begin
            if(in[i] == 1'b1)
                out = out + 1'b1;
        end
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = {in[2] & in[1] & in[0], in[1] & in[0]};
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = {in[2] & in[1] & in[0], in[1] & in[0]};
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i, count;
    
    initial begin
        count = 0;
        for(i=0; i<3; i=i+1) begin
            if(in[i])
                count = count + 1;
        end
        out = count;
    end
    
endmodule",-1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i, count;
    
    initial begin
        count = 0;
        for(i=0; i<3; i=i+1) begin
            if(in[i])
                count = count + 1;
        end
        out = count;
    end
    
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer count;
    
    assign out = count[1:0];
    
    always @(*)
        begin
            count = 0;
            for(integer i=0; i<3; i=i+1)
                if(in[i])
                    count = count + 1;
        end

endmodule",1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer count;
    
    assign out = count[1:0];
    
    always @(*)
        begin
            count = 0;
            for(integer i=0; i<3; i=i+1)
                if(in[i])
                    count = count + 1;
        end

endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    always @(*)
        begin
            case(in)
                3'd0: out = 2'd0;
                3'd1: out = 2'd1;
                3'd2: out = 2'd2;
                3'd3: out = 2'd3;
                3'd4: out = 2'd4;
                3'd5: out = 2'd5;
                3'd6: out = 2'd6;
                3'd7: out = 2'd7;
                default: out = 2'd0;
            endcase
        end
                
endmodule",-1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    always @(*)
        begin
            case(in)
                3'd0: out = 2'd0;
                3'd1: out = 2'd1;
                3'd2: out = 2'd2;
                3'd3: out = 2'd3;
                3'd4: out = 2'd4;
                3'd5: out = 2'd5;
                3'd6: out = 2'd6;
                3'd7: out = 2'd7;
                default: out = 2'd0;
            endcase
        end
                
endmodule"
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    always @(*)
        begin
        out = 2'b00;
            for(integer i = 0; i<3; i++)
                begin
                    if(in[i])
                        out = out + 1'b1;
                end
        end

endmodule",-1,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    always @(*)
        begin
        out = 2'b00;
            for(integer i = 0; i<3; i++)
                begin
                    if(in[i])
                        out = out + 1'b1;
                end
        end

endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^ in[7:0];
endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;
    
endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule"
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


assign motor = ring & vibrate_mode;
assign ringer = ring & ~vibrate_mode;

endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] backup;
    reg [3:0] count;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            backup = temp;
            count = 4'd0;
        end
        else begin
            temp = temp >> 1;
            temp[511] = backup[511];
            count = count + 1;
            if(count == 4'd11) begin
                temp = temp << 1;
                count = 4'd0;
            end
        end
        q = temp;
    end
    
endmodule",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] backup;
    reg [3:0] count;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            backup = temp;
            count = 4'd0;
        end
        else begin
            temp = temp >> 1;
            temp[511] = backup[511];
            count = count + 1;
            if(count == 4'd11) begin
                temp = temp << 1;
                count = 4'd0;
            end
        end
        q = temp;
    end
    
endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [7:0] count;
    reg [7:0] count2;

    always @(posedge clk) begin
        // By default, initial the temp registers to 0
        temp <= 512'b0;
        temp2 <= 512'b0;
        
        // To load in the temp registers
        if(load) begin
            temp <= data;
            temp2 <= temp;
        end
        
        // For the first 8-bit input, we set the 2 MSB's to 0
        if(count == 8'd8) begin
            temp2[511:160] <= 0;
            temp2[159:0] = temp[511:160];
        end
        
        // For the second 8-bit input, we set the 2 MSB's to 1
        if(count2 == 8'd8) begin
            temp2[511:160] <= 1;
            temp2[159:0] = temp[511:160];
        end
        
        // For both 8-bit inputs, we increment the count
        if(count == 8'd9) begin
            count <= 0;
        end
        else begin
            count <= count + 1;
        end
        
        // For both 8-bit inputs, we increment the count2
        if(count2 == 8'd9) begin
            count2 <= 0;
        end
        else begin
            count2 <= count2 + 1;
        end
    end
    
    // The output is the result of adding the two temp registers
    assign q = temp + temp2;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [7:0] count;
    reg [7:0] count2;

    always @(posedge clk) begin
        // By default, initial the temp registers to 0
        temp <= 512'b0;
        temp2 <= 512'b0;
        
        // To load in the temp registers
        if(load) begin
            temp <= data;
            temp2 <= temp;
        end
        
        // For the first 8-bit input, we set the 2 MSB's to 0
        if(count == 8'd8) begin
            temp2[511:160] <= 0;
            temp2[159:0] = temp[511:160];
        end
        
        // For the second 8-bit input, we set the 2 MSB's to 1
        if(count2 == 8'd8) begin
            temp2[511:160] <= 1;
            temp2[159:0] = temp[511:160];
        end
        
        // For both 8-bit inputs, we increment the count
        if(count == 8'd9) begin
            count <= 0;
        end
        else begin
            count <= count + 1;
        end
        
        // For both 8-bit inputs, we increment the count2
        if(count2 == 8'd9) begin
            count2 <= 0;
        end
        else begin
            count2 <= count2 + 1;
        end
    end
    
    // The output is the result of adding the two temp registers
    assign q = temp + temp2;
    
endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp_q;
    reg [511:0] reg_q;

    always @(posedge clk) begin
        if(load) begin
            temp_q <= data;
        end
        else begin
            reg_q <= temp_q;
        end
    end

    assign q = reg_q;

endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp_q;
    reg [511:0] reg_q;

    always @(posedge clk) begin
        if(load) begin
            temp_q <= data;
        end
        else begin
            reg_q <= temp_q;
        end
    end

    assign q = reg_q;

endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] backup;
    reg [3:0] count;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            backup = temp;
            count = 4'd0;
        end
        else begin
            if(count == 4'd9) begin
                q <= {backup[511:0], temp[511:0]};
            end
            else begin
                temp <= temp << 1;
                temp[0] <= backup[511];
                count <= count + 1;
            end
        end
    end
endmodule",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] backup;
    reg [3:0] count;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            backup = temp;
            count = 4'd0;
        end
        else begin
            if(count == 4'd9) begin
                q <= {backup[511:0], temp[511:0]};
            end
            else begin
                temp <= temp << 1;
                temp[0] <= backup[511];
                count <= count + 1;
            end
        end
    end
endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp_q;
    reg [511:0] temp_q_next;
    
    always @(posedge clk) begin
        if(load)
            temp_q <= data;
        else
            temp_q <= temp_q_next;
    end
    
    always @(posedge clk) begin
        temp_q_next <= temp_q;
        if(temp_q[511])
            temp_q_next[511] <= 0;
        else
            temp_q_next[511] <= temp_q[511] ^ temp_q[510];
        if(temp_q[510])
            temp_q_next[510] <= 0;
        else
            temp_q_next[510] <= temp_q[510] ^ temp_q[509];
        if(temp_q[509])
            temp_q_next[509] <= 0;
        else
            temp_q_next[509] <= temp_q[509] ^ temp_q[508];
        if(temp_q[508])
            temp_q_next[508] <= 0;
        else
            temp_q_next[508] <= temp_q[508] ^ temp_q[507];
        if(temp_q[507])
            temp_q_next[507] <= 0;
        else
            temp_q_next[507] <= temp_q[507] ^ temp_q[506];
        if(temp_q[506])
            temp_q_next[506] <= 0;
        else
            temp_q_next[506] <= temp_q[506] ^ temp_q[505];
        if(temp_q[505])
            temp_q_next[505] <= 0;
        else
            temp_q_next[505] <= temp_q[505] ^ temp_q[504];
        if(temp_q[504])
            temp_q_next[504] <= 0;
        else
            temp_q_next[504] <= temp_q[504] ^ temp_q[503];
        if(temp_q[503])
            temp_q_next[503] <= 0;
        else
            temp_q_next[503] <= temp_q[503] ^ temp_q[502];
        if(temp_q[502])
            temp_q_next[502] <= 0;
        else
            temp_q_next[502] <= temp_q[502] ^ temp_q[501];
        if(temp_q[501])
            temp_q_next[501] <= 0;
        else
            temp_q_next[501] <= temp_q[501] ^ temp_q[500];
        if(temp_q[500])
            temp_q_next[500] <= 0;
        else
            temp_q_next[500] <= temp_q[500] ^ temp_q[499];
        if(temp_q[499])
            temp_q_next[499] <= 0;
        else
            temp_q_next[499] <= temp_q[499] ^ temp_q[498];
        if(temp_q[498])
            temp_q_next[498] <= 0;
        else
            temp_q_next[498] <= temp_q[498] ^ temp_q[497];
        if(temp_q[497])
            temp_q_next[497] <= 0;
        else
            temp_q_next[497] <= temp_q[497] ^ temp_q[496];
        if(temp_q[496])
            temp_q_next[496] <= 0;
        else
            temp_q_next[496] <= temp_q[496] ^ temp_q[495];
        if(temp_q[495])
            temp_q_next[495] <= 0;
        else
            temp_q_next[495] <= temp_q[495] ^ temp_q[494];
        if(temp_q[494])
            temp_q_next[494] <= 0;
        else
            temp_q_next[494] <= temp_q[494] ^ temp_q[493];
        if(temp_q[493])
            temp_q_next[493] <= 0;
        else
            temp",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp_q;
    reg [511:0] temp_q_next;
    
    always @(posedge clk) begin
        if(load)
            temp_q <= data;
        else
            temp_q <= temp_q_next;
    end
    
    always @(posedge clk) begin
        temp_q_next <= temp_q;
        if(temp_q[511])
            temp_q_next[511] <= 0;
        else
            temp_q_next[511] <= temp_q[511] ^ temp_q[510];
        if(temp_q[510])
            temp_q_next[510] <= 0;
        else
            temp_q_next[510] <= temp_q[510] ^ temp_q[509];
        if(temp_q[509])
            temp_q_next[509] <= 0;
        else
            temp_q_next[509] <= temp_q[509] ^ temp_q[508];
        if(temp_q[508])
            temp_q_next[508] <= 0;
        else
            temp_q_next[508] <= temp_q[508] ^ temp_q[507];
        if(temp_q[507])
            temp_q_next[507] <= 0;
        else
            temp_q_next[507] <= temp_q[507] ^ temp_q[506];
        if(temp_q[506])
            temp_q_next[506] <= 0;
        else
            temp_q_next[506] <= temp_q[506] ^ temp_q[505];
        if(temp_q[505])
            temp_q_next[505] <= 0;
        else
            temp_q_next[505] <= temp_q[505] ^ temp_q[504];
        if(temp_q[504])
            temp_q_next[504] <= 0;
        else
            temp_q_next[504] <= temp_q[504] ^ temp_q[503];
        if(temp_q[503])
            temp_q_next[503] <= 0;
        else
            temp_q_next[503] <= temp_q[503] ^ temp_q[502];
        if(temp_q[502])
            temp_q_next[502] <= 0;
        else
            temp_q_next[502] <= temp_q[502] ^ temp_q[501];
        if(temp_q[501])
            temp_q_next[501] <= 0;
        else
            temp_q_next[501] <= temp_q[501] ^ temp_q[500];
        if(temp_q[500])
            temp_q_next[500] <= 0;
        else
            temp_q_next[500] <= temp_q[500] ^ temp_q[499];
        if(temp_q[499])
            temp_q_next[499] <= 0;
        else
            temp_q_next[499] <= temp_q[499] ^ temp_q[498];
        if(temp_q[498])
            temp_q_next[498] <= 0;
        else
            temp_q_next[498] <= temp_q[498] ^ temp_q[497];
        if(temp_q[497])
            temp_q_next[497] <= 0;
        else
            temp_q_next[497] <= temp_q[497] ^ temp_q[496];
        if(temp_q[496])
            temp_q_next[496] <= 0;
        else
            temp_q_next[496] <= temp_q[496] ^ temp_q[495];
        if(temp_q[495])
            temp_q_next[495] <= 0;
        else
            temp_q_next[495] <= temp_q[495] ^ temp_q[494];
        if(temp_q[494])
            temp_q_next[494] <= 0;
        else
            temp_q_next[494] <= temp_q[494] ^ temp_q[493];
        if(temp_q[493])
            temp_q_next[493] <= 0;
        else
            temp"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [511:0] temp3;
    reg [511:0] temp4;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            temp2 = temp;
            temp3 = temp2;
            temp4 = temp3;
        end
        else begin
            temp2[511] = temp2[511] ^ temp2[510];
            temp2[510] = temp2[510] ^ temp2[509];
            temp2[509] = temp2[509] ^ temp2[508];
            temp2[508] = temp2[508] ^ temp2[507];
            temp2[507] = temp2[507] ^ temp2[506];
            temp2[506] = temp2[506] ^ temp2[505];
            temp2[505] = temp2[505] ^ temp2[504];
            temp2[504] = temp2[504] ^ temp2[503];
            temp2[503] = temp2[503] ^ temp2[502];
            temp2[502] = temp2[502] ^ temp2[501];
            temp2[501] = temp2[501] ^ temp2[500];
            temp2[500] = temp2[500] ^ temp2[499];
            temp2[499] = temp2[499] ^ temp2[498];
            temp2[498] = temp2[498] ^ temp2[497];
            temp2[497] = temp2[497] ^ temp2[496];
            temp2[496] = temp2[496] ^ temp2[495];
            temp2[495] = temp2[495] ^ temp2[494];
            temp2[494] = temp2[494] ^ temp2[493];
            temp2[493] = temp2[493] ^ temp2[492];
            temp2[492] = temp2[492] ^ temp2[491];
            temp2[491] = temp2[491] ^ temp2[490];
            temp2[490] = temp2[490] ^ temp2[489];
            temp2[489] = temp2[489] ^ temp2[488];
            temp2[488] = temp2[488] ^ temp2[487];
            temp2[487] = temp2[487] ^ temp2[486];
            temp2[486] = temp2[486] ^ temp2[485];
            temp2[485] = temp2[485] ^ temp2[484];
            temp2[484] = temp2[484] ^ temp2[483];
            temp2[483] = temp2[483] ^ temp2[482];
            temp2[482] = temp2[482] ^ temp2[481];
            temp2[481] = temp2[481] ^ temp2[480];
            temp2[480] = temp2[480] ^ temp2[479];
            temp2[479] = temp2[479] ^ temp2[478];
            temp2[478] = temp2[478] ^ temp2[477];
            temp2[477] = temp2[477] ^ temp2[476];
            temp2[476] = temp2[476] ^ temp2[475];
            temp2[475] = temp2[475] ^ temp2[474];
            temp2[474] = temp2[474] ^ temp2[473];
            temp2[473] = temp2[473] ^ temp2[472];
            temp2[472] = temp2[472] ^ temp2[471];
            temp2[471] = temp2[471] ^ temp2[470];
            temp2[470] = temp2[470] ^ temp2[469];
            temp2[469] = temp2[469] ^ temp2[468];
            temp2[468] = temp2[468] ^ temp2[467];
            temp2[467] = temp2[467] ^ temp2[466];
            temp2[466] = temp2[466] ^ temp2[465];
            temp2[465] = temp2[465] ^ temp2[464];
            temp2[464] = temp2[464] ^ temp2[463];
            temp2[463] = temp2[463] ^ temp2",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [511:0] temp3;
    reg [511:0] temp4;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            temp2 = temp;
            temp3 = temp2;
            temp4 = temp3;
        end
        else begin
            temp2[511] = temp2[511] ^ temp2[510];
            temp2[510] = temp2[510] ^ temp2[509];
            temp2[509] = temp2[509] ^ temp2[508];
            temp2[508] = temp2[508] ^ temp2[507];
            temp2[507] = temp2[507] ^ temp2[506];
            temp2[506] = temp2[506] ^ temp2[505];
            temp2[505] = temp2[505] ^ temp2[504];
            temp2[504] = temp2[504] ^ temp2[503];
            temp2[503] = temp2[503] ^ temp2[502];
            temp2[502] = temp2[502] ^ temp2[501];
            temp2[501] = temp2[501] ^ temp2[500];
            temp2[500] = temp2[500] ^ temp2[499];
            temp2[499] = temp2[499] ^ temp2[498];
            temp2[498] = temp2[498] ^ temp2[497];
            temp2[497] = temp2[497] ^ temp2[496];
            temp2[496] = temp2[496] ^ temp2[495];
            temp2[495] = temp2[495] ^ temp2[494];
            temp2[494] = temp2[494] ^ temp2[493];
            temp2[493] = temp2[493] ^ temp2[492];
            temp2[492] = temp2[492] ^ temp2[491];
            temp2[491] = temp2[491] ^ temp2[490];
            temp2[490] = temp2[490] ^ temp2[489];
            temp2[489] = temp2[489] ^ temp2[488];
            temp2[488] = temp2[488] ^ temp2[487];
            temp2[487] = temp2[487] ^ temp2[486];
            temp2[486] = temp2[486] ^ temp2[485];
            temp2[485] = temp2[485] ^ temp2[484];
            temp2[484] = temp2[484] ^ temp2[483];
            temp2[483] = temp2[483] ^ temp2[482];
            temp2[482] = temp2[482] ^ temp2[481];
            temp2[481] = temp2[481] ^ temp2[480];
            temp2[480] = temp2[480] ^ temp2[479];
            temp2[479] = temp2[479] ^ temp2[478];
            temp2[478] = temp2[478] ^ temp2[477];
            temp2[477] = temp2[477] ^ temp2[476];
            temp2[476] = temp2[476] ^ temp2[475];
            temp2[475] = temp2[475] ^ temp2[474];
            temp2[474] = temp2[474] ^ temp2[473];
            temp2[473] = temp2[473] ^ temp2[472];
            temp2[472] = temp2[472] ^ temp2[471];
            temp2[471] = temp2[471] ^ temp2[470];
            temp2[470] = temp2[470] ^ temp2[469];
            temp2[469] = temp2[469] ^ temp2[468];
            temp2[468] = temp2[468] ^ temp2[467];
            temp2[467] = temp2[467] ^ temp2[466];
            temp2[466] = temp2[466] ^ temp2[465];
            temp2[465] = temp2[465] ^ temp2[464];
            temp2[464] = temp2[464] ^ temp2[463];
            temp2[463] = temp2[463] ^ temp2"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [3:0] count;
    reg [3:0] count2;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            count = 4'b0;
            count2 = 4'b0;
        end
        else begin
            if(count == 4'b1111) begin
                temp2 = temp;
                temp = {temp2[511:0], temp2[511-count2]};
                count2 = count2 + 1'b1;
            end
            else begin
                temp = {temp[511:0], temp[511-count]};
                count = count + 1'b1;
            end
        end
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [3:0] count;
    reg [3:0] count2;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            count = 4'b0;
            count2 = 4'b0;
        end
        else begin
            if(count == 4'b1111) begin
                temp2 = temp;
                temp = {temp2[511:0], temp2[511-count2]};
                count2 = count2 + 1'b1;
            end
            else begin
                temp = {temp[511:0], temp[511-count]};
                count = count + 1'b1;
            end
        end
    end
    
    assign q = temp;
    
endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] backup;
    reg [8:0] index;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            backup = temp;
            index = 0;
        end
        else begin
            if(index < 512) begin
                temp[index] = ~temp[index];
                index = index + 1;
            end
            else index = 0;
        end
    end

    always @(posedge clk) begin
        q <= backup;
    end
    
endmodule",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] backup;
    reg [8:0] index;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            backup = temp;
            index = 0;
        end
        else begin
            if(index < 512) begin
                temp[index] = ~temp[index];
                index = index + 1;
            end
            else index = 0;
        end
    end

    always @(posedge clk) begin
        q <= backup;
    end
    
endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [7:0] count;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            count = 8'b0;
        end
        else begin
            temp = temp >> 1;
            temp2 = temp;
            count = count + 1;
            if(count == 8'b1) begin
                temp = temp2;
                count = 8'b0;
            end
        end
    end

    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [7:0] count;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            count = 8'b0;
        end
        else begin
            temp = temp >> 1;
            temp2 = temp;
            count = count + 1;
            if(count == 8'b1) begin
                temp = temp2;
                count = 8'b0;
            end
        end
    end

    assign q = temp;
    
endmodule"
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [3:0] count;
    reg [3:0] count2;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            count = 4'b0;
            count2 = 4'b0;
        end
        else begin
            //temp = temp >> 1;
            //count = count + 1;
            temp = {temp[510:0], 1'b0};
            count = count + 1;
            count2 = count2 + 1;
            if(count == 4) begin
                count = 4'b0;
                temp = {temp[511:1], 1'b0};
                count2 = count2 + 1;
            end
            if(count2 == 4) begin
                count2 = 4'b0;
                temp = temp >> 1;
            end
        end
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    reg [511:0] temp2;
    reg [3:0] count;
    reg [3:0] count2;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            count = 4'b0;
            count2 = 4'b0;
        end
        else begin
            //temp = temp >> 1;
            //count = count + 1;
            temp = {temp[510:0], 1'b0};
            count = count + 1;
            count2 = count2 + 1;
            if(count == 4) begin
                count = 4'b0;
                temp = {temp[511:1], 1'b0};
                count2 = count2 + 1;
            end
            if(count2 == 4) begin
                count2 = 4'b0;
                temp = temp >> 1;
            end
        end
    end
    
    assign q = temp;
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    reg [8:0] index;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            index = 9'b0;
        end
        else
            begin
                temp[index] = q[index];
                index = index + 1;
                if(index == 512)
                    index = 9'b0;
            end
    end
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    reg [8:0] index;

    always @(posedge clk) begin
        if(load) begin
            temp = data;
            index = 9'b0;
        end
        else
            begin
                temp[index] = q[index];
                index = index + 1;
                if(index == 512)
                    index = 9'b0;
            end
    end
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    reg [8:0] index;
    
    always @(posedge clk) begin
        if(load)
            temp = data;
        else
            temp = temp >> 1;
    end
    
    always @(posedge clk) begin
        if(index == 9'd511)
            index = 9'd0;
        else
            index = index + 9'd1;
    end
    
    assign q = temp[511:0];
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    reg [8:0] index;
    
    always @(posedge clk) begin
        if(load)
            temp = data;
        else
            temp = temp >> 1;
    end
    
    always @(posedge clk) begin
        if(index == 9'd511)
            index = 9'd0;
        else
            index = index + 9'd1;
    end
    
    assign q = temp[511:0];
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    integer i;
    
    reg [511:0] temp;
    reg [511:0] regfile [0:31];
    
    always @(posedge clk) begin
        if(load) begin
            for(i=0; i<32; i=i+1) begin
                regfile[i] <= data[511-i];
            end
        end
        else begin
            temp <= regfile[0];
            for(i=1; i<32; i=i+1) begin
                regfile[i] <= regfile[i-1];
            end
            regfile[0] <= temp;
        end
    end
    
    assign q = regfile[31];
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    integer i;
    
    reg [511:0] temp;
    reg [511:0] regfile [0:31];
    
    always @(posedge clk) begin
        if(load) begin
            for(i=0; i<32; i=i+1) begin
                regfile[i] <= data[511-i];
            end
        end
        else begin
            temp <= regfile[0];
            for(i=1; i<32; i=i+1) begin
                regfile[i] <= regfile[i-1];
            end
            regfile[0] <= temp;
        end
    end
    
    assign q = regfile[31];
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    genvar i;
    generate
        for(i=0; i<512; i=i+1) begin
            dff_t ins(clk, load, data[i], q[i]);
        end
    endgenerate
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    genvar i;
    generate
        for(i=0; i<512; i=i+1) begin
            dff_t ins(clk, load, data[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp_q;
    
    always @(posedge clk) begin
        if(load)
            temp_q <= data;
        else
            temp_q <= temp_q;
    end
    
    assign q = temp_q;
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp_q;
    
    always @(posedge clk) begin
        if(load)
            temp_q <= data;
        else
            temp_q <= temp_q;
    end
    
    assign q = temp_q;
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    integer i;
    
    reg [511:0] temp;
    reg [511:0] temp2;
    
    always @(posedge clk) begin
        if(load) begin
            temp = data;
            temp2 = temp;
            for(i=0; i<512; i=i+1) begin
                q[i] = temp2[511-i];
            end
        end
        else begin
            temp = temp2;
            for(i=0; i<512; i=i+1) begin
                q[i] = temp[511-i];
            end
        end
    end
    
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    integer i;
    
    reg [511:0] temp;
    reg [511:0] temp2;
    
    always @(posedge clk) begin
        if(load) begin
            temp = data;
            temp2 = temp;
            for(i=0; i<512; i=i+1) begin
                q[i] = temp2[511-i];
            end
        end
        else begin
            temp = temp2;
            for(i=0; i<512; i=i+1) begin
                q[i] = temp[511-i];
            end
        end
    end
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp_q;
    
    always @(posedge clk)
        begin
            if(load)
                temp_q <= data;
            else
                temp_q <= {temp_q[510:0], 1'b0};
        end
    
    assign q = temp_q;
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp_q;
    
    always @(posedge clk)
        begin
            if(load)
                temp_q <= data;
            else
                temp_q <= {temp_q[510:0], 1'b0};
        end
    
    assign q = temp_q;
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    genvar i;
    
    generate
        for(i=0; i<512; i=i+1) begin
            dff_t ins(clk, load, data[i], q[i]);
        end
    endgenerate
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    genvar i;
    
    generate
        for(i=0; i<512; i=i+1) begin
            dff_t ins(clk, load, data[i], q[i]);
        end
    endgenerate
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <=( (q[511:0]^{q[511:1],1'b0}) >> 1 ) ;
    end
    
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <=( (q[511:0]^{q[511:1],1'b0}) >> 1 ) ;
    end
    
endmodule"
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <=( (q[511:0]^{q[511:1],1'b0}) >> 1 ) ;
    end
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <=( (q[511:0]^{q[511:1],1'b0}) >> 1 ) ;
    end
endmodule"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63:8]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63:8]};
            endcase
        end
    end
    
endmodule"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[62:8]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[62:8]};
            endcase
        end
    end
    
endmodule"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0",-1,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'",-1,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'",-1,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q",-1,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load) q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q"
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
                default: q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55 : 0], 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0, 1'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
                default: q <= {q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63], q[63]};
            endcase
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0];
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if (load)
            q <= data;
        else if (ena)
            q[3:0] <= {1'b0, q[3:1]};
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if (load)
            q <= data;
        else if (ena)
            q[3:0] <= {1'b0, q[3:1]};
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 4'b0;
            else if (load)
                q <= data;
            else if (ena)
            	q[3:0] <= {1'b0, q[3:1]};
        end

endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset)
        begin
            if(areset)
                q <= 4'b0;
            else if (load)
                q <= data;
            else if (ena)
            	q[3:0] <= {1'b0, q[3:1]};
        end

endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0] ^ q[3];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0] ^ q[3];
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0];
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0];
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0] ^ q[3];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0] ^ q[3];
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0] ^ q[3];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[3] <= q[0] ^ q[3];
        end
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q[3:0] <= {1'b0, q[3:1]};
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q[3:0] <= {1'b0, q[3:1]};
    end
    
endmodule"
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[0] <= q[0] ^ q[3];
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[3:0] <= {1'b0, q[3:1]};
            q[0] <= q[0] ^ q[3];
        end
    end
    
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
endmodule"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial begin
    clk = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial begin
    clk = 0;
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial begin
    clk = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial begin
    clk = 0;
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial begin
    clk = 0;
    forever begin
        #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial begin
    clk = 0;
    forever begin
        #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial
begin
    clk = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial
begin
    clk = 0;
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial begin
    clk = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial begin
    clk = 0;
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial begin
    clk = 0;
    forever begin
        #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial begin
    clk = 0;
    forever begin
        #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk, rst, set;
reg [3:0] a, b;

initial begin
    $monitor (""clk = %b, rst = %b, set = %b, a = %b, b = %b"", clk, rst, set, a, b);
    clk = 0;
    rst = 0;
    set = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk, rst, set;
reg [3:0] a, b;

initial begin
    $monitor (""clk = %b, rst = %b, set = %b, a = %b, b = %b"", clk, rst, set, a, b);
    clk = 0;
    rst = 0;
    set = 0;
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk, reset, ena;
reg [7:0] data;

initial
begin
    clk = 1;
    reset = 0;
    ena = 0;
    data = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk, reset, ena;
reg [7:0] data;

initial
begin
    clk = 1;
    reset = 0;
    ena = 0;
    data = 0;
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial begin
    $monitor(""Time = %d clk = %b"",$time,clk);
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;

initial begin
    $monitor(""Time = %d clk = %b"",$time,clk);
    #"
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;
reg [7:0] a, b;
reg [2:0] c;
wire [7:0] sum;
wire carry;

// Create an instance of the dut (module instantiates all the necessary module instances)
dut dut1 (clk);

// This initial block will automatically be called when the module is instantiated.
initial
begin
	// Initialize the clock to 0
	clk = 1'b0;
	//After 10 ps, set the clock to 1
	#",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule","module top_module ( );

reg clk;
reg [7:0] a, b;
reg [2:0] c;
wire [7:0] sum;
wire carry;

// Create an instance of the dut (module instantiates all the necessary module instances)
dut dut1 (clk);

// This initial block will automatically be called when the module is instantiated.
initial
begin
	// Initialize the clock to 0
	clk = 1'b0;
	//After 10 ps, set the clock to 1
	#"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff ins1 (clk, reset, t, q);
    
    always
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff ins1 (clk, reset, t, q);
    
    always
        #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


// Declare a T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the stimulus module (no ports)

module stimulus;

// Declare variables to be connected
// to inputs
reg clk, reset, t;

// Declare output wire
wire q;

// Instantiate the T flip-flop

tff tff1(clk, reset, t, q);

// Stimulate the inputs

initial
begin
    clk = 1'b0;
    reset = 1'b1;
    t = 1'b0;
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


// Declare a T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the stimulus module (no ports)

module stimulus;

// Declare variables to be connected
// to inputs
reg clk, reset, t;

// Declare output wire
wire q;

// Instantiate the T flip-flop

tff tff1(clk, reset, t, q);

// Stimulate the inputs

initial
begin
    clk = 1'b0;
    reset = 1'b1;
    t = 1'b0;
    #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff ins1 (clk, reset, t, q);
    
    initial
    begin
        $dumpfile(""dump.vcd"");
        $dumpvars(1, top_module);
        
        clk = 0;
        reset = 0;
        t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff ins1 (clk, reset, t, q);
    
    initial
    begin
        $dumpfile(""dump.vcd"");
        $dumpvars(1, top_module);
        
        clk = 0;
        reset = 0;
        t = 0;
        #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


reg clk, reset, t;
wire q;

tff ins1 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    
    clk = 0;
    reset = 0;
    t = 0;
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


reg clk, reset, t;
wire q;

tff ins1 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    
    clk = 0;
    reset = 0;
    t = 0;
    #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


// Declare a T flip-flop
reg clk, reset, t;
wire q;

// Instantiate a design of a T flip-flop
tff DUT (clk, reset, t, q);

// Define clk
always
    begin
        clk = 1;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


// Declare a T flip-flop
reg clk, reset, t;
wire q;

// Instantiate a design of a T flip-flop
tff DUT (clk, reset, t, q);

// Define clk
always
    begin
        clk = 1;
        #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


reg clk, reset, t;
wire q;

tff ins1 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    
    clk = 0;
    reset = 0;
    t = 0;
    
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


reg clk, reset, t;
wire q;

tff ins1 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    
    clk = 0;
    reset = 0;
    t = 0;
    
    #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


reg clk, reset, t;
wire q;

tff t0 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    
    clk = 0;
    reset = 0;
    t = 0;
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


reg clk, reset, t;
wire q;

tff t0 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    
    clk = 0;
    reset = 0;
    t = 0;
    #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


// Declare a T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the stimulus (or stimulus input) port.

reg   t_reg, t_next;

always @(posedge clk)
    t_reg <= t_next;

// Define the T flip-flop input and output.

always @(posedge clk)
    t_next <= t;

// Define a counter.

reg [3:0] count;

// Define a module for counting.

counter counter1 (clk, reset, count);

// Define a module for toggling.

mux toggle (q, t, t_reg);

// Define a module for toggling.

mux toggle1 (q, t, t_reg);

// Define a module for counting.

counter counter2 (clk, reset, count);

// Define a module for toggling.

mux toggle2 (q, t, t_reg);

// Define a module for toggling.

mux toggle3 (q, t, t_reg);

// Define a module for toggling.

mux toggle4 (q, t, t_reg);

// Define a module for toggling.

mux toggle5 (q, t, t_reg);

// Define a module for toggling.

mux toggle6 (q, t, t_reg);

// Define a module for toggling.

mux toggle7 (q, t, t_reg);

// Define a module for toggling.

mux toggle8 (q, t, t_reg);

// Define a module for toggling.

mux toggle9 (q, t, t_reg);

// Define a module for toggling.

mux toggle10 (q, t, t_reg);

// Define a module for toggling.

mux toggle11 (q, t, t_reg);

// Define a module for toggling.

mux toggle12 (q, t, t_reg);

// Define a module for toggling.

mux toggle13 (q, t, t_reg);

// Define a module for toggling.

mux toggle14 (q, t, t_reg);

// Define a module for toggling.

mux toggle15 (q, t, t_reg);

// Define a module for toggling.

mux toggle16 (q, t, t_reg);

// Define a module for toggling.

mux toggle17 (q, t, t_reg);

// Define a module for toggling.

mux toggle18 (q, t, t_reg);

// Define a module for toggling.

mux toggle19 (q, t, t_reg);

// Define a module for toggling.

mux toggle20 (q, t, t_reg);

// Define a module for toggling.

mux toggle21 (q, t, t_reg);

// Define a module for toggling.

mux toggle22 (q, t, t_reg);

// Define a module for toggling.

mux toggle23 (q, t, t_reg);

// Define a module for toggling.

mux toggle24 (q, t, t_reg);

// Define a module for toggling.

mux toggle25 (q, t, t_reg);

// Define a module for toggling.

mux toggle26 (q, t, t_reg);

// Define a module for toggling.

mux toggle27 (q, t, t_reg);

// Define a module for toggling.

mux toggle28 (q, t, t_reg);

// Define a module for toggling.

mux toggle29 (q, t, t_reg);

// Define a module for toggling.

mux toggle30 (q, t",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


// Declare a T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the stimulus (or stimulus input) port.

reg   t_reg, t_next;

always @(posedge clk)
    t_reg <= t_next;

// Define the T flip-flop input and output.

always @(posedge clk)
    t_next <= t;

// Define a counter.

reg [3:0] count;

// Define a module for counting.

counter counter1 (clk, reset, count);

// Define a module for toggling.

mux toggle (q, t, t_reg);

// Define a module for toggling.

mux toggle1 (q, t, t_reg);

// Define a module for counting.

counter counter2 (clk, reset, count);

// Define a module for toggling.

mux toggle2 (q, t, t_reg);

// Define a module for toggling.

mux toggle3 (q, t, t_reg);

// Define a module for toggling.

mux toggle4 (q, t, t_reg);

// Define a module for toggling.

mux toggle5 (q, t, t_reg);

// Define a module for toggling.

mux toggle6 (q, t, t_reg);

// Define a module for toggling.

mux toggle7 (q, t, t_reg);

// Define a module for toggling.

mux toggle8 (q, t, t_reg);

// Define a module for toggling.

mux toggle9 (q, t, t_reg);

// Define a module for toggling.

mux toggle10 (q, t, t_reg);

// Define a module for toggling.

mux toggle11 (q, t, t_reg);

// Define a module for toggling.

mux toggle12 (q, t, t_reg);

// Define a module for toggling.

mux toggle13 (q, t, t_reg);

// Define a module for toggling.

mux toggle14 (q, t, t_reg);

// Define a module for toggling.

mux toggle15 (q, t, t_reg);

// Define a module for toggling.

mux toggle16 (q, t, t_reg);

// Define a module for toggling.

mux toggle17 (q, t, t_reg);

// Define a module for toggling.

mux toggle18 (q, t, t_reg);

// Define a module for toggling.

mux toggle19 (q, t, t_reg);

// Define a module for toggling.

mux toggle20 (q, t, t_reg);

// Define a module for toggling.

mux toggle21 (q, t, t_reg);

// Define a module for toggling.

mux toggle22 (q, t, t_reg);

// Define a module for toggling.

mux toggle23 (q, t, t_reg);

// Define a module for toggling.

mux toggle24 (q, t, t_reg);

// Define a module for toggling.

mux toggle25 (q, t, t_reg);

// Define a module for toggling.

mux toggle26 (q, t, t_reg);

// Define a module for toggling.

mux toggle27 (q, t, t_reg);

// Define a module for toggling.

mux toggle28 (q, t, t_reg);

// Define a module for toggling.

mux toggle29 (q, t, t_reg);

// Define a module for toggling.

mux toggle30 (q, t"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


reg clk, reset, t;
wire q;

tff ins1 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    $monitor(""time = %2d, clk = %b, reset = %b, t = %b, q = %b\n"", $time, clk, reset, t, q);
    
    clk = 0;
    reset = 0;
    t = 0;
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


reg clk, reset, t;
wire q;

tff ins1 (clk, reset, t, q);

initial
begin
    $dumpfile(""dump.vcd"");
    $dumpvars(1, top_module);
    $monitor(""time = %2d, clk = %b, reset = %b, t = %b, q = %b\n"", $time, clk, reset, t, q);
    
    clk = 0;
    reset = 0;
    t = 0;
    #"
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the D flip-flop module.

module dff (
    input clk,
    input d,
    input rst,
    output reg q
);

// Define the JK flip-flop module.

module jkff (
    input clk,
    input j,
    input k,
    output reg q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module dff (
    input clk,
    input d,
    input rst,
    output reg q
);

// Define the T flip-flop module.

module jkff (
    input clk,
    input j,
    input k,
    output reg q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module dff (
    input clk,
    input d,
    input rst,
    output reg q
);

// Define the T flip-flop module.

module jkff (
    input clk,
    input j,
    input k,
    output reg q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule","module top_module ();


// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the D flip-flop module.

module dff (
    input clk,
    input d,
    input rst,
    output reg q
);

// Define the JK flip-flop module.

module jkff (
    input clk,
    input j,
    input k,
    output reg q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module dff (
    input clk,
    input d,
    input rst,
    output reg q
);

// Define the T flip-flop module.

module jkff (
    input clk,
    input j,
    input k,
    output reg q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module dff (
    input clk,
    input d,
    input rst,
    output reg q
);

// Define the T flip-flop module.

module jkff (
    input clk,
    input j,
    input k,
    output reg q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Define the T flip-flop module.

module tff (
    input clk,
    input reset,   // active-high synchronous reset"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    
    // Reminder: The order in which you write assign statements doesn't matter. 
    // assign statements describe circuits, so you get the same circuit in the end
    // regardless of which portion you describe first.

    // Fan should be on when either heater or aircon is on, and also when requested to do so (fan_on = 1).
    assign fan = heater | aircon | fan_on;

    // Heater is on when it's too cold and mode is ""heating"".
    assign heater = (mode & too_cold);
    
    // Aircon is on when it's too hot and mode is not ""heating"".
    assign aircon = (~mode & too_hot);
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    
    // Reminder: The order in which you write assign statements doesn't matter. 
    // assign statements describe circuits, so you get the same circuit in the end
    // regardless of which portion you describe first.

    // Fan should be on when either heater or aircon is on, and also when requested to do so (fan_on = 1).
    assign fan = heater | aircon | fan_on;

    // Heater is on when it's too cold and mode is ""heating"".
    assign heater = (mode & too_cold);
    
    // Aircon is on when it's too hot and mode is not ""heating"".
    assign aircon = (~mode & too_hot);
    
endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    
    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;   
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    
    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;   
    
endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;   

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan    = heater | aircon | fan_on;   

endmodule"
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    
    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan = heater | aircon | fan_on;
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    
    assign heater = mode  & too_cold;
    assign aircon =!mode & too_hot;
    assign fan = heater | aircon | fan_on;
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1);
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1);
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1);
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1);
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1) | (x2 & x1);
    
endmodule"
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1);
    
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & x2) | (x3 & x1);
    
endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2,o1,o0} = vec;
    assign outv = vec;
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2,o1,o0} = vec;
    assign outv = vec;
endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2,o1,o0} = vec;
    assign outv = vec;
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2,o1,o0} = vec;
    assign outv = vec;
endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;

endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;

endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2,o1,o0} = vec;
    assign outv = vec;

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2,o1,o0} = vec;
    assign outv = vec;

endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;

endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule"
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign {o2, o1, o0} = vec;
    assign outv = vec;
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    // The following line will generate a warning that
    // the value of out will be x if in is x.
    assign out = in;

endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    // The following line will generate a warning that
    // the value of out will be x if in is x.
    assign out = in;

endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99], in[100], in[101], in[102], in[103], in[104], in[105], in[106], in[107], in[108], in[109], in[110], in[111], in[112], in[113], in[114], in[115], in[116], in[117], in[118], in[119], in[120], in[121], in[122], in[123], in[124], in[125], in[126], in[127], in[128], in[129], in[130], in[131], in[132], in[133], in[134], in[135], in[136], in[137], in[138], in[139], in[140], in[141], in[142], in[143], in[144], in[145], in[146], in[147], in[148], in[149], in[150], in[151], in[152], in[153], in[154], in[155], in[156], in[157], in[158], in[159], in[160], in[161], in[162], in[163], in[164], in[165], in[166], in[167], in[168], in[169], in[170], in[171], in[172], in[173], in[174], in[175], in[176], in[177], in[178], in[179], in[180], in[181], in[182], in[183], in[184], in[185], in[186], in[187], in[188], in[189], in[190], in[191], in[192], in[193], in[194], in[195], in[196], in[197], in[198], in[199], in[200], in[201], in[202], in[203], in[204], in[205], in[206], in[207], in[208], in[209], in[210], in[211], in[212], in[213], in[214], in[215], in[216], in[217], in[218], in[219], in[220], in[221], in[222], in[223], in[224], in[225], in[226], in[227], in[228], in[229], in[230], in[231], in[232], in[233], in[234], in[235], in[236], in[237], in[238], in[239], in[240], in[241], in[242], in[243], in[244], in[245], in[246], in[247], in[248], in[249], in[250], in[251], in[252], in[253], in",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99], in[100], in[101], in[102], in[103], in[104], in[105], in[106], in[107], in[108], in[109], in[110], in[111], in[112], in[113], in[114], in[115], in[116], in[117], in[118], in[119], in[120], in[121], in[122], in[123], in[124], in[125], in[126], in[127], in[128], in[129], in[130], in[131], in[132], in[133], in[134], in[135], in[136], in[137], in[138], in[139], in[140], in[141], in[142], in[143], in[144], in[145], in[146], in[147], in[148], in[149], in[150], in[151], in[152], in[153], in[154], in[155], in[156], in[157], in[158], in[159], in[160], in[161], in[162], in[163], in[164], in[165], in[166], in[167], in[168], in[169], in[170], in[171], in[172], in[173], in[174], in[175], in[176], in[177], in[178], in[179], in[180], in[181], in[182], in[183], in[184], in[185], in[186], in[187], in[188], in[189], in[190], in[191], in[192], in[193], in[194], in[195], in[196], in[197], in[198], in[199], in[200], in[201], in[202], in[203], in[204], in[205], in[206], in[207], in[208], in[209], in[210], in[211], in[212], in[213], in[214], in[215], in[216], in[217], in[218], in[219], in[220], in[221], in[222], in[223], in[224], in[225], in[226], in[227], in[228], in[229], in[230], in[231], in[232], in[233], in[234], in[235], in[236], in[237], in[238], in[239], in[240], in[241], in[242], in[243], in[244], in[245], in[246], in[247], in[248], in[249], in[250], in[251], in[252], in[253], in"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    // This could be done in one line with a for loop,
    // but it wouldn't work for some reason.
    // assign out = in;
    
    // Or, I could do this:
    // assign out = {in};
    
    // But this works:
    assign out = in[99:0];
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    // This could be done in one line with a for loop,
    // but it wouldn't work for some reason.
    // assign out = in;
    
    // Or, I could do this:
    // assign out = {in};
    
    // But this works:
    assign out = in[99:0];
    
endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99], in[100], in[101], in[102], in[103], in[104], in[105], in[106], in[107], in[108], in[109], in[110], in[111], in[112], in[113], in[114], in[115], in[116], in[117], in[118], in[119], in[120], in[121], in[122], in[123], in[124], in[125], in[126], in[127], in[128], in[129], in[130], in[131], in[132], in[133], in[134], in[135], in[136], in[137], in[138], in[139], in[140], in[141], in[142], in[143], in[144], in[145], in[146], in[147], in[148], in[149], in[150], in[151], in[152], in[153], in[154], in[155], in[156], in[157], in[158], in[159], in[160], in[161], in[162], in[163], in[164], in[165], in[166], in[167], in[168], in[169], in[170], in[171], in[172], in[173], in[174], in[175], in[176], in[177], in[178], in[179], in[180], in[181], in[182], in[183], in[184], in[185], in[186], in[187], in[188], in[189], in[190], in[191], in[192], in[193], in[194], in[195], in[196], in[197], in[198], in[199], in[200], in[201], in[202], in[203], in[204], in[205], in[206], in[207], in[208], in[209], in[210], in[211], in[212], in[213], in[214], in[215], in[216], in[217], in[218], in[219], in[220], in[221], in[222], in[223], in[224], in[225], in[226], in[227], in[228], in[229], in[230], in[231], in[232], in[233], in[234], in[235], in[236], in[237], in[238], in[239], in[240], in[241], in[242], in[243], in[244], in[245], in[246], in[247], in[248], in[249], in[250], in[251], in[252], in[253], in",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99], in[100], in[101], in[102], in[103], in[104], in[105], in[106], in[107], in[108], in[109], in[110], in[111], in[112], in[113], in[114], in[115], in[116], in[117], in[118], in[119], in[120], in[121], in[122], in[123], in[124], in[125], in[126], in[127], in[128], in[129], in[130], in[131], in[132], in[133], in[134], in[135], in[136], in[137], in[138], in[139], in[140], in[141], in[142], in[143], in[144], in[145], in[146], in[147], in[148], in[149], in[150], in[151], in[152], in[153], in[154], in[155], in[156], in[157], in[158], in[159], in[160], in[161], in[162], in[163], in[164], in[165], in[166], in[167], in[168], in[169], in[170], in[171], in[172], in[173], in[174], in[175], in[176], in[177], in[178], in[179], in[180], in[181], in[182], in[183], in[184], in[185], in[186], in[187], in[188], in[189], in[190], in[191], in[192], in[193], in[194], in[195], in[196], in[197], in[198], in[199], in[200], in[201], in[202], in[203], in[204], in[205], in[206], in[207], in[208], in[209], in[210], in[211], in[212], in[213], in[214], in[215], in[216], in[217], in[218], in[219], in[220], in[221], in[222], in[223], in[224], in[225], in[226], in[227], in[228], in[229], in[230], in[231], in[232], in[233], in[234], in[235], in[236], in[237], in[238], in[239], in[240], in[241], in[242], in[243], in[244], in[245], in[246], in[247], in[248], in[249], in[250], in[251], in[252], in[253], in"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99] };

endmodule",1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7], in[8], in[9], in[10], in[11], in[12], in[13], in[14], in[15], in[16], in[17], in[18], in[19], in[20], in[21], in[22], in[23], in[24], in[25], in[26], in[27], in[28], in[29], in[30], in[31], in[32], in[33], in[34], in[35], in[36], in[37], in[38], in[39], in[40], in[41], in[42], in[43], in[44], in[45], in[46], in[47], in[48], in[49], in[50], in[51], in[52], in[53], in[54], in[55], in[56], in[57], in[58], in[59], in[60], in[61], in[62], in[63], in[64], in[65], in[66], in[67], in[68], in[69], in[70], in[71], in[72], in[73], in[74], in[75], in[76], in[77], in[78], in[79], in[80], in[81], in[82], in[83], in[84], in[85], in[86], in[87], in[88], in[89], in[90], in[91], in[92], in[93], in[94], in[95], in[96], in[97], in[98], in[99] };

endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99:0], in[99:1] };
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99:0], in[99:1] };
    
endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99], in[0:98] };
    
endmodule",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99], in[0:98] };
    
endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99], in[0:98] };
    
endmodule",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99], in[0:98] };
    
endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99:0], in[99:1] };
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = { in[99:0], in[99:1] };
    
endmodule"
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[99:0], in[99:1] };

endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = { in[99:0], in[99:1] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = { in[7:0], in[15:8], in[23:16], in[31:24] };

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z} = {a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule",1,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    assign {w,x,y,z } = { a,b,c,d,e,f,2'b11};

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, {8{in[7]} }), in };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, {8{in[7]} }), in };
    assign out = { {24{in[7]}}, in };

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, in[7]), in };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, in[7]), in };
    assign out = { {24{in[7]}}, in };

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, {8{in[7]} }), in };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, {8{in[7]} }), in };
    assign out = { {24{in[7]}}, in };

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, {8{in[7]} }), in };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate(8, {8{in[7]} }), in };
    assign out = { {24{in[7]}}, in };

endmodule"
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };
    
endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };
    
endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    // assign out = {... } ^ {... };
    assign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};    
endmodule"
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = ~in;
endmodule",-0.5,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = ~in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = ~in;
endmodule",-0.5,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = ~in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
	assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
	assign out = in;
endmodule"
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
assign out = in;
endmodule","module top_module( input in, output out );
    assign out = in;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;

endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;

endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
    
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
    
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
    
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
    
endmodule"
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;

endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;

endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule"
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule"
