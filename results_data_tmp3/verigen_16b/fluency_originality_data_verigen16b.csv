Extracted Text,Reward,Prompt Name,Prompt Text,TrimmedModule,GoldenSolFull,,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",1,7420.v,"//The 7400-series integrated circuits are a series of digital chips with a few gates each. 
//The 7420 is a chip with two 4-input NAND gates.

// Create a module with the same functionality as the 7420 chip. It has 8 inputs and 2 outputs.

//Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a && p1b && p1c) || (p1d && p1e && p1f);
    assign p2y = (p2a && p2b) || (p2c && p2d);

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a && p1b && p1c) || (p1d && p1e && p1f);
    assign p2y = (p2a && p2b) || (p2c && p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = (p1a & p1b & p1c) | (p1d & p1e & p1f);
    assign p2y = (p2a & p2b) | (p2c & p2d);

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule",1,7458.v,"// The 7458 is a chip with four AND gates and two OR gates. 

// Create a module with the same functionality as the 7458 chip. 
// It has 10 inputs and 2 outputs. You may choose to use an assign statement 
// to drive each of the output wires, or you may choose to declare (four) wires 
// for use as intermediate signals, where each internal wire is driven by the 
// output of one of the AND gates. For extra practice, try it both ways.


// Hint: You need to drive two signals (p1y and p2y) with a value.

module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = p1a & p1b & p1c | p1d & p1e & p1f;
    assign p2y = p2a & p2b | p2c & p2d;

endmodule","module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    wire abc1, def1, ab2, cd2;
    assign abc1 = p1c & p1b & p1a;
    assign def1 = p1f & p1e & p1d;
    assign p1y = abc1 | def1;
    
    assign ab2 = p2a & p2b;
    assign cd2 = p2c & p2d;
    assign p2y = ab2 | cd2;
    
endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    bcd_fadd inst1 (a[3:0], b[3:0], cin, cout_temp[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], cout_temp[2], cout_temp[3], sum[15:12]);
    bcd_fadd inst5 (a[19:16], b[19:16], cout_temp[3], cout_temp[4], sum[19:16]);
    bcd_fadd inst6 (a[23:20], b[23:20], cout_temp[4], cout_temp[5], sum[23:20]);
    bcd_fadd inst7 (a[27:24], b[27:24], cout_temp[5], cout_temp[6], sum[27:24]);
    bcd_fadd inst8 (a[31:28], b[31:28], cout_temp[6], cout_temp[7], sum[31:28]);
    bcd_fadd inst9 (a[35:32], b[35:32], cout_temp[7], cout_temp[8], sum[35:32]);
    bcd_fadd inst10 (a[39:36], b[39:36], cout_temp[8], cout_temp[9], sum[39:36]);
    bcd_fadd inst11 (a[43:40], b[43:40], cout_temp[9], cout_temp[10], sum[43:40]);
    bcd_fadd inst12 (a[47:44], b[47:44], cout_temp[10], cout_temp[11], sum[47:44]);
    bcd_fadd inst13 (a[51:48], b[51:48], cout_temp[11], cout_temp[12], sum[51:48]);
    bcd_fadd inst14 (a[55:52], b[55:52], cout_temp[12], cout_temp[13], sum[55:52]);
    bcd_fadd inst15 (a[59:56], b[59:56], cout_temp[13], cout_temp[14], sum[59:56]);
    bcd_fadd inst16 (a[63:60], b[63:60], cout_temp[14], cout_temp[15], sum[63:60]);
    bcd_fadd inst17 (a[67:64], b[67:64], cout_temp[15], cout_temp[16], sum[67:64]);
    bcd_fadd inst18 (a[71:68], b[71:68], cout_temp[16], cout_temp[17], sum[71:68]);
    bcd_fadd inst19 (a[75:72], b[75:72], cout_temp[17], cout_temp[18], sum[75:72]);
    bcd_fadd inst20 (a[79:76], b[79:76], cout_temp[18], cout_temp[19], sum[79:76]);
    bcd_fadd inst21 (a[83:80], b[83:80], cout_temp[19], cout_temp[20], sum[83:80]);
    bcd_fadd inst22 (a[87:84], b[87:84], cout_temp[20], cout_temp[21], sum[87:84]);
    bcd_fadd inst23 (a[91:88], b[91:88], cout_temp[21], cout_temp[22], sum[91:88]);
    bcd_fadd inst24 (a[95:92], b[95:92], cout_temp[22], cout_temp[23], sum[95:92]);
    bcd_fadd inst25 (a[99:96], b[99:96], cout_temp[23], cout_temp[24], sum[99:96]);
    bcd_fadd inst26 (cout_temp[",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    bcd_fadd inst1 (a[3:0], b[3:0], cin, cout_temp[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], cout_temp[2], cout_temp[3], sum[15:12]);
    bcd_fadd inst5 (a[19:16], b[19:16], cout_temp[3], cout_temp[4], sum[19:16]);
    bcd_fadd inst6 (a[23:20], b[23:20], cout_temp[4], cout_temp[5], sum[23:20]);
    bcd_fadd inst7 (a[27:24], b[27:24], cout_temp[5], cout_temp[6], sum[27:24]);
    bcd_fadd inst8 (a[31:28], b[31:28], cout_temp[6], cout_temp[7], sum[31:28]);
    bcd_fadd inst9 (a[35:32], b[35:32], cout_temp[7], cout_temp[8], sum[35:32]);
    bcd_fadd inst10 (a[39:36], b[39:36], cout_temp[8], cout_temp[9], sum[39:36]);
    bcd_fadd inst11 (a[43:40], b[43:40], cout_temp[9], cout_temp[10], sum[43:40]);
    bcd_fadd inst12 (a[47:44], b[47:44], cout_temp[10], cout_temp[11], sum[47:44]);
    bcd_fadd inst13 (a[51:48], b[51:48], cout_temp[11], cout_temp[12], sum[51:48]);
    bcd_fadd inst14 (a[55:52], b[55:52], cout_temp[12], cout_temp[13], sum[55:52]);
    bcd_fadd inst15 (a[59:56], b[59:56], cout_temp[13], cout_temp[14], sum[59:56]);
    bcd_fadd inst16 (a[63:60], b[63:60], cout_temp[14], cout_temp[15], sum[63:60]);
    bcd_fadd inst17 (a[67:64], b[67:64], cout_temp[15], cout_temp[16], sum[67:64]);
    bcd_fadd inst18 (a[71:68], b[71:68], cout_temp[16], cout_temp[17], sum[71:68]);
    bcd_fadd inst19 (a[75:72], b[75:72], cout_temp[17], cout_temp[18], sum[75:72]);
    bcd_fadd inst20 (a[79:76], b[79:76], cout_temp[18], cout_temp[19], sum[79:76]);
    bcd_fadd inst21 (a[83:80], b[83:80], cout_temp[19], cout_temp[20], sum[83:80]);
    bcd_fadd inst22 (a[87:84], b[87:84], cout_temp[20], cout_temp[21], sum[87:84]);
    bcd_fadd inst23 (a[91:88], b[91:88], cout_temp[21], cout_temp[22], sum[91:88]);
    bcd_fadd inst24 (a[95:92], b[95:92], cout_temp[22], cout_temp[23], sum[95:92]);
    bcd_fadd inst25 (a[99:96], b[99:96], cout_temp[23], cout_temp[24], sum[99:96]);
    bcd_fadd inst26 (cout_temp[","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    assign cout = cin;
    assign sum = a + b;

endmodule",-0.5,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    assign cout = cin;
    assign sum = a + b;

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    assign cout = (a[99] == b[99])? cin : 0;
    assign sum = cout;

endmodule",-0.5,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    assign cout = (a[99] == b[99])? cin : 0;
    assign sum = cout;

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    bcd_fadd inst1 (a[3:0], b[3:0], cin, cout_temp[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], cout_temp[2], cout_temp[3], sum[15:12]);
    bcd_fadd inst5 (a[19:16], b[19:16], cout_temp[3], cout_temp[4], sum[19:16]);
    bcd_fadd inst6 (a[23:20], b[23:20], cout_temp[4], cout_temp[5], sum[23:20]);
    bcd_fadd inst7 (a[27:24], b[27:24], cout_temp[5], cout_temp[6], sum[27:24]);
    bcd_fadd inst8 (a[31:28], b[31:28], cout_temp[6], cout_temp[7], sum[31:28]);
    bcd_fadd inst9 (a[35:32], b[35:32], cout_temp[7], cout_temp[8], sum[35:32]);
    bcd_fadd inst10 (a[39:36], b[39:36], cout_temp[8], cout_temp[9], sum[39:36]);
    bcd_fadd inst11 (a[43:40], b[43:40], cout_temp[9], cout_temp[10], sum[43:40]);
    bcd_fadd inst12 (a[47:44], b[47:44], cout_temp[10], cout_temp[11], sum[47:44]);
    bcd_fadd inst13 (a[51:48], b[51:48], cout_temp[11], cout_temp[12], sum[51:48]);
    bcd_fadd inst14 (a[55:52], b[55:52], cout_temp[12], cout_temp[13], sum[55:52]);
    bcd_fadd inst15 (a[59:56], b[59:56], cout_temp[13], cout_temp[14], sum[59:56]);
    bcd_fadd inst16 (a[63:60], b[63:60], cout_temp[14], cout_temp[15], sum[63:60]);
    bcd_fadd inst17 (a[67:64], b[67:64], cout_temp[15], cout_temp[16], sum[67:64]);
    bcd_fadd inst18 (a[71:68], b[71:68], cout_temp[16], cout_temp[17], sum[71:68]);
    bcd_fadd inst19 (a[75:72], b[75:72], cout_temp[17], cout_temp[18], sum[75:72]);
    bcd_fadd inst20 (a[79:76], b[79:76], cout_temp[18], cout_temp[19], sum[79:76]);
    bcd_fadd inst21 (a[83:80], b[83:80], cout_temp[19], cout_temp[20], sum[83:80]);
    bcd_fadd inst22 (a[87:84], b[87:84], cout_temp[20], cout_temp[21], sum[87:84]);
    bcd_fadd inst23 (a[91:88], b[91:88], cout_temp[21], cout_temp[22], sum[91:88]);
    bcd_fadd inst24 (a[95:92], b[95:92], cout_temp[22], cout_temp[23], sum[95:92]);
    bcd_fadd inst25 (a[99:96], b[99:96], cout_temp[23], cout_temp[24], sum[99:96]);
    
    assign cout = cout_temp[24",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    bcd_fadd inst1 (a[3:0], b[3:0], cin, cout_temp[0], sum[3:0]);
    bcd_fadd inst2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum[7:4]);
    bcd_fadd inst3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum[11:8]);
    bcd_fadd inst4 (a[15:12], b[15:12], cout_temp[2], cout_temp[3], sum[15:12]);
    bcd_fadd inst5 (a[19:16], b[19:16], cout_temp[3], cout_temp[4], sum[19:16]);
    bcd_fadd inst6 (a[23:20], b[23:20], cout_temp[4], cout_temp[5], sum[23:20]);
    bcd_fadd inst7 (a[27:24], b[27:24], cout_temp[5], cout_temp[6], sum[27:24]);
    bcd_fadd inst8 (a[31:28], b[31:28], cout_temp[6], cout_temp[7], sum[31:28]);
    bcd_fadd inst9 (a[35:32], b[35:32], cout_temp[7], cout_temp[8], sum[35:32]);
    bcd_fadd inst10 (a[39:36], b[39:36], cout_temp[8], cout_temp[9], sum[39:36]);
    bcd_fadd inst11 (a[43:40], b[43:40], cout_temp[9], cout_temp[10], sum[43:40]);
    bcd_fadd inst12 (a[47:44], b[47:44], cout_temp[10], cout_temp[11], sum[47:44]);
    bcd_fadd inst13 (a[51:48], b[51:48], cout_temp[11], cout_temp[12], sum[51:48]);
    bcd_fadd inst14 (a[55:52], b[55:52], cout_temp[12], cout_temp[13], sum[55:52]);
    bcd_fadd inst15 (a[59:56], b[59:56], cout_temp[13], cout_temp[14], sum[59:56]);
    bcd_fadd inst16 (a[63:60], b[63:60], cout_temp[14], cout_temp[15], sum[63:60]);
    bcd_fadd inst17 (a[67:64], b[67:64], cout_temp[15], cout_temp[16], sum[67:64]);
    bcd_fadd inst18 (a[71:68], b[71:68], cout_temp[16], cout_temp[17], sum[71:68]);
    bcd_fadd inst19 (a[75:72], b[75:72], cout_temp[17], cout_temp[18], sum[75:72]);
    bcd_fadd inst20 (a[79:76], b[79:76], cout_temp[18], cout_temp[19], sum[79:76]);
    bcd_fadd inst21 (a[83:80], b[83:80], cout_temp[19], cout_temp[20], sum[83:80]);
    bcd_fadd inst22 (a[87:84], b[87:84], cout_temp[20], cout_temp[21], sum[87:84]);
    bcd_fadd inst23 (a[91:88], b[91:88], cout_temp[21], cout_temp[22], sum[91:88]);
    bcd_fadd inst24 (a[95:92], b[95:92], cout_temp[22], cout_temp[23], sum[95:92]);
    bcd_fadd inst25 (a[99:96], b[99:96], cout_temp[23], cout_temp[24], sum[99:96]);
    
    assign cout = cout_temp[24","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_temp;
    
    assign cout = cout_temp[99];
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1) begin
            full_adder FA1(a[i],b[i],cin,cout_temp[i],sum[i]);
        end
    endgenerate
    
endmodule",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_temp;
    
    assign cout = cout_temp[99];
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1) begin
            full_adder FA1(a[i],b[i],cin,cout_temp[i],sum[i]);
        end
    endgenerate
    
endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    assign {cout, sum} = a + b + cin;

endmodule",1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    assign {cout, sum} = a + b + cin;

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    // assign sum[0] = cin
    // assign cout = sum[99]
    
    // full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(c1) );
    // full_adder FA2(.a(a[1]),.b(b[1]),.cin(c1),.sum(sum[1]),.cout(c2) );
    // full_adder FA3(.a(a[2]),.b(b[2]),.cin(c2),.sum(sum[2]),.cout(c3) );
    // full_adder FA4(.a(a[3]),.b(b[3]),.cin(c3),.sum(sum[3]),.cout(c4) );
    // full_adder FA5(.a(a[4]),.b(b[4]),.cin(c4),.sum(sum[4]),.cout(c5) );
    // full_adder FA6(.a(a[5]),.b(b[5]),.cin(c5),.sum(sum[5]),.cout(c6) );
    // full_adder FA7(.a(a[6]),.b(b[6]),.cin(c6),.sum(sum[6]),.cout(c7) );
    // full_adder FA8(.a(a[7]),.b(b[7]),.cin(c7),.sum(sum[7]),.cout(c8) );
    // full_adder FA9(.a(a[8]),.b(b[8]),.cin(c8),.sum(sum[8]),.cout(c9) );
    // full_adder FA10(.a(a[9]),.b(b[9]),.cin(c9),.sum(sum[9]),.cout(c10) );
    // full_adder FA11(.a(a[10]),.b(b[10]),.cin(c10),.sum(sum[10]),.cout(c11) );
    // full_adder FA12(.a(a[11]),.b(b[11]),.cin(c11),.sum(sum[11]),.cout(c12) );
    // full_adder FA13(.a(a[12]),.b(b[12]),.cin(c12),.sum(sum[12]),.cout(c13) );
    // full_adder FA14(.a(a[13]),.b(b[13]),.cin(c13),.sum(sum[13]),.cout(c14) );
    // full_adder FA15(.a(a[14]),.b(b[14]),.cin(c14),.sum(sum[14]),.cout(c15) );
    // full_adder FA16(.a(a[15]),.b(b[15]),.cin(c15),.sum(sum[15]),.cout(c16) );
    // full_adder FA17(.a(a[16]),.b(b[16]),.cin(c16),.sum(sum[16]),.cout(c17) );
    // full_adder FA18(.a(a[17]),.b(b[17]),.cin(c17),.sum(sum[17]),.cout(c18) );
    // full_adder FA19(.a(a[18]),.b(b[18]),.cin(c18),.sum(sum[18]),.cout(c19) );
    // full_adder FA20(.a(a[19]),.b(b[19]),.cin(c19),.sum(sum[19]),.cout(c20) );
    // full_adder FA21(.a(a[20]),.b(b[20]),.cin(c20),.sum(sum[20]),.cout(c21) );
    // full_adder FA22(.a(a[21]),.b(b[21]),.cin(c21),.sum(sum[21]),.cout(c22) );
    // full_adder FA23(.a(a[22]),.b(b[22]),.cin(c22),.sum(",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    // assign sum[0] = cin
    // assign cout = sum[99]
    
    // full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(c1) );
    // full_adder FA2(.a(a[1]),.b(b[1]),.cin(c1),.sum(sum[1]),.cout(c2) );
    // full_adder FA3(.a(a[2]),.b(b[2]),.cin(c2),.sum(sum[2]),.cout(c3) );
    // full_adder FA4(.a(a[3]),.b(b[3]),.cin(c3),.sum(sum[3]),.cout(c4) );
    // full_adder FA5(.a(a[4]),.b(b[4]),.cin(c4),.sum(sum[4]),.cout(c5) );
    // full_adder FA6(.a(a[5]),.b(b[5]),.cin(c5),.sum(sum[5]),.cout(c6) );
    // full_adder FA7(.a(a[6]),.b(b[6]),.cin(c6),.sum(sum[6]),.cout(c7) );
    // full_adder FA8(.a(a[7]),.b(b[7]),.cin(c7),.sum(sum[7]),.cout(c8) );
    // full_adder FA9(.a(a[8]),.b(b[8]),.cin(c8),.sum(sum[8]),.cout(c9) );
    // full_adder FA10(.a(a[9]),.b(b[9]),.cin(c9),.sum(sum[9]),.cout(c10) );
    // full_adder FA11(.a(a[10]),.b(b[10]),.cin(c10),.sum(sum[10]),.cout(c11) );
    // full_adder FA12(.a(a[11]),.b(b[11]),.cin(c11),.sum(sum[11]),.cout(c12) );
    // full_adder FA13(.a(a[12]),.b(b[12]),.cin(c12),.sum(sum[12]),.cout(c13) );
    // full_adder FA14(.a(a[13]),.b(b[13]),.cin(c13),.sum(sum[13]),.cout(c14) );
    // full_adder FA15(.a(a[14]),.b(b[14]),.cin(c14),.sum(sum[14]),.cout(c15) );
    // full_adder FA16(.a(a[15]),.b(b[15]),.cin(c15),.sum(sum[15]),.cout(c16) );
    // full_adder FA17(.a(a[16]),.b(b[16]),.cin(c16),.sum(sum[16]),.cout(c17) );
    // full_adder FA18(.a(a[17]),.b(b[17]),.cin(c17),.sum(sum[17]),.cout(c18) );
    // full_adder FA19(.a(a[18]),.b(b[18]),.cin(c18),.sum(sum[18]),.cout(c19) );
    // full_adder FA20(.a(a[19]),.b(b[19]),.cin(c19),.sum(sum[19]),.cout(c20) );
    // full_adder FA21(.a(a[20]),.b(b[20]),.cin(c20),.sum(sum[20]),.cout(c21) );
    // full_adder FA22(.a(a[21]),.b(b[21]),.cin(c21),.sum(sum[21]),.cout(c22) );
    // full_adder FA23(.a(a[22]),.b(b[22]),.cin(c22),.sum(","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [98:0] intermediate_sum;
    
    assign intermediate_sum[0] = cin;
    
    genvar i;
    generate
        for(i=0; i<100; i=i+1)
            full_adder FA(a[i], b[i], intermediate_sum[i], intermediate_sum[i+1], sum[i]);
    endgenerate
    
    assign cout = intermediate_sum[98];

endmodule",-1,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [98:0] intermediate_sum;
    
    assign intermediate_sum[0] = cin;
    
    genvar i;
    generate
        for(i=0; i<100; i=i+1)
            full_adder FA(a[i], b[i], intermediate_sum[i], intermediate_sum[i+1], sum[i]);
    endgenerate
    
    assign cout = intermediate_sum[98];

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [98:0] intermediate_sum;
    assign intermediate_sum = a + b + cin;
    assign sum = intermediate_sum[98:0];
    assign cout = intermediate_sum[99];

endmodule",-0.5,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [98:0] intermediate_sum;
    assign intermediate_sum = a + b + cin;
    assign sum = intermediate_sum[98:0];
    assign cout = intermediate_sum[99];

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [98:0] intermediate_sum;
    
    assign intermediate_sum = a + b;
    assign sum = intermediate_sum[99:1] + cin;
    assign cout = intermediate_sum[98];

endmodule",-0.5,Adder100.v,"// Create a 100-bit binary adder. The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out.

// Hint: There are too many full adders to instantiate, but behavioural code works in this case.

module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );

    wire [98:0] intermediate_sum;
    
    assign intermediate_sum = a + b;
    assign sum = intermediate_sum[99:1] + cin;
    assign cout = intermediate_sum[98];

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum );
    
    wire [99:0] cout_tmp;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout_tmp[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    integer i;
    always @(*) begin
        for(i = 1; i < 100; i = i + 1) begin
            sum[i] = a[i] ^ b[i] ^ cout_tmp[i-1];
            cout_tmp[i] = a[i] & b[i] | a[i] & cout_tmp[i-1] | b[i] & cout_tmp[i-1];
        end
        cout = cout_tmp[99];
    end

endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [98:0] c;
    assign c[0] = cin;
    assign cout[0] = c[1];
    assign sum[0] = a[0] ^ b[0] ^ c[0];
    
    genvar i;
    generate
        for(i=1;i<100;i=i+1) begin
            full_adder fa(a[i],b[i],c[i-1],sum[i],c[i]);
        end
    endgenerate
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [98:0] c;
    assign c[0] = cin;
    assign cout[0] = c[1];
    assign sum[0] = a[0] ^ b[0] ^ c[0];
    
    genvar i;
    generate
        for(i=1;i<100;i=i+1) begin
            full_adder fa(a[i],b[i],c[i-1],sum[i],c[i]);
        end
    endgenerate
    
endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    // assign cout[0] = cin;
    
    // instantiate full adder
    
    // assign sum[0] = cin;
    
    // assign sum[1] = a[0] ^ b[0] ^ cin;
    
    // instantiate full adder
    
    // assign sum[2] = a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin);
    
    // instantiate full adder
    
    // assign sum[3] = a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin));
    
    // instantiate full adder
    
    // assign sum[4] = a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)));
    
    // instantiate full adder
    
    // assign sum[5] = a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))));
    
    // instantiate full adder
    
    // assign sum[6] = a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)))));
    
    // instantiate full adder
    
    // assign sum[7] = a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)))));
    
    // instantiate full adder
    
    // assign sum[8] = a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))))));
    
    // instantiate full adder
    
    // assign sum[9] = a[8] ^ b[8] ^ (a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)))))));
    
    // instantiate full adder
    
    // assign sum[10] = a[9] ^ b[9] ^ (a[8] ^ b[8] ^ (a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))))))));
    
    // instantiate full adder
    
    // assign sum[11] = a[10] ^ b[10] ^ (a[9] ^ b[9] ^ (a[8] ^ b[8] ^ (a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))))))));
    
    // instant",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    // assign cout[0] = cin;
    
    // instantiate full adder
    
    // assign sum[0] = cin;
    
    // assign sum[1] = a[0] ^ b[0] ^ cin;
    
    // instantiate full adder
    
    // assign sum[2] = a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin);
    
    // instantiate full adder
    
    // assign sum[3] = a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin));
    
    // instantiate full adder
    
    // assign sum[4] = a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)));
    
    // instantiate full adder
    
    // assign sum[5] = a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))));
    
    // instantiate full adder
    
    // assign sum[6] = a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)))));
    
    // instantiate full adder
    
    // assign sum[7] = a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)))));
    
    // instantiate full adder
    
    // assign sum[8] = a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))))));
    
    // instantiate full adder
    
    // assign sum[9] = a[8] ^ b[8] ^ (a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin)))))));
    
    // instantiate full adder
    
    // assign sum[10] = a[9] ^ b[9] ^ (a[8] ^ b[8] ^ (a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))))))));
    
    // instantiate full adder
    
    // assign sum[11] = a[10] ^ b[10] ^ (a[9] ^ b[9] ^ (a[8] ^ b[8] ^ (a[7] ^ b[7] ^ (a[6] ^ b[6] ^ (a[5] ^ b[5] ^ (a[4] ^ b[4] ^ (a[3] ^ b[3] ^ (a[2] ^ b[2] ^ (a[1] ^ b[1] ^ (a[0] ^ b[0] ^ cin))))))));
    
    // instant","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1) begin
            full_adder FA1(a[i],b[i],cin,cout_temp[i],sum[i]);
        end
    endgenerate
    assign cout = cout_temp[99];

endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1) begin
            full_adder FA1(a[i],b[i],cin,cout_temp[i],sum[i]);
        end
    endgenerate
    assign cout = cout_temp[99];

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    genvar i;
    generate
        for(i=0;i<100;i=i+1)
            full_adder FA(a[i],b[i],cin,cout[i],sum[i]);
    endgenerate
    assign cout[100] = 1'b0;
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    genvar i;
    generate
        for(i=0;i<100;i=i+1)
            full_adder FA(a[i],b[i],cin,cout[i],sum[i]);
    endgenerate
    assign cout[100] = 1'b0;
    
endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    // assign cout[0] = cin;
    // assign sum[0] = a[0] ^ b[0] ^ cin;
    // assign cout[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);
    // assign sum[1] = a[1] ^ b[1] ^ cout[0];
    
    //assign cout[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);
    //assign sum[1] = a[1] ^ b[1] ^ cout[0];
    
    //assign cout[2] = (a[1] & b[1]) | (a[1] & cout[0]) | (b[1] & cout[0]);
    //assign sum[2] = a[2] ^ b[2] ^ cout[1];
    
    //assign cout[3] = (a[2] & b[2]) | (a[2] & cout[1]) | (b[2] & cout[1]);
    //assign sum[3] = a[3] ^ b[3] ^ cout[2];
    
    //assign cout[4] = (a[3] & b[3]) | (a[3] & cout[2]) | (b[3] & cout[2]);
    //assign sum[4] = a[4] ^ b[4] ^ cout[3];
    
    //assign cout[5] = (a[4] & b[4]) | (a[4] & cout[3]) | (b[4] & cout[3]);
    //assign sum[5] = a[5] ^ b[5] ^ cout[4];
    
    //assign cout[6] = (a[5] & b[5]) | (a[5] & cout[4]) | (b[5] & cout[4]);
    //assign sum[6] = a[6] ^ b[6] ^ cout[5];
    
    //assign cout[7] = (a[6] & b[6]) | (a[6] & cout[5]) | (b[6] & cout[5]);
    //assign sum[7] = a[7] ^ b[7] ^ cout[6];
    
    //assign cout[8] = (a[7] & b[7]) | (a[7] & cout[6]) | (b[7] & cout[6]);
    //assign sum[8] = a[8] ^ b[8] ^ cout[7];
    
    //assign cout[9] = (a[8] & b[8]) | (a[8] & cout[7]) | (b[8] & cout[7]);
    //assign sum[9] = a[9] ^ b[9] ^ cout[8];
    
    //assign cout[10] = (a[9] & b[9]) | (a[9] & cout[8]) | (b[9] & cout[8]);
    //assign sum[10] = a[10] ^ b[10] ^ cout[9];
    
    //assign cout[11] = (a[10] & b[10]) | (a[10] & cout[9]) | (b[10] & cout[9]);
    //assign sum[11] = a[11] ^ b[11] ^ cout[10];
    
    //assign cout[12] = (a[11] & b[11]) | (a[11] & cout[10]) | (b[11] & cout[10]);
    //assign sum[12] = a[12] ^ b[12] ^ cout[11];
    
    //assign cout[13] = (a[12] & b[12]) | (a[12] & cout[11]) | (b[12] & cout[11]);
    //assign sum[13] = a[13] ^ b[13] ^ cout[12];
    
    //assign cout[14] = (a[13] & b[13]) | (a[13] & cout[12]) | (b[13] & cout[12]);",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    // assign cout[0] = cin;
    // assign sum[0] = a[0] ^ b[0] ^ cin;
    // assign cout[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);
    // assign sum[1] = a[1] ^ b[1] ^ cout[0];
    
    //assign cout[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);
    //assign sum[1] = a[1] ^ b[1] ^ cout[0];
    
    //assign cout[2] = (a[1] & b[1]) | (a[1] & cout[0]) | (b[1] & cout[0]);
    //assign sum[2] = a[2] ^ b[2] ^ cout[1];
    
    //assign cout[3] = (a[2] & b[2]) | (a[2] & cout[1]) | (b[2] & cout[1]);
    //assign sum[3] = a[3] ^ b[3] ^ cout[2];
    
    //assign cout[4] = (a[3] & b[3]) | (a[3] & cout[2]) | (b[3] & cout[2]);
    //assign sum[4] = a[4] ^ b[4] ^ cout[3];
    
    //assign cout[5] = (a[4] & b[4]) | (a[4] & cout[3]) | (b[4] & cout[3]);
    //assign sum[5] = a[5] ^ b[5] ^ cout[4];
    
    //assign cout[6] = (a[5] & b[5]) | (a[5] & cout[4]) | (b[5] & cout[4]);
    //assign sum[6] = a[6] ^ b[6] ^ cout[5];
    
    //assign cout[7] = (a[6] & b[6]) | (a[6] & cout[5]) | (b[6] & cout[5]);
    //assign sum[7] = a[7] ^ b[7] ^ cout[6];
    
    //assign cout[8] = (a[7] & b[7]) | (a[7] & cout[6]) | (b[7] & cout[6]);
    //assign sum[8] = a[8] ^ b[8] ^ cout[7];
    
    //assign cout[9] = (a[8] & b[8]) | (a[8] & cout[7]) | (b[8] & cout[7]);
    //assign sum[9] = a[9] ^ b[9] ^ cout[8];
    
    //assign cout[10] = (a[9] & b[9]) | (a[9] & cout[8]) | (b[9] & cout[8]);
    //assign sum[10] = a[10] ^ b[10] ^ cout[9];
    
    //assign cout[11] = (a[10] & b[10]) | (a[10] & cout[9]) | (b[10] & cout[9]);
    //assign sum[11] = a[11] ^ b[11] ^ cout[10];
    
    //assign cout[12] = (a[11] & b[11]) | (a[11] & cout[10]) | (b[11] & cout[10]);
    //assign sum[12] = a[12] ^ b[12] ^ cout[11];
    
    //assign cout[13] = (a[12] & b[12]) | (a[12] & cout[11]) | (b[12] & cout[11]);
    //assign sum[13] = a[13] ^ b[13] ^ cout[12];
    
    //assign cout[14] = (a[13] & b[13]) | (a[13] & cout[12]) | (b[13] & cout[12]);","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    assign {cout[99], sum[99]} = a[99] + b[99] + cin;
    
    genvar i;
    generate
        for(i=0; i<98; i=i+1) begin
            full_adder FA1(a[i], b[i], cin, sum[i], cout[i+1]);
        end
    endgenerate
    
endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    assign {cout[99], sum[99]} = a[99] + b[99] + cin;
    
    genvar i;
    generate
        for(i=0; i<98; i=i+1) begin
            full_adder FA1(a[i], b[i], cin, sum[i], cout[i+1]);
        end
    endgenerate
    
endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    assign {cout[99], sum[99]} = a[99] + b[99] + cin;
    
    genvar i;
    generate
        for(i=0; i<98; i=i+1) begin: adder
            full_adder FA1(a[i], b[i], cin, sum[i], cout[i+1]);
        end
    endgenerate

endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    assign {cout[99], sum[99]} = a[99] + b[99] + cin;
    
    genvar i;
    generate
        for(i=0; i<98; i=i+1) begin: adder
            full_adder FA1(a[i], b[i], cin, sum[i], cout[i+1]);
        end
    endgenerate

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1)
            full_adder FA1(a[i],b[i],cin,sum[i],cout_temp[i]);
    endgenerate
    
    assign cout = cout_temp[99];

endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1)
            full_adder FA1(a[i],b[i],cin,sum[i],cout_temp[i]);
    endgenerate
    
    assign cout = cout_temp[99];

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    genvar i;
    generate
        for(i=0;i<100;i=i+1)
            full_adder FA(a[i],b[i],cin,sum[i],cout[i]);
    endgenerate

endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    genvar i;
    generate
        for(i=0;i<100;i=i+1)
            full_adder FA(a[i],b[i],cin,sum[i],cout[i]);
    endgenerate

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1) begin
            full_adder FA1(a[i],b[i],cin,sum[i],cout_temp[i]);
        end
    endgenerate
    assign cout = cout_temp[99];

endmodule",-1,Adder100i.v,"// Create a 100-bit binary ripple-carry adder by instantiating 100 full adders. 
// The adder adds two 100-bit numbers and a carry-in to produce a 100-bit sum and carry out. 
// To encourage you to actually instantiate full adders, 
// also output the carry-out from each full adder in the ripple-carry adder. 
// cout[99] is the final carry-out from the last full adder, and is the carry-out you usually see.

// Hint: There are many full adders to instantiate. An instance array or generate statement would help here.

module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    wire [99:0] cout_temp;
    
    genvar i;
    generate
        for(i=0;i<100;i=i+1) begin
            full_adder FA1(a[i],b[i],cin,sum[i],cout_temp[i]);
        end
    endgenerate
    assign cout = cout_temp[99];

endmodule","module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );
    
    always @(*) begin
        for(int i = 0; i < 100; i++) begin
            if(!i) begin  // 加法刚开始，所以进位标志用cin
                if(!cin) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
            else begin // 加法已经开始，所以进位标志用cout[i - 1]
                if(!cout[i - 1]) begin // 第一种情况，无进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 0;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                end
                else begin // 第二种情况，进位
                    if(a[i] == 0 && b[i] == 0) begin
                        sum[i] = 1;
                        cout[i] = 0;
                    end
                    else if((a[i] == 0 && b[i] == 1) || (a[i] == 1 && b[i] == 0)) begin
                        sum[i] = 0;
                        cout[i] = 1;
                    end
                    else begin
                        sum[i] = 1;
                        cout[i] = 1;
                    end
                end
            end
        end
    end

    // M-HHH 提供的精简思路
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i, j;
    
    // always @ (*)
    //     begin
    //         for (i=1; i<100; i++)    
    //             begin
    //                 sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //             end
    //     end
    
    // always @ (*)
    //     begin
    //         for(i=1; i<100; i++)
    //             begin
    //                 cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];  
    //             end
    //     end

    //基于 M-HHH 的思路作出的二次优化
    // assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    // assign sum[0]  = a[0] ^ b[0] ^ cin;
    
    // integer i;
    
    // always @ (*) begin
    //     for (i=1; i<100; i++) begin
    //             cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
    //             sum[i]  = a[i] ^ b[i] ^ cout[i-1];
    //     end
    // end


endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1 (a[0], b[0], cin, sum[0], cout[0]);
    full_adder FA2 (a[1], b[1], cout[0], sum[1], cout[1]);
    full_adder FA3 (a[2], b[2], cout[1], sum[2], cout[2]);

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1 (a[0], b[0], cin, sum[0], cout[0]);
    full_adder FA2 (a[1], b[1], cout[0], sum[1], cout[1]);
    full_adder FA3 (a[2], b[2], cout[1], sum[2], cout[2]);

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign sum = a ^ b ^ cin;
    // assign cout = a & b | a & cin | b & cin;
    
    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    // assign sum = a ^ b ^ cin;
    // assign cout = a & b | a & cin | b & cin;
    
    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]));
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]));
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]));

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1 (a[0], b[0], cin, cout[0], sum[0]);
    full_adder FA2 (a[1], b[1], cout[0], cout[1], sum[1]);
    full_adder FA3 (a[2], b[2], cout[1], cout[2], sum[2]);

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1 (a[0], b[0], cin, cout[0], sum[0]);
    full_adder FA2 (a[1], b[1], cout[0], cout[1], sum[1]);
    full_adder FA3 (a[2], b[2], cout[1], cout[2], sum[2]);

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]) );
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]) );
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]) );

endmodule",-1,Adder3.v,"// Make 3 instances of full-adder to create a 3-bit binary ripple-carry adder. 
// The adder adds two 3-bit numbers and a carry-in to produce a 3-bit sum and carry out. 
// To encourage you to actually instantiate full adders, also output the carry-out from 
// each full adder in the ripple-carry adder. cout[2] is the final carry-out from the last 
// full adder, and is the carry-out you usually see.

module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    full_adder FA1(.a(a[0]),.b(b[0]),.cin(cin),.sum(sum[0]),.cout(cout[0]) );
    full_adder FA2(.a(a[1]),.b(b[1]),.cin(cout[0]),.sum(sum[1]),.cout(cout[1]) );
    full_adder FA3(.a(a[2]),.b(b[2]),.cin(cout[1]),.sum(sum[2]),.cout(cout[2]) );

endmodule","module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );
    
    integer i;
    assign sum[0] = a[0] ^ b[0] ^ cin;
    assign cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;
    always @(*) begin
        for(i = 1; i < 3; i=i+1) begin
            sum[i] = a[i] ^ b[i] ^ cout[i-1];
            cout[i] = a[i] & b[i] | a[i] & cout[i-1] | b[i] & cout[i-1];
        end
    end

endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
    
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
    
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule",1,Alwaysblock1.v,"//Build an AND gate using both an assign statement and a combinational always block. 

// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
","module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
    assign out_assign = a & b;
    always @(*) begin
        out_alwaysblock = a & b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);

    assign out_assign = a & b;
    always @(*) out_alwaysblock = a & b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff <= a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff <= a ^ b;

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*)
        out_always_comb = a ^ b;
    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   ); 

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end
endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   ); 

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   ); 

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end
    
endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   ); 

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end
    
endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   ); 

    assign out_assign = a ^ b;

    always @(*)
        out_always_comb = a ^ b;

    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   ); 

    assign out_assign = a ^ b;

    always @(*)
        out_always_comb = a ^ b;

    always @(posedge clk)
        out_always_ff = a ^ b;

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule",-0.5,Alwaysblock2.v,"// Build an XOR gate three ways, using an assign statement, a combinational always block, and a clocked always block.

// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );","module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) begin
        out_always_comb = a ^ b;
    end
    always @(posedge clk) begin
        out_always_ff = a ^ b;
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );

    assign out_assign = a ^ b;
    always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
    
endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'd0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'd0;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
    
endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'd0: out = data0;
            3'd1: out = data1;
            3'd2: out = data2;
            3'd3: out = data3;
            3'd4: out = data4;
            3'd5: out = data5;
            default: out = 4'b0;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 1'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 1'b0;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
    
endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 1'b0;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 1'b0;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule",1,Always_case.v,"// Case statements are more convenient than if statements if there are a large number of cases. 
//So, in this exercise, create a 6-to-1 multiplexer. When sel is between 0 and 5, 
// choose the corresponding data input. Otherwise, output 0. 
//The data inputs and outputs are all 4 bits wide.
// Be careful of inferring latches 

// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
","module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000: out = data0;
            3'b001: out = data1;
            3'b010: out = data2;
            3'b011: out = data3;
            3'b100: out = data4;
            3'b101: out = data5;
            default: out = 4'b0000;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            0 : out = data0;
            1 : out = data1;
            2 : out = data2;
            3 : out = data3;
            4 : out = data4;
            5 : out = data5;
            default : out = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase

endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*)
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase

endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case (in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case(in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case(in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case(in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule",-0.5,Always_case2.v,"// Build a 4-bit priority encoder. For this problem, if none of the input bits are high 
// (i.e., input is zero), output zero. Note that a 4-bit number has 16 possible combinations.

// Hint: Using hexadecimal (4'hb) or decimal (4'd11) number literals would save typing vs. binary (4'b1011) literals.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

","module top_module (
    input [3:0] in,
    output reg [1:0] pos  );

    always @(*) begin
        case(in)
            4'b0000: pos = 2'd0;
            4'b0001: pos = 2'd0;
            4'b0010: pos = 2'd1;
            4'b0011: pos = 2'd1;
            4'b0100: pos = 2'd2;
            4'b0101: pos = 2'd2;
            4'b0110: pos = 2'd3;
            4'b0111: pos = 2'd3;
            4'b1000: pos = 2'd0;
            4'b1001: pos = 2'd0;
            4'b1010: pos = 2'd1;
            4'b1011: pos = 2'd1;
            4'b1100: pos = 2'd2;
            4'b1101: pos = 2'd2;
            4'b1110: pos = 2'd3;
            4'b1111: pos = 2'd3;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    
    always @(*) begin
        case(in)
            4'b0000 : pos = 0;
            4'b0001 : pos = 0;
            4'b0010 : pos = 1;
            4'b0011 : pos = 0;
            4'b0100 : pos = 2;
            4'b0101 : pos = 0;
            4'b0110 : pos = 1;
            4'b0111 : pos = 0;
            4'b1000 : pos = 3;
            4'b1001 : pos = 0;
            4'b1010 : pos = 1;
            4'b1011 : pos = 0;
            4'b1100 : pos = 2;
            4'b1101 : pos = 0;
            4'b1110 : pos = 1;
            4'b1111 : pos = 0;
        endcase
    end

endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1: pos = 3'd0; 
            8'bzzzzzz1z: pos = 3'd1; 
            8'bzzzzz1zz: pos = 3'd2; 
            8'bzzzz1zzz: pos = 3'd3; 
            8'bzzz1zzzz: pos = 3'd4; 
            8'bzz1zzzzz: pos = 3'd5; 
            8'bz1zzzzzz: pos = 3'd6; 
            8'b1zzzzzzz: pos = 3'd7; 
            default: pos = 3'd0;
        endcase
    end
    
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1: pos = 3'd0; 
            8'bzzzzzz1z: pos = 3'd1; 
            8'bzzzzz1zz: pos = 3'd2; 
            8'bzzzz1zzz: pos = 3'd3; 
            8'bzzz1zzzz: pos = 3'd4; 
            8'bzz1zzzzz: pos = 3'd5; 
            8'bz1zzzzzz: pos = 3'd6; 
            8'b1zzzzzzz: pos = 3'd7; 
            default: pos = 3'd0;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex (in)
            8'bxxxxxxx1: pos = 3'd0; 
            8'bxxxxxx10: pos = 3'd1; 
            8'bxxxxx100: pos = 3'd2; 
            8'bxxxx1000: pos = 3'd3;
            8'bxxx10000: pos = 3'd4;
            8'bxx100000: pos = 3'd5;
            8'bx1000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
    
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex (in)
            8'bxxxxxxx1: pos = 3'd0; 
            8'bxxxxxx10: pos = 3'd1; 
            8'bxxxxx100: pos = 3'd2; 
            8'bxxxx1000: pos = 3'd3;
            8'bxxx10000: pos = 3'd4;
            8'bxx100000: pos = 3'd5;
            8'bx1000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1: pos = 3'd0;
            8'bzzzzzz1z: pos = 3'd1;
            8'bzzzzz1zz: pos = 3'd2;
            8'bzzzz1zzz: pos = 3'd3;
            8'bzzz1zzzz: pos = 3'd4;
            8'bzz1zzzzz: pos = 3'd5;
            8'bz1zzzzzz: pos = 3'd6;
            8'b1zzzzzzz: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
    
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1: pos = 3'd0;
            8'bzzzzzz1z: pos = 3'd1;
            8'bzzzzz1zz: pos = 3'd2;
            8'bzzzz1zzz: pos = 3'd3;
            8'bzzz1zzzz: pos = 3'd4;
            8'bzz1zzzzz: pos = 3'd5;
            8'bz1zzzzzz: pos = 3'd6;
            8'b1zzzzzzz: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case (in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case (in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex (in)
            8'bxxxxxxx1: pos=3'd0;
            8'bxxxxxx10: pos=3'd1;
            8'bxxxxx100: pos=3'd2;
            8'bxxxx1000: pos=3'd3;
            8'bxxx10000: pos=3'd4;
            8'bxx100000: pos=3'd5;
            8'bx1000000: pos=3'd6;
            8'b10000000: pos=3'd7;
            default: pos=3'd0;
        endcase
    end
    
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex (in)
            8'bxxxxxxx1: pos=3'd0;
            8'bxxxxxx10: pos=3'd1;
            8'bxxxxx100: pos=3'd2;
            8'bxxxx1000: pos=3'd3;
            8'bxxx10000: pos=3'd4;
            8'bxx100000: pos=3'd5;
            8'bx1000000: pos=3'd6;
            8'b10000000: pos=3'd7;
            default: pos=3'd0;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex(in)
            8'bxxxxxxx1: pos=3'd0; 
            8'bxxxxxx10: pos=3'd1;
            8'bxxxxx100: pos=3'd2;
            8'bxxxx1000: pos=3'd3;
            8'bxxx10000: pos=3'd4;
            8'bxx100000: pos=3'd5;
            8'bx1000000: pos=3'd6;
            8'b10000000: pos=3'd7;
            default: pos=3'd0;
        endcase
    end
    
endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex(in)
            8'bxxxxxxx1: pos=3'd0; 
            8'bxxxxxx10: pos=3'd1;
            8'bxxxxx100: pos=3'd2;
            8'bxxxx1000: pos=3'd3;
            8'bxxx10000: pos=3'd4;
            8'bxx100000: pos=3'd5;
            8'bx1000000: pos=3'd6;
            8'b10000000: pos=3'd7;
            default: pos=3'd0;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex (in)
            8'bxxxxxxx1: pos = 3'd0; 
            8'bxxxxxx10: pos = 3'd1; 
            8'bxxxxx100: pos = 3'd2;
            8'bxxxx1000: pos = 3'd3;
            8'bxxx10000: pos = 3'd4;
            8'bxx100000: pos = 3'd5;
            8'bx1000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end

endmodule",1,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        casex (in)
            8'bxxxxxxx1: pos = 3'd0; 
            8'bxxxxxx10: pos = 3'd1; 
            8'bxxxxx100: pos = 3'd2;
            8'bxxxx1000: pos = 3'd3;
            8'bxxx10000: pos = 3'd4;
            8'bxx100000: pos = 3'd5;
            8'bx1000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
            default: pos = 3'd0;
        endcase
    end

endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule",-0.5,Always_casez.v,"// Build a priority encoder for 8-bit inputs. Given an 8-bit vector, 
// the output should report the first (least significant) bit in the vector that is 1. 
// Report zero if the input vector has no bits that are high. 
// For example, the input 8'b10010000 should output 3'd4, because bit[4] is first bit that is high.

// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );","module top_module (
    input [7:0] in,
    output reg [2:0] pos );

    always @(*) begin
        case(in)
            8'b00000001: pos = 3'd0;
            8'b00000010: pos = 3'd1;
            8'b00000100: pos = 3'd2;
            8'b00001000: pos = 3'd3;
            8'b00010000: pos = 3'd4;
            8'b00100000: pos = 3'd5;
            8'b01000000: pos = 3'd6;
            8'b10000000: pos = 3'd7;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos  );

    always @(*) begin
        casez(in)
            8'bzzzzzzz1 : pos = 0;
            8'bzzzzzz1z : pos = 1;
            8'bzzzzz1zz : pos = 2;
            8'bzzzz1zzz : pos = 3;
            8'bzzz1zzzz : pos = 4;
            8'bzz1zzzzz : pos = 5;
            8'bz1zzzzzz : pos = 6;
            8'b1zzzzzzz : pos = 7;
            default : pos = 0;
        endcase
    end
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule",1,Always_if.v,"// Build a 2-to-1 mux that chooses between a and b. 
// Choose b if both sel_b1 and sel_b2 are true. Otherwise, choose a. 
// Do the same twice, once using assign statements and once using a procedural if statement.

// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
","module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign = (sel_b1 == 1 && sel_b2 == 1)? b : a;
    
    always @(*) begin
        if (sel_b1 == 1 && sel_b2 == 1) begin
            out_always = b;
        end
        else begin
            out_always = a;
        end
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   ); 

    assign out_assign = (sel_b1 && sel_b2) ? b : a;
    always @(*) out_always = (sel_b1 && sel_b2) ? b : a;
    
endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 1'b0;
        down = 1'b0;
        right = 1'b0;
        up = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 1'b0;
        down = 1'b0;
        right = 1'b0;
        up = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//       ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule",1,Always_nolatches.v,"// Suppose you're building a circuit to process scancodes from a PS/2 keyboard for a game. 
// Given the last two bytes of scancodes received, you need to indicate whether one of the 
// arrow keys on the keyboard have been pressed. This involves a fairly simple mapping, 
// which can be implemented as a case statement (or if-elseif) with four cases.


// Scancode [15:0]	Arrow key
// 16'he06b		left arrow
// 16'he072		down arrow
// 16'he074		right arrow
// 16'he075		up arrow
// Anything else	none

// Hint: Your circuit has one 16-bit input, and four outputs. Build this circuit that 
// recognizes these four scancodes and asserts the correct output.

// To avoid creating latches, all outputs must be assigned a value in all possible conditions. 
// Simply having a default case is not enough. You must assign a value to all four outputs in 
// all four cases and the default case. This can involve a lot of unnecessary typing. 
// One easy way around this is to assign a ""default value"" to the outputs before the case statement:

// always @(*) begin
//    up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
//    case (scancode)
//        ... // Set to 1 as necessary.
//    endcase
// end

// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
","module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        up = 1'b0; down = 1'b0; left = 1'b0; right = 1'b0;
        case (scancode)
            16'he06b: left = 1'b1;
            16'he072: down = 1'b1;
            16'he074: right = 1'b1;
            16'he075: up = 1'b1;
        endcase
    end
    
endmodule","// synthesis verilog_input_version verilog_2001
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
    
    always @(*) begin
        left = 0; down = 0; right = 0; up = 0;
        case(scancode)
            16'he06b : left = 1;
            16'he072 : down = 1;
            16'he074 : right = 1;
            16'he075 : up = 1;
            default : ;
        endcase
    end

endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;
    
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;
    
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;
    
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = a && b;
    
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule",1,Andgate.v,"// Create a module that implements an AND gate.

// Hint: Verilog has separate bitwise-AND (&) and logical-AND (&&) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a && b;
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = a & b;
endmodule",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] sum_temp;
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, sum_temp[0], sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], sum_temp[0], sum_temp[1], sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], sum_temp[1], sum_temp[2], sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], sum_temp[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] sum_temp;
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, sum_temp[0], sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], sum_temp[0], sum_temp[1], sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], sum_temp[1], sum_temp[2], sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], sum_temp[2], cout, sum[15:12]);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] sum_temp;
    wire [3:0] carry_in;
    
    assign carry_in[0] = cin;
    assign carry_in[1] = (a[0] & b[0]) | (a[0] & carry_in[0]) | (b[0] & carry_in[0]);
    assign carry_in[2] = (a[1] & b[1]) | (a[1] & carry_in[1]) | (b[1] & carry_in[1]);
    assign carry_in[3] = (a[2] & b[2]) | (a[2] & carry_in[2]) | (b[2] & carry_in[2]);
    assign carry_in[4] = (a[3] & b[3]) | (a[3] & carry_in[3]) | (b[3] & carry_in[3]);
    assign carry_in[5] = (a[4] & b[4]) | (a[4] & carry_in[4]) | (b[4] & carry_in[4]);
    assign carry_in[6] = (a[5] & b[5]) | (a[5] & carry_in[5]) | (b[5] & carry_in[5]);
    assign carry_in[7] = (a[6] & b[6]) | (a[6] & carry_in[6]) | (b[6] & carry_in[6]);
    assign carry_in[8] = (a[7] & b[7]) | (a[7] & carry_in[7]) | (b[7] & carry_in[7]);
    assign carry_in[9] = (a[8] & b[8]) | (a[8] & carry_in[8]) | (b[8] & carry_in[8]);
    assign carry_in[10] = (a[9] & b[9]) | (a[9] & carry_in[9]) | (b[9] & carry_in[9]);
    assign carry_in[11] = (a[10] & b[10]) | (a[10] & carry_in[10]) | (b[10] & carry_in[10]);
    assign carry_in[12] = (a[11] & b[11]) | (a[11] & carry_in[11]) | (b[11] & carry_in[11]);
    assign carry_in[13] = (a[12] & b[12]) | (a[12] & carry_in[12]) | (b[12] & carry_in[12]);
    assign carry_in[14] = (a[13] & b[13]) | (a[13] & carry_in[13]) | (b[13] & carry_in[13]);
    assign carry_in[15] = (a[14] & b[14]) | (a[14] & carry_in[14]) | (b[14] & carry_in[14]);
    
    assign sum_temp[0] = a[0] ^ b[0] ^ carry_in[0];
    assign sum_temp[1] = a[1] ^ b[1] ^ carry_in[1];
    assign sum_temp[2] = a[2] ^ b[2] ^ carry_in[2];
    assign sum_temp[3] = a[3] ^ b[3] ^ carry_in[3];
    assign sum_temp[4] = a[4] ^ b[4] ^ carry_in[4];
    assign sum_temp[5] = a[5] ^ b[5] ^ carry_in[5];
    assign sum_temp[6] = a[6] ^ b[6] ^ carry_in[6];
    assign sum_temp[7] = a[7] ^ b[7] ^ carry_in[7];
    assign sum_temp[8] = a[8] ^ b[8] ^ carry_in[8];
    assign sum_temp[9] = a[9] ^ b[9] ^ carry_in[9];
    assign sum_",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] sum_temp;
    wire [3:0] carry_in;
    
    assign carry_in[0] = cin;
    assign carry_in[1] = (a[0] & b[0]) | (a[0] & carry_in[0]) | (b[0] & carry_in[0]);
    assign carry_in[2] = (a[1] & b[1]) | (a[1] & carry_in[1]) | (b[1] & carry_in[1]);
    assign carry_in[3] = (a[2] & b[2]) | (a[2] & carry_in[2]) | (b[2] & carry_in[2]);
    assign carry_in[4] = (a[3] & b[3]) | (a[3] & carry_in[3]) | (b[3] & carry_in[3]);
    assign carry_in[5] = (a[4] & b[4]) | (a[4] & carry_in[4]) | (b[4] & carry_in[4]);
    assign carry_in[6] = (a[5] & b[5]) | (a[5] & carry_in[5]) | (b[5] & carry_in[5]);
    assign carry_in[7] = (a[6] & b[6]) | (a[6] & carry_in[6]) | (b[6] & carry_in[6]);
    assign carry_in[8] = (a[7] & b[7]) | (a[7] & carry_in[7]) | (b[7] & carry_in[7]);
    assign carry_in[9] = (a[8] & b[8]) | (a[8] & carry_in[8]) | (b[8] & carry_in[8]);
    assign carry_in[10] = (a[9] & b[9]) | (a[9] & carry_in[9]) | (b[9] & carry_in[9]);
    assign carry_in[11] = (a[10] & b[10]) | (a[10] & carry_in[10]) | (b[10] & carry_in[10]);
    assign carry_in[12] = (a[11] & b[11]) | (a[11] & carry_in[11]) | (b[11] & carry_in[11]);
    assign carry_in[13] = (a[12] & b[12]) | (a[12] & carry_in[12]) | (b[12] & carry_in[12]);
    assign carry_in[14] = (a[13] & b[13]) | (a[13] & carry_in[13]) | (b[13] & carry_in[13]);
    assign carry_in[15] = (a[14] & b[14]) | (a[14] & carry_in[14]) | (b[14] & carry_in[14]);
    
    assign sum_temp[0] = a[0] ^ b[0] ^ carry_in[0];
    assign sum_temp[1] = a[1] ^ b[1] ^ carry_in[1];
    assign sum_temp[2] = a[2] ^ b[2] ^ carry_in[2];
    assign sum_temp[3] = a[3] ^ b[3] ^ carry_in[3];
    assign sum_temp[4] = a[4] ^ b[4] ^ carry_in[4];
    assign sum_temp[5] = a[5] ^ b[5] ^ carry_in[5];
    assign sum_temp[6] = a[6] ^ b[6] ^ carry_in[6];
    assign sum_temp[7] = a[7] ^ b[7] ^ carry_in[7];
    assign sum_temp[8] = a[8] ^ b[8] ^ carry_in[8];
    assign sum_temp[9] = a[9] ^ b[9] ^ carry_in[9];
    assign sum_","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] c;
    
    bcd_fadd a1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    bcd_fadd a2 (a[7:4], b[7:4], c[0], c[1], sum[7:4]);
    bcd_fadd a3 (a[11:8], b[11:8], c[1], c[2], sum[11:8]);
    bcd_fadd a4 (a[15:12], b[15:12], c[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] c;
    
    bcd_fadd a1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    bcd_fadd a2 (a[7:4], b[7:4], c[0], c[1], sum[7:4]);
    bcd_fadd a3 (a[11:8], b[11:8], c[1], c[2], sum[11:8]);
    bcd_fadd a4 (a[15:12], b[15:12], c[2], cout, sum[15:12]);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    bcd_fadd fadd0 (a[3:0], b[3:0], cin, cout0, sum0);
    bcd_fadd fadd1 (a[7:4], b[7:4], cout0, cout1, sum1);
    bcd_fadd fadd2 (a[11:8], b[11:8], cout1, cout2, sum2);
    bcd_fadd fadd3 (a[15:12], b[15:12], cout2, cout, sum3);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    bcd_fadd fadd0 (a[3:0], b[3:0], cin, cout0, sum0);
    bcd_fadd fadd1 (a[7:4], b[7:4], cout0, cout1, sum1);
    bcd_fadd fadd2 (a[11:8], b[11:8], cout1, cout2, sum2);
    bcd_fadd fadd3 (a[15:12], b[15:12], cout2, cout, sum3);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] c;
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], c[0], c[1], sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], c[1], c[2], sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], c[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] c;
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], c[0], c[1], sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], c[1], c[2], sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], c[2], cout, sum[15:12]);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
// Instantiate two bcd_fadd modules to compute the sum of two bcd numbers.
// The carry-in is 1 in the first adder, and 0 in the second.


module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] sum
);

    assign sum = a + b;

endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
// Instantiate two bcd_fadd modules to compute the sum of two bcd numbers.
// The carry-in is 1 in the first adder, and 0 in the second.


module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] sum
);

    assign sum = a + b;

endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, cout1, sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], cout1, cout2, sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], cout2, cout3, sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], cout3, cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, cout1, sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], cout1, cout2, sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], cout2, cout3, sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], cout3, cout, sum[15:12]);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] sum_temp;
    
    bcd_fadd a1 (a[3:0], b[3:0], cin, sum_temp[0], sum[3:0]);
    bcd_fadd a2 (a[7:4], b[7:4], sum_temp[0], sum_temp[1], sum[7:4]);
    bcd_fadd a3 (a[11:8], b[11:8], sum_temp[1], sum_temp[2], sum[11:8]);
    bcd_fadd a4 (a[15:12], b[15:12], sum_temp[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] sum_temp;
    
    bcd_fadd a1 (a[3:0], b[3:0], cin, sum_temp[0], sum[3:0]);
    bcd_fadd a2 (a[7:4], b[7:4], sum_temp[0], sum_temp[1], sum[7:4]);
    bcd_fadd a3 (a[11:8], b[11:8], sum_temp[1], sum_temp[2], sum[11:8]);
    bcd_fadd a4 (a[15:12], b[15:12], sum_temp[2], cout, sum[15:12]);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] cout_temp;
    wire [3:0] sum_temp;
    
    bcd_fadd a1 (a[3:0], b[3:0], cin, cout_temp[0], sum_temp[0]);
    bcd_fadd a2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum_temp[1]);
    bcd_fadd a3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum_temp[2]);
    bcd_fadd a4 (a[15:12], b[15:12], cout_temp[2], cout, sum_temp[3]);
    
    assign cout = cout_temp[2];
    
    assign sum = {sum_temp[3], sum_temp[2], sum_temp[1], sum_temp[0]};
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] cout_temp;
    wire [3:0] sum_temp;
    
    bcd_fadd a1 (a[3:0], b[3:0], cin, cout_temp[0], sum_temp[0]);
    bcd_fadd a2 (a[7:4], b[7:4], cout_temp[0], cout_temp[1], sum_temp[1]);
    bcd_fadd a3 (a[11:8], b[11:8], cout_temp[1], cout_temp[2], sum_temp[2]);
    bcd_fadd a4 (a[15:12], b[15:12], cout_temp[2], cout, sum_temp[3]);
    
    assign cout = cout_temp[2];
    
    assign sum = {sum_temp[3], sum_temp[2], sum_temp[1], sum_temp[0]};
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] c;
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], c[0], c[1], sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], c[1], c[2], sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], c[2], cout, sum[15:12]);
    
endmodule",-1,Bcdadd4.v,"// You are provided with a BCD (binary-coded decimal) one-digit adder named bcd_fadd that adds two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 4 copies of bcd_fadd to create a 4-digit BCD ripple-carry adder. Your adder should add two 4-digit BCD numbers (packed into 16-bit vectors) and a carry-in to produce a 4-digit sum and carry out.

// Hint: The BCD representation for the 5-digit decimal number 12345 is 20'h12345. This is not the same as 14'd12345 (which is 14'h3039).
// The circuit is structured just like a binary ripple-carry adder, except the adders are base-10 rather than base-2.


module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
","module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [3:0] c;
    
    bcd_fadd f1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    bcd_fadd f2 (a[7:4], b[7:4], c[0], c[1], sum[7:4]);
    bcd_fadd f3 (a[11:8], b[11:8], c[1], c[2], sum[11:8]);
    bcd_fadd f4 (a[15:12], b[15:12], c[2], cout, sum[15:12]);
    
endmodule","module top_module( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire [15:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]), .sum(sum[3:0]));
    assign cout = cout_tmp[12];
    generate
        genvar i;
        for(i = 4; i < 16; i = i + 4) begin:adder
            bcd_fadd fadd(.a(a[i + 3:i]), .b(b[i + 3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]), .sum(sum[i + 3:i]));
        end
    endgenerate

endmodule


",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd fadd (
               .a(a[3*i+:3]),
               .b(b[3*i+:3]),
               .cin(carry[i]),
               .cout(carry[i+1]),
               .sum(sum[3*i+:3])
            );
        end
    endgenerate
    assign cout = carry[100];

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd fadd (
               .a(a[3*i+:3]),
               .b(b[3*i+:3]),
               .cin(carry[i]),
               .cout(carry[i+1]),
               .sum(sum[3*i+:3])
            );
        end
    endgenerate
    assign cout = carry[100];

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    bcd_fadd fadd1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    generate
        genvar i;
        for (i=4; i<400; i=i+4)
            bcd_fadd fadd (a[i+3:i], b[i+3:i], carry[i-4], carry[i], sum[i+3:i]);
    endgenerate
    assign cout = carry[99];

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    bcd_fadd fadd1 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    generate
        genvar i;
        for (i=4; i<400; i=i+4)
            bcd_fadd fadd (a[i+3:i], b[i+3:i], carry[i-4], carry[i], sum[i+3:i]);
    endgenerate
    assign cout = carry[99];

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    bcd_fadd inst_fadd (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(carry[0]),
       .sum(sum[3:0])
    );
    
    genvar i;
    generate
        for(i=4; i<400; i=i+4) begin
            assign carry[i/4] = (a[i] & b[i]) | (a[i] & carry[i/4]) | (b[i] & carry[i/4]);
            assign sum[i] = a[i] ^ b[i] ^ carry[i/4];
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    bcd_fadd inst_fadd (
       .a(a[3:0]),
       .b(b[3:0]),
       .cin(cin),
       .cout(carry[0]),
       .sum(sum[3:0])
    );
    
    genvar i;
    generate
        for(i=4; i<400; i=i+4) begin
            assign carry[i/4] = (a[i] & b[i]) | (a[i] & carry[i/4]) | (b[i] & carry[i/4]);
            assign sum[i] = a[i] ^ b[i] ^ carry[i/4];
        end
    endgenerate
    
    assign cout = carry[99];
    
endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd f(a[3*i+:3], b[3*i+:3], cin, carry[i], sum[3*i+:3]);
        end
    endgenerate

    assign cout = carry[100];

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd f(a[3*i+:3], b[3*i+:3], cin, carry[i], sum[3*i+:3]);
        end
    endgenerate

    assign cout = carry[100];

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [3:0] c;
    bcd_fadd f1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    generate
        genvar i;
        for (i = 4; i < 400; i = i + 4) begin: add
            bcd_fadd f (a[i+3:i], b[i+3:i], c[i-4], c[i-3], sum[i+3:i]);
        end
    endgenerate
    assign cout = c[399];
    
endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [3:0] c;
    bcd_fadd f1 (a[3:0], b[3:0], cin, c[0], sum[3:0]);
    generate
        genvar i;
        for (i = 4; i < 400; i = i + 4) begin: add
            bcd_fadd f (a[i+3:i], b[i+3:i], c[i-4], c[i-3], sum[i+3:i]);
        end
    endgenerate
    assign cout = c[399];
    
endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    assign top_module.cout = bcd_fadd(a[3:0], b[3:0], cin, top_module.cout, sum[3:0]);
    assign top_module.cout = bcd_fadd(a[7:4], b[7:4], top_module.cout, top_module.cout2, sum[7:4]);
    assign top_module.cout = bcd_fadd(a[11:8], b[11:8], top_module.cout2, top_module.cout3, sum[11:8]);
    assign top_module.cout = bcd_fadd(a[15:12], b[15:12], top_module.cout3, top_module.cout4, sum[15:12]);
    assign top_module.cout = bcd_fadd(a[19:16], b[19:16], top_module.cout4, top_module.cout5, sum[19:16]);
    assign top_module.cout = bcd_fadd(a[23:20], b[23:20], top_module.cout5, top_module.cout6, sum[23:20]);
    assign top_module.cout = bcd_fadd(a[27:24], b[27:24], top_module.cout6, top_module.cout7, sum[27:24]);
    assign top_module.cout = bcd_fadd(a[31:28], b[31:28], top_module.cout7, top_module.cout8, sum[31:28]);
    assign top_module.cout = bcd_fadd(a[35:32], b[35:32], top_module.cout8, top_module.cout9, sum[35:32]);
    assign top_module.cout = bcd_fadd(a[39:36], b[39:36], top_module.cout9, top_module.cout10, sum[39:36]);
    assign top_module.cout = bcd_fadd(a[43:40], b[43:40], top_module.cout10, top_module.cout11, sum[43:40]);
    assign top_module.cout = bcd_fadd(a[47:44], b[47:44], top_module.cout11, top_module.cout12, sum[47:44]);
    assign top_module.cout = bcd_fadd(a[51:48], b[51:48], top_module.cout12, top_module.cout13, sum[51:48]);
    assign top_module.cout = bcd_fadd(a[55:52], b[55:52], top_module.cout13, top_module.cout14, sum[55:52]);
    assign top_module.cout = bcd_fadd(a[59:56], b[59:56], top_module.cout14, top_module.cout15, sum[59:56]);
    assign top_module.cout = bcd_fadd(a[63:60], b[63:60], top_module.cout15, top_module.cout16, sum[63:60]);
    assign top_module.cout = bcd_fadd(a[67:64], b[67:64], top_module.cout16, top_module.cout17, sum[67:64]);
    assign top_module.cout = bcd_fadd(a[71:68], b[71:68], top_module.cout17, top_module.cout18, sum[71:68]);
    assign top_module.cout = bcd_fadd(a[75:72], b[75:72], top_module.cout18, top_module.cout19, sum[75:72]);
    assign top_module.cout = bcd_fadd(a[79:76], b[79:76], top_module.cout19, top_module.cout20, sum[79:76]);
    assign top_module.cout =",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    assign top_module.cout = bcd_fadd(a[3:0], b[3:0], cin, top_module.cout, sum[3:0]);
    assign top_module.cout = bcd_fadd(a[7:4], b[7:4], top_module.cout, top_module.cout2, sum[7:4]);
    assign top_module.cout = bcd_fadd(a[11:8], b[11:8], top_module.cout2, top_module.cout3, sum[11:8]);
    assign top_module.cout = bcd_fadd(a[15:12], b[15:12], top_module.cout3, top_module.cout4, sum[15:12]);
    assign top_module.cout = bcd_fadd(a[19:16], b[19:16], top_module.cout4, top_module.cout5, sum[19:16]);
    assign top_module.cout = bcd_fadd(a[23:20], b[23:20], top_module.cout5, top_module.cout6, sum[23:20]);
    assign top_module.cout = bcd_fadd(a[27:24], b[27:24], top_module.cout6, top_module.cout7, sum[27:24]);
    assign top_module.cout = bcd_fadd(a[31:28], b[31:28], top_module.cout7, top_module.cout8, sum[31:28]);
    assign top_module.cout = bcd_fadd(a[35:32], b[35:32], top_module.cout8, top_module.cout9, sum[35:32]);
    assign top_module.cout = bcd_fadd(a[39:36], b[39:36], top_module.cout9, top_module.cout10, sum[39:36]);
    assign top_module.cout = bcd_fadd(a[43:40], b[43:40], top_module.cout10, top_module.cout11, sum[43:40]);
    assign top_module.cout = bcd_fadd(a[47:44], b[47:44], top_module.cout11, top_module.cout12, sum[47:44]);
    assign top_module.cout = bcd_fadd(a[51:48], b[51:48], top_module.cout12, top_module.cout13, sum[51:48]);
    assign top_module.cout = bcd_fadd(a[55:52], b[55:52], top_module.cout13, top_module.cout14, sum[55:52]);
    assign top_module.cout = bcd_fadd(a[59:56], b[59:56], top_module.cout14, top_module.cout15, sum[59:56]);
    assign top_module.cout = bcd_fadd(a[63:60], b[63:60], top_module.cout15, top_module.cout16, sum[63:60]);
    assign top_module.cout = bcd_fadd(a[67:64], b[67:64], top_module.cout16, top_module.cout17, sum[67:64]);
    assign top_module.cout = bcd_fadd(a[71:68], b[71:68], top_module.cout17, top_module.cout18, sum[71:68]);
    assign top_module.cout = bcd_fadd(a[75:72], b[75:72], top_module.cout18, top_module.cout19, sum[75:72]);
    assign top_module.cout = bcd_fadd(a[79:76], b[79:76], top_module.cout19, top_module.cout20, sum[79:76]);
    assign top_module.cout =","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [3:0] carry;
    
    assign carry[0] = cin;
    
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd fadd (
               .a(a[3*i+:3]),
               .b(b[3*i+:3]),
               .cin(carry[i]),
               .cout(carry[i+1]),
               .sum(sum[3*i+:3])
            );
        end
    endgenerate
    
    assign cout = carry[100];

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [3:0] carry;
    
    assign carry[0] = cin;
    
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd fadd (
               .a(a[3*i+:3]),
               .b(b[3*i+:3]),
               .cin(carry[i]),
               .cout(carry[i+1]),
               .sum(sum[3*i+:3])
            );
        end
    endgenerate
    
    assign cout = carry[100];

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    assign top_module.cout = bcd_fadd(a[3:0], b[3:0], cin, top_module.sum[3:0]);
    assign top_module.sum = a + b + cin;

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    assign top_module.cout = bcd_fadd(a[3:0], b[3:0], cin, top_module.sum[3:0]);
    assign top_module.sum = a + b + cin;

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [3:0] carry;
    
    assign carry[0] = cin;
    assign cout = carry[3];
    
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd fadd(a[3*i+:3], b[3*i+:3], carry[i], carry[i+1], sum[3*i+:3]);
        end
    endgenerate

endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [3:0] carry;
    
    assign carry[0] = cin;
    assign cout = carry[3];
    
    genvar i;
    generate
        for (i=0; i<100; i=i+1) begin
            bcd_fadd fadd(a[3*i+:3], b[3*i+:3], carry[i], carry[i+1], sum[3*i+:3]);
        end
    endgenerate

endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    bcd_fadd inst_fadd0 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    generate
        genvar i;
        for (i = 4; i < 400; i = i + 4) begin : adder
            bcd_fadd inst_fadd (a[i+3:i], b[i+3:i], carry[i-4], carry[i], sum[i+3:i]);
        end
    endgenerate
    assign cout = carry[99];
    
endmodule",-1,Bcsadd100.v,"// You are provided with a BCD one-digit adder named bcd_fadd that adds 
// two BCD digits and carry-in, and produces a sum and carry-out.

module bcd_fadd (
    input [3:0] a,
    input [3:0] b,
    input     cin,
    output   cout,
    output [3:0] sum );
    
// Instantiate 100 copies of bcd_fadd to create a 100-digit BCD ripple-carry adder. 
//Your adder should add two 100-digit BCD numbers (packed into 400-bit vectors) 
//and a carry-in to produce a 100-digit sum and carry out.


// Hint: An instance array or generate statement would be useful here.

module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );

    wire [99:0] carry;
    bcd_fadd inst_fadd0 (a[3:0], b[3:0], cin, carry[0], sum[3:0]);
    generate
        genvar i;
        for (i = 4; i < 400; i = i + 4) begin : adder
            bcd_fadd inst_fadd (a[i+3:i], b[i+3:i], carry[i-4], carry[i], sum[i+3:i]);
        end
    endgenerate
    assign cout = carry[99];
    
endmodule","module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [399:0] cout_tmp;
    bcd_fadd fadd(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(cout_tmp[0]),.sum(sum[3:0]));
    assign cout = cout_tmp[396];
    
    generate
        genvar i;
        for(i = 4; i < 400; i=i+4) begin : adder
            bcd_fadd fadd(.a(a[i+3:i]), .b(b[i+3:i]), .cin(cout_tmp[i-4]), .cout(cout_tmp[i]),.sum(sum[i+3:i]));
        end
    endgenerate

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min = (a < b)? a : ( (c < d)? c : d );
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min = (a < b)? a : ( (c < d)? c : d );
    
endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? a:b)? a:b;
    // assign min = (compare? a:b)? a:b;
    assign min = (a<b)?a:b;
    assign min = (a<c)?a:c;
    assign min = (a<d)?a:d;
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? a:b)? a:b;
    // assign min = (compare? a:b)? a:b;
    assign min = (a<b)?a:b;
    assign min = (a<c)?a:c;
    assign min = (a<d)?a:d;
    
endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min = (a < b)? a : ( (c < d)? c : d );
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min = (a < b)? a : ( (c < d)? c : d );
    
endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare? true: false;
    // assign min = intermediate_result1 < intermediate_result2?
    //     intermediate_result1: intermediate_result2;
    
    assign min = (a < b)? a:b;
    assign min = (c < d)? c:d;
    assign min = (a < c)? a:c;
    assign min = (b < d)? b:d;
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign intermediate_result2 = compare? true: false;
    // assign min = intermediate_result1 < intermediate_result2?
    //     intermediate_result1: intermediate_result2;
    
    assign min = (a < b)? a:b;
    assign min = (c < d)? c:d;
    assign min = (a < c)? a:c;
    assign min = (b < d)? b:d;
    
endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? a: b);
    assign min = (compare? (a<b?a:b):(a<c?a:c));
endmodule",-1,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? a: b);
    assign min = (compare? (a<b?a:b):(a<c?a:c));
endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? min1: min2);
    assign min = (a < b)? a: ( (a == b)? min1: min2);
    assign min1 = (c < d)? c: ( (c == d)? min3: min4);
    assign min2 = (min1 < min3)? min1: min3;
    assign min3 = (min2 < min4)? min2: min4;
    assign min4 = (min3 < min4)? min3: min4;

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? min1: min2);
    assign min = (a < b)? a: ( (a == b)? min1: min2);
    assign min1 = (c < d)? c: ( (c == d)? min3: min4);
    assign min2 = (min1 < min3)? min1: min3;
    assign min3 = (min2 < min4)? min2: min4;
    assign min4 = (min3 < min4)? min3: min4;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? a: b);
    assign min = (a < b)? a:b;
    assign min = (a < c)? a:c;
    assign min = (a < d)? a:d;
    // assign min = (compare? a: b);
    // assign min = (compare? b: c);
    // assign min = (compare? c: d);
    // assign min = (compare? d: a);

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? a: b);
    assign min = (a < b)? a:b;
    assign min = (a < c)? a:c;
    assign min = (a < d)? a:d;
    // assign min = (compare? a: b);
    // assign min = (compare? b: c);
    // assign min = (compare? c: d);
    // assign min = (compare? d: a);

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? intermediate_result1 : min);
    assign min = (a < b)? a : b;
    assign min = (c < min)? c : min;
    assign min = (d < min)? d : min;

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? intermediate_result1 : min);
    assign min = (a < b)? a : b;
    assign min = (c < min)? c : min;
    assign min = (d < min)? d : min;

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min = (a < b)? a : ( (c < d)? c : d );

endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    assign min = (a < b)? a : ( (c < d)? c : d );

endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? intermediate_result1: 8'b00000000) + (compare? 8'b00000000: a);
    assign min = (a < b)? a : b;
    assign min = (a < c)? (a < d? a : d) : (c < d? c : d);
    
endmodule",-0.5,Conditional.v,"// Given four unsigned numbers, find the minimum. 
// Unsigned numbers can be compared with standard comparison operators (a < b). 
// Use the conditional operator to make two-way min circuits, 
// then compose a few of them to create a 4-way min circuit. 
// You'll probably want some wire vectors for the intermediate results.

module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // Insert your code below
    // assign intermediate_result1 = compare? true: false;
    // assign min = (compare? intermediate_result1: 8'b00000000) + (compare? 8'b00000000: a);
    assign min = (a < b)? a : b;
    assign min = (a < c)? (a < d? a : d) : (c < d? c : d);
    
endmodule","module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//

    // assign intermediate_result1 = compare? true: false;
    wire [7:0] min_mid, min_mid1, min_mid2;
    assign min_mid = (a < b) ? a : b;
    assign min_mid1 = (c < min_mid) ? c : min_mid;
    assign min_mid2 = (d < min_mid1) ? d : min_mid1;
    assign min = min_mid2;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    // Declare three 8-bit counters
    // One counter for the minutes
    // One counter for the hours
    // One counter for the seconds
    
    // Initialize each counter to zero
    reg [7:0] hh_r = 8'd0, mm_r = 8'd0, ss_r = 8'd0;
    
    // Keep track of whether we've incremented the hour
    reg hh_inc = 0, mm_inc = 0, ss_inc = 0;
    
    // Keep track of the previous hour
    reg [7:0] prev_hour = 8'd0;
    
    // Increment the counters
    always @(posedge clk) begin
        if (reset) begin
            hh_r <= 8'd0;
            mm_r <= 8'd0;
            ss_r <= 8'd0;
            
            hh_inc <= 0;
            mm_inc <= 0;
            ss_inc <= 0;
            
            prev_hour <= 8'd0;
        end
        else begin
            if (ena) begin
                // Check if we've incremented the hour
                if (ss_inc) begin
                    // If we have, increment the hour
                    if (hh_inc) begin
                        // If we've incremented the hour past 11, increment the minute
                        if (hh_r == 8'd11) begin
                            hh_r <= 8'd0;
                            mm_r <= mm_inc? 8'd59 : mm_r;
                            mm_inc <= 0;
                            hh_inc <= 0;
                        end
                        else begin
                            hh_r <= hh_r + 8'd1;
                            hh_inc <= 1;
                        end
                    end
                    else begin
                        hh_r <= hh_r;
                        hh_inc <= 0;
                        mm_r <= mm_inc? 8'd59 : mm_r;
                        mm_inc <= 0;
                    end
                    
                    // Check if we've incremented the minute
                    if (mm_inc) begin
                        // If we have, increment the minute
                        if (mm_r == 8'd59) begin
                            mm_r <= 8'd0;
                            ss_r <= ss_inc? 8'd59 : ss_r;
                            ss_inc <= 0;
                        end
                        else begin
                            mm_r <= mm_r + 8'd1;
                            ss_inc <= 1;
                        end
                    end
                    else begin
                        mm_r <= mm_r;
                        mm_inc <= 0;
                        ss_r <= ss_inc? 8'd59 : ss_r;
                        ss_inc <= 0;
                    end
                    
                    // Check if we've incremented the second
                    if (ss_inc) begin
                        // If we have, increment the second
                        if (ss_r == 8'd59) begin
                            ss_r <= 8'd0;
                            
                            // Check if we've incremented the minute
                            if (mm_inc) begin
                                // If we have, increment the minute
                                if (mm_r == 8'd59) begin
                                    mm_r <= 8'd0;
                                    hh_r <= hh_inc? 8'd11 : hh_r;
                                    hh_inc <= 0;
                                end
                                else begin
                                    mm_r <= mm_r + 8'd1;
                                    hh_inc <= 1;
                                end
                            end
                            else begin
                                mm_r <= mm_r;
                                hh_r <= hh_inc? 8'd11 : hh_r;
                                hh_inc <= 0;
                            end
                        end
                        else begin
                            ss_r <= ss_r + 8'd1;
                        end
                    end
                    else begin
                        ss_r <= ss_r;
                        ss_inc <= 0;
                        
                        // Check if we've incremented the minute
                        if (mm_inc) begin
                            // If we have, increment the minute
                            if (mm_r == 8'd59) begin
                                mm_r <= 8'd0;
                                hh_r <= hh_inc? 8'd11 : hh_r;
                                hh_inc <= 0;
                            end
                            else begin
                                mm_r <= mm_r + 8'd1;
                                hh_inc <= 1;
                            end
                        end
                        else begin
                            mm_r <=",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    // Declare three 8-bit counters
    // One counter for the minutes
    // One counter for the hours
    // One counter for the seconds
    
    // Initialize each counter to zero
    reg [7:0] hh_r = 8'd0, mm_r = 8'd0, ss_r = 8'd0;
    
    // Keep track of whether we've incremented the hour
    reg hh_inc = 0, mm_inc = 0, ss_inc = 0;
    
    // Keep track of the previous hour
    reg [7:0] prev_hour = 8'd0;
    
    // Increment the counters
    always @(posedge clk) begin
        if (reset) begin
            hh_r <= 8'd0;
            mm_r <= 8'd0;
            ss_r <= 8'd0;
            
            hh_inc <= 0;
            mm_inc <= 0;
            ss_inc <= 0;
            
            prev_hour <= 8'd0;
        end
        else begin
            if (ena) begin
                // Check if we've incremented the hour
                if (ss_inc) begin
                    // If we have, increment the hour
                    if (hh_inc) begin
                        // If we've incremented the hour past 11, increment the minute
                        if (hh_r == 8'd11) begin
                            hh_r <= 8'd0;
                            mm_r <= mm_inc? 8'd59 : mm_r;
                            mm_inc <= 0;
                            hh_inc <= 0;
                        end
                        else begin
                            hh_r <= hh_r + 8'd1;
                            hh_inc <= 1;
                        end
                    end
                    else begin
                        hh_r <= hh_r;
                        hh_inc <= 0;
                        mm_r <= mm_inc? 8'd59 : mm_r;
                        mm_inc <= 0;
                    end
                    
                    // Check if we've incremented the minute
                    if (mm_inc) begin
                        // If we have, increment the minute
                        if (mm_r == 8'd59) begin
                            mm_r <= 8'd0;
                            ss_r <= ss_inc? 8'd59 : ss_r;
                            ss_inc <= 0;
                        end
                        else begin
                            mm_r <= mm_r + 8'd1;
                            ss_inc <= 1;
                        end
                    end
                    else begin
                        mm_r <= mm_r;
                        mm_inc <= 0;
                        ss_r <= ss_inc? 8'd59 : ss_r;
                        ss_inc <= 0;
                    end
                    
                    // Check if we've incremented the second
                    if (ss_inc) begin
                        // If we have, increment the second
                        if (ss_r == 8'd59) begin
                            ss_r <= 8'd0;
                            
                            // Check if we've incremented the minute
                            if (mm_inc) begin
                                // If we have, increment the minute
                                if (mm_r == 8'd59) begin
                                    mm_r <= 8'd0;
                                    hh_r <= hh_inc? 8'd11 : hh_r;
                                    hh_inc <= 0;
                                end
                                else begin
                                    mm_r <= mm_r + 8'd1;
                                    hh_inc <= 1;
                                end
                            end
                            else begin
                                mm_r <= mm_r;
                                hh_r <= hh_inc? 8'd11 : hh_r;
                                hh_inc <= 0;
                            end
                        end
                        else begin
                            ss_r <= ss_r + 8'd1;
                        end
                    end
                    else begin
                        ss_r <= ss_r;
                        ss_inc <= 0;
                        
                        // Check if we've incremented the minute
                        if (mm_inc) begin
                            // If we have, increment the minute
                            if (mm_r == 8'd59) begin
                                mm_r <= 8'd0;
                                hh_r <= hh_inc? 8'd11 : hh_r;
                                hh_inc <= 0;
                            end
                            else begin
                                mm_r <= mm_r + 8'd1;
                                hh_inc <= 1;
                            end
                        end
                        else begin
                            mm_r <=","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    // Create a clocked-counter module that counts up by 1 every second.
    
    wire [3:0] counter;
    
    clocked_counter clk_counter0(clk, reset, ena, counter);
    
    // Create a module that converts the counter value to BCD.
    
    bcd_converter bcd0(counter, hh, mm, ss);
    
    // Create a module that produces a pulse when the hour is 11:59.
    
    assign pm = (hh == 11 && mm == 59 && ss == 59);
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    // Create a clocked-counter module that counts up by 1 every second.
    
    wire [3:0] counter;
    
    clocked_counter clk_counter0(clk, reset, ena, counter);
    
    // Create a module that converts the counter value to BCD.
    
    bcd_converter bcd0(counter, hh, mm, ss);
    
    // Create a module that produces a pulse when the hour is 11:59.
    
    assign pm = (hh == 11 && mm == 59 && ss == 59);
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_1hz, clk_5h, clk_1hz_ena, clk_5h_ena;
    
    clk_gen_0 top_clk(
       .clk(clk),
       .reset(reset),
       .ena(clk_1hz_ena),
       .clk_1hz(clk_1hz),
       .clk_5h(clk_5h));
    
    clk_gen_1 top_clk_1hz(
       .clk(clk_1hz),
       .reset(reset),
       .ena(clk_1hz_ena),
       .clk_1hz(clk_1hz));
        
    clk_gen_2 top_clk_5h(
       .clk(clk_5h),
       .reset(reset),
       .ena(clk_5h_ena),
       .clk_5h(clk_5h));
        
    clk_div_0 top_clk_div(
       .clk(clk),
       .reset(reset),
       .ena(ena),
       .clk_out(clk_1hz));
        
    clk_div_1 top_clk_div_1hz(
       .clk(clk_1hz),
       .reset(reset),
       .ena(clk_1hz_ena),
       .clk_out(clk_5h));
        
    bcd_to_7seg top_bcd_to_7seg_0(
       .clk(clk),
       .reset(reset),
       .enable(clk_1hz_ena),
       .bcd(hh),
       .sseg(ss));
        
    bcd_to_7seg top_bcd_to_7seg_1(
       .clk(clk_1hz),
       .reset(reset),
       .enable(clk_5h_ena),
       .bcd(mm),
       .sseg(mm));
        
    assign pm = clk_5h_ena;
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_1hz, clk_5h, clk_1hz_ena, clk_5h_ena;
    
    clk_gen_0 top_clk(
       .clk(clk),
       .reset(reset),
       .ena(clk_1hz_ena),
       .clk_1hz(clk_1hz),
       .clk_5h(clk_5h));
    
    clk_gen_1 top_clk_1hz(
       .clk(clk_1hz),
       .reset(reset),
       .ena(clk_1hz_ena),
       .clk_1hz(clk_1hz));
        
    clk_gen_2 top_clk_5h(
       .clk(clk_5h),
       .reset(reset),
       .ena(clk_5h_ena),
       .clk_5h(clk_5h));
        
    clk_div_0 top_clk_div(
       .clk(clk),
       .reset(reset),
       .ena(ena),
       .clk_out(clk_1hz));
        
    clk_div_1 top_clk_div_1hz(
       .clk(clk_1hz),
       .reset(reset),
       .ena(clk_1hz_ena),
       .clk_out(clk_5h));
        
    bcd_to_7seg top_bcd_to_7seg_0(
       .clk(clk),
       .reset(reset),
       .enable(clk_1hz_ena),
       .bcd(hh),
       .sseg(ss));
        
    bcd_to_7seg top_bcd_to_7seg_1(
       .clk(clk_1hz),
       .reset(reset),
       .enable(clk_5h_ena),
       .bcd(mm),
       .sseg(mm));
        
    assign pm = clk_5h_ena;
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] c_hour;
    wire [3:0] c_min;
    wire [3:0] c_sec;
    
    // count up to 12:59:59
    bcdcount counter_hour(clk, reset, ena, c_hour);
    
    // count up to 59:59
    bcdcount counter_min(clk, reset, ena, c_min);
    
    // count up to 59:59
    bcdcount counter_sec(clk, reset, ena, c_sec);
    
    // decide whether it's PM or AM
    assign pm = c_hour == 12? 1'b1 : 1'b0;
    
    // output the hour
    assign hh = c_hour % 10;
    
    // output the minutes
    assign mm = c_min % 10;
    
    // output the seconds
    assign ss = c_sec % 10;
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] c_hour;
    wire [3:0] c_min;
    wire [3:0] c_sec;
    
    // count up to 12:59:59
    bcdcount counter_hour(clk, reset, ena, c_hour);
    
    // count up to 59:59
    bcdcount counter_min(clk, reset, ena, c_min);
    
    // count up to 59:59
    bcdcount counter_sec(clk, reset, ena, c_sec);
    
    // decide whether it's PM or AM
    assign pm = c_hour == 12? 1'b1 : 1'b0;
    
    // output the hour
    assign hh = c_hour % 10;
    
    // output the minutes
    assign mm = c_min % 10;
    
    // output the seconds
    assign ss = c_sec % 10;
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] h_out, m_out, s_out;
    
    bcd_to_7seg seg0(.sin(h_out),.seg(hh));
    bcd_to_7seg seg1(.sin(m_out),.seg(mm));
    bcd_to_7seg seg2(.sin(s_out),.seg(ss));
    
    wire [3:0] h_in, m_in, s_in;
    
    assign h_in = ena? h_out : 4'd0;
    assign m_in = ena? m_out : 4'd0;
    assign s_in = ena? s_out : 4'd0;
    
    wire [3:0] h_next, m_next, s_next;
    
    assign h_next = ena? h_in : 4'd0;
    assign m_next = ena? m_in : 4'd0;
    assign s_next = ena? s_in : 4'd0;
    
    wire [3:0] h_out_next, m_out_next, s_out_next;
    
    assign h_out_next = ena? h_next : 4'd0;
    assign m_out_next = ena? m_next : 4'd0;
    assign s_out_next = ena? s_next : 4'd0;
    
    wire [3:0] h_out_next_next, m_out_next_next, s_out_next_next;
    
    assign h_out_next_next = ena? h_out_next : 4'd0;
    assign m_out_next_next = ena? m_out_next : 4'd0;
    assign s_out_next_next = ena? s_out_next : 4'd0;
    
    wire [3:0] h_out_next_next_next, m_out_next_next_next, s_out_next_next_next;
    
    assign h_out_next_next_next = ena? h_out_next_next : 4'd0;
    assign m_out_next_next_next = ena? m_out_next_next : 4'd0;
    assign s_out_next_next_next = ena? s_out_next_next : 4'd0;
    
    wire [3:0] h_out_next_next_next_next, m_out_next_next_next_next, s_out_next_next_next_next;
    
    assign h_out_next_next_next_next = ena? h_out_next_next_next : 4'd0;
    assign m_out_next_next_next_next = ena? m_out_next_next_next : 4'd0;
    assign s_out_next_next_next_next = ena? s_out_next_next_next : 4'd0;
    
    wire [3:0] h_out_next_next_next_next_next, m_out_next_next_next_next_next, s_out_next_next_next_next_next;
    
    assign h_out_next_next_next_next_next = ena? h_out_next_next_next_next : 4'd0;
    assign m_out_next_next_next_next_next = ena? m_out_next_next_next_next : 4'd0;
    assign s_out_next_next_next_next_next = ena? s_out_next_next_next_next : 4'd0;
    
    wire [3:0] h_out_next_next_next_next_next_next, m_out_next_next_next_next_next_next, s_out_next_next_next_next_next_next;
    
    assign h_out_next_next_next_next_next_next = ena? h_out_next_next_next_next_next : 4'd0;
    assign m_out_next_next_",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] h_out, m_out, s_out;
    
    bcd_to_7seg seg0(.sin(h_out),.seg(hh));
    bcd_to_7seg seg1(.sin(m_out),.seg(mm));
    bcd_to_7seg seg2(.sin(s_out),.seg(ss));
    
    wire [3:0] h_in, m_in, s_in;
    
    assign h_in = ena? h_out : 4'd0;
    assign m_in = ena? m_out : 4'd0;
    assign s_in = ena? s_out : 4'd0;
    
    wire [3:0] h_next, m_next, s_next;
    
    assign h_next = ena? h_in : 4'd0;
    assign m_next = ena? m_in : 4'd0;
    assign s_next = ena? s_in : 4'd0;
    
    wire [3:0] h_out_next, m_out_next, s_out_next;
    
    assign h_out_next = ena? h_next : 4'd0;
    assign m_out_next = ena? m_next : 4'd0;
    assign s_out_next = ena? s_next : 4'd0;
    
    wire [3:0] h_out_next_next, m_out_next_next, s_out_next_next;
    
    assign h_out_next_next = ena? h_out_next : 4'd0;
    assign m_out_next_next = ena? m_out_next : 4'd0;
    assign s_out_next_next = ena? s_out_next : 4'd0;
    
    wire [3:0] h_out_next_next_next, m_out_next_next_next, s_out_next_next_next;
    
    assign h_out_next_next_next = ena? h_out_next_next : 4'd0;
    assign m_out_next_next_next = ena? m_out_next_next : 4'd0;
    assign s_out_next_next_next = ena? s_out_next_next : 4'd0;
    
    wire [3:0] h_out_next_next_next_next, m_out_next_next_next_next, s_out_next_next_next_next;
    
    assign h_out_next_next_next_next = ena? h_out_next_next_next : 4'd0;
    assign m_out_next_next_next_next = ena? m_out_next_next_next : 4'd0;
    assign s_out_next_next_next_next = ena? s_out_next_next_next : 4'd0;
    
    wire [3:0] h_out_next_next_next_next_next, m_out_next_next_next_next_next, s_out_next_next_next_next_next;
    
    assign h_out_next_next_next_next_next = ena? h_out_next_next_next_next : 4'd0;
    assign m_out_next_next_next_next_next = ena? m_out_next_next_next_next : 4'd0;
    assign s_out_next_next_next_next_next = ena? s_out_next_next_next_next : 4'd0;
    
    wire [3:0] h_out_next_next_next_next_next_next, m_out_next_next_next_next_next_next, s_out_next_next_next_next_next_next;
    
    assign h_out_next_next_next_next_next_next = ena? h_out_next_next_next_next_next : 4'd0;
    assign m_out_next_next_","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] h_bin, m_bin, s_bin;
    wire [3:0] h_bcd, m_bcd, s_bcd;
    wire [3:0] h_bin2, m_bin2, s_bin2;
    wire [3:0] h_bcd2, m_bcd2, s_bcd2;
    
    bin2bcd bin2bcd_h(.bin(h_bin),.bcd(h_bcd));
    bin2bcd bin2bcd_m(.bin(m_bin),.bcd(m_bcd));
    bin2bcd bin2bcd_s(.bin(s_bin),.bcd(s_bcd));
    
    bcd2bin bcd2bin_h(.bcd(h_bcd),.bin(h_bin2));
    bcd2bin bcd2bin_m(.bcd(m_bcd),.bin(m_bin2));
    bcd2bin bcd2bin_s(.bcd(s_bcd),.bin(s_bin2));
    
    reg [3:0] h_reg, m_reg, s_reg;
    reg [3:0] h_reg2, m_reg2, s_reg2;
    
    always @(posedge clk) begin
        if(reset) begin
            h_reg <= 4'd0;
            m_reg <= 4'd0;
            s_reg <= 4'd0;
        end else begin
            if(ena) begin
                h_reg <= h_bin2;
                m_reg <= m_bin2;
                s_reg <= s_bin2;
            end
        end
    end
    
    assign h_bin2 = h_reg;
    assign m_bin2 = m_reg;
    assign s_bin2 = s_reg;
    
    assign h_bcd2 = h_reg;
    assign m_bcd2 = m_reg;
    assign s_bcd2 = s_reg;
    
    assign h_bin = h_reg2;
    assign m_bin = m_reg2;
    assign s_bin = s_reg2;
    
    assign h_bcd = h_reg2;
    assign m_bcd = m_reg2;
    assign s_bcd = s_reg2;
    
    always @(posedge clk) begin
        if(reset) begin
            h_reg2 <= 4'd0;
            m_reg2 <= 4'd0;
            s_reg2 <= 4'd0;
        end else begin
            if(ena) begin
                h_reg2 <= h_bcd2;
                m_reg2 <= m_bcd2;
                s_reg2 <= s_bcd2;
            end
        end
    end
    
    assign pm = (h_reg2 > 4'd11)? 1'b1 : 1'b0;
    
    bcd2bcd bin2bcd_hh(.bcd(h_reg2),.bin(h_bcd2));
    bcd2bcd bin2bcd_mm(.bcd(m_reg2),.bin(m_bcd2));
    bcd2bcd bin2bcd_ss(.bcd(s_reg2),.bin(s_bcd2));
    
    assign hh = h_bcd2;
    assign mm = m_bcd2;
    assign ss = s_bcd2;
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] h_bin, m_bin, s_bin;
    wire [3:0] h_bcd, m_bcd, s_bcd;
    wire [3:0] h_bin2, m_bin2, s_bin2;
    wire [3:0] h_bcd2, m_bcd2, s_bcd2;
    
    bin2bcd bin2bcd_h(.bin(h_bin),.bcd(h_bcd));
    bin2bcd bin2bcd_m(.bin(m_bin),.bcd(m_bcd));
    bin2bcd bin2bcd_s(.bin(s_bin),.bcd(s_bcd));
    
    bcd2bin bcd2bin_h(.bcd(h_bcd),.bin(h_bin2));
    bcd2bin bcd2bin_m(.bcd(m_bcd),.bin(m_bin2));
    bcd2bin bcd2bin_s(.bcd(s_bcd),.bin(s_bin2));
    
    reg [3:0] h_reg, m_reg, s_reg;
    reg [3:0] h_reg2, m_reg2, s_reg2;
    
    always @(posedge clk) begin
        if(reset) begin
            h_reg <= 4'd0;
            m_reg <= 4'd0;
            s_reg <= 4'd0;
        end else begin
            if(ena) begin
                h_reg <= h_bin2;
                m_reg <= m_bin2;
                s_reg <= s_bin2;
            end
        end
    end
    
    assign h_bin2 = h_reg;
    assign m_bin2 = m_reg;
    assign s_bin2 = s_reg;
    
    assign h_bcd2 = h_reg;
    assign m_bcd2 = m_reg;
    assign s_bcd2 = s_reg;
    
    assign h_bin = h_reg2;
    assign m_bin = m_reg2;
    assign s_bin = s_reg2;
    
    assign h_bcd = h_reg2;
    assign m_bcd = m_reg2;
    assign s_bcd = s_reg2;
    
    always @(posedge clk) begin
        if(reset) begin
            h_reg2 <= 4'd0;
            m_reg2 <= 4'd0;
            s_reg2 <= 4'd0;
        end else begin
            if(ena) begin
                h_reg2 <= h_bcd2;
                m_reg2 <= m_bcd2;
                s_reg2 <= s_bcd2;
            end
        end
    end
    
    assign pm = (h_reg2 > 4'd11)? 1'b1 : 1'b0;
    
    bcd2bcd bin2bcd_hh(.bcd(h_reg2),.bin(h_bcd2));
    bcd2bcd bin2bcd_mm(.bcd(m_reg2),.bin(m_bcd2));
    bcd2bcd bin2bcd_ss(.bcd(s_reg2),.bin(s_bcd2));
    
    assign hh = h_bcd2;
    assign mm = m_bcd2;
    assign ss = s_bcd2;
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_1hz, clk_1hz_pm;
    wire [3:0] secs, mins, tens, ones;
    wire [3:0] secs_pm, mins_pm, tens_pm, ones_pm;
    
    clock_divider_circuit cd1(clk, reset, clk_1hz);
    clock_divider_circuit cd2(clk, reset, clk_1hz_pm);
    bcd_to_7seg bcd1(clk_1hz, secs, tens, ones);
    bcd_to_7seg bcd2(clk_1hz_pm, secs_pm, tens_pm, ones_pm);
    
    assign hh = {tens_pm, ones_pm};
    assign mm = {tens, ones};
    assign ss = {secs, tens, ones};
    assign pm = clk_1hz_pm;
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_1hz, clk_1hz_pm;
    wire [3:0] secs, mins, tens, ones;
    wire [3:0] secs_pm, mins_pm, tens_pm, ones_pm;
    
    clock_divider_circuit cd1(clk, reset, clk_1hz);
    clock_divider_circuit cd2(clk, reset, clk_1hz_pm);
    bcd_to_7seg bcd1(clk_1hz, secs, tens, ones);
    bcd_to_7seg bcd2(clk_1hz_pm, secs_pm, tens_pm, ones_pm);
    
    assign hh = {tens_pm, ones_pm};
    assign mm = {tens, ones};
    assign ss = {secs, tens, ones};
    assign pm = clk_1hz_pm;
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_1hz, clk_5ms;
    
    clk_gen_0 top_module(.clk(clk),.reset(reset),.ena(ena),.clk_1hz(clk_1hz),.clk_5ms(clk_5ms));
    
    clk_divider_0 top_module(.clk(clk_1hz),.reset(reset),.clk_out(clk_5ms));
    
    bcd_to_7seg_0 top_module(.clk(clk_5ms),.reset(reset),.bcd(ss),.seg(ss));
    
    bcd_to_7seg_1 top_module(.clk(clk_5ms),.reset(reset),.bcd(mm),.seg(mm));
    
    bcd_to_7seg_2 top_module(.clk(clk_5ms),.reset(reset),.bcd(hh),.seg(hh));
    
    pm_gen_0 top_module(.clk(clk_1hz),.reset(reset),.clk_out(pm));
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_1hz, clk_5ms;
    
    clk_gen_0 top_module(.clk(clk),.reset(reset),.ena(ena),.clk_1hz(clk_1hz),.clk_5ms(clk_5ms));
    
    clk_divider_0 top_module(.clk(clk_1hz),.reset(reset),.clk_out(clk_5ms));
    
    bcd_to_7seg_0 top_module(.clk(clk_5ms),.reset(reset),.bcd(ss),.seg(ss));
    
    bcd_to_7seg_1 top_module(.clk(clk_5ms),.reset(reset),.bcd(mm),.seg(mm));
    
    bcd_to_7seg_2 top_module(.clk(clk_5ms),.reset(reset),.bcd(hh),.seg(hh));
    
    pm_gen_0 top_module(.clk(clk_1hz),.reset(reset),.clk_out(pm));
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_out;
    wire [3:0] clk_out2;
    wire [3:0] clk_out3;
    
    clk_wiz_0 my_clk_inst (.clk_out1(clk_out),.clk_in1(clk));
    clk_wiz_0_0 my_clk_inst2 (.clk_out1(clk_out2),.clk_in1(clk));
    clk_wiz_0_0 my_clk_inst3 (.clk_out1(clk_out3),.clk_in1(clk));
    
    reg [7:0] hh_r, mm_r, ss_r;
    
    always @(posedge clk_out) begin
        if (reset) begin
            hh_r <= 8'h12;
            mm_r <= 8'h00;
            ss_r <= 8'h00;
        end
        else begin
            if (ena) begin
                if (ss_r == 8'h59) begin
                    ss_r <= 8'h00;
                    if (mm_r == 8'h59) begin
                        mm_r <= 8'h00;
                        if (hh_r == 8'h23) begin
                            hh_r <= 8'h00;
                        end
                        else begin
                            if (hh_r == 8'h11)
                                hh_r <= 8'h12;
                            else
                                hh_r <= hh_r + 1;
                        end
                    end
                    else begin
                        mm_r <= mm_r + 1;
                    end
                end
                else begin
                    ss_r <= ss_r + 1;
                end
            end
        end
    end
    
    assign pm = (hh_r == 8'h11) & (mm_r == 8'h59) & (ss_r == 8'h59);
    
    assign hh = hh_r;
    assign mm = mm_r;
    assign ss = ss_r;
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire clk_out;
    wire [3:0] clk_out2;
    wire [3:0] clk_out3;
    
    clk_wiz_0 my_clk_inst (.clk_out1(clk_out),.clk_in1(clk));
    clk_wiz_0_0 my_clk_inst2 (.clk_out1(clk_out2),.clk_in1(clk));
    clk_wiz_0_0 my_clk_inst3 (.clk_out1(clk_out3),.clk_in1(clk));
    
    reg [7:0] hh_r, mm_r, ss_r;
    
    always @(posedge clk_out) begin
        if (reset) begin
            hh_r <= 8'h12;
            mm_r <= 8'h00;
            ss_r <= 8'h00;
        end
        else begin
            if (ena) begin
                if (ss_r == 8'h59) begin
                    ss_r <= 8'h00;
                    if (mm_r == 8'h59) begin
                        mm_r <= 8'h00;
                        if (hh_r == 8'h23) begin
                            hh_r <= 8'h00;
                        end
                        else begin
                            if (hh_r == 8'h11)
                                hh_r <= 8'h12;
                            else
                                hh_r <= hh_r + 1;
                        end
                    end
                    else begin
                        mm_r <= mm_r + 1;
                    end
                end
                else begin
                    ss_r <= ss_r + 1;
                end
            end
        end
    end
    
    assign pm = (hh_r == 8'h11) & (mm_r == 8'h59) & (ss_r == 8'h59);
    
    assign hh = hh_r;
    assign mm = mm_r;
    assign ss = ss_r;
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] h_in, m_in, s_in;
    wire [3:0] h_out, m_out, s_out;
    
    reg pm_out;
    
    bcd_to_7seg bcd_to_7seg_h(h_in, h_out);
    bcd_to_7seg bcd_to_7seg_m(m_in, m_out);
    bcd_to_7seg bcd_to_7seg_s(s_in, s_out);
    
    always @(posedge clk) begin
        if(reset) begin
            pm_out <= 0;
        end
        else begin
            if(ena) begin
                pm_out <= ~pm_out;
            end
        end
    end
    
    assign pm = pm_out;
    assign hh = ~h_out;
    assign mm = ~m_out;
    assign ss = ~s_out;
    
endmodule",-1,Count_clock.v,"// Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second).

// reset resets the clock to 12:00 AM. pm is 0 for AM and 1 for PM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset has higher priority than enable, and can occur even when not enabled.

// Hint: Note that 11:59:59 PM advances to 12:00:00 AM, and 12:59:59 PM advances to 01:00:00 PM. There is no 00:00:00.

module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
","module top_module(
    input clk,
    input reset,
    input ena,
    output pm,
    output [7:0] hh,
    output [7:0] mm,
    output [7:0] ss);
    
    wire [3:0] h_in, m_in, s_in;
    wire [3:0] h_out, m_out, s_out;
    
    reg pm_out;
    
    bcd_to_7seg bcd_to_7seg_h(h_in, h_out);
    bcd_to_7seg bcd_to_7seg_m(m_in, m_out);
    bcd_to_7seg bcd_to_7seg_s(s_in, s_out);
    
    always @(posedge clk) begin
        if(reset) begin
            pm_out <= 0;
        end
        else begin
            if(ena) begin
                pm_out <= ~pm_out;
            end
        end
    end
    
    assign pm = pm_out;
    assign hh = ~h_out;
    assign mm = ~m_out;
    assign ss = ~s_out;
    
endmodule","module top_module 
    (
        input clk,
        input reset,
        input ena,
        output pm,
        output [7:0] hh,
        output [7:0] mm,
        output [7:0] ss
    );

    reg p;  //0: am, 1: pm
    reg [7:0] h;
    reg [7:0] m;
    reg [7:0] s;

    always @ (posedge clk)
        begin
            if(reset)
                begin
                    p <= 0;
                    h <= 8'h12;
                    m <= 8'h00;
                    s <= 8'h00;
                end
            else
                begin
                    if(ena)
                        begin
                            if(s < 8'h59)
                                begin
                                    if(s[3:0] < 4'h9)
                                        begin
                                            s[3:0] <= s[3:0] + 1'h1; 
                                        end
                                    else
                                        begin
                                            s[3:0] <= 0;
                                            s[7:4] <= s[7:4] + 1'h1;
                                        end 
                                end
                            else
                                begin
                                    s <= 0;
                                    if(m < 8'h59)
                                        begin
                                            if(m[3:0] < 4'h9)
                                                begin
                                                    m[3:0] <= m[3:0] + 1'h1; 
                                                end 
                                            else
                                                begin
                                                    m[3:0] <= 0;
                                                    m[7:4] <= m[7:4] + 1'h1;
                                                end
                                        end
                                    else
                                        begin
                                            m <= 1'h0;
                                            if(h == 8'h11)
                                                p = !p;
                                            if(h < 8'h12)
                                                begin
                                                    if(h[3:0] < 4'h9)
                                                        h[3:0] <= h[3:0] + 1'h1;
                                                    else
                                                        begin
                                                            h[3:0] <= 4'h0;
                                                            h[7:4] <= h[7:4] + 1'h1;
                                                        end
                                                end
                                            else
                                                begin
                                                   h <= 1'h1; 
                                                end
                                        end
                                end
                        end
                end
        end

    assign pm = p;
    assign hh = h;
    assign mm = m;
    assign ss = s;

endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q <= q + 4'd1;
            if(q == 4'd9)
                q <= 4'd0;
        end
    end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q <= q + 4'd1;
            if(q == 4'd9)
                q <= 4'd0;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q <= q + 4'd1;
            if(q == 4'd9)
                q <= 4'd0;
        end
    end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q <= q + 4'd1;
            if(q == 4'd9)
                q <= 4'd0;
        end
    end
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= ~q[3];
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= ~q[3];
                end
        end

endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q[3] <= q[2];
            q[2] <= q[1];
            q[1] <= q[0];
            q[0] <= 1'b0;
        end
    end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q[3] <= q[2];
            q[2] <= q[1];
            q[1] <= q[0];
            q[0] <= 1'b0;
        end
    end
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= ~q[3];
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= ~q[3];
                end
        end

endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= 1'b0;
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= 1'b0;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= ~q[3];
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= ~q[3];
                end
        end

endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q[3] <= q[2];
            q[2] <= q[1];
            q[1] <= q[0];
            q[0] <= 1'b0;
        end
    end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q[3] <= q[2];
            q[2] <= q[1];
            q[1] <= q[0];
            q[0] <= 1'b0;
        end
    end
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= 1'b0;
                end
        end

endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= 1'b0;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= 1'b1;
                end
        end
endmodule",-1,Count10.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                begin
                    q[3] <= q[2];
                    q[2] <= q[1];
                    q[1] <= q[0];
                    q[0] <= 1'b1;
                end
        end
endmodule","module top_module (
    input clk,
    input reset,        // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 9) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if(reset)
            q <= 4'd0;
    	else
            q <= q + 4'd1;
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if(reset)
            q <= 4'd0;
    	else
            q <= q + 4'd1;
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if (reset)
            q <= 4'd0;
        else
            q <= q + 4'd1;

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if (reset)
            q <= 4'd0;
        else
            q <= q + 4'd1;

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q[0] <= q[3];
            q[1] <= q[0];
            q[2] <= q[1];
            q[3] <= q[2] ^ q[3];
        end
    end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk) begin
        if(reset)
            q <= 4'd0;
        else begin
            q[0] <= q[3];
            q[1] <= q[0];
            q[2] <= q[1];
            q[3] <= q[2] ^ q[3];
        end
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if(reset)
            q <= 4'd0;
        else
            q <= q + 4'd1;

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if(reset)
            q <= 4'd0;
        else
            q <= q + 4'd1;

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if(reset)
            q <= 4'd0;
    	else
            q <= q + 4'd1;
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        if(reset)
            q <= 4'd0;
    	else
            q <= q + 4'd1;
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk) begin
        if(reset)
            q <= 4'd0;
        else
            q <= q + 4'd1;
    end

endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk) begin
        if(reset)
            q <= 4'd0;
        else
            q <= q + 4'd1;
    end

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end
endmodule",-1,Count15.v,"// Build a 4-bit binary counter that counts from 0 through 15, inclusive, with a period of 16. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else
                q <= q + 4'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous active-high reset
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(q == 15) begin
                q <= 0;
            end
            else begin
                q <= q + 1;
            end
        end
    end

endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q); 

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q); 

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if (reset)
                q <= 4'd1;
            else if (q == 10)
                q <= 4'd1;
            else
                q <= q + 4'd1;
        end
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if (reset)
                q <= 4'd1;
            else if (q == 10)
                q <= 4'd1;
            else
                q <= q + 4'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if (reset)
                q <= 4'd1;
            else if (q == 10)
                q <= 4'd1;
            else
                q <= q + 4'd1;
        end
endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if (reset)
                q <= 4'd1;
            else if (q == 10)
                q <= 4'd1;
            else
                q <= q + 4'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 1;
                    else
                        q <= q + 1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 1;
                    else
                        q <= q + 1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q); 

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q); 

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule",-1,Count1to10.v,"// Make a decade counter that counts 1 through 10, inclusive. The reset input is synchronous, and should reset the counter to 1.

module top_module (
    input clk,
    input reset,
    output [3:0] q);","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 4'd1;
            else
                begin
                    if(q == 9)
                        q <= 4'd1;
                    else
                        q <= q + 1'b1;
                end
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 1;
        end
        else begin
            if(q == 10) begin
                q <= 1;
            end
            else begin
                q <= q + 1;
            end
        end
    end
    
endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter #(.WIDTH(4)) decade_counter0 (
       .clk(clk),
       .reset(reset),
       .q(q_d),
       .ena(1'b1),
       .enb(1'b1),
       .enc(1'b1),
       .enl(1'b1)
    );
    
    assign q = {q_d, q_d, q_d, q_d};
    assign ena = {q_d[3], q_d[3], q_d[3], 1'b1};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter #(.WIDTH(4)) decade_counter0 (
       .clk(clk),
       .reset(reset),
       .q(q_d),
       .ena(1'b1),
       .enb(1'b1),
       .enc(1'b1),
       .enl(1'b1)
    );
    
    assign q = {q_d, q_d, q_d, q_d};
    assign ena = {q_d[3], q_d[3], q_d[3], 1'b1};
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] ena_bar;
    
    assign ena_bar = 4'b1100;
    
    decade_counter dc0 (clk, reset, ena_bar[0], q[3:0]);
    decade_counter dc1 (clk, reset, ena_bar[1], q[7:4]);
    decade_counter dc2 (clk, reset, ena_bar[2], q[11:8]);
    decade_counter dc3 (clk, reset, ena_bar[3], q[15:12]);
    
    assign ena = {q[3:1] == 4'd1, q[7:4] == 4'd1, q[11:8] == 4'd1, q[15:12] == 4'd1};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] ena_bar;
    
    assign ena_bar = 4'b1100;
    
    decade_counter dc0 (clk, reset, ena_bar[0], q[3:0]);
    decade_counter dc1 (clk, reset, ena_bar[1], q[7:4]);
    decade_counter dc2 (clk, reset, ena_bar[2], q[11:8]);
    decade_counter dc3 (clk, reset, ena_bar[3], q[15:12]);
    
    assign ena = {q[3:1] == 4'd1, q[7:4] == 4'd1, q[11:8] == 4'd1, q[15:12] == 4'd1};
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter u1(clk, reset, 1'b1, q_d);
    
    assign ena = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
    assign q = {q_d[3:1], q_d[0]};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter u1(clk, reset, 1'b1, q_d);
    
    assign ena = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
    assign q = {q_d[3:1], q_d[0]};
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // One-hot encoding of numbers 0-9 (10 total)
    reg [3:0] ones = 4'd0;
    reg [3:0] tens = 4'd0;
    reg [3:0] hundreds = 4'd0;
    reg [3:0] thousands = 4'd0;
    
    // Count how many times each digit is to be incremented
    reg [1:0] ones_to_increment = 2'd0;
    reg [1:0] tens_to_increment = 2'd0;
    reg [1:0] hundreds_to_increment = 2'd0;
    reg [1:0] thousands_to_increment = 2'd0;
    
    // Keep track of which digit to increment
    reg [3:0] digit_to_increment = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_ones = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_tens = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_hundreds = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay2 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay3 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay4 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay5 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay6 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay7 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay8 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay9 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay10 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay11 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay12 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay13 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay14 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay15 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay16 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay17 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay18 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay19 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay20 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay21 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay22 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay23 = 4'd0;
    
    // 4-bit",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // One-hot encoding of numbers 0-9 (10 total)
    reg [3:0] ones = 4'd0;
    reg [3:0] tens = 4'd0;
    reg [3:0] hundreds = 4'd0;
    reg [3:0] thousands = 4'd0;
    
    // Count how many times each digit is to be incremented
    reg [1:0] ones_to_increment = 2'd0;
    reg [1:0] tens_to_increment = 2'd0;
    reg [1:0] hundreds_to_increment = 2'd0;
    reg [1:0] thousands_to_increment = 2'd0;
    
    // Keep track of which digit to increment
    reg [3:0] digit_to_increment = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_ones = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_tens = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_hundreds = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay2 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay3 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay4 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay5 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay6 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay7 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay8 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay9 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay10 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay11 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay12 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay13 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay14 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay15 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay16 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay17 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay18 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay19 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay20 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay21 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay22 = 4'd0;
    
    // 4-bit binary counter
    reg [3:0] count_thousands_delay23 = 4'd0;
    
    // 4-bit","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // One-hot decoder to generate enable signals for each decade
    // The input to the decoder must be one-hot
    
    assign ena[1] = q[3] | q[7] | q[11] | q[15];
    assign ena[2] = q[7] | q[11] | q[15];
    assign ena[3] = q[11] | q[15];
    
    // Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc.
    
    // Instantiate each decade counter using the generate code
    
    // For example, the ones digit is q[3:0] and the tens digit is q[7:4]
    
    // You may want to modify the generate code to instantiate each digit
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // One-hot decoder to generate enable signals for each decade
    // The input to the decoder must be one-hot
    
    assign ena[1] = q[3] | q[7] | q[11] | q[15];
    assign ena[2] = q[7] | q[11] | q[15];
    assign ena[3] = q[11] | q[15];
    
    // Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc.
    
    // Instantiate each decade counter using the generate code
    
    // For example, the ones digit is q[3:0] and the tens digit is q[7:4]
    
    // You may want to modify the generate code to instantiate each digit
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want to modify the generate code to instantiate each decade counter
    
    // You may want","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d, ena_d;
    
    decade_counter_4b d0 (clk, reset, ena[0], q[3:0], q_d[3:0]);
    decade_counter_4b d1 (clk, reset, ena[1], q[7:4], q_d[7:4]);
    decade_counter_4b d2 (clk, reset, ena[2], q[11:8], q_d[11:8]);
    decade_counter_4b d3 (clk, reset, ena[3], q[15:12], q_d[15:12]);
    
    assign ena_d = ena + q_d;
    
    always @(*)
        if(reset)
            q = 0;
        else
            q = ena_d;
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d, ena_d;
    
    decade_counter_4b d0 (clk, reset, ena[0], q[3:0], q_d[3:0]);
    decade_counter_4b d1 (clk, reset, ena[1], q[7:4], q_d[7:4]);
    decade_counter_4b d2 (clk, reset, ena[2], q[11:8], q_d[11:8]);
    decade_counter_4b d3 (clk, reset, ena[3], q[15:12], q_d[15:12]);
    
    assign ena_d = ena + q_d;
    
    always @(*)
        if(reset)
            q = 0;
        else
            q = ena_d;
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // One-hot encoding of the enable signals.
    // ena[1] is asserted when any of the upper 3 digits should be incremented.
    // ena[2] is asserted when any of the middle 2 digits should be incremented.
    // ena[3] is asserted when any of the lower 2 digits should be incremented.
    
    // One-hot encoding of the lower 2 digits.
    // q[3] is asserted when any of the lower 2 digits should be incremented.
    // q[7] is asserted when any of the middle 2 digits should be incremented.
    // q[11] is asserted when any of the upper 3 digits should be incremented.
    
    // One-hot encoding of the middle 2 digits.
    // q[9] is asserted when any of the middle 2 digits should be incremented.
    // q[10] is asserted when any of the upper 3 digits should be incremented.
    
    // One-hot encoding of the upper 3 digits.
    // q[15] is asserted when any of the upper 3 digits should be incremented.
    
    // Instantiate the decade counters as shown above.
    
    // The reset synchronizes the decade counters.
    // The enable signals enable the decade counters to increment.
    // The outputs of the decade counters are fed into the one-hot encoder.
    
    // The one-hot encoder output is assigned to the q output.
    
    // Note that the one-hot encoder output is only one bit wide, so it is
    // necessary to use a 16-entry truth table to model the full truth table
    // of the q output.
    
    // The truth table is as follows:
    // q[15]  q[14]  q[13]  q[12]  q[11]  q[10]  q[9]  q[8]  q[7]  q[6]  q[5]  q[4]  q[3]  q[2]  q[1]  q[0]  | q[15:0]
    // 0      x      x      x      x      x      x      x      x      x      x      x      x      x      x      x      x      | xxxxxxxxxxxxxxxx
    // 1      1      1      1      1      1      1      1      1      1      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 1      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      | xxxxxxxxxxxxxxxx
    // 1      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      | xxxxxxxxxxxxxxxx
    // 0      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      1      0      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      1      1      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      1      1      1      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      1      1      1      1",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    // One-hot encoding of the enable signals.
    // ena[1] is asserted when any of the upper 3 digits should be incremented.
    // ena[2] is asserted when any of the middle 2 digits should be incremented.
    // ena[3] is asserted when any of the lower 2 digits should be incremented.
    
    // One-hot encoding of the lower 2 digits.
    // q[3] is asserted when any of the lower 2 digits should be incremented.
    // q[7] is asserted when any of the middle 2 digits should be incremented.
    // q[11] is asserted when any of the upper 3 digits should be incremented.
    
    // One-hot encoding of the middle 2 digits.
    // q[9] is asserted when any of the middle 2 digits should be incremented.
    // q[10] is asserted when any of the upper 3 digits should be incremented.
    
    // One-hot encoding of the upper 3 digits.
    // q[15] is asserted when any of the upper 3 digits should be incremented.
    
    // Instantiate the decade counters as shown above.
    
    // The reset synchronizes the decade counters.
    // The enable signals enable the decade counters to increment.
    // The outputs of the decade counters are fed into the one-hot encoder.
    
    // The one-hot encoder output is assigned to the q output.
    
    // Note that the one-hot encoder output is only one bit wide, so it is
    // necessary to use a 16-entry truth table to model the full truth table
    // of the q output.
    
    // The truth table is as follows:
    // q[15]  q[14]  q[13]  q[12]  q[11]  q[10]  q[9]  q[8]  q[7]  q[6]  q[5]  q[4]  q[3]  q[2]  q[1]  q[0]  | q[15:0]
    // 0      x      x      x      x      x      x      x      x      x      x      x      x      x      x      x      x      | xxxxxxxxxxxxxxxx
    // 1      1      1      1      1      1      1      1      1      1      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 1      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      | xxxxxxxxxxxxxxxx
    // 1      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      | xxxxxxxxxxxxxxxx
    // 0      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      *      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      1      0      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      0      0      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      0      0      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      0      0      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      0      1      1      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      0      1      1      1      1      1      1      1      1      1      1      | xxxxxxxxxxxxxxxx
    // 0      0      0      0      0      0      0      1      1      1      1","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter d0 (clk, reset, q_d[0], ena[0]);
    decade_counter d1 (clk, reset, q_d[1], ena[1]);
    decade_counter d2 (clk, reset, q_d[2], ena[2]);
    decade_counter d3 (clk, reset, q_d[3], ena[3]);
    
    assign q = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter d0 (clk, reset, q_d[0], ena[0]);
    decade_counter d1 (clk, reset, q_d[1], ena[1]);
    decade_counter d2 (clk, reset, q_d[2], ena[2]);
    decade_counter d3 (clk, reset, q_d[3], ena[3]);
    
    assign q = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter_4b dec4b(.clk(clk),.reset(reset),.ena(1'b1),.q(q_d));
    
    assign ena = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
    assign q = {q_d[3:1], q_d[0]};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter_4b dec4b(.clk(clk),.reset(reset),.ena(1'b1),.q(q_d));
    
    assign ena = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
    assign q = {q_d[3:1], q_d[0]};
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter #(.WIDTH(4)) decade_counter0 (clk, reset, q_d[0], ena[0]);
    decade_counter #(.WIDTH(4)) decade_counter1 (clk, reset, q_d[1], ena[1]);
    decade_counter #(.WIDTH(4)) decade_counter2 (clk, reset, q_d[2], ena[2]);
    decade_counter #(.WIDTH(4)) decade_counter3 (clk, reset, q_d[3], ena[3]);
    
    assign q = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
endmodule",-1,Countbcd.v,"// Build a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is encoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit, etc. For digits [3:1], also output an enable signal indicating when each of the upper three digits should be incremented.

// You may want to instantiate or modify some one-digit decade counters.

module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    wire [3:0] q_d;
    
    decade_counter #(.WIDTH(4)) decade_counter0 (clk, reset, q_d[0], ena[0]);
    decade_counter #(.WIDTH(4)) decade_counter1 (clk, reset, q_d[1], ena[1]);
    decade_counter #(.WIDTH(4)) decade_counter2 (clk, reset, q_d[2], ena[2]);
    decade_counter #(.WIDTH(4)) decade_counter3 (clk, reset, q_d[3], ena[3]);
    
    assign q = {q_d[3], q_d[2], q_d[1], q_d[0]};
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous active-high reset
    output [3:1] ena,
    output [15:0] q);
    
    always @(posedge clk) begin
        if(reset) begin
            q = 0;
            ena = 0;
        end
        else begin
            q[3:0] = q[3:0] + 1;
            ena[1] = (q[3:0] == 9) ? 1 : 0;
            if(q[3:0] == 10) begin
                q[3:0] = 0;
                q[7:4] = q[7:4] + 1;
            end
            ena[2] = ((q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[7:4] == 10) begin
                q[7:4] = 0;
                q[11:8] = q[11:8] + 1;
            end
            ena[3] = ((q[11:8] == 9) && (q[7:4] == 9) && (q[3:0] == 9)) ? 1 : 0;
            if(q[11:8] == 10) begin
                q[11:8] = 0;
                q[15:12] = q[15:12] + 1;
            end
            if(q[15:12] == 10) begin
                q = 0;
            end
        end
    end

endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Modify FSM and datapath from Fsm_serialdata
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7, S8 = 8, S9 = 9;
    reg [3:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S2;
                else
                    next_state <= S1;
            end
            S2: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S3;
                else
                    next_state <= S2;
            end
            S3: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S4;
                else
                    next_state <= S3;
            end
            S4: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S5;
                else
                    next_state <= S4;
            end
            S5: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S6;
                else
                    next_state <= S5;
            end
            S6: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S7;
                else
                    next_state <= S6;
            end
            S7: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S8;
                else
                    next_state <= S7;
            end
            S8: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S9;
                else
                    next_state <= S8;
            end
            S9: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S0;
                else
                    next_state <= S9;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign q = state;
endmodule",-0.5,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Modify FSM and datapath from Fsm_serialdata
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7, S8 = 8, S9 = 9;
    reg [3:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S2;
                else
                    next_state <= S1;
            end
            S2: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S3;
                else
                    next_state <= S2;
            end
            S3: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S4;
                else
                    next_state <= S3;
            end
            S4: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S5;
                else
                    next_state <= S4;
            end
            S5: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S6;
                else
                    next_state <= S5;
            end
            S6: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S7;
                else
                    next_state <= S6;
            end
            S7: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S8;
                else
                    next_state <= S7;
            end
            S8: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S9;
                else
                    next_state <= S8;
            end
            S9: begin
                if (!reset)
                    next_state <= S0;
                else if (slowena)
                    next_state <= S0;
                else
                    next_state <= S9;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign q = state;
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset |!slowena)
            q <= 4'd0;
        else
            q <= q + 4'd1;
endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset |!slowena)
            q <= 4'd0;
        else
            q <= q + 4'd1;
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;
endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;
    end
endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;
    end
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk) begin
        if (reset) begin
            q <= 4'd0;
        end
        else begin
            if (slowena) begin
                q <= q + 4'd1;
            end
        end
    end

endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk) begin
        if (reset) begin
            q <= 4'd0;
        end
        else begin
            if (slowena) begin
                q <= q + 4'd1;
            end
        end
    end

endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;

endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;

endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;

endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 4'd0;
        else if(slowena)
            q <= q + 4'd1;

endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else if(slowena)
                q <= q + 4'd1;
        end
endmodule",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 4'd0;
            else if(slowena)
                q <= q + 4'd1;
        end
endmodule","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use the active low reset signal, and an asynchronous enable signal.
    
    // The reset signal is active low, and is a wired-AND combination of the 
    // slowena and the clk.
    
    // The enable signal is active high, and is a wired-OR combination of the 
    // slowena and the clk.
    
    // The clk is the clock input, and the slowena is the enable signal.
    
    // The q output is the counter.
    
    // The q output should only be assigned when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use the active low reset signal, and an asynchronous enable signal.
    
    // The reset signal is active low, and is a wired-AND combination of the 
    // slowena and the clk.
    
    // The enable signal is active high, and is a wired-OR combination of the 
    // slowena and the clk.
    
    // The clk is the clock input, and the slowena is the enable signal.
    
    // The q output is the counter.
    
    // The q output should only be assigned when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the slowena is active.
    
    // The q output should only be incremented when the clk is active.
    
    // The q output should only be incremented when the reset signal is active.
    
    // The q output should only","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use two counters, one for each decade
    // (i.e. q0 is the most significant digit of the counter, and q4 the least significant digit)
    // The decade counter counts from 0 to 9, and the decade counter is only active when slowena is high
    
    // The decade counter is implemented as a 4-bit counter
    // (We could have also used a 4-bit DFF and a 1-bit enable, but this is somewhat clearer)
    
    // The decade counter is reset when reset is high, and when the slowena signal is high
    
    // The output is the value of the counter when the slowena signal is high
    
    // You may need to add a counter to the output, since the output is only updated when the slowena signal is high
    
    // Note that the counter increments on the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the falling edge of the clock
    
    // You may need to add a counter to the falling edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a",-1,Countslow.v,"// Build a decade counter that counts from 0 through 9, inclusive, with a period of 10. The reset input is synchronous, and should reset the counter to 0. We want to be able to pause the counter rather than always incrementing every clock cycle, so the slowena input indicates when the counter should increment.

// Hint: This is a regular decade counter with an enable control signal

module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);
    
    // Use two counters, one for each decade
    // (i.e. q0 is the most significant digit of the counter, and q4 the least significant digit)
    // The decade counter counts from 0 to 9, and the decade counter is only active when slowena is high
    
    // The decade counter is implemented as a 4-bit counter
    // (We could have also used a 4-bit DFF and a 1-bit enable, but this is somewhat clearer)
    
    // The decade counter is reset when reset is high, and when the slowena signal is high
    
    // The output is the value of the counter when the slowena signal is high
    
    // You may need to add a counter to the output, since the output is only updated when the slowena signal is high
    
    // Note that the counter increments on the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the falling edge of the clock
    
    // You may need to add a counter to the falling edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a counter to the rising edge of the clock
    
    // You may need to add a","module top_module (
    input clk,
    input slowena,
    input reset,
    output [3:0] q);

    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            if(slowena) begin
                if(q == 9) begin
                    q <= 0;
                end
                else begin
                    q <= q + 1;
                end
            end
        end
    end
    
endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Create a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Create a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk) begin
        q <= d;
    end
    
endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Create a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    always @(posedge clk) begin
        q <= d;
    end
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Create a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    always @(posedge clk) begin
        q <= d;
    end
endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;
        
endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;
        
endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule",-0.5,Dff_1.v,"// Create a single D flip-flop.
// Use a clocked always block
// copy d to q at every positive edge of clk
// Clocked always blocks should use non-blocking assignments

module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );
    
    // Use a clocked always block
    //   copy d to q at every positive edge of clk
    //   Clocked always blocks should use non-blocking assignments
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn)
            q <= 16'd0;
        else begin
            if(byteena[1])
                q[15:8] <= d[15:8];
            if(byteena[0])
                q[7:0] <= d[7:0];
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn)
            q <= 16'd0;
        else begin
            if(byteena[1])
                q[15:8] <= d[15:8];
            if(byteena[0])
                q[7:0] <= d[7:0];
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'd0;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'd0;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(!resetn) begin
            // reset
            q <= 16'h0000;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(!resetn) begin
            // reset
            q <= 16'h0000;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn)
            q <= 16'h0000;
        else begin
            if(byteena[1])
                q[15:8] <= d[15:8];
            if(byteena[0])
                q[7:0] <= d[7:0];
        end
    end
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn)
            q <= 16'h0000;
        else begin
            if(byteena[1])
                q[15:8] <= d[15:8];
            if(byteena[0])
                q[7:0] <= d[7:0];
        end
    end
    
endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            // reset
            q <= 16'h0000;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            if(byteena[0]) begin
                q[7:0] <= d[7:0];
            end
        end
    end
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            // reset
            q <= 16'h0000;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            if(byteena[0]) begin
                q[7:0] <= d[7:0];
            end
        end
    end
    
endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'h0000;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            if(byteena[0]) begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'h0000;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            if(byteena[0]) begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'd0;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'd0;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn)
            q <= 16'd0;
        else begin
            if(byteena[1])
                q[15:8] <= d[15:8];
            if(byteena[0])
                q[7:0] <= d[7:0];
        end
    end
    
endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn)
            q <= 16'd0;
        else begin
            if(byteena[1])
                q[15:8] <= d[15:8];
            if(byteena[0])
                q[7:0] <= d[7:0];
        end
    end
    
endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'b0;
        end else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            if(byteena[0]) begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'b0;
        end else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            if(byteena[0]) begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'd0;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule",-1,Dff16e.v,"// Create 16 D flip-flops. It's sometimes useful to only modify parts of a group of flip-flops. The byte-enable inputs control whether each byte of the 16 registers should be written to on that cycle. byteena[1] controls the upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].

// resetn is a synchronous, active-low reset.

// All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);

    always @(posedge clk) begin
        if(~resetn) begin
            q <= 16'd0;
        end
        else begin
            if(byteena[1]) begin
                q[15:8] <= d[15:8];
            end
            else begin
                q[7:0] <= d[7:0];
            end
        end
    end

endmodule","module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    
    always @(posedge clk) begin
        if(!resetn) begin
            q <= 0;
        end
        else begin
            q[15:8] <= byteena[1] ? d[15:8] : q[15:8];
            q[7:0] <= byteena[0] ? d[7:0] : q[7:0];
        end
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            q <= d;
        end

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            q <= d;
        end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            q <= d;
        end

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            q <= d;
        end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            q <= d;
        end

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            q <= d;
        end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        q <= d;
    end

endmodule",-1,Dff8.v,"// Create 8 D flip-flops. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        q <= d;
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'd0;
        else
            q <= d;
    end

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'd0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

// Create the flip-flop primitive
    DFF_X1 clk_ff (clk, areset, clk_ff_en);
    
    // Create the counter
    always @(posedge clk_ff_en)
        q <= d;

endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

// Create the flip-flop primitive
    DFF_X1 clk_ff (clk, areset, clk_ff_en);
    
    // Create the counter
    always @(posedge clk_ff_en)
        q <= d;

endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'h0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'h0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule",-1,Dff8ar.v,"// Create 8 D flip-flops with active high asynchronous reset. All DFFs should be triggered by the positive edge of clk.

// Hint: The only difference in code between synchronous and asynchronous reset flip-flops is in the sensitivity list.

module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 8'b0;
        else
            q <= d;
    end
    
endmodule","module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end
endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @ (posedge clk)
        if (reset)
            q <= 8'h34;
    	else
            q <= d;

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @ (posedge clk)
        if (reset)
            q <= 8'h34;
    	else
            q <= d;

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 8'b0;
            else
                q <= d;
        end

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 8'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 8'b0;
            else
                q <= d;
        end

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @ (posedge clk)
        begin
            if(reset)
                q <= 8'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end
endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end
endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        if(reset)
            q <= 8'b0;
        else
            q <= d;

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        if(reset)
            q <= 8'b0;
        else
            q <= d;

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
); 
    
    always @ (posedge clk)
        if (reset)
            q <= 8'b0;
    	else
            q <= d;

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
); 
    
    always @ (posedge clk)
        if (reset)
            q <= 8'b0;
    	else
            q <= d;

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end

endmodule",-1,Dff8p.v,"// Create 8 D flip-flops with active high synchronous reset. The flip-flops must be reset to 0x34 rather than zero. All DFFs should be triggered by the negative edge of clk.

// Hint: Resetting a register to '1' is sometimes called ""preset""

module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h34;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    
    always @(negedge clk) begin
        if(reset) begin
            q <= 8'h34;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
); 

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
); 

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h0;
        else begin
            q <= d;
        end
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'h0;
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        if(reset)
            q <= 8'd0;
        else
            q <= d;
    end
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        if(reset)
            q <= 8'd0;
        else
            q <= d;
    end
endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'd0;
        else begin
            q <= d;
        end
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'd0;
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            if(reset)
                q <= 8'b0;
            else
                q <= d;
        end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk)
        begin
            if(reset)
                q <= 8'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else begin
            q <= d;
        end
    end
endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        if(reset)
            q <= 0;
        else begin
            q <= d;
        end
    end
endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else begin
            q <= d;
        end
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'b0;
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'd0;
        else begin
            q <= d;
        end
    end

endmodule",-1,Dff8r.v,"// Create 8 D flip-flops with active high synchronous reset. All DFFs should be triggered by the positive edge of clk.

module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk) begin
        if(reset)
            q <= 8'd0;
        else begin
            q <= d;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

    always @(posedge clk) begin
        q <= d;
    end

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    assign q1 = d ^ q;
    assign q2 = d & q;
    
    always @(posedge clk)
        q <= q1;

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    wire q1, q2;
    
    assign q1 = d ^ q;
    assign q2 = d & q;
    
    always @(posedge clk)
        q <= q1;

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

    always @(posedge clk) begin
        q <= d;
    end

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);

    always @(posedge clk) begin
        q <= d;
    end

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    reg q1, q2;
    
    always @(posedge clk) begin
        q1 <= d;
        q2 <= q1;
    end
    
    assign q = q2;
    
endmodule",1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg q1, q2;
    
    always @(posedge clk) begin
        q1 <= d;
        q2 <= q1;
    end
    
    assign q = q2;
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

    wire q1, q2;
    
    assign q1 = d ^ q;
    assign q2 = d & q;
    
    always @(posedge clk)
        q <= q1;

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);

    wire q1, q2;
    
    assign q1 = d ^ q;
    assign q2 = d & q;
    
    always @(posedge clk)
        q <= q1;

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    always @(posedge clk)
        q <= d;
        
endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    always @(posedge clk)
        q <= d;
        
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);

    always @(posedge clk)
        q <= ~d;

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);

    always @(posedge clk)
        q <= ~d;

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    reg q1, q2;
    
    always @(posedge clk)
        q1 <= d;
    
    always @(negedge clk)
        q2 <= d;
    
    assign q = q1 ^ q2;
    
endmodule",-0.5,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    reg q1, q2;
    
    always @(posedge clk)
        q1 <= d;
    
    always @(negedge clk)
        q2 <= d;
    
    assign q = q1 ^ q2;
    
endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    always @(posedge clk)
        q <= d;

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    always @(posedge clk)
        q <= d;

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);
    
    wire q_0, q_1;
    
    assign q_0 = d ^ q_1;
    assign q = clk? q_0 : q_1;
    
    always @(posedge clk)
        q_1 <= d;

endmodule",-1,Dualedge.v,"// You're familiar with flip-flops that are triggered on the positive edge of the clock, or negative edge of the clock. A dual-edge triggered flip-flop is triggered on both edges of the clock. However, FPGAs don't have dual-edge triggered flip-flops, and always @(posedge clk or negedge clk) is not accepted as a legal sensitivity list.

// Build a circuit that functionally behaves like a dual-edge triggered flip-flop

// Hint: You can't create a dual-edge triggered flip-flop on an FPGA. But you can create both positive-edge triggered and negative-edge triggered flip-flops.
// This problem is a moderately difficult circuit design problem, but requires only basic Verilog language features. (This is a circuit design problem, not a coding problem.) It may help to first sketch a circuit by hand before attempting to code it.

module top_module (
    input clk,
    input d,
    output q
);","module top_module (
    input clk,
    input d,
    output q
);
    
    wire q_0, q_1;
    
    assign q_0 = d ^ q_1;
    assign q = clk? q_0 : q_1;
    
    always @(posedge clk)
        q_1 <= d;

endmodule","module top_module (
    input clk,
    input d,
    output q
);
    
    reg [1:0] status;
    
    always @(posedge clk) begin
        status[0] = d;
    end
    
    always @(negedge clk) begin
        status[1] = d;
    end
    
    assign q = clk ? status[0] : status[1];
    
endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;
    
    always @ (posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end
    
    assign out = reg_out;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;
    
    always @ (posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end
    
    assign out = reg_out;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk) begin
        if(reset)
            temp <= 0;
        else begin
            temp <= temp << 1;
            temp[0] <= in[31];
        end
    end
    
    assign out = temp;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk) begin
        if(reset)
            temp <= 0;
        else begin
            temp <= temp << 1;
            temp[0] <= in[31];
        end
    end
    
    assign out = temp;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk)
        if(reset)
            temp <= 0;
        else
            temp <= in;
            
    assign out = temp;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk)
        if(reset)
            temp <= 0;
        else
            temp <= in;
            
    assign out = temp;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;

    always @(posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end

    assign out = reg_out;

endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;

    always @(posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end

    assign out = reg_out;

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk) begin
        if(reset)
            temp <= 0;
        else begin
            temp <= in;
            temp[31] <= ~temp[31];
        end
    end
    
    assign out = temp;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk) begin
        if(reset)
            temp <= 0;
        else begin
            temp <= in;
            temp[31] <= ~temp[31];
        end
    end
    
    assign out = temp;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;

    always @ (posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end

    assign out = reg_out;

endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;

    always @ (posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end

    assign out = reg_out;

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;
    
    always @ (posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end
    
    assign out = reg_out;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] reg_out;
    
    always @ (posedge clk) begin
        if (reset) begin
            reg_out <= 0;
        end
        else begin
            reg_out <= in;
        end
    end
    
    assign out = reg_out;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else begin
            out <= in;
            out[31] <= ~out[31];
        end
    end

endmodule",-1,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    always @(posedge clk) begin
        if(reset)
            out <= 0;
        else begin
            out <= in;
            out[31] <= ~out[31];
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk)
        if(reset)
            temp <= 32'd0;
        else
            temp <= in;
    
    assign out = temp;
    
endmodule",-0.5,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;
    
    always @(posedge clk)
        if(reset)
            temp <= 32'd0;
        else
            temp <= in;
    
    assign out = temp;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the'reset' event occurs one cycle earlier than the'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;

    always @(posedge clk) begin
        if (reset) temp <= 0;
        else begin
            temp <= in;
            out <= ~temp;
        end
    end

endmodule",-1,Edgecapture.v,"// For each bit in a 32-bit vector, capture when the input signal changes from 1 in one clock cycle to 0 the next. ""Capture"" means that the output will remain 1 until the register is reset (synchronous reset).

// Each output bit behaves like a SR flip-flop: The output bit should be set (to 1) the cycle after a 1 to 0 transition occurs. The output bit should be reset (to 0) at the positive clock edge when reset is high. If both of the above events occur at the same time, reset has precedence. In the last 4 cycles of the example waveform below, the 'reset' event occurs one cycle earlier than the 'set' event, so there is no conflict here.

module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);

    reg [31:0] temp;

    always @(posedge clk) begin
        if (reset) temp <= 0;
        else begin
            temp <= in;
            out <= ~temp;
        end
    end

endmodule","module top_module (
    input clk,
    input reset,
    input [31:0] in,
    output [31:0] out
);
    
    reg [31:0] old, result, tmp;
    initial tmp = 0;
    always @(posedge clk) begin
        if(reset) begin
            old = in;
            result = 0;
            out = 0;
        end
        else begin
            tmp = (in ^ old) & old;
            result = result | tmp;
            out = result;
            old = in;
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @ (posedge clk)
        temp <= in;
        
    assign pedge = (temp[7] & ~temp[6])? temp[7:0] : temp[7:0] & temp[6:0];

endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @ (posedge clk)
        temp <= in;
        
    assign pedge = (temp[7] & ~temp[6])? temp[7:0] : temp[7:0] & temp[6:0];

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @(posedge clk)
        temp <= in;
        
    assign pedge = (temp == 8'b0)? temp : temp - 8'b1;

endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    
    always @(posedge clk)
        temp <= in;
        
    assign pedge = (temp == 8'b0)? temp : temp - 8'b1;

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] in_reg;
    reg [7:0] pedge_reg;
    
    always @ (posedge clk) begin
        in_reg <= in;
        pedge_reg <= pedge;
    end
    
    assign pedge = ~pedge_reg & in_reg;
    
endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] in_reg;
    reg [7:0] pedge_reg;
    
    always @ (posedge clk) begin
        in_reg <= in;
        pedge_reg <= pedge;
    end
    
    assign pedge = ~pedge_reg & in_reg;
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;

    always @(posedge clk)
        begin
            temp <= in;
        end

    assign pedge = (temp[7] & ~temp[6]) | (temp[7] & temp[6] & ~temp[5]) | (temp[7] & temp[6] & temp[5] & ~temp[4]) | (temp[7] & temp[6] & temp[5] & temp[4] & ~temp[3]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & ~temp[2]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & temp[2] & ~temp[1]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & temp[2] & temp[1] & ~temp[0]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & temp[2] & temp[1] & temp[0]);

endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;

    always @(posedge clk)
        begin
            temp <= in;
        end

    assign pedge = (temp[7] & ~temp[6]) | (temp[7] & temp[6] & ~temp[5]) | (temp[7] & temp[6] & temp[5] & ~temp[4]) | (temp[7] & temp[6] & temp[5] & temp[4] & ~temp[3]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & ~temp[2]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & temp[2] & ~temp[1]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & temp[2] & temp[1] & ~temp[0]) | (temp[7] & temp[6] & temp[5] & temp[4] & temp[3] & temp[2] & temp[1] & temp[0]);

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    reg [7:0] prev;
    
    always @(posedge clk) begin
        temp <= in;
        prev <= temp;
    end
    
    assign pedge = ~prev & temp;
    
endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    reg [7:0] prev;
    
    always @(posedge clk) begin
        temp <= in;
        prev <= temp;
    end
    
    assign pedge = ~prev & temp;
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    reg [7:0] prev;
    
    always @(posedge clk) begin
        temp <= in;
        prev <= temp;
    end
    
    assign pedge = (temp & ~prev)? 8'b1 : 8'b0;
    
endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    reg [7:0] prev;
    
    always @(posedge clk) begin
        temp <= in;
        prev <= temp;
    end
    
    assign pedge = (temp & ~prev)? 8'b1 : 8'b0;
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] x;
    reg [7:0] y;
    reg [7:0] z;

    always @(posedge clk) begin
        x <= in;
        y <= x;
        z <= y;
    end

    assign pedge = x & ~z;

endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] x;
    reg [7:0] y;
    reg [7:0] z;

    always @(posedge clk) begin
        x <= in;
        y <= x;
        z <= y;
    end

    assign pedge = x & ~z;

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    // The first stage is a mux that chooses between the input vector and a replicate of the input vector.
    // The replicate is the concatenation of the input vector along with itself.
    // For example, if the input vector is ABCD, then the replicate is ABCDABCD.
    // The mux output is the input vector if the input vector is greater than the replicate.
    // Otherwise, the mux output is the replicate.
    // In this case, the output is ABCD if A > C, otherwise the output is ABCD.
    // This stage also adds a 2 clock delay to the output.
    // The 2 clock delay is required to detect a positive edge.
    // The output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final stage is a mux that selects between the output of the first stage or the input vector.
    // The final output is the input vector if the input vector is greater than the replicate.
    // Otherwise, the final output is the output of the first stage.
    // In this case, the final output is ABCD if A > C, otherwise the final output is ABCD.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // In this case, the final output is ABCD if A > C, otherwise the final output is ABCD.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    //",-1,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    // The first stage is a mux that chooses between the input vector and a replicate of the input vector.
    // The replicate is the concatenation of the input vector along with itself.
    // For example, if the input vector is ABCD, then the replicate is ABCDABCD.
    // The mux output is the input vector if the input vector is greater than the replicate.
    // Otherwise, the mux output is the replicate.
    // In this case, the output is ABCD if A > C, otherwise the output is ABCD.
    // This stage also adds a 2 clock delay to the output.
    // The 2 clock delay is required to detect a positive edge.
    // The output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final stage is a mux that selects between the output of the first stage or the input vector.
    // The final output is the input vector if the input vector is greater than the replicate.
    // Otherwise, the final output is the output of the first stage.
    // In this case, the final output is ABCD if A > C, otherwise the final output is ABCD.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // In this case, the final output is ABCD if A > C, otherwise the final output is ABCD.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    // The pedge output is 0 if there is a negative edge.
    // The pedge output is the same as the input if there is no edge.
    // The final output is the same as the input if there is no edge.
    // The pedge output is the same as the input if there is no edge.
    // The pedge output is 1 if there is a positive edge.
    //","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] x;
    reg [7:0] y;
    
    always @(posedge clk) begin
        x <= in;
        y <= x;
    end
    
    assign pedge = y ^ x;
    
endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] x;
    reg [7:0] y;
    
    always @(posedge clk) begin
        x <= in;
        y <= x;
    end
    
    assign pedge = y ^ x;
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    always @(posedge clk)
        temp <= in;
    assign pedge = temp ^ in;

endmodule",-0.5,Edgedetect.v,"// For each bit in an 8-bit vector, detect when the input signal changes from 0 in one clock cycle to 1 the next (similar to positive edge detection). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);

    reg [7:0] temp;
    always @(posedge clk)
        temp <= in;
    assign pedge = temp ^ in;

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] pedge
);
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i] && in[i] == 1) begin
                pedge[i] = 1;
            end
            else begin
                pedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000001: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000010: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000100: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00001000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00010000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000001: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000010: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000100: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00001000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00010000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        next_state = state;
        case (state)
            8'h00: begin
                if(in[0])
                    next_state = 8'h01;
                else if(in[1])
                    next_state = 8'h02;
                else if(in[2])
                    next_state = 8'h04;
                else if(in[3])
                    next_state = 8'h08;
                else if(in[4])
                    next_state = 8'h10;
                else if(in[5])
                    next_state = 8'h20;
                else if(in[6])
                    next_state = 8'h40;
                else if(in[7])
                    next_state = 8'h80;
                else
                    next_state = 8'h00;
            end
            8'h01: begin
                if(in[0])
                    next_state = 8'h02;
                else if(in[1])
                    next_state = 8'h04;
                else if(in[2])
                    next_state = 8'h08;
                else if(in[3])
                    next_state = 8'h10;
                else if(in[4])
                    next_state = 8'h20;
                else if(in[5])
                    next_state = 8'h40;
                else if(in[6])
                    next_state = 8'h80;
                else if(in[7])
                    next_state = 8'h00;
                else
                    next_state = 8'h01;
            end
            8'h02: begin
                if(in[0])
                    next_state = 8'h04;
                else if(in[1])
                    next_state = 8'h08;
                else if(in[2])
                    next_state = 8'h10;
                else if(in[3])
                    next_state = 8'h20;
                else if(in[4])
                    next_state = 8'h40;
                else if(in[5])
                    next_state = 8'h80;
                else if(in[6])
                    next_state = 8'h00;
                else if(in[7])
                    next_state = 8'h01;
                else
                    next_state = 8'h02;
            end
            8'h04: begin
                if(in[0])
                    next_state = 8'h08;
                else if(in[1])
                    next_state = 8'h10;
                else if(in[2])
                    next_state = 8'h20;
                else if(in[3])
                    next_state = 8'h40;
                else if(in[4])
                    next_state = 8'h80;
                else if(in[5])
                    next_state = 8'h00;
                else if(in[6])
                    next_state = 8'h01;
                else if(in[7])
                    next_state = 8'h02;
                else
                    next_state = 8'h04;
            end
            8'h08: begin
                if(in[0])
                    next_state = 8'h10;
                else if(in[1])
                    next_state = 8'h20;
                else if(in[2])
                    next_state = 8'h40;
                else if(in[3])
                    next_state = 8'h80;
                else if(in[4])
                    next_state = 8'h00;
                else if(in[5])
                    next_state = 8'h01;
                else if(in[6])
                    next_state = 8'h02;
                else if(in[7])
                    next_state = 8'h04;
                else
                    next_state = 8'h08;
            end
            8'h10: begin
                if(in[0])
                    next_state = 8'h20;
                else if(in[1])
                    next_state = 8'h40;",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        next_state = state;
        case (state)
            8'h00: begin
                if(in[0])
                    next_state = 8'h01;
                else if(in[1])
                    next_state = 8'h02;
                else if(in[2])
                    next_state = 8'h04;
                else if(in[3])
                    next_state = 8'h08;
                else if(in[4])
                    next_state = 8'h10;
                else if(in[5])
                    next_state = 8'h20;
                else if(in[6])
                    next_state = 8'h40;
                else if(in[7])
                    next_state = 8'h80;
                else
                    next_state = 8'h00;
            end
            8'h01: begin
                if(in[0])
                    next_state = 8'h02;
                else if(in[1])
                    next_state = 8'h04;
                else if(in[2])
                    next_state = 8'h08;
                else if(in[3])
                    next_state = 8'h10;
                else if(in[4])
                    next_state = 8'h20;
                else if(in[5])
                    next_state = 8'h40;
                else if(in[6])
                    next_state = 8'h80;
                else if(in[7])
                    next_state = 8'h00;
                else
                    next_state = 8'h01;
            end
            8'h02: begin
                if(in[0])
                    next_state = 8'h04;
                else if(in[1])
                    next_state = 8'h08;
                else if(in[2])
                    next_state = 8'h10;
                else if(in[3])
                    next_state = 8'h20;
                else if(in[4])
                    next_state = 8'h40;
                else if(in[5])
                    next_state = 8'h80;
                else if(in[6])
                    next_state = 8'h00;
                else if(in[7])
                    next_state = 8'h01;
                else
                    next_state = 8'h02;
            end
            8'h04: begin
                if(in[0])
                    next_state = 8'h08;
                else if(in[1])
                    next_state = 8'h10;
                else if(in[2])
                    next_state = 8'h20;
                else if(in[3])
                    next_state = 8'h40;
                else if(in[4])
                    next_state = 8'h80;
                else if(in[5])
                    next_state = 8'h00;
                else if(in[6])
                    next_state = 8'h01;
                else if(in[7])
                    next_state = 8'h02;
                else
                    next_state = 8'h04;
            end
            8'h08: begin
                if(in[0])
                    next_state = 8'h10;
                else if(in[1])
                    next_state = 8'h20;
                else if(in[2])
                    next_state = 8'h40;
                else if(in[3])
                    next_state = 8'h80;
                else if(in[4])
                    next_state = 8'h00;
                else if(in[5])
                    next_state = 8'h01;
                else if(in[6])
                    next_state = 8'h02;
                else if(in[7])
                    next_state = 8'h04;
                else
                    next_state = 8'h08;
            end
            8'h10: begin
                if(in[0])
                    next_state = 8'h20;
                else if(in[1])
                    next_state = 8'h40;","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00000001: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00000010: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00000100: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00001000: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00010000: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00000001: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00000010: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00000100: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00001000: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'b00000100;
                    else if(in[3])
                        next_state = 8'b00001000;
                    else if(in[4])
                        next_state = 8'b00010000;
                    else if(in[5])
                        next_state = 8'b00100000;
                    else if(in[6])
                        next_state = 8'b01000000;
                    else if(in[7])
                        next_state = 8'b10000000;
                end
                8'b00010000: begin
                    if(in[0])
                        next_state = 8'b00000001;
                    else if(in[1])
                        next_state = 8'b00000010;
                    else if(in[2])
                        next_state = 8'","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    
    always @ (posedge clk)
        begin
            state <= in;
        end
    
    assign anyedge = state ^ in;

endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    
    always @ (posedge clk)
        begin
            state <= in;
        end
    
    assign anyedge = state ^ in;

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    assign anyedge = state ^ next_state;
    
    always @(*) begin
        case(state)
            8'b0xxxxxxx: next_state = in;
            8'b10011111: next_state = in;
            8'b10111111: next_state = in;
            8'b11011111: next_state = in;
            8'b11100111: next_state = in;
            8'b11110111: next_state = in;
            8'b11111011: next_state = in;
            8'b11111101: next_state = in;
            8'b11111110: next_state = in;
            default:     next_state = 8'b0xxxxxxx;
        endcase
    end
    
    always @(posedge clk) begin
        state <= next_state;
    end
    
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    assign anyedge = state ^ next_state;
    
    always @(*) begin
        case(state)
            8'b0xxxxxxx: next_state = in;
            8'b10011111: next_state = in;
            8'b10111111: next_state = in;
            8'b11011111: next_state = in;
            8'b11100111: next_state = in;
            8'b11110111: next_state = in;
            8'b11111011: next_state = in;
            8'b11111101: next_state = in;
            8'b11111110: next_state = in;
            default:     next_state = 8'b0xxxxxxx;
        endcase
    end
    
    always @(posedge clk) begin
        state <= next_state;
    end
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: next_state = 8'b00000001;
                8'b00000001: next_state = 8'b00000010;
                8'b00000010: next_state = 8'b00000100;
                8'b00000100: next_state = 8'b00001000;
                8'b00001000: next_state = 8'b00010000;
                8'b00010000: next_state = 8'b00100000;
                8'b00100000: next_state = 8'b01000000;
                8'b01000000: next_state = 8'b10000000;
                8'b10000000: next_state = 8'b00000000;
                default:     next_state = 8'b00000000;
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            state <= next_state;
        end
    
    // Output logic
    assign anyedge = state;

endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: next_state = 8'b00000001;
                8'b00000001: next_state = 8'b00000010;
                8'b00000010: next_state = 8'b00000100;
                8'b00000100: next_state = 8'b00001000;
                8'b00001000: next_state = 8'b00010000;
                8'b00010000: next_state = 8'b00100000;
                8'b00100000: next_state = 8'b01000000;
                8'b01000000: next_state = 8'b10000000;
                8'b10000000: next_state = 8'b00000000;
                default:     next_state = 8'b00000000;
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            state <= next_state;
        end
    
    // Output logic
    assign anyedge = state;

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000001: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000010: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000100: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00001000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00010000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'",-1,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = state;
            case (state)
                8'b00000000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000001: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000010: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00000100: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00001000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'b00000100;
                    else if (in[3])
                        next_state = 8'b00001000;
                    else if (in[4])
                        next_state = 8'b00010000;
                    else if (in[5])
                        next_state = 8'b00100000;
                    else if (in[6])
                        next_state = 8'b01000000;
                    else if (in[7])
                        next_state = 8'b10000000;
                end
                8'b00010000: begin
                    if (in[0])
                        next_state = 8'b00000001;
                    else if (in[1])
                        next_state = 8'b00000010;
                    else if (in[2])
                        next_state = 8'","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    assign anyedge = state ^ next_state;
    
    always @(*) begin
        case(state)
            8'b0xxxxxxx: next_state = in;
            8'b10011111: next_state = in;
            8'b10111111: next_state = in;
            8'b11011111: next_state = in;
            8'b11100111: next_state = in;
            8'b11110111: next_state = in;
            8'b11111011: next_state = in;
            8'b11111101: next_state = in;
            8'b11111110: next_state = in;
            default:     next_state = 8'b0xxxxxxx;
        endcase
    end
    
    always @(posedge clk) begin
        state <= next_state;
    end
    
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    reg [7:0] next_state;
    
    assign anyedge = state ^ next_state;
    
    always @(*) begin
        case(state)
            8'b0xxxxxxx: next_state = in;
            8'b10011111: next_state = in;
            8'b10111111: next_state = in;
            8'b11011111: next_state = in;
            8'b11100111: next_state = in;
            8'b11110111: next_state = in;
            8'b11111011: next_state = in;
            8'b11111101: next_state = in;
            8'b11111110: next_state = in;
            default:     next_state = 8'b0xxxxxxx;
        endcase
    end
    
    always @(posedge clk) begin
        state <= next_state;
    end
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    
    always @ (posedge clk)
        state <= in;
    
    assign anyedge = state ^ in;

endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    
    always @ (posedge clk)
        state <= in;
    
    assign anyedge = state ^ in;

endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    
    always @(posedge clk) begin
        state <= in;
    end
    
    assign anyedge = state;
    
endmodule",-0.5,Edgedetect2.v,"// For each bit in an 8-bit vector, detect when the input signal changes from one clock cycle to the next (detect any edge). The output bit should be set the cycle after a 0 to 1 transition occurs.

module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);

    reg [7:0] state;
    
    always @(posedge clk) begin
        state <= in;
    end
    
    assign anyedge = state;
    
endmodule","module top_module (
    input clk,
    input [7:0] in,
    output [7:0] anyedge
);
    
    integer i;
    reg [7:0] in_tmp;
    always @(posedge clk) begin
        for(i = 0; i < 8; i = i + 1) begin
            if(in_tmp[i] != in[i]) begin
                anyedge[i] = 1;
            end
            else begin
                anyedge[i] = 0;
            end
            in_tmp[i] = in[i];
        end
    end

endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & ~x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & ~x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[4]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & x[3]) | (x[1] & ~x[2] & ~x[3]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & x[3]) | (x[1] & ~x[2] & ~x[3]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3])&(~x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3])&(~x[4]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & x[3]) | (x[1] & ~x[2] & ~x[3]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & x[3]) | (x[1] & ~x[2] & ~x[3]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & x[3]) | (x[1] & ~x[2] & ~x[3]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & x[3]) | (x[1] & ~x[2] & ~x[3]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3])&(~x[4]) | x[1]&(~x[2])&x[4];

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3])&(~x[4]) | x[1]&(~x[2])&x[4];

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & ~x[3]) | (x[1] & x[2] & x[3]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (x[1] & x[2] & ~x[3]) | (x[1] & x[2] & x[3]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & ~x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & ~x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[4]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & ~x[2] & ~x[3] & x[4]) | (x[1] & x[2] & ~x[3] & x[4]) | (x[1] & ~x[2] & x[3] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & ~x[2] & ~x[3] & x[4]) | (x[1] & x[2] & ~x[3] & x[4]) | (x[1] & ~x[2] & x[3] & x[4]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & x[4]) | (x[2] & x[3]) | (x[2] & x[4]);

endmodule",-0.5,Exams_2012_q1g.v,"// Consider the function f shown in the Karnaugh map below. Implement this function.
//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
// x_3'x_4'	1		0		0		1
// x_3'x_4		0		0		0		0
// x_3x_4  	1		1		1		0
// x_3x_4'		1		1		0		1

// Hint: Be careful of the ordering of the x[4:1] input bits in the Karnaugh map.

module top_module (
    input [4:1] x,
    output f
);

","module top_module (
    input [4:1] x,
    output f
);

    assign f = (~x[1] & x[3]) | (~x[1] & x[4]) | (x[2] & x[3]) | (x[2] & x[4]);

endmodule","module top_module (
    input [4:1] x,
    output f
); 

    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & ~x[4]) | (x[1] & ~x[2] & x[3] & ~x[4]) | (x[2] & x[3] & x[4]);
    
endmodule",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25, NUM_STATES=26;
    reg [NUM_STATES-1:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                next_state = B;
                f = 0;
                g = 0;
            end
            B: begin
                next_state = C;
                f = 0;
                g = 0;
            end
            C: begin
                next_state = D;
                f = 0;
                g = 0;
            end
            D: begin
                next_state = E;
                f = 0;
                g = 0;
            end
            E: begin
                next_state = F;
                f = 0;
                g = 0;
            end
            F: begin
                next_state = G;
                f = 0;
                g = 0;
            end
            G: begin
                next_state = H;
                f = 0;
                g = 0;
            end
            H: begin
                next_state = I;
                f = 0;
                g = 0;
            end
            I: begin
                next_state = J;
                f = 0;
                g = 0;
            end
            J: begin
                next_state = K;
                f = 0;
                g = 0;
            end
            K: begin
                next_state = L;
                f = 0;
                g = 0;
            end
            L: begin
                next_state = M;
                f = 0;
                g = 0;
            end
            M: begin
                next_state = N;
                f = 0;
                g = 0;
            end
            N: begin
                next_state = O;
                f = 0;
                g = 0;
            end
            O: begin
                next_state = P;
                f = 0;
                g = 0;
            end
            P: begin
                next_state = Q;
                f = 0;
                g = 0;
            end
            Q: begin
                next_state = R;
                f = 0;
                g = 0;
            end
            R: begin
                next_state = S;
                f = 0;
                g = 0;
            end
            S: begin
                next_state = T;
                f = 0;
                g = 0;
            end
            T: begin
                next_state = U;
                f = 0;
                g = 0;
            end
            U: begin
                next_state = V;
                f = 0;
                g = 0;
            end
            V: begin
                next_state = W;
                f = 0;
                g = 0;
            end
            W: begin
                next_state = X;
                f = 0;
                g = 0;
            end
            X: begin
                next_state = Y;
                f = 0;
                g = 0;
            end
            Y: begin
                next_state = Z;
                f = 0;
                g = 0;
            end
            Z: begin
                next_state = NUM_STATES;
                f = 1;
                g = 0;
            end
            default: begin
                next_state = A;
                f = 0;
                g = 0;
            end
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign f = (state == NUM_STATES-1)? 1:0;
    assign g = (state == NUM_STATES-1)? 1:0;
    
endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25, NUM_STATES=26;
    reg [NUM_STATES-1:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                next_state = B;
                f = 0;
                g = 0;
            end
            B: begin
                next_state = C;
                f = 0;
                g = 0;
            end
            C: begin
                next_state = D;
                f = 0;
                g = 0;
            end
            D: begin
                next_state = E;
                f = 0;
                g = 0;
            end
            E: begin
                next_state = F;
                f = 0;
                g = 0;
            end
            F: begin
                next_state = G;
                f = 0;
                g = 0;
            end
            G: begin
                next_state = H;
                f = 0;
                g = 0;
            end
            H: begin
                next_state = I;
                f = 0;
                g = 0;
            end
            I: begin
                next_state = J;
                f = 0;
                g = 0;
            end
            J: begin
                next_state = K;
                f = 0;
                g = 0;
            end
            K: begin
                next_state = L;
                f = 0;
                g = 0;
            end
            L: begin
                next_state = M;
                f = 0;
                g = 0;
            end
            M: begin
                next_state = N;
                f = 0;
                g = 0;
            end
            N: begin
                next_state = O;
                f = 0;
                g = 0;
            end
            O: begin
                next_state = P;
                f = 0;
                g = 0;
            end
            P: begin
                next_state = Q;
                f = 0;
                g = 0;
            end
            Q: begin
                next_state = R;
                f = 0;
                g = 0;
            end
            R: begin
                next_state = S;
                f = 0;
                g = 0;
            end
            S: begin
                next_state = T;
                f = 0;
                g = 0;
            end
            T: begin
                next_state = U;
                f = 0;
                g = 0;
            end
            U: begin
                next_state = V;
                f = 0;
                g = 0;
            end
            V: begin
                next_state = W;
                f = 0;
                g = 0;
            end
            W: begin
                next_state = X;
                f = 0;
                g = 0;
            end
            X: begin
                next_state = Y;
                f = 0;
                g = 0;
            end
            Y: begin
                next_state = Z;
                f = 0;
                g = 0;
            end
            Z: begin
                next_state = NUM_STATES;
                f = 1;
                g = 0;
            end
            default: begin
                next_state = A;
                f = 0;
                g = 0;
            end
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign f = (state == NUM_STATES-1)? 1:0;
    assign g = (state == NUM_STATES-1)? 1:0;
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state;
    reg [2:0] next_state;
    reg f_reg;
    reg g_reg;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = A;
            case (state)
                A: begin
                    if (y == 1'b1)
                        next_state = B;
                end
                B: begin
                    if (y == 1'b0)
                        next_state = B;
                    else if (x == 1'b1)
                        next_state = C;
                end
                C: begin
                    if (y == 1'b0)
                        next_state = C;
                    else if (x == 1'b0)
                        next_state = D;
                end
                D: begin
                    if (y == 1'b1)
                        next_state = E;
                end
                E: begin
                    if (y == 1'b0)
                        next_state = E;
                    else if (x == 1'b1)
                        next_state = F;
                end
                F: begin
                    if (y == 1'b0)
                        next_state = F;
                    else if (x == 1'b0)
                        next_state = G;
                end
                G: begin
                    if (y == 1'b1)
                        next_state = DONE;
                end
                DONE: begin
                    if (y == 1'b1)
                        next_state = C2;
                end
                C2: begin
                    if (y == 1'b0)
                        next_state = A;
                end
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (resetn == 1'b0)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    always @(*)
        begin
            f_reg = 1'b0;
            g_reg = 1'b0;
            case (state)
                A: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                B: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                C: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                D: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                E: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                F: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                G: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                DONE: begin
                    f_reg = 1'b1;
                    g_reg = 1'b1;
                end
                C2: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
            endcase
        end
    
    assign f = f_reg;
    assign g = g_reg;
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state;
    reg [2:0] next_state;
    reg f_reg;
    reg g_reg;
    
    // State transition logic (combinational)
    always @(*)
        begin
            next_state = A;
            case (state)
                A: begin
                    if (y == 1'b1)
                        next_state = B;
                end
                B: begin
                    if (y == 1'b0)
                        next_state = B;
                    else if (x == 1'b1)
                        next_state = C;
                end
                C: begin
                    if (y == 1'b0)
                        next_state = C;
                    else if (x == 1'b0)
                        next_state = D;
                end
                D: begin
                    if (y == 1'b1)
                        next_state = E;
                end
                E: begin
                    if (y == 1'b0)
                        next_state = E;
                    else if (x == 1'b1)
                        next_state = F;
                end
                F: begin
                    if (y == 1'b0)
                        next_state = F;
                    else if (x == 1'b0)
                        next_state = G;
                end
                G: begin
                    if (y == 1'b1)
                        next_state = DONE;
                end
                DONE: begin
                    if (y == 1'b1)
                        next_state = C2;
                end
                C2: begin
                    if (y == 1'b0)
                        next_state = A;
                end
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (resetn == 1'b0)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    always @(*)
        begin
            f_reg = 1'b0;
            g_reg = 1'b0;
            case (state)
                A: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                B: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                C: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                D: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                E: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                F: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                G: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
                DONE: begin
                    f_reg = 1'b1;
                    g_reg = 1'b1;
                end
                C2: begin
                    f_reg = 1'b0;
                    g_reg = 1'b0;
                end
            endcase
        end
    
    assign f = f_reg;
    assign g = g_reg;
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, COUNT=8;
    reg [3:0] state;
    reg [3:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            case (state)
                A: next_state = B;
                B: next_state = C;
                C: next_state = x? D : E;
                D: next_state = x? E : F;
                E: next_state = x? F : G;
                F: next_state = x? G : DONE;
                G: next_state = COUNT;
                COUNT: next_state = COUNT;
                DONE: next_state = COUNT;
                default: next_state = A;
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            if(!resetn)
                state <= A;
            else
                state <= next_state;
        end
    
    // Output logic
    assign f = (state == COUNT) || (state == DONE);
    assign g = (state == COUNT);
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, COUNT=8;
    reg [3:0] state;
    reg [3:0] next_state;
    
    // State transition logic (combinational)
    always @(*)
        begin
            case (state)
                A: next_state = B;
                B: next_state = C;
                C: next_state = x? D : E;
                D: next_state = x? E : F;
                E: next_state = x? F : G;
                F: next_state = x? G : DONE;
                G: next_state = COUNT;
                COUNT: next_state = COUNT;
                DONE: next_state = COUNT;
                default: next_state = A;
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            if(!resetn)
                state <= A;
            else
                state <= next_state;
        end
    
    // Output logic
    assign f = (state == COUNT) || (state == DONE);
    assign g = (state == COUNT);
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: next_state = B;
            B: next_state = x? C : A;
            C: next_state = x? D : A;
            D: next_state = x? E : A;
            E: next_state = y? C : A;
            default: next_state = A;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state = A;
    	else
            state = next_state;
    
    // Output logic
    assign f = (state == E) || (state == D);
    assign g = (state == B) || (state == C);
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: next_state = B;
            B: next_state = x? C : A;
            C: next_state = x? D : A;
            D: next_state = x? E : A;
            E: next_state = y? C : A;
            default: next_state = A;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state = A;
    	else
            state = next_state;
    
    // Output logic
    assign f = (state == E) || (state == D);
    assign g = (state == B) || (state == C);
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state;
    reg [2:0] next_state;
    reg f_reg;
    reg g_reg;
    
    always @(*) begin
        // State transition logic
        case(state)
            A: begin
                if(~y)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(~y)
                    next_state = C;
                else
                    next_state = B;
            end
            C: begin
                if(~y)
                    next_state = D;
                else
                    next_state = C;
            end
            D: begin
                if(~y)
                    next_state = E;
                else
                    next_state = D;
            end
            E: begin
                if(~y)
                    next_state = F;
                else
                    next_state = E;
            end
            F: begin
                if(~y)
                    next_state = G;
                else
                    next_state = F;
            end
            G: begin
                if(~y)
                    next_state = DONE;
                else
                    next_state = G;
            end
            DONE: begin
                if(~y)
                    next_state = C2;
                else
                    next_state = DONE;
            end
            C2: begin
                if(~y)
                    next_state = DONE;
                else
                    next_state = C2;
            end
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        // Output logic
        case(state)
            A: begin
                f_reg <= 0;
                g_reg <= 0;
            end
            B: begin
                f_reg <= 1;
                g_reg <= 0;
            end
            C: begin
                f_reg <= 0;
                g_reg <= 1;
            end
            D: begin
                f_reg <= 0;
                g_reg <= 1;
            end
            E: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            F: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            G: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            DONE: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            C2: begin
                f_reg <= 1;
                g_reg <= 1;
            end
        endcase
    end
    
    assign f = f_reg;
    assign g = g_reg;
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state;
    reg [2:0] next_state;
    reg f_reg;
    reg g_reg;
    
    always @(*) begin
        // State transition logic
        case(state)
            A: begin
                if(~y)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(~y)
                    next_state = C;
                else
                    next_state = B;
            end
            C: begin
                if(~y)
                    next_state = D;
                else
                    next_state = C;
            end
            D: begin
                if(~y)
                    next_state = E;
                else
                    next_state = D;
            end
            E: begin
                if(~y)
                    next_state = F;
                else
                    next_state = E;
            end
            F: begin
                if(~y)
                    next_state = G;
                else
                    next_state = F;
            end
            G: begin
                if(~y)
                    next_state = DONE;
                else
                    next_state = G;
            end
            DONE: begin
                if(~y)
                    next_state = C2;
                else
                    next_state = DONE;
            end
            C2: begin
                if(~y)
                    next_state = DONE;
                else
                    next_state = C2;
            end
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        // Output logic
        case(state)
            A: begin
                f_reg <= 0;
                g_reg <= 0;
            end
            B: begin
                f_reg <= 1;
                g_reg <= 0;
            end
            C: begin
                f_reg <= 0;
                g_reg <= 1;
            end
            D: begin
                f_reg <= 0;
                g_reg <= 1;
            end
            E: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            F: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            G: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            DONE: begin
                f_reg <= 1;
                g_reg <= 1;
            end
            C2: begin
                f_reg <= 1;
                g_reg <= 1;
            end
        endcase
    end
    
    assign f = f_reg;
    assign g = g_reg;
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state;
    reg [2:0] next_state;
    reg [2:0] count;
    reg f_reg, g_reg;
    
    // State transition logic (combinational)
    always @(*)
        begin
            case (state)
                A: begin
                    if (y == 1)
                        next_state = B;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                B: begin
                    if (y == 1)
                        next_state = C;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                C: begin
                    if (y == 1)
                        next_state = C2;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                C2: begin
                    if (y == 1)
                        next_state = C2;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 1;
                end
                D: begin
                    if (y == 1)
                        next_state = E;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                E: begin
                    if (y == 1)
                        next_state = F;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                F: begin
                    if (y == 1)
                        next_state = G;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                G: begin
                    if (y == 1)
                        next_state = G;
                    else
                        next_state = A;
                    f_reg = 1;
                    g_reg = 0;
                end
                DONE: begin
                    if (y == 1)
                        next_state = DONE;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                default: begin
                    next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            if (resetn == 0)
                state <= A;
            else
                state <= next_state;
        end
    
    // Output logic
    assign f = f_reg;
    assign g = g_reg;
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state;
    reg [2:0] next_state;
    reg [2:0] count;
    reg f_reg, g_reg;
    
    // State transition logic (combinational)
    always @(*)
        begin
            case (state)
                A: begin
                    if (y == 1)
                        next_state = B;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                B: begin
                    if (y == 1)
                        next_state = C;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                C: begin
                    if (y == 1)
                        next_state = C2;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                C2: begin
                    if (y == 1)
                        next_state = C2;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 1;
                end
                D: begin
                    if (y == 1)
                        next_state = E;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                E: begin
                    if (y == 1)
                        next_state = F;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                F: begin
                    if (y == 1)
                        next_state = G;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                G: begin
                    if (y == 1)
                        next_state = G;
                    else
                        next_state = A;
                    f_reg = 1;
                    g_reg = 0;
                end
                DONE: begin
                    if (y == 1)
                        next_state = DONE;
                    else
                        next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
                default: begin
                    next_state = A;
                    f_reg = 0;
                    g_reg = 0;
                end
            endcase
        end
    
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            if (resetn == 0)
                state <= A;
            else
                state <= next_state;
        end
    
    // Output logic
    assign f = f_reg;
    assign g = g_reg;
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] PS, NS;
    reg [3:0] count;
    reg f, g, done;

    assign g = (PS == E) || (PS == F)? 1 : 0;
    assign f = (PS == D) || (PS == E) || (PS == G)? 1 : 0;
    assign g2 = (NS == E) || (NS == F)? 1 : 0;
    assign f2 = (NS == D) || (NS == E) || (NS == G)? 1 : 0;

    always @(posedge clk)
        if(!resetn)
            PS <= A;
    	else
            PS <= NS;

    always @(posedge clk)
        if(!resetn)
            count <= 4'b0;
    	else if(PS == C2)
            count <= 4'b0;
    	else if(PS == DONE)
            count <= 4'b0;
    	else
            count <= count + 4'b1;

    always @(posedge clk)
        if(!resetn)
            done <= 1'b0;
    	else if(PS == DONE)
            done <= 1'b1;

    always @(*)
        case(PS)
            A: NS = x? B : A;
            B: NS = x? B : C;
            C: NS = x? B : D;
            D: NS = x? E : B;
            E: NS = x? E : C;
            F: NS = x? G : E;
            G: NS = x? G : F;
            C2: NS = x? DONE : C2;
            DONE: NS = x? DONE : C2;
            default: NS = PS;
        endcase

    always @(posedge clk)
        if(!resetn)
            f <= 1'b0;
    	else if(PS == F)
            f <= 1'b1;

    always @(posedge clk)
        if(!resetn)
            g <= 1'b0;
    	else if(PS == G)
            g <= 1'b1;

endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] PS, NS;
    reg [3:0] count;
    reg f, g, done;

    assign g = (PS == E) || (PS == F)? 1 : 0;
    assign f = (PS == D) || (PS == E) || (PS == G)? 1 : 0;
    assign g2 = (NS == E) || (NS == F)? 1 : 0;
    assign f2 = (NS == D) || (NS == E) || (NS == G)? 1 : 0;

    always @(posedge clk)
        if(!resetn)
            PS <= A;
    	else
            PS <= NS;

    always @(posedge clk)
        if(!resetn)
            count <= 4'b0;
    	else if(PS == C2)
            count <= 4'b0;
    	else if(PS == DONE)
            count <= 4'b0;
    	else
            count <= count + 4'b1;

    always @(posedge clk)
        if(!resetn)
            done <= 1'b0;
    	else if(PS == DONE)
            done <= 1'b1;

    always @(*)
        case(PS)
            A: NS = x? B : A;
            B: NS = x? B : C;
            C: NS = x? B : D;
            D: NS = x? E : B;
            E: NS = x? E : C;
            F: NS = x? G : E;
            G: NS = x? G : F;
            C2: NS = x? DONE : C2;
            DONE: NS = x? DONE : C2;
            default: NS = PS;
        endcase

    always @(posedge clk)
        if(!resetn)
            f <= 1'b0;
    	else if(PS == F)
            f <= 1'b1;

    always @(posedge clk)
        if(!resetn)
            g <= 1'b0;
    	else if(PS == G)
            g <= 1'b1;

endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, COUNT=8;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        case(state)
            A: begin
                if(~y)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(~y)
                    next_state = C;
                else
                    next_state = B;
            end
            C: begin
                if(~y)
                    next_state = D;
                else
                    next_state = C;
            end
            D: begin
                if(~y)
                    next_state = E;
                else
                    next_state = D;
            end
            E: begin
                if(~y)
                    next_state = F;
                else
                    next_state = E;
            end
            F: begin
                if(~y)
                    next_state = G;
                else
                    next_state = F;
            end
            G: begin
                if(~y)
                    next_state = DONE;
                else
                    next_state = G;
            end
            DONE: begin
                if(~y)
                    next_state = COUNT;
                else
                    next_state = DONE;
            end
            COUNT: begin
                if(count==3)
                    next_state = DONE;
                else
                    next_state = COUNT;
            end
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign f = (state == COUNT)? 1:0;
    assign g = (state == COUNT)? 1:0;
    
    // Counter for counting the number of times x has been asserted
    reg [2:0] count;
    always @(posedge clk) begin
        if(~resetn)
            count <= 0;
        else if(state == COUNT)
            count <= count + 1;
    end
    
endmodule",-0.5,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, COUNT=8;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        case(state)
            A: begin
                if(~y)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(~y)
                    next_state = C;
                else
                    next_state = B;
            end
            C: begin
                if(~y)
                    next_state = D;
                else
                    next_state = C;
            end
            D: begin
                if(~y)
                    next_state = E;
                else
                    next_state = D;
            end
            E: begin
                if(~y)
                    next_state = F;
                else
                    next_state = E;
            end
            F: begin
                if(~y)
                    next_state = G;
                else
                    next_state = F;
            end
            G: begin
                if(~y)
                    next_state = DONE;
                else
                    next_state = G;
            end
            DONE: begin
                if(~y)
                    next_state = COUNT;
                else
                    next_state = DONE;
            end
            COUNT: begin
                if(count==3)
                    next_state = DONE;
                else
                    next_state = COUNT;
            end
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign f = (state == COUNT)? 1:0;
    assign g = (state == COUNT)? 1:0;
    
    // Counter for counting the number of times x has been asserted
    reg [2:0] count;
    always @(posedge clk) begin
        if(~resetn)
            count <= 0;
        else if(state == COUNT)
            count <= count + 1;
    end
    
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                next_state = B;
                f = 0;
                g = 0;
            end
            B: begin
                next_state = C;
                f = 0;
                g = 0;
            end
            C: begin
                next_state = x? C2 : C;
                f = 0;
                g = 0;
            end
            C2: begin
                next_state = x? C2 : D;
                f = 0;
                g = 0;
            end
            D: begin
                next_state = x? E : C;
                f = 0;
                g = 0;
            end
            E: begin
                next_state = y? G : F;
                f = 0;
                g = 0;
            end
            F: begin
                next_state = y? G : DONE;
                f = 0;
                g = 0;
            end
            G: begin
                next_state = y? G : DONE;
                f = 0;
                g = 1;
            end
            DONE: begin
                next_state = DONE;
                f = 1;
                g = 0;
            end
            default: begin
                next_state = A;
                f = 0;
                g = 0;
            end
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state <= A;
        else
            state <= next_state;
endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, DONE=7, C2=8;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                next_state = B;
                f = 0;
                g = 0;
            end
            B: begin
                next_state = C;
                f = 0;
                g = 0;
            end
            C: begin
                next_state = x? C2 : C;
                f = 0;
                g = 0;
            end
            C2: begin
                next_state = x? C2 : D;
                f = 0;
                g = 0;
            end
            D: begin
                next_state = x? E : C;
                f = 0;
                g = 0;
            end
            E: begin
                next_state = y? G : F;
                f = 0;
                g = 0;
            end
            F: begin
                next_state = y? G : DONE;
                f = 0;
                g = 0;
            end
            G: begin
                next_state = y? G : DONE;
                f = 0;
                g = 1;
            end
            DONE: begin
                next_state = DONE;
                f = 1;
                g = 0;
            end
            default: begin
                next_state = A;
                f = 0;
                g = 0;
            end
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state <= A;
        else
            state <= next_state;
endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                next_state = B;
                f = 0;
                g = 0;
            end
            B: begin
                next_state = C;
                f = 0;
                g = 0;
            end
            C: begin
                next_state = x? D : E;
                f = 0;
                g = 0;
            end
            D: begin
                next_state = x? C : E;
                f = 0;
                g = 0;
            end
            E: begin
                next_state = x? C : F;
                f = 0;
                g = 0;
            end
            F: begin
                next_state = x? C : E;
                f = 0;
                g = 1;
            end
            default: begin
                next_state = A;
                f = 0;
                g = 0;
            end
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state <= A;
    	else
            state <= next_state;
    
    // Output logic
    assign g = (state == F)? 1:0;

endmodule",-1,Exams_2013_q2bfsm.v,"// Consider a finite state machine that is used to control some type of motor. The FSM has inputs x and y, which come from the motor, and produces outputs f and g, which control the motor. There is also a clock input called clk and a reset input called resetn.

// The FSM has to work as follows. As long as the reset input is asserted, the FSM stays in a beginning state, called state A. When the reset signal is de-asserted, then after the next clock edge the FSM has to set the output f to 1 for one clock cycle. Then, the FSM has to monitor the x input. When x has produced the values 1, 0, 1 in three successive clock cycles, then g should be set to 1 on the following clock cycle. While maintaining g = 1 the FSM has to monitor the y input. If y has the value 1 within at most two clock cycles, then the FSM should maintain g = 1 permanently (that is, until reset). But if y does not become 1 within two clock cycles, then the FSM should set g = 0 permanently (until reset).

// Implement the FSM

// Hint: The FSM does not begin to monitor the x input until the cycle after f is 1.

module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output f,
    output g
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                next_state = B;
                f = 0;
                g = 0;
            end
            B: begin
                next_state = C;
                f = 0;
                g = 0;
            end
            C: begin
                next_state = x? D : E;
                f = 0;
                g = 0;
            end
            D: begin
                next_state = x? C : E;
                f = 0;
                g = 0;
            end
            E: begin
                next_state = x? C : F;
                f = 0;
                g = 0;
            end
            F: begin
                next_state = x? C : E;
                f = 0;
                g = 1;
            end
            default: begin
                next_state = A;
                f = 0;
                g = 0;
            end
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(!resetn)
            state <= A;
    	else
            state <= next_state;
    
    // Output logic
    assign g = (state == F)? 1:0;

endmodule","module top_module (
    input clk,
    input resetn,    // active-low synchronous reset
    input x,
    input y,
    output reg f,
    output reg g
); 

    parameter A=4'd0, f1=4'd1, tmp0=4'd2, tmp1=4'd3, tmp2=4'd4, g1=4'd5, g1p=4'd6, tmp3=4'd7, g0p=4'd8;
    reg [3:0] state, next_state;
    
    always@(*) begin
        case(state)
            A: begin
                if(resetn) 
                    next_state = f1;
                else
                    next_state = A;
            end
            f1:     next_state = tmp0;
            tmp0: begin
                if(x)
                    next_state = tmp1;
                else
                    next_state = tmp0;
            end
            tmp1: begin
                if(~x)
                    next_state = tmp2;
                else
                    next_state = tmp1;
            end
            tmp2: begin
                if(x)
                    next_state = g1;
                else
                    next_state = tmp0;
            end
            g1: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = tmp3;
            end
            tmp3: begin
                if(y)
                    next_state = g1p;
                else
                    next_state = g0p;
            end
            g1p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g1p;
            end
            g0p: begin
                if(~resetn)
                    next_state = A;
                else
                    next_state = g0p;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(~resetn)
            state <= A;
        else
            state <= next_state;
    end
    
    always@(posedge clk) begin
        case(next_state)
            f1:     f <= 1'b1;
            g1,
            tmp3,
            g1p:    g <= 1'b1;
            g0p:    g <= 1'b0;
            default: begin
                    f <= 1'b0;
                    g <= 1'b0;
            end
        endcase
    end

endmodule
",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    // State transition logic: next_state = f(state,x)
    always @(*)
        case(state)
            A: begin
                if(x==1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            C: begin
                if(x==0)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
    	else
            state = next_state;
    // Output logic
    assign z = (state == D)? 1:0;
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    // State transition logic: next_state = f(state,x)
    always @(*)
        case(state)
            A: begin
                if(x==1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            C: begin
                if(x==0)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
    	else
            state = next_state;
    // Output logic
    assign z = (state == D)? 1:0;
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    // State transition logic
    always @(*) begin
        case(state)
            A: next_state <= x? B : A;
            B: next_state <= x? B : C;
            C: next_state <= x? D : A;
            D: next_state <= x? B : C;
            default: next_state <= state;
        endcase
    end
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    // Output logic
    assign z = (state == D);
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    // State transition logic
    always @(*) begin
        case(state)
            A: next_state <= x? B : A;
            B: next_state <= x? B : C;
            C: next_state <= x? D : A;
            D: next_state <= x? B : C;
            default: next_state <= state;
        endcase
    end
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    // Output logic
    assign z = (state == D);
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        case(state)
            A: begin
                if(x == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            
            B: begin
                if(x == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            
            C: begin
                if(x == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            
            D: begin
                if(x == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            
            default: next_state <= A;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == D)? 1:0;
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        case(state)
            A: begin
                if(x == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            
            B: begin
                if(x == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            
            C: begin
                if(x == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            
            D: begin
                if(x == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            
            default: next_state <= A;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    // Output logic
    assign z = (state == D)? 1:0;
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? C:A;
            C: NS <= (x)? D:A;
            D: NS <= (x)? E:A;
            E: NS <= (x)? E:F;
            F: NS <= (x)? C:A;
            default: NS <= PS;
        endcase

endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? C:A;
            C: NS <= (x)? D:A;
            D: NS <= (x)? E:A;
            E: NS <= (x)? E:F;
            F: NS <= (x)? C:A;
            default: NS <= PS;
        endcase

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == C))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= x? B:A;
            B: NS <= x? B:C;
            C: NS <= x? D:A;
            D: NS <= x? D:C;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == C))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= x? B:A;
            B: NS <= x? B:C;
            C: NS <= x? D:A;
            D: NS <= x? D:C;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    
    // State transition logic: next_state = f(state,x)
    always @(*)
        case(state)
            A: begin
                if(x==1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            C: begin
                if(x==0)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
    	else
            state = next_state;
    
    // Output logic:  z = f(state) for a Moore state machine
    assign z = (state == C || state == D);
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    
    // State transition logic: next_state = f(state,x)
    always @(*)
        case(state)
            A: begin
                if(x==1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            C: begin
                if(x==0)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if(x==1)
                    next_state = C;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
    	else
            state = next_state;
    
    // Output logic:  z = f(state) for a Moore state machine
    assign z = (state == C || state == D);
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case (PS)
            A: begin
                NS <= B;
                end
            B: begin
                NS <= C;
                end
            C: begin
                NS <= D;
                end
            D: begin
                NS <= E;
                end
            E: begin
                NS <= F;
                end
            F: begin
                NS <= F;
                end
            default: NS <= PS;
        endcase
    
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case (PS)
            A: begin
                NS <= B;
                end
            B: begin
                NS <= C;
                end
            C: begin
                NS <= D;
                end
            D: begin
                NS <= E;
                end
            E: begin
                NS <= F;
                end
            F: begin
                NS <= F;
                end
            default: NS <= PS;
        endcase
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case (PS)
            A: NS <= B;
            B: NS <= C;
            C: NS <= D;
            D: NS <= E;
            E: NS <= F;
            F: NS <= F;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case (PS)
            A: NS <= B;
            B: NS <= C;
            C: NS <= D;
            D: NS <= E;
            E: NS <= F;
            F: NS <= F;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == C))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= x? B:A;
            B: NS <= x? B:C;
            C: NS <= x? D:A;
            D: NS <= x? D:C;
            default: NS <= PS;
        endcase

endmodule",-0.5,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] PS, NS;
    
    assign z = ((PS == D) || (PS == C))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= x? B:A;
            B: NS <= x? B:C;
            C: NS <= x? D:A;
            D: NS <= x? D:C;
            default: NS <= PS;
        endcase

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*)
        case(state)
            A: begin
                next_state = x? B : A;
                z = 0;
            end
            B: begin
                next_state = x? B : C;
                z = 0;
            end
            C: begin
                next_state = x? D : A;
                z = 0;
            end
            D: begin
                next_state = x? B : C;
                z = x? 0 : 1;
            end
            default: next_state = state;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
    	else
            state = next_state;
endmodule",-1,Exams_2014_q3bfsm.v,"// Given the state-assigned table shown below, implement the finite-state machine. Reset should reset the FSM to state 000.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);
    parameter A=0, B=1, C=2, D=3;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*)
        case(state)
            A: begin
                next_state = x? B : A;
                z = 0;
            end
            B: begin
                next_state = x? B : C;
                z = 0;
            end
            C: begin
                next_state = x? D : A;
                z = 0;
            end
            D: begin
                next_state = x? B : C;
                z = x? 0 : 1;
            end
            default: next_state = state;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
    	else
            state = next_state;
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input x,
    output z
);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = x ? b : a;
            b: next_state = x ? e : b;
            c: next_state = x ? b : c;
            d: next_state = x ? c : b;
            e: next_state = x ? e : d;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign z = (state == d || state == e);

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] NS;
    
    always @(*)
        case(y)
            A: NS = x? B : A;
            B: NS = x? C : A;
            C: NS = x? D : A;
            D: NS = x? E : A;
            E: NS = x? E : F;
            F: NS = x? D : A;
            default: NS = 3'bxxx;
        endcase
    
    assign Y0 = NS[0];
    assign z = NS[2] & ~x;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] NS;
    
    always @(*)
        case(y)
            A: NS = x? B : A;
            B: NS = x? C : A;
            C: NS = x? D : A;
            D: NS = x? E : A;
            E: NS = x? E : F;
            F: NS = x? D : A;
            default: NS = 3'bxxx;
        endcase
    
    assign Y0 = NS[0];
    assign z = NS[2] & ~x;
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg Y0_, z_;
    
    always @(*) begin
        case({y, x})
            4'b0000: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0001: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0010: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0011: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b0100: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b0101: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0110: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0111: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b1000: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b1001: begin
                Y0_ = 1;
                z_ = 0;
            end
            default: begin
                Y0_ = 1'bx;
                z_ = 1'bx;
            end
        endcase
    end
    
    assign Y0 = Y0_;
    assign z = z_;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg Y0_, z_;
    
    always @(*) begin
        case({y, x})
            4'b0000: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0001: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0010: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0011: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b0100: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b0101: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0110: begin
                Y0_ = 0;
                z_ = 0;
            end
            4'b0111: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b1000: begin
                Y0_ = 1;
                z_ = 0;
            end
            4'b1001: begin
                Y0_ = 1;
                z_ = 0;
            end
            default: begin
                Y0_ = 1'bx;
                z_ = 1'bx;
            end
        endcase
    end
    
    assign Y0 = Y0_;
    assign z = z_;
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] Y;
    
    always @(*) begin
        case (y)
            3'd0: Y = x? 3'd1 : 3'd0;
            3'd1: Y = x? 3'd2 : 3'd0;
            3'd2: Y = x? 3'd1 : 3'd0;
            3'd3: Y = x? 3'd2 : 3'd0;
            default: Y = 3'd0;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2];
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] Y;
    
    always @(*) begin
        case (y)
            3'd0: Y = x? 3'd1 : 3'd0;
            3'd1: Y = x? 3'd2 : 3'd0;
            3'd2: Y = x? 3'd1 : 3'd0;
            3'd3: Y = x? 3'd2 : 3'd0;
            default: Y = 3'd0;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2];
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    reg [2:0] state;
    
    parameter A=3'b000, B=3'b001, C=3'b010, D=3'b011, E=3'b100;
    
    // State transition logic: next_state = f(state, x)
    always @(*)
        case(state)
            A: begin
                if(x==1) next_state = B;
                else next_state = A;
            end
            B: begin
                if(x==1) next_state = C;
                else next_state = A;
            end
            C: begin
                if(x==1) next_state = D;
                else next_state = A;
            end
            D: begin
                if(x==1) next_state = E;
                else next_state = A;
            end
            E: begin
                if(x==1) next_state = B;
                else next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
        else
            state = next_state;
    
    // Output logic: Y0 = f(state) for a Moore state machine
    assign Y0 = (state == E)? 1:0;
    
    // z = f(state) for a Mealy state machine
    assign z = (state == E) || (state == D)? 1:0;

endmodule",-1,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    reg [2:0] state;
    
    parameter A=3'b000, B=3'b001, C=3'b010, D=3'b011, E=3'b100;
    
    // State transition logic: next_state = f(state, x)
    always @(*)
        case(state)
            A: begin
                if(x==1) next_state = B;
                else next_state = A;
            end
            B: begin
                if(x==1) next_state = C;
                else next_state = A;
            end
            C: begin
                if(x==1) next_state = D;
                else next_state = A;
            end
            D: begin
                if(x==1) next_state = E;
                else next_state = A;
            end
            E: begin
                if(x==1) next_state = B;
                else next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state = A;
        else
            state = next_state;
    
    // Output logic: Y0 = f(state) for a Moore state machine
    assign Y0 = (state == E)? 1:0;
    
    // z = f(state) for a Mealy state machine
    assign z = (state == E) || (state == D)? 1:0;

endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    reg [2:0] state;
    
    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;
    
    // State transition logic: next_state = f(state,x)
    always @(*)
        case(state)
            A: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(x == 0)
                    next_state = C;
                else
                    next_state = E;
            end
            C: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = D;
            end
            D: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = E;
            end
            E: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(y[2] == 1'b0)
            state <= A;
        else
            state <= next_state;
    
    // Output logic: Y0 = f(state) for a Moore state machine
    assign Y0 = (state == E)? 1:0;
    
    // z = (state == D)? 1:0;
    assign z = (state == D)? 1:0;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    reg [2:0] state;
    
    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;
    
    // State transition logic: next_state = f(state,x)
    always @(*)
        case(state)
            A: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(x == 0)
                    next_state = C;
                else
                    next_state = E;
            end
            C: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = D;
            end
            D: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = E;
            end
            E: begin
                if(x == 0)
                    next_state = B;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(y[2] == 1'b0)
            state <= A;
        else
            state <= next_state;
    
    // Output logic: Y0 = f(state) for a Moore state machine
    assign Y0 = (state == E)? 1:0;
    
    // z = (state == D)? 1:0;
    assign z = (state == D)? 1:0;
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    reg [2:0] state;
    
    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;
    
    // State transition logic: next_state = f(state,x)
    always @(*)
        case (state)
            A: begin
                if (x == 1'b0)
                    next_state = A;
                else
                    next_state = B;
            end
            B: begin
                if (x == 1'b0)
                    next_state = C;
                else
                    next_state = E;
            end
            C: begin
                if (x == 1'b0)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if (x == 1'b0)
                    next_state = C;
                else
                    next_state = B;
            end
            E: begin
                if (x == 1'b0)
                    next_state = A;
                else
                    next_state = E;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if (y[2] == 1'b1)
            state <= E;
        else
            state <= next_state;
    
    // Output logic: Y0 = f(state) for a Moore state machine
    assign Y0 = (state == E)? 1'b1 : 1'b0;
    
    // Output logic: z = f(state) for a Mealy state machine
    assign z = (state == E)? (y[2] == 1'b1) : (y[2] == 1'b0);
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    reg [2:0] state;
    
    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100;
    
    // State transition logic: next_state = f(state,x)
    always @(*)
        case (state)
            A: begin
                if (x == 1'b0)
                    next_state = A;
                else
                    next_state = B;
            end
            B: begin
                if (x == 1'b0)
                    next_state = C;
                else
                    next_state = E;
            end
            C: begin
                if (x == 1'b0)
                    next_state = A;
                else
                    next_state = D;
            end
            D: begin
                if (x == 1'b0)
                    next_state = C;
                else
                    next_state = B;
            end
            E: begin
                if (x == 1'b0)
                    next_state = A;
                else
                    next_state = E;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if (y[2] == 1'b1)
            state <= E;
        else
            state <= next_state;
    
    // Output logic: Y0 = f(state) for a Moore state machine
    assign Y0 = (state == E)? 1'b1 : 1'b0;
    
    // Output logic: z = f(state) for a Mealy state machine
    assign z = (state == E)? (y[2] == 1'b1) : (y[2] == 1'b0);
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg Y0_, z_;
    
    always @ (posedge clk) begin
        case (y)
            3'd0: begin
                Y0_ <= 1'b0;
                z_ <= 1'b0;
            end
            3'd1: begin
                Y0_ <= 1'b0;
                z_ <= 1'b0;
            end
            3'd2: begin
                Y0_ <= 1'b1;
                z_ <= 1'b0;
            end
            3'd3: begin
                Y0_ <= 1'b0;
                z_ <= 1'b1;
            end
            3'd4: begin
                Y0_ <= 1'b0;
                z_ <= 1'b1;
            end
            3'd5: begin
                Y0_ <= 1'b1;
                z_ <= 1'b1;
            end
            default: begin
                Y0_ <= 1'b0;
                z_ <= 1'b0;
            end
        endcase
    end
    
    assign Y0 = Y0_;
    assign z = z_;
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    reg Y0_, z_;
    
    always @ (posedge clk) begin
        case (y)
            3'd0: begin
                Y0_ <= 1'b0;
                z_ <= 1'b0;
            end
            3'd1: begin
                Y0_ <= 1'b0;
                z_ <= 1'b0;
            end
            3'd2: begin
                Y0_ <= 1'b1;
                z_ <= 1'b0;
            end
            3'd3: begin
                Y0_ <= 1'b0;
                z_ <= 1'b1;
            end
            3'd4: begin
                Y0_ <= 1'b0;
                z_ <= 1'b1;
            end
            3'd5: begin
                Y0_ <= 1'b1;
                z_ <= 1'b1;
            end
            default: begin
                Y0_ <= 1'b0;
                z_ <= 1'b0;
            end
        endcase
    end
    
    assign Y0 = Y0_;
    assign z = z_;
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] Y;
    
    always @(*) begin
        case (y)
            3'b000: Y = x? 3'b001 : 3'b000;
            3'b001: Y = x? 3'b100 : 3'b010;
            3'b010: Y = x? 3'b001 : 3'b011;
            3'b011: Y = x? 3'b100 : 3'b100;
            3'b100: Y = x? 3'b010 : 3'b011;
            3'b101: Y = x? 3'b000 : 3'b001;
            default: Y = x? 3'b010 : 3'b011;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] & ~x;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] Y;
    
    always @(*) begin
        case (y)
            3'b000: Y = x? 3'b001 : 3'b000;
            3'b001: Y = x? 3'b100 : 3'b010;
            3'b010: Y = x? 3'b001 : 3'b011;
            3'b011: Y = x? 3'b100 : 3'b100;
            3'b100: Y = x? 3'b010 : 3'b011;
            3'b101: Y = x? 3'b000 : 3'b001;
            default: Y = x? 3'b010 : 3'b011;
        endcase
    end
    
    assign Y0 = Y[0];
    assign z = Y[2] & ~x;
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg Y0_, z_;
    
    always @ (posedge clk) begin
        Y0_ <= (y == 3'd0)? 1'b0 : 1'b1;
        z_ <= (y == 3'd1)? 1'b1 : 1'b0;
    end
    
    assign Y0 = Y0_;
    assign z = z_;
    
endmodule",-0.5,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg Y0_, z_;
    
    always @ (posedge clk) begin
        Y0_ <= (y == 3'd0)? 1'b0 : 1'b1;
        z_ <= (y == 3'd1)? 1'b1 : 1'b0;
    end
    
    assign Y0 = Y0_;
    assign z = z_;
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    
    // State transition logic
    always @(*) begin
        case(y)
            3'b000: next_state <= x? 3'b001 : 3'b000;
            3'b001: next_state <= x? 3'b100 : 3'b010;
            3'b010: next_state <= x? 3'b001 : 3'b011;
            3'b011: next_state <= x? 3'b100 : 3'b000;
            3'b100: next_state <= x? 3'b010 : 3'b011;
            default: next_state <= x? 3'b001 : 3'b000;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(y[2] == 1'b0)
            y <= 3'b000;
        else
            y <= next_state;
    end
    
    // Output logic
    assign Y0 = (y == 3'b100) || (y == 3'b010) || (y == 3'b011);
    assign z = (y == 3'b000) || (y == 3'b100);
    
endmodule",-1,Exams_2014_q3c.v,"// Given the state-assigned table shown below, implement the logic functions Y[0] and z.

//Present state 		Next state Y[2:0]
//		y[2:0]								Output z
//							x=0	x=1
						
//		000					000	001				0
//		001					001	100				0
//		010					010	001				0
//		011					001	010				1
//		100					011	100				1


module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);
    
    reg [2:0] next_state;
    
    // State transition logic
    always @(*) begin
        case(y)
            3'b000: next_state <= x? 3'b001 : 3'b000;
            3'b001: next_state <= x? 3'b100 : 3'b010;
            3'b010: next_state <= x? 3'b001 : 3'b011;
            3'b011: next_state <= x? 3'b100 : 3'b000;
            3'b100: next_state <= x? 3'b010 : 3'b011;
            default: next_state <= x? 3'b001 : 3'b000;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(y[2] == 1'b0)
            y <= 3'b000;
        else
            y <= next_state;
    end
    
    // Output logic
    assign Y0 = (y == 3'b100) || (y == 3'b010) || (y == 3'b011);
    assign z = (y == 3'b000) || (y == 3'b100);
    
endmodule","module top_module (
    input clk,
    input [2:0] y,
    input x,
    output Y0,
    output z
);

    reg [2:0] Y;
    
    always@(*) begin
        case({y, x})
            4'b0000:    Y = 3'b000;
            4'b0001:    Y = 3'b001;
            4'b0010:    Y = 3'b001;
            4'b0011:    Y = 3'b100;
            4'b0100:    Y = 3'b010;
            4'b0101:    Y = 3'b001;
            4'b0110:    Y = 3'b001;
            4'b0111:    Y = 3'b010;
            4'b1000:    Y = 3'b011;
            4'b1001:    Y = 3'b100;
        endcase
    end
    
    assign  z = (y == 3'b011 || y == 3'b100);
    assign Y0 = Y[0];

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3;
    reg [1:0] PS, NS;
    
    assign z = ((PS == C) || (PS == D))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case (PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            D: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            default: NS <= PS;
        endcase

endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3;
    reg [1:0] PS, NS;
    
    assign z = ((PS == C) || (PS == D))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case (PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            D: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            default: NS <= PS;
        endcase

endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                if(w == 0)
                    next_state = A;
                else
                    next_state = B;
            end
            B: begin
                if(w == 0)
                    next_state = C;
                else
                    next_state = D;
            end
            C: begin
                if(w == 0)
                    next_state = E;
                else
                    next_state = F;
            end
            D: begin
                if(w == 0)
                    next_state = G;
                else
                    next_state = H;
            end
            E: begin
                if(w == 0)
                    next_state = I;
                else
                    next_state = J;
            end
            F: begin
                if(w == 0)
                    next_state = K;
                else
                    next_state = I;
            end
            G: begin
                if(w == 0)
                    next_state = E;
                else
                    next_state = H;
            end
            H: begin
                if(w == 0)
                    next_state = I;
                else
                    next_state = J;
            end
            I: begin
                if(w == 0)
                    next_state = K;
                else
                    next_state = I;
            end
            J: begin
                if(w == 0)
                    next_state = E;
                else
                    next_state = H;
            end
            K: begin
                if(w == 0)
                    next_state = I;
                else
                    next_state = J;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign z = (state == F) || (state == G) || (state == H) || (state == I) || (state == J) || (state == K);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                if(w == 0)
                    next_state = A;
                else
                    next_state = B;
            end
            B: begin
                if(w == 0)
                    next_state = C;
                else
                    next_state = D;
            end
            C: begin
                if(w == 0)
                    next_state = E;
                else
                    next_state = F;
            end
            D: begin
                if(w == 0)
                    next_state = G;
                else
                    next_state = H;
            end
            E: begin
                if(w == 0)
                    next_state = I;
                else
                    next_state = J;
            end
            F: begin
                if(w == 0)
                    next_state = K;
                else
                    next_state = I;
            end
            G: begin
                if(w == 0)
                    next_state = E;
                else
                    next_state = H;
            end
            H: begin
                if(w == 0)
                    next_state = I;
                else
                    next_state = J;
            end
            I: begin
                if(w == 0)
                    next_state = K;
                else
                    next_state = I;
            end
            J: begin
                if(w == 0)
                    next_state = E;
                else
                    next_state = H;
            end
            K: begin
                if(w == 0)
                    next_state = I;
                else
                    next_state = J;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign z = (state == F) || (state == G) || (state == H) || (state == I) || (state == J) || (state == K);
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                if(w == 1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(w == 1)
                    next_state = C;
                else
                    next_state = A;
            end
            C: begin
                if(w == 1)
                    next_state = D;
                else
                    next_state = A;
            end
            D: begin
                if(w == 1)
                    next_state = E;
                else
                    next_state = A;
            end
            E: begin
                if(w == 1)
                    next_state = B;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign z = (state == E && s == 1);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            A: begin
                if(w == 1)
                    next_state = B;
                else
                    next_state = A;
            end
            B: begin
                if(w == 1)
                    next_state = C;
                else
                    next_state = A;
            end
            C: begin
                if(w == 1)
                    next_state = D;
                else
                    next_state = A;
            end
            D: begin
                if(w == 1)
                    next_state = E;
                else
                    next_state = A;
            end
            E: begin
                if(w == 1)
                    next_state = B;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign z = (state == E && s == 1);
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            B: begin
                if(w)
                    next_state <= C;
                else
                    next_state <= A;
            end
            C: begin
                if(w)
                    next_state <= D;
                else
                    next_state <= A;
            end
            D: begin
                if(w)
                    next_state <= E;
                else
                    next_state <= A;
            end
            E: begin
                if(w)
                    next_state <= F;
                else
                    next_state <= A;
            end
            F: begin
                if(w)
                    next_state <= G;
                else
                    next_state <= A;
            end
            G: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            default: begin
                next_state <= A;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == F || state == G);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            B: begin
                if(w)
                    next_state <= C;
                else
                    next_state <= A;
            end
            C: begin
                if(w)
                    next_state <= D;
                else
                    next_state <= A;
            end
            D: begin
                if(w)
                    next_state <= E;
                else
                    next_state <= A;
            end
            E: begin
                if(w)
                    next_state <= F;
                else
                    next_state <= A;
            end
            F: begin
                if(w)
                    next_state <= G;
                else
                    next_state <= A;
            end
            G: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            default: begin
                next_state <= A;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == F || state == G);
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case(PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(s == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            D: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            E: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            F: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= C;
            end
            
            default: NS <= PS;
        endcase
        
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case(PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(s == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            D: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            E: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            F: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= C;
            end
            
            default: NS <= PS;
        endcase
        
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case({state, s})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = D;
            {C, 1'b1}: next_state = B;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == D)? 1:0;
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case({state, s})
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = C;
            {B, 1'b1}: next_state = B;
            {C, 1'b0}: next_state = D;
            {C, 1'b1}: next_state = B;
            {D, 1'b0}: next_state = C;
            {D, 1'b1}: next_state = B;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign z = (state == D)? 1:0;
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25;
    reg [4:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(w) next_state = B;
                else next_state = A;
            end
            B: begin
                if(w) next_state = C;
                else next_state = A;
            end
            C: begin
                if(w) next_state = D;
                else next_state = A;
            end
            D: begin
                if(w) next_state = E;
                else next_state = A;
            end
            E: begin
                if(w) next_state = F;
                else next_state = A;
            end
            F: begin
                if(w) next_state = G;
                else next_state = A;
            end
            G: begin
                if(w) next_state = H;
                else next_state = A;
            end
            H: begin
                if(w) next_state = I;
                else next_state = A;
            end
            I: begin
                if(w) next_state = J;
                else next_state = A;
            end
            J: begin
                if(w) next_state = K;
                else next_state = A;
            end
            K: begin
                if(w) next_state = L;
                else next_state = A;
            end
            L: begin
                if(w) next_state = M;
                else next_state = A;
            end
            M: begin
                if(w) next_state = N;
                else next_state = A;
            end
            N: begin
                if(w) next_state = O;
                else next_state = A;
            end
            O: begin
                if(w) next_state = P;
                else next_state = A;
            end
            P: begin
                if(w) next_state = Q;
                else next_state = A;
            end
            Q: begin
                if(w) next_state = R;
                else next_state = A;
            end
            R: begin
                if(w) next_state = S;
                else next_state = A;
            end
            S: begin
                if(w) next_state = T;
                else next_state = A;
            end
            T: begin
                if(w) next_state = U;
                else next_state = A;
            end
            U: begin
                if(w) next_state = V;
                else next_state = A;
            end
            V: begin
                if(w) next_state = W;
                else next_state = A;
            end
            W: begin
                if(w) next_state = X;
                else next_state = A;
            end
            X: begin
                if(w) next_state = Y;
                else next_state = A;
            end
            Y: begin
                if(w) next_state = Z;
                else next_state = A;
            end
            Z: begin
                if(w) next_state = Z;
                else next_state = A;
            end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) state <= A;
        else state <= next_state;
    end
    
    assign z = (state == F) || (state == T) || (state == U) || (state == V) || (state == W) || (state == X) || (state == Y) || (state == Z);
    
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25;
    reg [4:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(w) next_state = B;
                else next_state = A;
            end
            B: begin
                if(w) next_state = C;
                else next_state = A;
            end
            C: begin
                if(w) next_state = D;
                else next_state = A;
            end
            D: begin
                if(w) next_state = E;
                else next_state = A;
            end
            E: begin
                if(w) next_state = F;
                else next_state = A;
            end
            F: begin
                if(w) next_state = G;
                else next_state = A;
            end
            G: begin
                if(w) next_state = H;
                else next_state = A;
            end
            H: begin
                if(w) next_state = I;
                else next_state = A;
            end
            I: begin
                if(w) next_state = J;
                else next_state = A;
            end
            J: begin
                if(w) next_state = K;
                else next_state = A;
            end
            K: begin
                if(w) next_state = L;
                else next_state = A;
            end
            L: begin
                if(w) next_state = M;
                else next_state = A;
            end
            M: begin
                if(w) next_state = N;
                else next_state = A;
            end
            N: begin
                if(w) next_state = O;
                else next_state = A;
            end
            O: begin
                if(w) next_state = P;
                else next_state = A;
            end
            P: begin
                if(w) next_state = Q;
                else next_state = A;
            end
            Q: begin
                if(w) next_state = R;
                else next_state = A;
            end
            R: begin
                if(w) next_state = S;
                else next_state = A;
            end
            S: begin
                if(w) next_state = T;
                else next_state = A;
            end
            T: begin
                if(w) next_state = U;
                else next_state = A;
            end
            U: begin
                if(w) next_state = V;
                else next_state = A;
            end
            V: begin
                if(w) next_state = W;
                else next_state = A;
            end
            W: begin
                if(w) next_state = X;
                else next_state = A;
            end
            X: begin
                if(w) next_state = Y;
                else next_state = A;
            end
            Y: begin
                if(w) next_state = Z;
                else next_state = A;
            end
            Z: begin
                if(w) next_state = Z;
                else next_state = A;
            end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) state <= A;
        else state <= next_state;
    end
    
    assign z = (state == F) || (state == T) || (state == U) || (state == V) || (state == W) || (state == X) || (state == Y) || (state == Z);
    
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25;
    reg [3:0] state;
    reg [3:0] next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            B: begin
                if(w)
                    next_state <= C;
                else
                    next_state <= A;
            end
            C: begin
                if(w)
                    next_state <= D;
                else
                    next_state <= A;
            end
            D: begin
                if(w)
                    next_state <= E;
                else
                    next_state <= A;
            end
            E: begin
                if(w)
                    next_state <= F;
                else
                    next_state <= A;
            end
            F: begin
                if(w)
                    next_state <= G;
                else
                    next_state <= A;
            end
            G: begin
                if(w)
                    next_state <= H;
                else
                    next_state <= A;
            end
            H: begin
                if(w)
                    next_state <= I;
                else
                    next_state <= A;
            end
            I: begin
                if(w)
                    next_state <= J;
                else
                    next_state <= A;
            end
            J: begin
                if(w)
                    next_state <= K;
                else
                    next_state <= A;
            end
            K: begin
                if(w)
                    next_state <= L;
                else
                    next_state <= A;
            end
            L: begin
                if(w)
                    next_state <= M;
                else
                    next_state <= A;
            end
            M: begin
                if(w)
                    next_state <= N;
                else
                    next_state <= A;
            end
            N: begin
                if(w)
                    next_state <= O;
                else
                    next_state <= A;
            end
            O: begin
                if(w)
                    next_state <= P;
                else
                    next_state <= A;
            end
            P: begin
                if(w)
                    next_state <= Q;
                else
                    next_state <= A;
            end
            Q: begin
                if(w)
                    next_state <= R;
                else
                    next_state <= A;
            end
            R: begin
                if(w)
                    next_state <= S;
                else
                    next_state <= A;
            end
            S: begin
                if(w)
                    next_state <= T;
                else
                    next_state <= A;
            end
            T: begin
                if(w)
                    next_state <= U;
                else
                    next_state <= A;
            end
            U: begin
                if(w)
                    next_state <= V;
                else
                    next_state <= A;
            end
            V: begin
                if(w)
                    next_state <= W;
                else
                    next_state <= A;
            end
            W: begin
                if(w)
                    next_state <= X;
                else
                    next_state <= A;
            end
            X: begin
                if(w)
                    next_state <= Y;
                else
                    next_state <= A;
            end
            Y: begin
                if(w)
                    next_state <= Z;
                else
                    next_state <= A;
            end
            Z: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            default: next_state <= A;
        endcase
    end",-1,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6, H=7, I=8, J=9, K=10, L=11, M=12, N=13, O=14, P=15, Q=16, R=17, S=18, T=19, U=20, V=21, W=22, X=23, Y=24, Z=25;
    reg [3:0] state;
    reg [3:0] next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            B: begin
                if(w)
                    next_state <= C;
                else
                    next_state <= A;
            end
            C: begin
                if(w)
                    next_state <= D;
                else
                    next_state <= A;
            end
            D: begin
                if(w)
                    next_state <= E;
                else
                    next_state <= A;
            end
            E: begin
                if(w)
                    next_state <= F;
                else
                    next_state <= A;
            end
            F: begin
                if(w)
                    next_state <= G;
                else
                    next_state <= A;
            end
            G: begin
                if(w)
                    next_state <= H;
                else
                    next_state <= A;
            end
            H: begin
                if(w)
                    next_state <= I;
                else
                    next_state <= A;
            end
            I: begin
                if(w)
                    next_state <= J;
                else
                    next_state <= A;
            end
            J: begin
                if(w)
                    next_state <= K;
                else
                    next_state <= A;
            end
            K: begin
                if(w)
                    next_state <= L;
                else
                    next_state <= A;
            end
            L: begin
                if(w)
                    next_state <= M;
                else
                    next_state <= A;
            end
            M: begin
                if(w)
                    next_state <= N;
                else
                    next_state <= A;
            end
            N: begin
                if(w)
                    next_state <= O;
                else
                    next_state <= A;
            end
            O: begin
                if(w)
                    next_state <= P;
                else
                    next_state <= A;
            end
            P: begin
                if(w)
                    next_state <= Q;
                else
                    next_state <= A;
            end
            Q: begin
                if(w)
                    next_state <= R;
                else
                    next_state <= A;
            end
            R: begin
                if(w)
                    next_state <= S;
                else
                    next_state <= A;
            end
            S: begin
                if(w)
                    next_state <= T;
                else
                    next_state <= A;
            end
            T: begin
                if(w)
                    next_state <= U;
                else
                    next_state <= A;
            end
            U: begin
                if(w)
                    next_state <= V;
                else
                    next_state <= A;
            end
            V: begin
                if(w)
                    next_state <= W;
                else
                    next_state <= A;
            end
            W: begin
                if(w)
                    next_state <= X;
                else
                    next_state <= A;
            end
            X: begin
                if(w)
                    next_state <= Y;
                else
                    next_state <= A;
            end
            Y: begin
                if(w)
                    next_state <= Z;
                else
                    next_state <= A;
            end
            Z: begin
                if(w)
                    next_state <= B;
                else
                    next_state <= A;
            end
            default: next_state <= A;
        endcase
    end","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case(PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            D: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= G;
            end
            
            E: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            F: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= G;
            end
            
            G: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case(PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            D: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= G;
            end
            
            E: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            F: begin
                if(w == 0)
                    NS <= E;
                else
                    NS <= G;
            end
            
            G: begin
                if(w == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case(PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(s == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            D: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            E: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            F: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_2014_q3fsm.v,"// Consider a finite state machine with inputs s and w. Assume that the FSM begins in a reset state called A, as depicted below. The FSM remains in state A as long as s = 0, and it moves to state B when s = 1. Once in state B the FSM examines the value of the input w in the next three clock cycles. If w = 1 in exactly two of these clock cycles, then the FSM has to set an output z to 1 in the following clock cycle. Otherwise z has to be 0. The FSM continues checking w for the next three clock cycles, and so on. The timing diagram below illustrates the required values of z for different values of w.

// Use as few states as possible. Note that the s input is used only in state A, so you need to consider just the w input.

module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, s, w)
        case(PS)
            A: begin
                if(s == 0)
                    NS <= A;
                else
                    NS <= B;
            end
            
            B: begin
                if(s == 0)
                    NS <= C;
                else
                    NS <= D;
            end
            
            C: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            D: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            E: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            F: begin
                if(s == 0)
                    NS <= E;
                else
                    NS <= F;
            end
            
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,   // Synchronous reset
    input s,
    input w,
    output z
);

    parameter A = 0, B = 1;
    reg [2:0] state, next_state;
    reg [2:0] w_new;
    reg [2:0] count;

    always @(*) begin
        case ({state, s})
            // there will be a wrong message, if write like {A, 0}
            {A, 1'b0}: next_state = A;
            {A, 1'b1}: next_state = B;
            {B, 1'b0}: next_state = B;
            {B, 1'b1}: next_state = B;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= A;
        end
        else begin
            state <= next_state;
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            w_new <= 0;
        end
        else if (next_state == B) begin
            w_new <= {w_new[1:0], w};
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
        end
        else if (next_state == B) begin
            if (count == 3) begin
                count <= 1;
            end
            else begin
                count <= count + 1;
            end
        end
    end

    assign z = (count == 1 && (w_new == 3'b011 || w_new == 3'b110 || w_new == 3'b101));

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    
    mux4to1 m1(
       .in(SW),
       .sel(KEY[1:0]),
       .out(LEDR[3:0])
    );",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    
    mux4to1 m1(
       .in(SW),
       .sel(KEY[1:0]),
       .out(LEDR[3:0])
    );","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    muxdff m0(.d(SW[0]),.clk(KEY[0]),.q(LEDR[0]));
    muxdff m1(.d(SW[1]),.clk(KEY[0]),.q(LEDR[1]));
    muxdff m2(.d(SW[2]),.clk(KEY[0]),.q(LEDR[2]));
    muxdff m3(.d(SW[3]),.clk(KEY[0]),.q(LEDR[3]));

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    muxdff m0(.d(SW[0]),.clk(KEY[0]),.q(LEDR[0]));
    muxdff m1(.d(SW[1]),.clk(KEY[0]),.q(LEDR[1]));
    muxdff m2(.d(SW[2]),.clk(KEY[0]),.q(LEDR[2]));
    muxdff m3(.d(SW[3]),.clk(KEY[0]),.q(LEDR[3]));

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    wire [3:0] Q;
    
    muxdff mux0 (KEY[0], SW[3], KEY[3], KEY[2], KEY[1], Q[0]);
    muxdff mux1 (KEY[0], SW[2], KEY[3], KEY[2], KEY[1], Q[1]);
    muxdff mux2 (KEY[0], SW[1], KEY[3], KEY[2], KEY[1], Q[2]);
    muxdff mux3 (KEY[0], SW[0], KEY[3], KEY[2], KEY[1], Q[3]);
    
    assign LEDR[3:0] = Q[3:0];

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    wire [3:0] Q;
    
    muxdff mux0 (KEY[0], SW[3], KEY[3], KEY[2], KEY[1], Q[0]);
    muxdff mux1 (KEY[0], SW[2], KEY[3], KEY[2], KEY[1], Q[1]);
    muxdff mux2 (KEY[0], SW[1], KEY[3], KEY[2], KEY[1], Q[2]);
    muxdff mux3 (KEY[0], SW[0], KEY[3], KEY[2], KEY[1], Q[3]);
    
    assign LEDR[3:0] = Q[3:0];

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    
    // Use the four-bit binary mux from your design to implement the following circuit.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    
    // Use the four-bit binary mux from your design to implement the following circuit.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the MUXDFF is the output of the MUX.
    // The input to the","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    mux_4_to_1 mux_4_to_1_1(
       .in(SW[3:0]),
       .sel(KEY[3:1]),
       .out(LEDR[3:0])
    );

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    mux_4_to_1 mux_4_to_1_1(
       .in(SW[3:0]),
       .sel(KEY[3:1]),
       .out(LEDR[3:0])
    );

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    muxdff m0(SW[0], KEY[0], SW[3], KEY[3], LEDR[0]);
    muxdff m1(SW[1], KEY[0], SW[2], KEY[2], LEDR[1]);
    muxdff m2(SW[2], KEY[0], SW[1], KEY[1], LEDR[2]);
    muxdff m3(SW[3], KEY[0], SW[0], KEY[1], LEDR[3]);

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    muxdff m0(SW[0], KEY[0], SW[3], KEY[3], LEDR[0]);
    muxdff m1(SW[1], KEY[0], SW[2], KEY[2], LEDR[1]);
    muxdff m2(SW[2], KEY[0], SW[1], KEY[1], LEDR[2]);
    muxdff m3(SW[3], KEY[0], SW[0], KEY[1], LEDR[3]);

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    mux4to1 mux1(
       .in(SW),
       .out(LEDR[3:0])
    );

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    mux4to1 mux1(
       .in(SW),
       .out(LEDR[3:0])
    );

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    
    mux4to1 m1(
       .in(SW),
       .sel(KEY[3:1]),
       .out(LEDR[3:0])
    );
    
    
    
endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    // Write your code here
    
    mux4to1 m1(
       .in(SW),
       .sel(KEY[3:1]),
       .out(LEDR[3:0])
    );
    
    
    
endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    muxdff mux1(SW[3], KEY[3], SW[1], KEY[1], SW[0], KEY[0], LEDR[3]);
    muxdff mux2(SW[2], KEY[2], LEDR[3], KEY[1], SW[0], KEY[0], LEDR[2]);
    muxdff mux3(SW[1], KEY[1], LEDR[2], KEY[0], SW[0], KEY[0], LEDR[1]);
    muxdff mux4(SW[0], KEY[0], LEDR[1], KEY[0], SW[0], KEY[0], LEDR[0]);

endmodule",-1,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    muxdff mux1(SW[3], KEY[3], SW[1], KEY[1], SW[0], KEY[0], LEDR[3]);
    muxdff mux2(SW[2], KEY[2], LEDR[3], KEY[1], SW[0], KEY[0], LEDR[2]);
    muxdff mux3(SW[1], KEY[1], LEDR[2], KEY[0], SW[0], KEY[0], LEDR[1]);
    muxdff mux4(SW[0], KEY[0], LEDR[1], KEY[0], SW[0], KEY[0], LEDR[0]);

endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    wire [3:0] Q, M;
    
    assign M = SW;
    
    assign Q[0] = KEY[0]? M[0] : 1'b0;
    assign Q[1] = KEY[1]? M[1] : 1'b0;
    assign Q[2] = KEY[2]? M[2] : 1'b0;
    assign Q[3] = KEY[3]? M[3] : 1'b0;
    
    assign LEDR[3:0] = Q[3:0];
    
endmodule",-0.5,Exams_2014_q4b.v,"// Write a top-level Verilog module (named top_module) for the shift register, assuming that n = 4. Instantiate four copies of your MUXDFF subcircuit in your top-level module. Assume that you are going to implement the circuit on the DE2 board.

// Connect the R inputs to the SW switches,
// clk to KEY[0],
// E to KEY[1],
// L to KEY[2], and
// w to KEY[3].
// Connect the outputs to the red lights LEDR[3:0].

module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //

    wire [3:0] Q, M;
    
    assign M = SW;
    
    assign Q[0] = KEY[0]? M[0] : 1'b0;
    assign Q[1] = KEY[1]? M[1] : 1'b0;
    assign Q[2] = KEY[2]? M[2] : 1'b0;
    assign Q[3] = KEY[3]? M[3] : 1'b0;
    
    assign LEDR[3:0] = Q[3:0];
    
endmodule","module top_module (
    input [3:0] SW,
    input [3:0] KEY,
    output [3:0] LEDR
); //
    
    MUXDFF ins0(SW[3], KEY[0], KEY[1], KEY[2], KEY[3], LEDR[3]);
    MUXDFF ins1(SW[2], KEY[0], KEY[1], KEY[2], LEDR[3], LEDR[2]);
    MUXDFF ins2(SW[1], KEY[0], KEY[1], KEY[2], LEDR[2], LEDR[1]);
    MUXDFF ins3(SW[0], KEY[0], KEY[1], KEY[2], LEDR[1], LEDR[0]);

endmodule

module MUXDFF (
    input R,
    input clk,
    input E,
    input L,
    input w,
    output out
);
    wire [1:0] mid;
    assign mid[0] = E ? w : out;
    assign mid[1] = L ? R : mid[0];
    
    always @(posedge clk) begin
        out <= mid[1];
    end

endmodule",,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    reg [2:0] state;
    reg [2:0] next_state;
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    
    always @(*) begin
        case(state)
            A: begin
                if(S == 1'b0) next_state = A;
                else next_state = B;
            end
            
            B: begin
                if(S == 1'b1) next_state = C;
                else next_state = B;
            end
            
            C: begin
                if(S == 1'b0) next_state = D;
                else next_state = E;
            end
            
            D: begin
                if(S == 1'b1) next_state = F;
                else next_state = B;
            end
            
            E: begin
                if(S == 1'b0) next_state = B;
                else next_state = E;
            end
            
            F: begin
                if(S == 1'b1) next_state = B;
                else next_state = A;
            end
            
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(enable) state <= next_state;
    end
    
    assign Z = (state == F)? 1'b1:1'b0;
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    reg [2:0] state;
    reg [2:0] next_state;
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    
    always @(*) begin
        case(state)
            A: begin
                if(S == 1'b0) next_state = A;
                else next_state = B;
            end
            
            B: begin
                if(S == 1'b1) next_state = C;
                else next_state = B;
            end
            
            C: begin
                if(S == 1'b0) next_state = D;
                else next_state = E;
            end
            
            D: begin
                if(S == 1'b1) next_state = F;
                else next_state = B;
            end
            
            E: begin
                if(S == 1'b0) next_state = B;
                else next_state = E;
            end
            
            F: begin
                if(S == 1'b1) next_state = B;
                else next_state = A;
            end
            
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(enable) state <= next_state;
    end
    
    assign Z = (state == F)? 1'b1:1'b0;
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [7:0] Q;
    reg [7:0] Qbar;
    reg [7:0] next_Q;
    reg [7:0] next_Qbar;
    
    always @(posedge clk) begin
        if(enable) begin
            Q <= next_Q;
            Qbar <= next_Qbar;
        end
    end
    
    always @(*) begin
        next_Q = Qbar;
        next_Qbar = Q;
        case({S,A,B,C})
            4'b0000: next_Q = Q;
            4'b0001: next_Q = B;
            4'b0010: next_Q = Qbar;
            4'b0011: next_Q = Qbar;
            4'b0100: next_Q = Q;
            4'b0101: next_Q = Qbar;
            4'b0110: next_Q = Qbar;
            4'b0111: next_Q = Q;
            4'b1000: next_Q = Qbar;
            4'b1001: next_Q = Q;
            4'b1010: next_Q = Qbar;
            4'b1011: next_Q = Q;
            4'b1100: next_Q = Qbar;
            4'b1101: next_Q = Q;
            4'b1110: next_Q = Qbar;
            4'b1111: next_Q = Q;
        endcase
    end
    
    assign Z = (Q[0] == 1);
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [7:0] Q;
    reg [7:0] Qbar;
    reg [7:0] next_Q;
    reg [7:0] next_Qbar;
    
    always @(posedge clk) begin
        if(enable) begin
            Q <= next_Q;
            Qbar <= next_Qbar;
        end
    end
    
    always @(*) begin
        next_Q = Qbar;
        next_Qbar = Q;
        case({S,A,B,C})
            4'b0000: next_Q = Q;
            4'b0001: next_Q = B;
            4'b0010: next_Q = Qbar;
            4'b0011: next_Q = Qbar;
            4'b0100: next_Q = Q;
            4'b0101: next_Q = Qbar;
            4'b0110: next_Q = Qbar;
            4'b0111: next_Q = Q;
            4'b1000: next_Q = Qbar;
            4'b1001: next_Q = Q;
            4'b1010: next_Q = Qbar;
            4'b1011: next_Q = Q;
            4'b1100: next_Q = Qbar;
            4'b1101: next_Q = Q;
            4'b1110: next_Q = Qbar;
            4'b1111: next_Q = Q;
        endcase
    end
    
    assign Z = (Q[0] == 1);
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q = {B, C, A};
    
    always @(posedge clk)
        if(enable)
            Z <= Q[0];
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q = {B, C, A};
    
    always @(posedge clk)
        if(enable)
            Z <= Q[0];
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & A & B & C);
    assign Q[1] = (S & A & ~B & C);
    assign Q[2] = (S & A & B & ~C);
    
    always @ (posedge clk)
        if (enable)
            Z <= Q[2];
        else
            Z <= Q[0];
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & A & B & C);
    assign Q[1] = (S & A & ~B & C);
    assign Q[2] = (S & A & B & ~C);
    
    always @ (posedge clk)
        if (enable)
            Z <= Q[2];
        else
            Z <= Q[0];
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [7:0] Q;
    reg [7:0] Qbar;
    
    always @(posedge clk)
        begin
            if(enable)
                begin
                    Qbar <= {Qbar[6:0], S};
                end
        end
    
    always @(*)
        begin
            if(A==0 && B==0 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==0 && B==0 && C==1)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==0 && B==1 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==0 && B==1 && C==1)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==1 && B==0 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==1 && B==0 && C==1)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==1 && B==1 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z =",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [7:0] Q;
    reg [7:0] Qbar;
    
    always @(posedge clk)
        begin
            if(enable)
                begin
                    Qbar <= {Qbar[6:0], S};
                end
        end
    
    always @(*)
        begin
            if(A==0 && B==0 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==0 && B==0 && C==1)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==0 && B==1 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==0 && B==1 && C==1)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==1 && B==0 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==1 && B==0 && C==1)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z = Q[2];
                        8'b00001000: Z = Q[3];
                        8'b00010000: Z = Q[4];
                        8'b00100000: Z = Q[5];
                        8'b01000000: Z = Q[6];
                        8'b10000000: Z = Q[7];
                    endcase
                end
            else if(A==1 && B==1 && C==0)
                begin
                    case(Qbar)
                        8'b00000001: Z = Q[0];
                        8'b00000010: Z = Q[1];
                        8'b00000100: Z =",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    wire [2:0] Q_next;
    
    assign Q[0] = (~S & B & C) | (~S & A & C) | (S & A & B) | (S & B & C) ;
    assign Q[1] = (~S & B & ~C) | (~S & A & ~C) | (S & A & B) | (S & B & C) ;
    assign Q[2] = (~S & ~B & C) | (~S & ~A & C) | (S & A & ~B) | (S & ~B & ~C) | (S & B & C) ;
    
    always @(posedge clk)
        if(enable)
            Q <= Q_next;
    
    assign Q_next = Q[2:0] ^ Q[2:0] ^ {Q[2],Q[1],Q[0]};
    assign Z = Q[2] | Q[1] | Q[0];
    
endmodule",-1,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    wire [2:0] Q_next;
    
    assign Q[0] = (~S & B & C) | (~S & A & C) | (S & A & B) | (S & B & C) ;
    assign Q[1] = (~S & B & ~C) | (~S & A & ~C) | (S & A & B) | (S & B & C) ;
    assign Q[2] = (~S & ~B & C) | (~S & ~A & C) | (S & A & ~B) | (S & ~B & ~C) | (S & B & C) ;
    
    always @(posedge clk)
        if(enable)
            Q <= Q_next;
    
    assign Q_next = Q[2:0] ^ Q[2:0] ^ {Q[2],Q[1],Q[0]};
    assign Z = Q[2] | Q[1] | Q[0];
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & enable) | (~S & Q[0]);
    assign Q[1] = (A & enable) | (~A & Q[1]);
    assign Q[2] = (B & enable) | (~B & Q[2]);
    assign Z = (C & enable) | (~C & Q[2]);
    
endmodule",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & enable) | (~S & Q[0]);
    assign Q[1] = (A & enable) | (~A & Q[1]);
    assign Q[2] = (B & enable) | (~B & Q[2]);
    assign Z = (C & enable) | (~C & Q[2]);
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & enable) | (~S & A);
    assign Q[1] = (S & enable) | (~S & B);
    assign Q[2] = (S & enable) | (~S & C);
    
    assign Z = Q[0] | Q[1] | Q[2];
    
endmodule",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & enable) | (~S & A);
    assign Q[1] = (S & enable) | (~S & B);
    assign Q[2] = (S & enable) | (~S & C);
    
    assign Z = Q[0] | Q[1] | Q[2];
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    reg [2:0] state;
    reg [2:0] next_state;
    reg [2:0] count;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(enable)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b000;
            end
            3'b001: begin
                if(count==3'b111)
                    next_state <= 3'b000;
                else
                    next_state <= 3'b010;
            end
            3'b010: begin
                if(enable)
                    next_state <= 3'b011;
                else
                    next_state <= 3'b010;
            end
            3'b011: begin
                if(count==3'b111)
                    next_state <= 3'b000;
                else
                    next_state <= 3'b100;
            end
            3'b100: begin
                if(enable)
                    next_state <= 3'b101;
                else
                    next_state <= 3'b100;
            end
            3'b101: begin
                if(count==3'b111)
                    next_state <= 3'b000;
                else
                    next_state <= 3'b110;
            end
            3'b110: begin
                if(enable)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b110;
            end
            default: begin
                next_state <= 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(enable) begin
            state <= next_state;
            count <= count + 1;
        end
    end
    
    assign Z = (state == 3'b100 || state == 3'b110)? 1:0;
    
endmodule",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    reg [2:0] state;
    reg [2:0] next_state;
    reg [2:0] count;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(enable)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b000;
            end
            3'b001: begin
                if(count==3'b111)
                    next_state <= 3'b000;
                else
                    next_state <= 3'b010;
            end
            3'b010: begin
                if(enable)
                    next_state <= 3'b011;
                else
                    next_state <= 3'b010;
            end
            3'b011: begin
                if(count==3'b111)
                    next_state <= 3'b000;
                else
                    next_state <= 3'b100;
            end
            3'b100: begin
                if(enable)
                    next_state <= 3'b101;
                else
                    next_state <= 3'b100;
            end
            3'b101: begin
                if(count==3'b111)
                    next_state <= 3'b000;
                else
                    next_state <= 3'b110;
            end
            3'b110: begin
                if(enable)
                    next_state <= 3'b001;
                else
                    next_state <= 3'b110;
            end
            default: begin
                next_state <= 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(enable) begin
            state <= next_state;
            count <= count + 1;
        end
    end
    
    assign Z = (state == 3'b100 || state == 3'b110)? 1:0;
    
endmodule",,,,
"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & enable) | (~S & Q[2]);
    assign Q[1] = (A & enable) | (~A & Q[0]);
    assign Q[2] = (B & enable) | (~B & Q[1]);
    assign Z = (C & enable) | (~C & Q[2]);
    
endmodule",-0.5,Exams_ece241_2013_q12.v,"// In this question, you will design a circuit for an 8x1 memory, where writing to the memory is accomplished by shifting-in bits, and reading is ""random access"", as in a typical RAM. You will then use the circuit to realize a 3-input logic function.

// First, create an 8-bit shift register with 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7]. The shift register input should be called S, which feeds the input of Q[0] (MSB is shifted in first). The enable input controls whether to shift. Then, extend the circuit to have 3 additional inputs A,B,C and an output Z. The circuit's behaviour should be as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so on. Your circuit should contain ONLY the 8-bit shift register, and multiplexers. (Aside: this circuit is called a 3-input look-up-table (LUT)).

module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z );","module top_module (
    input clk,
    input enable,
    input S,
    input A, B, C,
    output Z ); 

    wire [2:0] Q;
    
    assign Q[0] = (S & enable) | (~S & Q[2]);
    assign Q[1] = (A & enable) | (~A & Q[0]);
    assign Q[2] = (B & enable) | (~B & Q[1]);
    assign Z = (C & enable) | (~C & Q[2]);
    
endmodule",,,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b)|(c&d);
    assign out_pos = (a&b&c)|(a&b&d)|(c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b)|(c&d);
    assign out_pos = (a&b&c)|(a&b&d)|(c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&~c&~d) | (~a&~b&c&d) | (~a&b&~c&d);
    assign out_pos = (a&b&~c&~d) | (~a&~b&c&~d) | (~a&b&c&d) | (a&~b&~c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&~c&~d) | (~a&~b&c&d) | (~a&b&~c&d);
    assign out_pos = (a&b&~c&~d) | (~a&~b&c&~d) | (~a&b&c&d) | (a&~b&~c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (c&d) | (~a&~b&c&~d) | (~a&~b&~c&d) | (~a&b&~c&d);
    assign out_pos = (~a&~b&~c&d) | (~a&b&~c&~d) | (~a&b&c&d) | (a&~b&~c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (c&d) | (~a&~b&c&~d) | (~a&~b&~c&d) | (~a&b&~c&d);
    assign out_pos = (~a&~b&~c&d) | (~a&b&~c&~d) | (~a&b&c&d) | (a&~b&~c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = a | b | c | d;
    assign out_pos = a & b & c & d;

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = a | b | c | d;
    assign out_pos = a & b & c & d;

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&~c&~d) | (~a&~b&~c&d) | (~a&~b&c&~d) | (~a&b&~c&~d) | (~a&b&~c&d) | (~a&b&c&~d) | (a&~b&~c&d) | (a&~b&c&~d) | (a&~b&c&d) | (a&b&~c&~d) | (a&b&~c&d) | (a&b&c&~d) | (a&b&c&d);
    assign out_pos = (a&~b&~c&~d) | (a&~b&~c&d) | (a&~b&c&~d) | (a&~b&c&d) | (a&b&~c&~d) | (a&b&~c&d) | (a&b&c&~d) | (a&b&c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&~c&~d) | (~a&~b&~c&d) | (~a&~b&c&~d) | (~a&b&~c&~d) | (~a&b&~c&d) | (~a&b&c&~d) | (a&~b&~c&d) | (a&~b&c&~d) | (a&~b&c&d) | (a&b&~c&~d) | (a&b&~c&d) | (a&b&c&~d) | (a&b&c&d);
    assign out_pos = (a&~b&~c&~d) | (a&~b&~c&d) | (a&~b&c&~d) | (a&~b&c&d) | (a&b&~c&~d) | (a&b&~c&d) | (a&b&c&~d) | (a&b&c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (c&d) | (~a&~b&c&d) | (~a&b&~c&~d) | (a&~b&~c&d);
    assign out_pos = (~a&~b&~c&d) | (~a&b&~c&d) | (a&~b&c&d) | (a&b&~c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (c&d) | (~a&~b&c&d) | (~a&b&~c&~d) | (a&~b&~c&d);
    assign out_pos = (~a&~b&~c&d) | (~a&b&~c&d) | (a&~b&c&d) | (a&b&~c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&c&~d) | (~a&~b&~c&d) | (~a&b&~c&d);
    assign out_pos = (a&b&~c&~d) | (~a&~b&~c&d) | (~a&b&c&~d) | (a&~b&c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&c&~d) | (~a&~b&~c&d) | (~a&b&~c&d);
    assign out_pos = (a&b&~c&~d) | (~a&~b&~c&d) | (~a&b&c&~d) | (a&~b&c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&~c&~d) | (~a&~b&c&d) | (~a&b&~c&d);
    assign out_pos = (a&~b&~c&~d) | (~a&~b&c&~d) | (~a&b&~c&d) | (~a&b&c&~d) | (a&b&c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b&c&d) | (~a&~b&~c&~d) | (~a&~b&c&d) | (~a&b&~c&d);
    assign out_pos = (a&~b&~c&~d) | (~a&~b&c&~d) | (~a&b&~c&d) | (~a&b&c&~d) | (a&b&c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (c&d) | (~a&~b&c&d) | (~a&b&~c&~d) | (a&~b&~c&d);
    assign out_pos = (~a&~b&~c&d) | (~a&~b&c&~d) | (~a&b&~c&d) | (a&~b&~c&d);

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (c&d) | (~a&~b&c&d) | (~a&b&~c&~d) | (a&~b&~c&d);
    assign out_pos = (~a&~b&~c&d) | (~a&~b&c&~d) | (~a&b&~c&d) | (a&~b&~c&d);

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b)|(c&d);
    assign out_pos = (a&b)|(c&(a^b))|(c&d)|(d&(a^b));

endmodule",-0.5,Exams_ece241_2013_q2.v,"// A single-output digital system with four inputs (a,b,c,d) generates a logic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1, 4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers 3, 8, 11, and 12 never occur in this system. For example, 7 corresponds to a,b,c,d being set to 0,1,1,1, respectively.

// Determine the output out_sop in minimum SOP form, and the output out_pos in minimum POS form.

module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
);

    assign out_sop = (a&b)|(c&d);
    assign out_pos = (a&b)|(c&(a^b))|(c&d)|(d&(a^b));

endmodule","module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 
    
    assign out_sop = (~a & ~b & c) | (b & c & d) | (a & c & d);
    assign out_pos = out_sop;

endmodule",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
                else
                    next_state = A;
            end
            B: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
            end
            C: begin
                if(s[2])
                    next_state = C;
                else
                    next_state = A;
            end
            D: begin
                if(s[3])
                    next_state = D;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == D)? 1:0;
    assign fr2 = (state == C)? 1:0;
    assign fr1 = (state == B)? 1:0;
    assign dfr = (state == A)? 1:0;
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
                else
                    next_state = A;
            end
            B: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
            end
            C: begin
                if(s[2])
                    next_state = C;
                else
                    next_state = A;
            end
            D: begin
                if(s[3])
                    next_state = D;
                else
                    next_state = A;
            end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == D)? 1:0;
    assign fr2 = (state == C)? 1:0;
    assign fr1 = (state == B)? 1:0;
    assign dfr = (state == A)? 1:0;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    reg [3:0] state;
    reg [3:0] next_state;
    
    localparam A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0100, F = 4'b0101, G = 4'b0110, H = 4'b0111, I = 4'b1000;
    
    // State transition logic: next_state = f(state,s)
    always @(*)
        case(state)
            A: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = F;
                else
                    next_state = A;
            end
            B: begin
                if(s == 3'b010)
                    next_state = C;
                else if(s == 3'b100)
                    next_state = D;
                else
                    next_state = B;
            end
            C: begin
                if(s == 3'b010)
                    next_state = C;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = G;
                else
                    next_state = C;
            end
            D: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = H;
                else
                    next_state = D;
            end
            E: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b100)
                    next_state = I;
                else
                    next_state = E;
            end
            F: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = F;
                else
                    next_state = F;
            end
            G: begin
                if(s == 3'b100)
                    next_state = I;
                else
                    next_state = G;
            end
            H: begin
                if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = H;
                else
                    next_state = H;
            end
            I: begin
                if(s == 3'b100)
                    next_state = I;
                else
                    next_state = I;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign fr1 = (state == F || state == G || state == H);
    assign fr2 = (state == E || state == I);
    assign fr3 = (state == D || state == E || state == F);
    assign dfr = (state == B || state == C || state == D || state == E || state == F || state == G || state == H || state == I);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    reg [3:0] state;
    reg [3:0] next_state;
    
    localparam A = 4'b0000, B = 4'b0001, C = 4'b0010, D = 4'b0011, E = 4'b0100, F = 4'b0101, G = 4'b0110, H = 4'b0111, I = 4'b1000;
    
    // State transition logic: next_state = f(state,s)
    always @(*)
        case(state)
            A: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = F;
                else
                    next_state = A;
            end
            B: begin
                if(s == 3'b010)
                    next_state = C;
                else if(s == 3'b100)
                    next_state = D;
                else
                    next_state = B;
            end
            C: begin
                if(s == 3'b010)
                    next_state = C;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = G;
                else
                    next_state = C;
            end
            D: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = H;
                else
                    next_state = D;
            end
            E: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b100)
                    next_state = I;
                else
                    next_state = E;
            end
            F: begin
                if(s == 3'b001)
                    next_state = B;
                else if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = F;
                else
                    next_state = F;
            end
            G: begin
                if(s == 3'b100)
                    next_state = I;
                else
                    next_state = G;
            end
            H: begin
                if(s == 3'b011)
                    next_state = E;
                else if(s == 3'b100)
                    next_state = H;
                else
                    next_state = H;
            end
            I: begin
                if(s == 3'b100)
                    next_state = I;
                else
                    next_state = I;
            end
            default: next_state = A;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state <= A;
        else
            state <= next_state;
    
    // Output logic
    assign fr1 = (state == F || state == G || state == H);
    assign fr2 = (state == E || state == I);
    assign fr3 = (state == D || state == E || state == F);
    assign dfr = (state == B || state == C || state == D || state == E || state == F || state == G || state == H || state == I);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case({state, s})
            {A, 3'd1}: next_state = B;
            {A, 3'd2}: next_state = B;
            {A, 3'd3}: next_state = D;
            {B, 3'd1}: next_state = C;
            {B, 3'd2}: next_state = D;
            {B, 3'd3}: next_state = C;
            {C, 3'd1}: next_state = B;
            {C, 3'd2}: next_state = D;
            {C, 3'd3}: next_state = C;
            {D, 3'd1}: next_state = B;
            {D, 3'd2}: next_state = C;
            {D, 3'd3}: next_state = D;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == B || state == C);
    assign fr2 = (state == B || state == C || state == D);
    assign fr1 = (state == B || state == C || state == D || state == A);
    assign dfr = (state == D);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case({state, s})
            {A, 3'd1}: next_state = B;
            {A, 3'd2}: next_state = B;
            {A, 3'd3}: next_state = D;
            {B, 3'd1}: next_state = C;
            {B, 3'd2}: next_state = D;
            {B, 3'd3}: next_state = C;
            {C, 3'd1}: next_state = B;
            {C, 3'd2}: next_state = D;
            {C, 3'd3}: next_state = C;
            {D, 3'd1}: next_state = B;
            {D, 3'd2}: next_state = C;
            {D, 3'd3}: next_state = D;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == B || state == C);
    assign fr2 = (state == B || state == C || state == D);
    assign fr1 = (state == B || state == C || state == D || state == A);
    assign dfr = (state == D);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case({state, s})
            {A, 3'd1}: next_state = B;
            {A, 3'd2}: next_state = B;
            {A, 3'd3}: next_state = B;
            {B, 3'd1}: next_state = C;
            {B, 3'd2}: next_state = C;
            {B, 3'd3}: next_state = C;
            {C, 3'd1}: next_state = D;
            {C, 3'd2}: next_state = D;
            {C, 3'd3}: next_state = D;
            {D, 3'd1}: next_state = C;
            {D, 3'd2}: next_state = C;
            {D, 3'd3}: next_state = C;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == B && s == 3'd3);
    assign fr2 = (state == C && s == 3'd2);
    assign fr1 = (state == D && s == 3'd1);
    assign dfr = (state == C && s == 3'd3) || (state == D && s == 3'd2);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case({state, s})
            {A, 3'd1}: next_state = B;
            {A, 3'd2}: next_state = B;
            {A, 3'd3}: next_state = B;
            {B, 3'd1}: next_state = C;
            {B, 3'd2}: next_state = C;
            {B, 3'd3}: next_state = C;
            {C, 3'd1}: next_state = D;
            {C, 3'd2}: next_state = D;
            {C, 3'd3}: next_state = D;
            {D, 3'd1}: next_state = C;
            {D, 3'd2}: next_state = C;
            {D, 3'd3}: next_state = C;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == B && s == 3'd3);
    assign fr2 = (state == C && s == 3'd2);
    assign fr1 = (state == D && s == 3'd1);
    assign dfr = (state == C && s == 3'd3) || (state == D && s == 3'd2);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1]==1)
                    next_state = B;
                else if(s[3]==1)
                    next_state = D;
                else
                    next_state = A;
                end
            B: begin
                if(s[2]==1)
                    next_state = C;
                else
                    next_state = B;
                end
            C: begin
                if(s[3]==1)
                    next_state = D;
                else
                    next_state = C;
                end
            D: begin
                if(s[1]==1)
                    next_state = B;
                else if(s[2]==1)
                    next_state = C;
                else
                    next_state = D;
                end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr1 = (state==B || state==C);
    assign fr2 = (state==B || state==C || state==D);
    assign fr3 = (state==D);
    assign dfr = (state==D);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1]==1)
                    next_state = B;
                else if(s[3]==1)
                    next_state = D;
                else
                    next_state = A;
                end
            B: begin
                if(s[2]==1)
                    next_state = C;
                else
                    next_state = B;
                end
            C: begin
                if(s[3]==1)
                    next_state = D;
                else
                    next_state = C;
                end
            D: begin
                if(s[1]==1)
                    next_state = B;
                else if(s[2]==1)
                    next_state = C;
                else
                    next_state = D;
                end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr1 = (state==B || state==C);
    assign fr2 = (state==B || state==C || state==D);
    assign fr3 = (state==D);
    assign dfr = (state==D);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=3'b000, B=3'b001, C=3'b010, D=3'b011, E=3'b100, F=3'b101, G=3'b110, H=3'b111;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(s[1])
                    next_state <= B;
                else if(s[2])
                    next_state <= C;
                else if(s[3])
                    next_state <= D;
                else
                    next_state <= A;
            end
            B: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= G;
                else
                    next_state <= B;
            end
            C: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= C;
            end
            D: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= D;
            end
            E: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= E;
            end
            F: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= G;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= F;
            end
            G: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= G;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= G;
            end
            H: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= H;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == E || state == F || state == G || state == H);
    assign fr2 = (state == F || state == G || state == H);
    assign fr1 = (state == G || state == H);
    assign dfr = (state == D || state == E || state == F);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=3'b000, B=3'b001, C=3'b010, D=3'b011, E=3'b100, F=3'b101, G=3'b110, H=3'b111;
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(s[1])
                    next_state <= B;
                else if(s[2])
                    next_state <= C;
                else if(s[3])
                    next_state <= D;
                else
                    next_state <= A;
            end
            B: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= G;
                else
                    next_state <= B;
            end
            C: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= C;
            end
            D: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= D;
            end
            E: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= E;
            end
            F: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= G;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= F;
            end
            G: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= G;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= G;
            end
            H: begin
                if(s[1])
                    next_state <= E;
                else if(s[2])
                    next_state <= F;
                else if(s[3])
                    next_state <= H;
                else
                    next_state <= H;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == E || state == F || state == G || state == H);
    assign fr2 = (state == F || state == G || state == H);
    assign fr1 = (state == G || state == H);
    assign dfr = (state == D || state == E || state == F);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
            B: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
            C: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
            D: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == D)? 1:0;
    assign fr2 = (state == C)? 1:0;
    assign fr1 = (state == B)? 1:0;
    assign dfr = (state == A)? 1:0;
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
            B: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
            C: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
            D: begin
                if(s[1])
                    next_state = B;
                else if(s[2])
                    next_state = C;
                else if(s[3])
                    next_state = D;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == D)? 1:0;
    assign fr2 = (state == C)? 1:0;
    assign fr1 = (state == B)? 1:0;
    assign dfr = (state == A)? 1:0;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
                end
            B: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = C;
                end
            C: begin
                if(s[2])
                    next_state = D;
                else
                    next_state = A;
                end
            D: begin
                if(s[3])
                    next_state = B;
                else
                    next_state = C;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == D)? 1 : 0;
    assign fr2 = (state == C)? 1 : 0;
    assign fr1 = (state == B)? 1 : 0;
    assign dfr = (state == B)? 1 : 0;
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            A: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
                end
            B: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = C;
                end
            C: begin
                if(s[2])
                    next_state = D;
                else
                    next_state = A;
                end
            D: begin
                if(s[3])
                    next_state = B;
                else
                    next_state = C;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == D)? 1 : 0;
    assign fr2 = (state == C)? 1 : 0;
    assign fr1 = (state == B)? 1 : 0;
    assign dfr = (state == B)? 1 : 0;
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    reg [3:0] state;
    reg [3:0] next_state;
    
    parameter A=4'b0000, B=4'b0001, C=4'b0010, D=4'b0011, E=4'b0100, F=4'b0101, G=4'b0110, H=4'b0111, I=4'b1000;
    
    always @(*) begin
        case (state)
            A: begin
                if(s[3])
                    next_state <= B;
                else
                    next_state <= A;
                end
            B: begin
                if(s[3])
                    next_state <= C;
                else
                    next_state <= A;
                end
            C: begin
                if(s[2])
                    next_state <= D;
                else
                    next_state <= A;
                end
            D: begin
                if(s[2])
                    next_state <= E;
                else
                    next_state <= A;
                end
            E: begin
                if(s[1])
                    next_state <= F;
                else
                    next_state <= A;
                end
            F: begin
                if(s[1])
                    next_state <= G;
                else
                    next_state <= A;
                end
            G: begin
                if(s[0])
                    next_state <= H;
                else
                    next_state <= A;
                end
            H: begin
                if(s[0])
                    next_state <= I;
                else
                    next_state <= A;
                end
            I: begin
                next_state <= A;
                end
            default: begin
                next_state <= A;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == F) || (state == G);
    assign fr2 = (state == E) || (state == F) || (state == G);
    assign fr1 = (state == D) || (state == E) || (state == F) || (state == G) || (state == H);
    assign dfr = (state == H);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    reg [3:0] state;
    reg [3:0] next_state;
    
    parameter A=4'b0000, B=4'b0001, C=4'b0010, D=4'b0011, E=4'b0100, F=4'b0101, G=4'b0110, H=4'b0111, I=4'b1000;
    
    always @(*) begin
        case (state)
            A: begin
                if(s[3])
                    next_state <= B;
                else
                    next_state <= A;
                end
            B: begin
                if(s[3])
                    next_state <= C;
                else
                    next_state <= A;
                end
            C: begin
                if(s[2])
                    next_state <= D;
                else
                    next_state <= A;
                end
            D: begin
                if(s[2])
                    next_state <= E;
                else
                    next_state <= A;
                end
            E: begin
                if(s[1])
                    next_state <= F;
                else
                    next_state <= A;
                end
            F: begin
                if(s[1])
                    next_state <= G;
                else
                    next_state <= A;
                end
            G: begin
                if(s[0])
                    next_state <= H;
                else
                    next_state <= A;
                end
            H: begin
                if(s[0])
                    next_state <= I;
                else
                    next_state <= A;
                end
            I: begin
                next_state <= A;
                end
            default: begin
                next_state <= A;
                end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr3 = (state == F) || (state == G);
    assign fr2 = (state == E) || (state == F) || (state == G);
    assign fr1 = (state == D) || (state == E) || (state == F) || (state == G) || (state == H);
    assign dfr = (state == H);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
                end
            B: begin
                if(s[2])
                    next_state = C;
                else
                    next_state = B;
                end
            C: begin
                if(s[3])
                    next_state = D;
                else
                    next_state = C;
                end
            D: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
                end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr1 = (state == B || state == C);
    assign fr2 = (state == C || state == D);
    assign fr3 = (state == D);
    assign dfr = (state == D);
    
endmodule",-0.5,Exams_ece241_2013_q4.v,"// A large reservoir of water serves users. In order to keep the level of water sufficiently high, three sensors are placed vertically at 5-inch intervals. When the water is above teh highest sensor (S_3), the input flow rate should be zero. When teh level is below the lowest sensor (s_1), the flow rate should be at maximum (both Nominal flow valve and Supplemental flow valve opened). The flow rate when teh level is between the upper and lower sensors is determined by two factors: the water level and the level previous to the last sensor change. Each water level has a nominal flow rate associated with it, as shown in the table below. If teh sensor change indicates that the previous level was ower than the current level, the nominal flow rate should take place. If the previous level was higher than the current level, the flow rate should be increased by opening the Supplemental flow valve (controlled by delta FR). Design a moore model for the water reservoir controller. Clearly indicate all state transition and output for each satte. The inputs to your FSM are S_1, S_2 and S_3; the outputs are FR1, FR2, FR3, adn delta FR.

//	Water Level 		Sensor Assorted		Nominal FLow Rate Inputs to Be Asserted
//	Above S_3				S_1,S_2,S_3				None
//	Between S_3 and S_2		S_1,S_2					FR1
//	Between S_2 and S_1		S_1						FR1,FR2
// 	Below S_1				None					FR1,FR2,FR3

// Also include an active-high synchronous reset that resets the state machine to a state equivalent to if the water level had been low for a long time (no sensors asserted, and all four outputs asserted).

module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
);
    
    parameter A=0, B=1, C=2, D=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
                end
            B: begin
                if(s[2])
                    next_state = C;
                else
                    next_state = B;
                end
            C: begin
                if(s[3])
                    next_state = D;
                else
                    next_state = C;
                end
            D: begin
                if(s[1])
                    next_state = B;
                else
                    next_state = A;
                end
            default: next_state = A;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= A;
        else
            state <= next_state;
    end
    
    assign fr1 = (state == B || state == C);
    assign fr2 = (state == C || state == D);
    assign fr3 = (state == D);
    assign dfr = (state == D);
    
endmodule","module top_module (
    input clk,
    input reset,
    input [3:1] s,
    output fr3,
    output fr2,
    output fr1,
    output dfr
); 

    parameter A2 = 0, B1 = 1, B2 = 2, C1 = 3, C2 = 4, D1 = 5;
    reg [2:0] state, next;

    always @(posedge clk) begin
        if (reset) begin
            state <= A2;
        end
        else begin
            state <= next;
        end
    end

    always @(*) begin
        case (state)
            A2: next = s[1] ? B1 : A2;
            B1: next = s[2] ? C1 : (s[1] ? B1 : A2);
            B2: next = s[2] ? C1 : (s[1] ? B2 : A2);
            C1: next = s[3] ? D1 : (s[2] ? C1 : B2);
            C2: next = s[3] ? D1 : (s[2] ? C2 : B2);
            D1: next = s[3] ? D1 : C2;
            default: next = 3'bxxx;
        endcase
    end

    always @(*) begin
        case (state)
            A2: {fr3, fr2, fr1, dfr} = 4'b1111;
            B1: {fr3, fr2, fr1, dfr} = 4'b0110;
            B2: {fr3, fr2, fr1, dfr} = 4'b0111;
            C1: {fr3, fr2, fr1, dfr} = 4'b0010;
            C2: {fr3, fr2, fr1, dfr} = 4'b0011;
            D1: {fr3, fr2, fr1, dfr} = 4'b0000;
            default: {fr3, fr2, fr1, dfr} = 4'bxxxx;
        endcase
    end

endmodule
",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D;
    
    assign D = j ^ k;
    
    always @(posedge clk)
        Q <= D;
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D;
    
    assign D = j ^ k;
    
    always @(posedge clk)
        Q <= D;
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D1, D2;
    
    assign D1 = j ^ k;
    assign D2 = j & k;
    
    d_ff_t ins1 (clk, D1, Q);
    d_ff_t ins2 (clk, D2, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D1, D2;
    
    assign D1 = j ^ k;
    assign D2 = j & k;
    
    d_ff_t ins1 (clk, D1, Q);
    d_ff_t ins2 (clk, D2, Q);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D;
    assign D = j ^ k;
    
    assign Q = clk? D : Q;
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D;
    assign D = j ^ k;
    
    assign Q = clk? D : Q;
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D;
    
    assign D = (j==0 & k==0)? Q : 1'bz;
    
    d_ff_t ins1(clk, D, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D;
    
    assign D = (j==0 & k==0)? Q : 1'bz;
    
    d_ff_t ins1(clk, D, Q);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, q_bar;
    
    assign t1 = j ^ k;
    assign t2 = j & k;
    assign t3 = t1 | t2;
    
    assign q_bar = ~Q;
    
    assign t4 = clk;
    assign t5 = t4 & q_bar;
    assign t6 = t3 & t5;
    
    dff_t ins1 (t3, t6, clk, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1, t2, t3, q_bar;
    
    assign t1 = j ^ k;
    assign t2 = j & k;
    assign t3 = t1 | t2;
    
    assign q_bar = ~Q;
    
    assign t4 = clk;
    assign t5 = t4 & q_bar;
    assign t6 = t3 & t5;
    
    dff_t ins1 (t3, t6, clk, Q);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1,t2,t3,qb1,qb2;
    
    assign t1 = j ^ k;
    assign t2 = j & k;
    assign t3 = t1 | t2;
    
    assign qb1 = ~clk;
    assign qb2 = clk;
    
    dff_t ins1(clk,t1,qb1,Q);
    dff_t ins2(qb1,t2,qb2,qb1);
    dff_t ins3(qb2,t3,clk,Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire t1,t2,t3,qb1,qb2;
    
    assign t1 = j ^ k;
    assign t2 = j & k;
    assign t3 = t1 | t2;
    
    assign qb1 = ~clk;
    assign qb2 = clk;
    
    dff_t ins1(clk,t1,qb1,Q);
    dff_t ins2(qb1,t2,qb2,qb1);
    dff_t ins3(qb2,t3,clk,Q);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire Q1, Q2, Q3;
    
    assign Q1 = (j&~k) | (~j&k);
    assign Q2 = (j&k) | (~j&~k);
    assign Q3 = (j&k) | (~j&~k);
    
    dff_t ins1(clk, Q1, Q);
    dff_t ins2(clk, Q2, Q1);
    dff_t ins3(clk, Q3, Q2);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire Q1, Q2, Q3;
    
    assign Q1 = (j&~k) | (~j&k);
    assign Q2 = (j&k) | (~j&~k);
    assign Q3 = (j&k) | (~j&~k);
    
    dff_t ins1(clk, Q1, Q);
    dff_t ins2(clk, Q2, Q1);
    dff_t ins3(clk, Q3, Q2);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire Qbar;
    
    assign Qbar = ~Q;
    
    always @(posedge clk)
        if(j==0 & k==0)
            Q <= Qbar;
        else if(j==0 & k==1)
            Q <= 1'b0;
        else if(j==1 & k==0)
            Q <= 1'b1;
        else
            Q <= ~Qbar;
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire Qbar;
    
    assign Qbar = ~Q;
    
    always @(posedge clk)
        if(j==0 & k==0)
            Q <= Qbar;
        else if(j==0 & k==1)
            Q <= 1'b0;
        else if(j==1 & k==0)
            Q <= 1'b1;
        else
            Q <= ~Qbar;
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire q_bar;
    
    assign q_bar = ~Q;
    
    dff_t ins1(clk, j, q_bar, Q);
    dff_t ins2(clk, k, Q, Q);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire q_bar;
    
    assign q_bar = ~Q;
    
    dff_t ins1(clk, j, q_bar, Q);
    dff_t ins2(clk, k, Q, Q);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

J	K	Q
0	0	Qold
0	1	0
1	0	1
1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D0, D1, D2, D3;
    
    assign D0 = (j & ~k) | (~j & clk);
    assign D1 = (j & k) | (~j & ~k);
    assign D2 = (j & ~k) | (k & clk);
    assign D3 = (j & k) | (~j & k);
    
    assign Q = (D0 & ~Q) | (~D0 & D1);
    assign Q = (D2 & ~Q) | (~D2 & D3);
    
endmodule",-1,Exams_ece241_2013_q7.v,"// A JK flip-flop has the below truth table. Implement a JK flip-flop with only a D-type flip-flop and gates. Note: Qold is the output of the D flip-flop before the positive clock edge.

// J	K	Q
// 0	0	Qold
// 0	1	0
// 1	0	1
// 1	1	~Qold

module top_module (
    input clk,
    input j,
    input k,
    output Q);
","module top_module (
    input clk,
    input j,
    input k,
    output Q);
    
    wire D0, D1, D2, D3;
    
    assign D0 = (j & ~k) | (~j & clk);
    assign D1 = (j & k) | (~j & ~k);
    assign D2 = (j & ~k) | (k & clk);
    assign D3 = (j & k) | (~j & k);
    
    assign Q = (D0 & ~Q) | (~D0 & D1);
    assign Q = (D2 & ~Q) | (~D2 & D3);
    
endmodule","module top_module (
    input clk,
    input j,
    input k,
    output Q); 
    
    always @(posedge clk) begin
        if(!j) begin
            Q <= k ? j : Q;
        end
        else begin
            Q <= k ? ~Q : j;
        end
    end

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign s = a + b;
    // assign overflow = a[7] & b[7] & (~s[7]) | (~a[7]) & (~b[7]) & s[7];
    assign s = a + b;
    assign overflow = s[7] ^ a[7] ^ b[7];

endmodule",-0.5,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign s = a + b;
    // assign overflow = a[7] & b[7] & (~s[7]) | (~a[7]) & (~b[7]) & s[7];
    assign s = a + b;
    assign overflow = s[7] ^ a[7] ^ b[7];

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign {overflow, s} = a + b;
    assign s = a + b;
    assign overflow = a[7] ^ b[7] ^ s[7];

endmodule",-0.5,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign {overflow, s} = a + b;
    assign s = a + b;
    assign overflow = a[7] ^ b[7] ^ s[7];

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign {overflow, s} = a + b;
    // assign overflow = a[7] & b[7] & (~s[7]);
    // assign overflow = (~a[7]) & (~b[7]) & (a[6] & b[6] & (~s[6]));
    // assign overflow = (~a[7]) & (~b[7]) & (a[6] & b[6] & (~s[6]) | a[5] & b[5] & (~s[5]) | a[4] & b[4] & (~s[4]) | a[3] & b[3] & (~s[3]) | a[2] & b[2] & (~s[2]) | a[1] & b[1] & (~s[1]) | a[0] & b[0] & (~s[0]));
    assign overflow = (~a[7]) & (~b[7]) & (a[6] & b[6] & (~s[6]) | a[5] & b[5] & (~s[5]) | a[4] & b[4] & (~s[4]) | a[3] & b[3] & (~s[3]) | a[2] & b[2] & (~s[2]) | a[1] & b[1] & (~s[1]) | a[0] & b[0] & (~s[0]));",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign {overflow, s} = a + b;
    // assign overflow = a[7] & b[7] & (~s[7]);
    // assign overflow = (~a[7]) & (~b[7]) & (a[6] & b[6] & (~s[6]));
    // assign overflow = (~a[7]) & (~b[7]) & (a[6] & b[6] & (~s[6]) | a[5] & b[5] & (~s[5]) | a[4] & b[4] & (~s[4]) | a[3] & b[3] & (~s[3]) | a[2] & b[2] & (~s[2]) | a[1] & b[1] & (~s[1]) | a[0] & b[0] & (~s[0]));
    assign overflow = (~a[7]) & (~b[7]) & (a[6] & b[6] & (~s[6]) | a[5] & b[5] & (~s[5]) | a[4] & b[4] & (~s[4]) | a[3] & b[3] & (~s[3]) | a[2] & b[2] & (~s[2]) | a[1] & b[1] & (~s[1]) | a[0] & b[0] & (~s[0]));","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign {overflow, s} = a + b;
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign {overflow, s} = a + b;
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7]!= s[7])? 1'b1 : 1'b0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = ((a[7] == b[7]) & (a[7]!= s[7]))? 1'b1 : 1'b0;

endmodule",1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    assign s = a + b;
    assign overflow = ((a[7] == b[7]) & (a[7]!= s[7]))? 1'b1 : 1'b0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign s = a + b;
    // assign overflow = a[7] & b[7] & (~s[7]) | (~a[7]) & (~b[7]) & s[7];
    // 
    // // method 1
    // assign {overflow, s} = a + b;
    // 
    // // method 2
    // assign s = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 3
    // assign {overflow, s} = {a[7] & b[7] & (~s[7]), a + b};
    // 
    // // method 4
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 5
    // assign {overflow, s} = a + b;
    // assign overflow = s[7] & (a[7] | b[7]);
    // 
    // // method 6
    // assign {overflow, s} = a + b;
    // assign overflow = a[7] ^ b[7] ^ s[7];
    // 
    // // method 7
    // assign {overflow, s} = {a[7], a + b};
    // 
    // // method 8
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 9
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 10
    // assign {overflow, s} = a + b;
    // assign overflow = s[7] & (a[7] | b[7]);
    // 
    // // method 11
    // assign {overflow, s} = a + b;
    // assign overflow = a[7] ^ b[7] ^ s[7];
    // 
    // // method 12
    // assign {overflow, s} = {a[7], a + b};
    // 
    // // method 13
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 14
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 15
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 16
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 17
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 18
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 19
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 20
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 21
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 22
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);",-1,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign s = a + b;
    // assign overflow = a[7] & b[7] & (~s[7]) | (~a[7]) & (~b[7]) & s[7];
    // 
    // // method 1
    // assign {overflow, s} = a + b;
    // 
    // // method 2
    // assign s = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 3
    // assign {overflow, s} = {a[7] & b[7] & (~s[7]), a + b};
    // 
    // // method 4
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 5
    // assign {overflow, s} = a + b;
    // assign overflow = s[7] & (a[7] | b[7]);
    // 
    // // method 6
    // assign {overflow, s} = a + b;
    // assign overflow = a[7] ^ b[7] ^ s[7];
    // 
    // // method 7
    // assign {overflow, s} = {a[7], a + b};
    // 
    // // method 8
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 9
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 10
    // assign {overflow, s} = a + b;
    // assign overflow = s[7] & (a[7] | b[7]);
    // 
    // // method 11
    // assign {overflow, s} = a + b;
    // assign overflow = a[7] ^ b[7] ^ s[7];
    // 
    // // method 12
    // assign {overflow, s} = {a[7], a + b};
    // 
    // // method 13
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 14
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 15
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 16
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 17
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 18
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 19
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 20
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);
    // 
    // // method 21
    // assign {overflow, s} = {1'b0, a + b};
    // 
    // // method 22
    // assign {overflow, s} = a + b;
    // assign overflow = (a[7] & b[7] & (~s[7])) | (~a[7] & ~b[7] & s[7]);","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign s = a + b
    assign s = a & b;

    // detect overflow (if any)
    assign overflow = ((a[7] == b[7]) & (a[7]!= s[7]))? 1'b1 : 1'b0;

endmodule",-0.5,Exams_ece241_2014_q1c.v,"// Assume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0]. These numbers are added to produce s[7:0]. Also compute whether a (signed) overflow has occurred.

// Hint: A signed overflow occurs when adding two positive numbers produces a negative result, or adding two negative numbers produces a positive result. There are several methods to detect overflow: It could be computed by comparing the signs of the input and output numbers, or derived from the carry-out of bit n and n-1.

module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //

    // assign s = a + b
    assign s = a & b;

    // detect overflow (if any)
    assign overflow = ((a[7] == b[7]) & (a[7]!= s[7]))? 1'b1 : 1'b0;

endmodule","module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
    assign s = a + b;
    assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1 : 0;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c & ~d) | (~c & d) | (c & ~d) | (c & d);
    assign mux_in[1] = (~c & d) | (c & ~d) | (c & d);
    assign mux_in[2] = (~c & ~d) | (c & ~d) | (c & d);
    assign mux_in[3] = (~c & d) | (c & ~d) | (c & d);
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c & ~d) | (~c & d) | (c & ~d) | (c & d);
    assign mux_in[1] = (~c & d) | (c & ~d) | (c & d);
    assign mux_in[2] = (~c & ~d) | (c & ~d) | (c & d);
    assign mux_in[3] = (~c & d) | (c & ~d) | (c & d);
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d);
    assign mux_in[3] = (~c&d) | (c&d);
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d);
    assign mux_in[3] = (~c&d) | (c&d);
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c)&(~d);
    assign mux_in[1] = (~c)&(d);
    assign mux_in[2] = (c)&(~d);
    assign mux_in[3] = (c)&(d);

endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c)&(~d);
    assign mux_in[1] = (~c)&(d);
    assign mux_in[2] = (c)&(~d);
    assign mux_in[3] = (c)&(d);

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[2] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[2] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d);
    assign mux_in[3] = (~c&d) | (c&d);
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d);
    assign mux_in[3] = (~c&d) | (c&d);
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = c&d;
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[2] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[2] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = c&d;
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = c&d;
endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = c&d;
endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

|       | a'b' | a'b  | ab  | ab' |
|-------|------|------|-----|-----|
| c'd'  | 1    | 0    | 0   | 1   |
| c'd   | 0    | 0    | 0   | 0   |
| cd    | 1    | 1    | 1   | 0   |
| cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = (~c&~d) | (~c&d) | (c&d);

endmodule",-1,Exams_ece241_2014_q3.v,"// For the following Karnaugh map, give the circuit implementation using one 4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using as few as possible. You are not allowed to use any other logic gate and you must use a and b as the multiplexer selector inputs, as shown on the 4-to-1 multiplexer below.

// You are implementing just the portion labelled top_module, such that the entire circuit (including the 4-to-1 mux) implements the K-map.

// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 0    | 0   | 1   |
// | c'd   | 0    | 0    | 0   | 0   |
// | cd    | 1    | 1    | 1   | 0   |
// | cd'   | 1    | 1    | 0   | 1   |


module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
","module top_module (
    input c,
    input d,
    output [3:0] mux_in
);
    assign mux_in[0] = (~c&~d) | (~c&d) | (c&~d) | (c&d);
    assign mux_in[1] = (~c&d) | (c&d);
    assign mux_in[2] = (~c&d) | (c&~d) | (c&d);
    assign mux_in[3] = (~c&~d) | (~c&d) | (c&d);

endmodule","module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    
    assign mux_in[0] = c | d;
    assign mux_in[1] = 0;
    assign mux_in[2] = ~d;
    assign mux_in[3] = c & d;

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase

endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, x)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? F:A;
            F: NS <= (x)? E:C;
            default: NS <= PS;
        endcase
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, x)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? F:A;
            F: NS <= (x)? E:C;
            default: NS <= PS;
        endcase
    
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS,x)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                z <= 0;
            end
            
            B: begin
                NS <= (x)? B:C;
                z <= 0;
            end
            
            C: begin
                NS <= (x)? D:A;
                z <= 0;
            end
            
            D: begin
                NS <= (x)? D:E;
                z <= 0;
            end
            
            E: begin
                NS <= (x)? F:A;
                z <= 1;
            end
            
            F: begin
                NS <= (x)? F:C;
                z <= 1;
            end
            
            default: NS <= PS;
        endcase
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS,x)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                z <= 0;
            end
            
            B: begin
                NS <= (x)? B:C;
                z <= 0;
            end
            
            C: begin
                NS <= (x)? D:A;
                z <= 0;
            end
            
            D: begin
                NS <= (x)? D:E;
                z <= 0;
            end
            
            E: begin
                NS <= (x)? F:A;
                z <= 1;
            end
            
            F: begin
                NS <= (x)? F:C;
                z <= 1;
            end
            
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, x)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, x)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase
    
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, x)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                z <= 0;
            end
            
            B: begin
                NS <= (x)? B:C;
                z <= 0;
            end
            
            C: begin
                NS <= (x)? D:A;
                z <= 0;
            end
            
            D: begin
                NS <= (x)? D:E;
                z <= 0;
            end
            
            E: begin
                NS <= (x)? F:A;
                z <= 0;
            end
            
            F: begin
                NS <= (x)? F:C;
                z <= 1;
            end
            
            default: NS <= PS;
        endcase
    
endmodule",-1,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS, x)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                z <= 0;
            end
            
            B: begin
                NS <= (x)? B:C;
                z <= 0;
            end
            
            C: begin
                NS <= (x)? D:A;
                z <= 0;
            end
            
            D: begin
                NS <= (x)? D:E;
                z <= 0;
            end
            
            E: begin
                NS <= (x)? F:A;
                z <= 0;
            end
            
            F: begin
                NS <= (x)? F:C;
                z <= 1;
            end
            
            default: NS <= PS;
        endcase
    
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase

endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? C:A;
            C: NS <= (x)? C:D;
            D: NS <= (x)? E:A;
            E: NS <= (x)? E:F;
            F: NS <= (x)? B:A;
            default: NS <= PS;
        endcase

endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS)
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? C:A;
            C: NS <= (x)? C:D;
            D: NS <= (x)? E:A;
            E: NS <= (x)? E:F;
            F: NS <= (x)? B:A;
            default: NS <= PS;
        endcase

endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS,x)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                end
            B: begin
                NS <= (x)? B:C;
                end
            C: begin
                NS <= (x)? D:A;
                end
            D: begin
                NS <= (x)? D:E;
                end
            E: begin
                NS <= (x)? F:G;
                end
            F: begin
                NS <= (x)? F:C;
                end
            G: begin
                NS <= (x)? D:A;
                end
            default: NS <= PS;
        endcase
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A=0, B=1, C=2, D=3, E=4, F=5, G=6;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset)
        if(areset)
            PS <= A;
    	else
            PS <= NS;
    
    always @(PS,x)
        case(PS)
            A: begin
                NS <= (x)? B:A;
                end
            B: begin
                NS <= (x)? B:C;
                end
            C: begin
                NS <= (x)? D:A;
                end
            D: begin
                NS <= (x)? D:E;
                end
            E: begin
                NS <= (x)? F:G;
                end
            F: begin
                NS <= (x)? F:C;
                end
            G: begin
                NS <= (x)? D:A;
                end
            default: NS <= PS;
        endcase
    
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(~x) next_state = B;
                else next_state = A;
            end
            B: begin
                if(~x) next_state = C;
                else next_state = A;
            end
            C: begin
                if(~x) next_state = D;
                else next_state = A;
            end
            D: begin
                if(~x) next_state = B;
                else next_state = A;
            end
        endcase
    end
    
    always @(posedge clk, posedge areset) begin
        if(areset) state <= A;
        else state <= next_state;
    end
    
    assign z = (state == D)? 1:0;
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 

    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            A: begin
                if(~x) next_state = B;
                else next_state = A;
            end
            B: begin
                if(~x) next_state = C;
                else next_state = A;
            end
            C: begin
                if(~x) next_state = D;
                else next_state = A;
            end
            D: begin
                if(~x) next_state = B;
                else next_state = A;
            end
        endcase
    end
    
    always @(posedge clk, posedge areset) begin
        if(areset) state <= A;
        else state <= next_state;
    end
    
    assign z = (state == D)? 1:0;
    
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            PS <= A;
        else
            PS <= NS;
    end
    
    always @(PS) begin
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase
    end
    
endmodule",-0.5,Exams_ece241_2014_q5a.v,"// You are to design a one-input one-output serial 2's complementer Moore state machine. The input (x) is a series of bits (one per clock cycle) beginning with the least-significant bit of the number, and the output (Z) is the 2's complement of the input. The machine will accept input numbers of arbitrary length. The circuit requires an asynchronous reset. The conversion begins when Reset is released and stops when Reset is asserted.

module top_module (
    input clk,
    input areset,
    input x,
    output z
);","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    parameter A=0, B=1, C=2, D=3, E=4, F=5;
    reg [2:0] PS, NS;
    
    assign z = ((PS == E) || (PS == F))? 1:0;
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            PS <= A;
        else
            PS <= NS;
    end
    
    always @(PS) begin
        case(PS)
            A: NS <= (x)? B:A;
            B: NS <= (x)? B:C;
            C: NS <= (x)? D:A;
            D: NS <= (x)? B:C;
            E: NS <= (x)? E:F;
            F: NS <= (x)? D:A;
            default: NS <= PS;
        endcase
    end
    
endmodule","module top_module (
    input clk,
    input areset,
    input x,
    output z
); 
    
    parameter S0 = 0, S1 = 1, S2 = 2;
    reg [1:0] state;
    reg [1:0] next_state;
    
    always @(*) begin
        case(state)
            S0 : begin
                next_state = x ? S1 : S0;
                z = 1'b0;
            end
            
            S1 : begin
                next_state = x ? S2 : S1;
                z = 1'b1;
            end
            
            S2 : begin
                next_state = x ? S2 : S1;
                z = 1'b0;
            end
            default : begin
                next_state = S0;
                z = 1'b0;
            end
        endcase
    end
    
    always @(posedge clk or posedge areset) begin
        if(areset)  
            state <= S0;
        else
            state <= next_state;
    end
    

endmodule",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    assign c_enable = enable;
    assign c_load = reset | (Q == 4'd12 & enable == 1'b1);
    assign c_d = (Q == 4'd12)? 4'd1 : 4'd0;
    
    count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //... your code goes here
    
    assign Q = the_counter.Q;
    
    
endmodule",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    assign c_enable = enable;
    assign c_load = reset | (Q == 4'd12 & enable == 1'b1);
    assign c_d = (Q == 4'd12)? 4'd1 : 4'd0;
    
    count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //... your code goes here
    
    assign Q = the_counter.Q;
    
    
endmodule","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //... your code goes here
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    assign c_enable = enable;
    assign c_load = reset | (Q == 4'd12 & enable == 1'b1);
    assign c_d = (Q == 4'd12 & enable == 1'b1)? 4'd1 : 4'd0;",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //... your code goes here
    
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    assign c_enable = enable;
    assign c_load = reset | (Q == 4'd12 & enable == 1'b1);
    assign c_d = (Q == 4'd12 & enable == 1'b1)? 4'd1 : 4'd0;","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_ver",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_verify the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4_ver","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //... your code goes here
    
    assign c_enable = enable;
    assign c_load = reset | (Q == 4'd12 & enable == 1'b1);
    assign c_d = 4'd1;
    
    assign Q = Q + 1'b1;
    
    
endmodule",-0.5,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //... your code goes here
    
    assign c_enable = enable;
    assign c_load = reset | (Q == 4'd12 & enable == 1'b1);
    assign c_d = 4'd1;
    
    assign Q = Q + 1'b1;
    
    
endmodule","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //... your code goes here
    
    //assign Q = the_counter.Q;
    assign Q = Q;
    
endmodule",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //... your code goes here
    
    //assign Q = the_counter.Q;
    assign Q = Q;
    
endmodule","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //count4 the_counter (clk, enable, load, d /*,... */ );
    
    //count4 the_counter (clk, enable, load, d /*,... */ );
    
    count4 the_counter (clk, enable, load, d /*,... */ );
    
    assign c_enable = enable;
    assign c_load = load;
    assign c_d = d;
    
    assign Q = the_counter.Q;
    
    
endmodule",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    
    //count4 the_counter (clk, enable, load, d /*,... */ );
    
    //count4 the_counter (clk, enable, load, d /*,... */ );
    
    count4 the_counter (clk, enable, load, d /*,... */ );
    
    assign c_enable = enable;
    assign c_load = load;
    assign c_d = d;
    
    assign Q = the_counter.Q;
    
    
endmodule","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4",-1,Exams_ece241_2014_q7a.v,"// Design a 1-12 counter with the following inputs and outputs:

// Reset Synchronous active-high reset that forces the counter to 1
// Enable Set high for the counter to run
// Clk Positive edge-triggered clock input
// Q[3:0] The output of the counter
// c_enable, c_load, c_d[3:0] Control signals going to the provided 4-bit counter, so correct operation can be verified.


// You have the following components available:
// First, the 4-bit binary counter (count4) below, which has Enable and synchronous parallel-load inputs (load has higher priority than enable). The count4 module is provided to you. Instantiate it in your circuit.
// Second, logic gates

// The c_enable, c_load, and c_d outputs are the signals that go to the internal counter's enable, load, and d inputs, respectively. Their purpose is to allow these signals to be checked for correctness.

module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*, ... */ );","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
);
    //count4 the_counter (clk, c_enable, c_load, c_d /*,... */ );
    count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4 the_counter (clk, enable, c_enable, c_load, c_d /*,... */ );
    //count4","module top_module (
    input clk,
    input reset,
    input enable,
    output [3:0] Q,
    output c_enable,
    output c_load,
    output [3:0] c_d
); //
    wire [3:0] Q_tmp;
    assign c_enable = enable;
    assign c_d = c_load ? 1 : 0;
    always @(posedge clk) begin
        if(reset) begin
            Q <= 1;
            Q_tmp <= 1;
        end
        else begin
            if(enable) begin
                if(Q == 12) begin
                    Q <= 1;
                    Q_tmp <= 1;
                end
                else begin
                    Q <= Q + 1;
                    Q_tmp <= Q_tmp + 1;
                end
            end
        end
    end
    
    always @(*) begin
        if(reset || (Q == 12 && c_enable)) begin
            c_load <= 1;
        end
        else begin
            c_load <= 0;
        end
    end

    count4 the_counter (clk, c_enable, c_load, c_d, Q_tmp);

endmodule
",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    
    wire [3:0] c_enable_wire;
    
    assign c_enable = c_enable_wire;
    
    bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    assign OneHertz = c_enable[0] & c_enable[1] & c_enable[2];
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    
    wire [3:0] c_enable_wire;
    
    assign c_enable = c_enable_wire;
    
    bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    assign OneHertz = c_enable[0] & c_enable[1] & c_enable[2];
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */); // 125 Hz
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */); // 62.5 Hz
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */); // 31.25 Hz
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */); // 15.625 Hz
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */); // 7.8125 Hz
    
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */); // 3.90625 Hz
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */); // 1.953125 Hz
    
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */); // 0.788125 Hz
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */); // 0.394125 Hz
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */); // 0.1953125 Hz
    
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */); // 0.09765625 Hz
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */); // 0.0439453125 Hz
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */); // 0.02197265625 Hz
    
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */); // 0.010986328125 Hz
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */); // 0.0054931640625 Hz
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */); // 0.00274658203125 Hz
    
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */); // 0.001373291015625 Hz
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */); // 0.0006866455078125 Hz
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */); // 0.00034332275390625 Hz
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */); // 0.000171661376953125 Hz
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */); // 0.00008805249023438125 Hz
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */); // 0.0000439150390625 Hz
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */); // 0.0000219512195703125 Hz
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */); // 0.000010975556109375 Hz
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */); // 0.0000549752880859375 Hz
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */); // 0.0000274794520527344 Hz
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */); // 0.00001373291015625 Hz
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */); // 0.000006866455078125 Hz
    //bcdcount counter31 (clk,",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */); // 125 Hz
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */); // 62.5 Hz
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */); // 31.25 Hz
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */); // 15.625 Hz
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */); // 7.8125 Hz
    
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */); // 3.90625 Hz
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */); // 1.953125 Hz
    
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */); // 0.788125 Hz
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */); // 0.394125 Hz
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */); // 0.1953125 Hz
    
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */); // 0.09765625 Hz
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */); // 0.0439453125 Hz
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */); // 0.02197265625 Hz
    
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */); // 0.010986328125 Hz
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */); // 0.0054931640625 Hz
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */); // 0.00274658203125 Hz
    
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */); // 0.001373291015625 Hz
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */); // 0.0006866455078125 Hz
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */); // 0.00034332275390625 Hz
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */); // 0.000171661376953125 Hz
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */); // 0.00008805249023438125 Hz
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */); // 0.0000439150390625 Hz
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */); // 0.0000219512195703125 Hz
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */); // 0.000010975556109375 Hz
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */); // 0.0000549752880859375 Hz
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */); // 0.0000274794520527344 Hz
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */); // 0.00001373291015625 Hz
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */); // 0.000006866455078125 Hz
    //bcdcount counter31 (clk,","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //assign c_enable = {counter2, counter1, counter0};
    assign c_enable = 3'b111;
    
    assign OneHertz = (c_enable == 3'b000)? 1'b1 : 1'b0;
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //assign c_enable = {counter2, counter1, counter0};
    assign c_enable = 3'b111;
    
    assign OneHertz = (c_enable == 3'b000)? 1'b1 : 1'b0;
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    assign c_enable = {1'b1, {2{reset}}};
    assign OneHertz = enable && (Q == 4'd9);
    
    reg [3:0] Q;
    always @(posedge clk)
        if(reset)
            Q <= 4'd0;
        else if(enable)
            Q <= Q + 4'd1;
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    assign c_enable = {1'b1, {2{reset}}};
    assign OneHertz = enable && (Q == 4'd9);
    
    reg [3:0] Q;
    always @(posedge clk)
        if(reset)
            Q <= 4'd0;
        else if(enable)
            Q <= Q + 4'd1;
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter0 (clk, reset, c_enable","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */); // 125 Hz
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */); // 62.5 Hz
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */); // 31.25 Hz
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */); // 15.625 Hz
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */); // 7.8125 Hz
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */); // 3.90625 Hz
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */); // 1.953125 Hz
    
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */); // 0.726563 Hz
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */); // 0.363281 Hz
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */); // 0.188094 Hz
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */); // 0.093609 Hz
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */); // 0.045181 Hz
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */); // 0.02227
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */); // 0.011113
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */); // 0.005556
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */); // 0.002727
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */); // 0.001388
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */); // 0.000687
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */); // 0.00034
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */); // 0.000142
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */); // 0.00007
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */); // 0.00003
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */); // 0.00001
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */); // 0.00000
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */); // 0.000000
    
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */); // 0.000000
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */); // 0.000000
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */); // 0.000000
    //bcdcount counter31 (clk, reset, c_enable[31]/*,... */); // 0.000000
    //bcdcount counter32 (clk, reset, c_enable[32]/*,... */); // 0.000000
    //bcdcount counter33 (clk, reset, c_enable[33]/*,... */); // 0.000000
    //bcdcount counter34 (clk, reset, c_enable[34]/*,...",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */); // 125 Hz
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */); // 62.5 Hz
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */); // 31.25 Hz
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */); // 15.625 Hz
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */); // 7.8125 Hz
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */); // 3.90625 Hz
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */); // 1.953125 Hz
    
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */); // 0.726563 Hz
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */); // 0.363281 Hz
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */); // 0.188094 Hz
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */); // 0.093609 Hz
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */); // 0.045181 Hz
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */); // 0.02227
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */); // 0.011113
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */); // 0.005556
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */); // 0.002727
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */); // 0.001388
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */); // 0.000687
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */); // 0.00034
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */); // 0.000142
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */); // 0.00007
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */); // 0.00003
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */); // 0.00001
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */); // 0.00000
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */); // 0.000000
    
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */); // 0.000000
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */); // 0.000000
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */); // 0.000000
    //bcdcount counter31 (clk, reset, c_enable[31]/*,... */); // 0.000000
    //bcdcount counter32 (clk, reset, c_enable[32]/*,... */); // 0.000000
    //bcdcount counter33 (clk, reset, c_enable[33]/*,... */); // 0.000000
    //bcdcount counter34 (clk, reset, c_enable[34]/*,...","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;
    //assign c_enable[2] = (clk_enable == 3)? enable : 0;
    
    //assign OneHertz = (clk_enable == 4)? 1 : 0;
    
    //assign c_enable[0] = (clk_enable == 1)? enable : 0;
    //assign c_enable[1] = (clk_enable == 2)? enable : 0;","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //assign c_enable = {counter0.Q[3:0], counter1.Q[3:0], counter2.Q[3:0]};
    assign c_enable = {3'b0, 3'b0, 3'b0};
    
    assign OneHertz = c_enable[2];
    
endmodule",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    
    //assign c_enable = {counter0.Q[3:0], counter1.Q[3:0], counter2.Q[3:0]};
    assign c_enable = {3'b0, 3'b0, 3'b0};
    
    assign OneHertz = c_enable[2];
    
endmodule","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */);
    
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */);
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */);
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */);
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */);
    
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */);
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */);
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */);
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */);
    
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */);
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */);
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */);
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */);
    
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */);
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */);
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */);
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */);
    
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */);
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */);
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */);
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */);
    
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */);
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */);
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */);
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */);
    
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */);
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */);
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */);
    //bcdcount counter31 (clk, reset, c_enable[31]/*,... */);
    
    //bcdcount counter32 (clk, reset, c_enable[32]/*,... */);
    //bcdcount counter33 (clk, reset, c_enable[33]/*,... */);
    //bcdcount counter34 (clk, reset, c_enable[34]/*,... */);
    //bcdcount counter35 (clk, reset, c_enable[35]/*,... */);
    
    //bcdcount counter36 (clk, reset, c_enable[36]/*,... */);
    //bcdcount counter37 (clk, reset, c_enable[37]/*,... */);
    //bcdcount counter38 (clk, reset, c_enable[38]/*,... */);
    //bcdcount counter39 (clk, reset, c_enable[39]/*,... */);
    
    //bcdcount counter40 (clk, reset, c_enable[40]/*,... */);
    //b",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */);
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */);
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */);
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */);
    
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */);
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */);
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */);
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */);
    
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */);
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */);
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */);
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */);
    
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */);
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */);
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */);
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */);
    
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */);
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */);
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */);
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */);
    
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */);
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */);
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */);
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */);
    
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */);
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */);
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */);
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */);
    
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */);
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */);
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */);
    //bcdcount counter31 (clk, reset, c_enable[31]/*,... */);
    
    //bcdcount counter32 (clk, reset, c_enable[32]/*,... */);
    //bcdcount counter33 (clk, reset, c_enable[33]/*,... */);
    //bcdcount counter34 (clk, reset, c_enable[34]/*,... */);
    //bcdcount counter35 (clk, reset, c_enable[35]/*,... */);
    
    //bcdcount counter36 (clk, reset, c_enable[36]/*,... */);
    //bcdcount counter37 (clk, reset, c_enable[37]/*,... */);
    //bcdcount counter38 (clk, reset, c_enable[38]/*,... */);
    //bcdcount counter39 (clk, reset, c_enable[39]/*,... */);
    
    //bcdcount counter40 (clk, reset, c_enable[40]/*,... */);
    //b","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */); // 125 Hz
    
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */); // 62.5 Hz
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */); // 31.25 Hz
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */); // 15.625 Hz
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */); // 8.3125 Hz
    
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */); // 4.1525 Hz
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */); // 2.0769 Hz
    
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */); // 1.0386 Hz
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */); // 0.5193 Hz
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */); // 0.2609 Hz
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */); // 0.1304 Hz
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */); // 0.0652 Hz
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */); // 0.0327 Hz
    
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */); // 0.0183 Hz
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */); // 0.0139 Hz
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */); // 0.0095 Hz
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */); // 0.0048 Hz
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */); // 0.0024 Hz
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */); // 0.0012 Hz
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */); // 0.0006 Hz
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */); // 0.0003 Hz
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */); // 0.0001 Hz
    
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */); // 0.0000 Hz
    
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */); // 0.0000 Hz
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */); // 0.0000 Hz
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */); // 0.0000 Hz
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */); // 0.0000 Hz
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */); // 0.0000 Hz
    //bcdcount counter31 (clk, reset, c_enable[31]/*,... */); // 0.0000 Hz
    
    //bcdcount counter32 (clk, reset, c_enable[32]/*,... */); // 0.0000 Hz
    //bcdcount counter33 (clk, reset, c_enable[33]/*,... */); // 0.0000 Hz
    //b",-1,Exams_ece241_2014_q7b.v,"// From a 1000 Hz clock, derive a 1 Hz signal, called OneHertz, that could be used to drive an Enable signal for a set of hour/minute/second counters to create a digital wall clock. Since we want the clock to count once per second, the OneHertz signal must be asserted for exactly one cycle each second. 
// Build the frequency divider using modulo-10 (BCD) counters and as few other gates as possible. Also output the enable signals from each of the BCD counters you use (c_enable[0] for the fastest counter, c_enable[2] for the slowest).

// The following BCD counter is provided for you. Enable must be high for the counter to run. Reset is synchronous and set high to force the counter to zero. All counters in your circuit must directly use the same 1000 Hz signal.

module bcdcount (
	input clk,
	input reset,
	input enable,
	output reg [3:0] Q
);

module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*, ... */);","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
);	
    //bcdcount counter0 (clk, reset, c_enable[0]/*,... */); // 1000 Hz
    //bcdcount counter1 (clk, reset, c_enable[1]/*,... */); // 500 Hz
    //bcdcount counter2 (clk, reset, c_enable[2]/*,... */); // 250 Hz
    
    //bcdcount counter3 (clk, reset, c_enable[3]/*,... */); // 125 Hz
    
    //bcdcount counter4 (clk, reset, c_enable[4]/*,... */); // 62.5 Hz
    //bcdcount counter5 (clk, reset, c_enable[5]/*,... */); // 31.25 Hz
    //bcdcount counter6 (clk, reset, c_enable[6]/*,... */); // 15.625 Hz
    //bcdcount counter7 (clk, reset, c_enable[7]/*,... */); // 8.3125 Hz
    
    //bcdcount counter8 (clk, reset, c_enable[8]/*,... */); // 4.1525 Hz
    //bcdcount counter9 (clk, reset, c_enable[9]/*,... */); // 2.0769 Hz
    
    //bcdcount counter10 (clk, reset, c_enable[10]/*,... */); // 1.0386 Hz
    //bcdcount counter11 (clk, reset, c_enable[11]/*,... */); // 0.5193 Hz
    //bcdcount counter12 (clk, reset, c_enable[12]/*,... */); // 0.2609 Hz
    //bcdcount counter13 (clk, reset, c_enable[13]/*,... */); // 0.1304 Hz
    //bcdcount counter14 (clk, reset, c_enable[14]/*,... */); // 0.0652 Hz
    //bcdcount counter15 (clk, reset, c_enable[15]/*,... */); // 0.0327 Hz
    
    //bcdcount counter16 (clk, reset, c_enable[16]/*,... */); // 0.0183 Hz
    //bcdcount counter17 (clk, reset, c_enable[17]/*,... */); // 0.0139 Hz
    //bcdcount counter18 (clk, reset, c_enable[18]/*,... */); // 0.0095 Hz
    //bcdcount counter19 (clk, reset, c_enable[19]/*,... */); // 0.0048 Hz
    //bcdcount counter20 (clk, reset, c_enable[20]/*,... */); // 0.0024 Hz
    //bcdcount counter21 (clk, reset, c_enable[21]/*,... */); // 0.0012 Hz
    //bcdcount counter22 (clk, reset, c_enable[22]/*,... */); // 0.0006 Hz
    //bcdcount counter23 (clk, reset, c_enable[23]/*,... */); // 0.0003 Hz
    //bcdcount counter24 (clk, reset, c_enable[24]/*,... */); // 0.0001 Hz
    
    //bcdcount counter25 (clk, reset, c_enable[25]/*,... */); // 0.0000 Hz
    
    //bcdcount counter26 (clk, reset, c_enable[26]/*,... */); // 0.0000 Hz
    //bcdcount counter27 (clk, reset, c_enable[27]/*,... */); // 0.0000 Hz
    //bcdcount counter28 (clk, reset, c_enable[28]/*,... */); // 0.0000 Hz
    //bcdcount counter29 (clk, reset, c_enable[29]/*,... */); // 0.0000 Hz
    //bcdcount counter30 (clk, reset, c_enable[30]/*,... */); // 0.0000 Hz
    //bcdcount counter31 (clk, reset, c_enable[31]/*,... */); // 0.0000 Hz
    
    //bcdcount counter32 (clk, reset, c_enable[32]/*,... */); // 0.0000 Hz
    //bcdcount counter33 (clk, reset, c_enable[33]/*,... */); // 0.0000 Hz
    //b","module top_module (
    input clk,
    input reset,
    output OneHertz,
    output [2:0] c_enable
); //
    
    wire [3:0] q0, q1, q2;

    bcdcount counter0 (clk, reset, c_enable[0], q0);
    bcdcount counter1 (clk, reset, c_enable[1], q1);
    bcdcount counter2 (clk, reset, c_enable[2], q2);

    assign c_enable = {(q1 == 4'd9) && (q0 == 4'd9), q0 == 4'd9, 1'b1};
    assign OneHertz = (q2 == 4'd9) && (q1 == 4'd9) && (q0 == 4'd9);
    
endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | (~x[3])&(~x[5]) | x[1]&x[2]&x[4]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | x[3]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | x[3]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | (~x[3])&(~x[5]) | x[1]&x[2]&x[4]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | x[3]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | x[3]&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&x[5];
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&x[2]&x[4]&x[5] | (~x[3])&(~x[5]) | (~x[4])&(~x[5]);
    // assign f = (~x[1])&x[3] | (~x[2])&(~x[4]) | x[1]&","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & x[0]) | (x[2] & x[3] & x[0]);
    
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1] & x[3]) | (~x[2] & ~x[3] & x[0]) | (x[2] & x[3] & x[0]);
    
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]& (~x[3]) | x[1]&(~x[2])&x[3];
    // assign f = (~x[1])&x[3] | x[1]&(~x[2])&x[3];
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&x[2]&x[3];
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&x[2]&x[3];
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&(~x[2])&(~x[3]) | (~x[1])&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&(~x[3]) | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&(~x[2])&(~x[3]) | (~x[1])&x[2]&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&x[2]&x[3];
    // assign f = x[1]&x[2]&x[3] | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&x[2]&x[3] | (~x[1])&x[2]&(~x[3]);
    // assign f = x[1]&x[2]&x[3] | (~x[1])&(~x[2])&(~x[3]);
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&x[2]&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&(~x[2])&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]& (~x[3]) | x[1]&(~x[2])&x[3];
    // assign f = (~x[1])&x[3] | x[1]&(~x[2])&x[3];
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&x[2]&x[3];
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&x[2]&x[3];
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&(~x[2])&(~x[3]) | (~x[1])&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&(~x[3]) | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&(~x[2])&(~x[3]) | (~x[1])&x[2]&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&x[2]&x[3];
    // assign f = x[1]&x[2]&x[3] | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&x[2]&x[3] | (~x[1])&x[2]&(~x[3]);
    // assign f = x[1]&x[2]&x[3] | (~x[1])&(~x[2])&(~x[3]);
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&x[2]&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&(~x[2])&x[3];
    // assign f = x[1]&x[2]&(~x[3]) | (~x[1])&(~x[2])&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[3]);
    // assign f = x[1]&(~x[2])&x[3] | x[1]&x[2]&(~x[","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[1] & x[2] & ~x[3]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1] & x[3]) | (x[1] & x[2] & ~x[3]);
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&(~x[3]);
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&(~x[3]);
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&(~x[3]);
    
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3]) | x[1]&(~x[2])&x[3] | (~x[1])&(~x[2])&(~x[3]);
    
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'

x_3'x_4'	d		0		d		d
x_3'x_4		0		d		1		0
x_3x_4  	1		1		d		d
x_3x_4'		1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3])&(~x[4]) | x[1]&(~x[2])&x[4];
    
endmodule",-1,Exams_m2014_q3.v,"// Consider the function f shown in the Karnaugh map below.

// Implement this function. d is don't-care, which means you may choose to output whatever value is convenient.

//         x_1'x_2'	x_1'x_2 	x_1x_2		x_1x_2'
//
// x_3'x_4'	d		0		d		d
// x_3'x_4	0		d		1		0
// x_3x_4  	1		1		d		d
// x_3x_4'	1		1		0		d


module top_module (
    input [4:1] x, 
    output f );
","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = (~x[1])&x[3] | x[1]&x[2]&(~x[3])&(~x[4]) | x[1]&(~x[2])&x[4];
    
endmodule","module top_module (
    input [4:1] x, 
    output f );
    
    assign f = ~((~x[2] & ~x[3] & x[4]) | (~x[1] & x[2] & ~x[3] & x[4]) | (x[1] & x[2] & x[3] & ~x[4]) | (~x[1] & x[2] & ~x[3] & ~x[4]));

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if(ena)
            q = d;
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if(ena)
            q = d;
endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end
endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if (ena)
            q <= d;
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if (ena)
            q <= d;
endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if(ena)
            q <= d;
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if(ena)
            q <= d;
endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena)
            q = d;
    end

endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if (ena)
            q <= d;
endmodule",-1,Exams_m2014_q4a.v,"// Implement a D flip flop. Note that this is a latch, so a Quartus warning about having inferred a latch is expected.

module top_module (
    input d, 
    input ena,
    output q);

","module top_module (
    input d, 
    input ena,
    output q);

    always @ (d or ena)
        if (ena)
            q <= d;
endmodule","module top_module (
    input d, 
    input ena,
    output q);
    
    always @(*) begin
        if (ena) begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        if(ar)
            q <= 1'b0;
        else
            q <= d;

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        if(ar)
            q <= 1'b0;
        else
            q <= d;

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        if(ar)
            q <= 1'b0;
        else
            q <= d;

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        if(ar)
            q <= 1'b0;
        else
            q <= d;

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        begin
            if(ar)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        begin
            if(ar)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @ (posedge clk or posedge ar)
        if(ar)
            q <= 1'b0;
        else
            q <= d;

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @ (posedge clk or posedge ar)
        if(ar)
            q <= 1'b0;
        else
            q <= d;

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        begin
            if(ar)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar)
        begin
            if(ar)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule",-1,Exams_m2014_q4b.v,"// Implement the following D flip-flop with asynchronous reset

module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);


    always @(posedge clk or posedge ar) begin
        if(ar)
            q <= 1'b0;
        else
            q <= d;
    end

endmodule","module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end
    
endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        if(r)
            q <= 1'b0;
    	else
            q <= d;
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        if(r)
            q <= 1'b0;
    	else
            q <= d;
endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end
endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule",-1,Exams_m2014_q4c.v,"// Implement the following D flip-flop with synchronous reset

module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @ (posedge clk)
        begin
            if(r)
                q <= 1'b0;
            else
                q <= d;
        end

endmodule","module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);
    
    always @(posedge clk) begin
        if(r) begin
            q <= 0;
        end
        else begin
            q <= d;
        end
    end

endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = ~in;
    
endmodule",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = ~in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = ~in;
    
endmodule",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = ~in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    assign out = in;
endmodule",1,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    assign out = in;
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
    
    assign out = ~in;
    
endmodule",-0.5,Exams_m2014_q4h.v,"// Implement the following circuit:

// in --- out

module top_module (
    input in,
    output out);
","module top_module (
    input in,
    output out);
    
    assign out = ~in;
    
endmodule","module top_module (
    input in,
    output out);

    assign out = in;
    
endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= q + 10'd1;
        end
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= q + 10'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;

endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                begin
                    q <= q + 10'd1;
                end
        end
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                begin
                    q <= q + 10'd1;
                end
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end

endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= q + 10'd1;
        end

endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= q + 10'd1;
        end

endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= q + 10'd1;
        end
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= q + 10'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @ (posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        begin
            if(reset)
                q <= 10'd0;
            else
                q <= (q == 10'd999)? 10'd0 : q + 10'd1;
        end
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;
endmodule",-1,Exams_review2015_count1k.v,"// Build a counter that counts from 0 to 999, inclusive, with a period of 1000 cycles. The reset input is synchronous, and should reset the counter to 0.

module top_module (
    input clk,
    input reset,
    output [9:0] q);
","module top_module (
    input clk,
    input reset,
    output [9:0] q);
    
    always @(posedge clk)
        if(reset)
            q <= 10'd0;
        else
            q <= (q == 10'd999)? 10'd0 : q + 10'd1;
endmodule","module top_module (
    input clk,
    input reset,
    output [9:0] q);

    always @(posedge clk) begin
        if (reset) begin
            q <= 0;
        end
        else if (q == 999) begin
            q <= 0;
        end
        else begin
            q <= q + 1;
        end
    end

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    localparam S_RESET = 0, S_COUNT = 1, S_WAIT = 2, S_DONE = 3;
    reg [1:0] state, next_state;
    reg [3:0] count_reg, count_next;
    reg counting_reg, counting_next;
    reg done_reg, done_next;
    reg ack_reg, ack_next;
    
    always @(*) begin
        state <= next_state;
        count_reg <= count_next;
        counting_reg <= counting_next;
        done_reg <= done_next;
        ack_reg <= ack_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= S_RESET;
        else
            next_state <= state;
            
        count_next <= count_reg;
        counting_next <= counting_reg;
        done_next <= done_reg;
        ack_next <= ack_reg;
    end
    
    assign count = count_reg;
    assign counting = counting_reg;
    assign done = done_reg;
    assign ack = ack_reg;
    
    always @(*) begin
        case(state)
            S_RESET: begin
                if(data == 1'b1)
                    next_state <= S_COUNT;
                else
                    next_state <= S_RESET;
            end
            S_COUNT: begin
                if(counting)
                    next_state <= S_WAIT;
                else
                    next_state <= S_COUNT;
            end
            S_WAIT: begin
                if(ack)
                    next_state <= S_DONE;
                else
                    next_state <= S_WAIT;
            end
            S_DONE: begin
                if(data == 1'b1)
                    next_state <= S_COUNT;
                else
                    next_state <= S_RESET;
            end
            default: begin
                next_state <= S_RESET;
            end
        endcase
    end
    
endmodule",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    localparam S_RESET = 0, S_COUNT = 1, S_WAIT = 2, S_DONE = 3;
    reg [1:0] state, next_state;
    reg [3:0] count_reg, count_next;
    reg counting_reg, counting_next;
    reg done_reg, done_next;
    reg ack_reg, ack_next;
    
    always @(*) begin
        state <= next_state;
        count_reg <= count_next;
        counting_reg <= counting_next;
        done_reg <= done_next;
        ack_reg <= ack_next;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= S_RESET;
        else
            next_state <= state;
            
        count_next <= count_reg;
        counting_next <= counting_reg;
        done_next <= done_reg;
        ack_next <= ack_reg;
    end
    
    assign count = count_reg;
    assign counting = counting_reg;
    assign done = done_reg;
    assign ack = ack_reg;
    
    always @(*) begin
        case(state)
            S_RESET: begin
                if(data == 1'b1)
                    next_state <= S_COUNT;
                else
                    next_state <= S_RESET;
            end
            S_COUNT: begin
                if(counting)
                    next_state <= S_WAIT;
                else
                    next_state <= S_COUNT;
            end
            S_WAIT: begin
                if(ack)
                    next_state <= S_DONE;
                else
                    next_state <= S_WAIT;
            end
            S_DONE: begin
                if(data == 1'b1)
                    next_state <= S_COUNT;
                else
                    next_state <= S_RESET;
            end
            default: begin
                next_state <= S_RESET;
            end
        endcase
    end
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Count:Wait;
            Wait: NS <= (ack)? S:Count;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Count:Wait;
            Wait: NS <= (ack)? S:Count;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    reg [3:0] count_reg;
    reg counting_reg;
    reg done_reg;
    reg [3:0] delay_reg;
    reg [3:0] delay_reg_1;
    reg [3:0] delay_reg_2;
    reg [3:0] delay_reg_3;
    reg [3:0] delay_reg_4;
    reg [3:0] delay_reg_5;
    reg [3:0] delay_reg_6;
    reg [3:0] delay_reg_7;
    reg [3:0] delay_reg_8;
    reg [3:0] delay_reg_9;
    reg [3:0] delay_reg_10;
    reg [3:0] delay_reg_11;
    reg [3:0] delay_reg_12;
    reg [3:0] delay_reg_13;
    reg [3:0] delay_reg_14;
    reg [3:0] delay_reg_15;
    reg [3:0] delay_reg_16;
    reg [3:0] delay_reg_17;
    reg [3:0] delay_reg_18;
    reg [3:0] delay_reg_19;
    reg [3:0] delay_reg_20;
    reg [3:0] delay_reg_21;
    reg [3:0] delay_reg_22;
    reg [3:0] delay_reg_23;
    reg [3:0] delay_reg_24;
    reg [3:0] delay_reg_25;
    reg [3:0] delay_reg_26;
    reg [3:0] delay_reg_27;
    reg [3:0] delay_reg_28;
    reg [3:0] delay_reg_29;
    reg [3:0] delay_reg_30;
    reg [3:0] delay_reg_31;
    reg [3:0] delay_reg_32;
    reg [3:0] delay_reg_33;
    reg [3:0] delay_reg_34;
    reg [3:0] delay_reg_35;
    reg [3:0] delay_reg_36;
    reg [3:0] delay_reg_37;
    reg [3:0] delay_reg_38;
    reg [3:0] delay_reg_39;
    reg [3:0] delay_reg_40;
    reg [3:0] delay_reg_41;
    reg [3:0] delay_reg_42;
    reg [3:0] delay_reg_43;
    reg [3:0] delay_reg_44;
    reg [3:0] delay_reg_45;
    reg [3:0] delay_reg_46;
    reg [3:0] delay_reg_47;
    reg [3:0] delay_reg_48;
    reg [3:0] delay_reg_49;
    reg [3:0] delay_reg_50;
    reg [3:0] delay_reg_51;
    reg [3:0] delay_reg_52;
    reg [3:0] delay_reg_53;
    reg [3:0] delay_reg_54;
    reg [3:0] delay_reg_55;
    reg [3:0] delay_reg_56;
    reg [3:0] delay_reg_57;
    reg [3:0] delay_reg_58;
    reg [3:0] delay_reg_59;
    reg [3:0] delay_reg_60;
    reg [3:0] delay_reg_61;
    reg [3:0] delay_reg_62;
    reg [3:0] delay_reg_63;
    reg [3:0] delay_reg_64;
    reg [3:0] delay_reg_65;
    reg [3:0] delay_reg_66;
    reg [3:0] delay_reg_67;
    reg [3:0] delay_reg_68;
    reg [3:0] delay_reg_69;
    reg [3:0] delay_reg_70;
    reg [3",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    reg [3:0] count_reg;
    reg counting_reg;
    reg done_reg;
    reg [3:0] delay_reg;
    reg [3:0] delay_reg_1;
    reg [3:0] delay_reg_2;
    reg [3:0] delay_reg_3;
    reg [3:0] delay_reg_4;
    reg [3:0] delay_reg_5;
    reg [3:0] delay_reg_6;
    reg [3:0] delay_reg_7;
    reg [3:0] delay_reg_8;
    reg [3:0] delay_reg_9;
    reg [3:0] delay_reg_10;
    reg [3:0] delay_reg_11;
    reg [3:0] delay_reg_12;
    reg [3:0] delay_reg_13;
    reg [3:0] delay_reg_14;
    reg [3:0] delay_reg_15;
    reg [3:0] delay_reg_16;
    reg [3:0] delay_reg_17;
    reg [3:0] delay_reg_18;
    reg [3:0] delay_reg_19;
    reg [3:0] delay_reg_20;
    reg [3:0] delay_reg_21;
    reg [3:0] delay_reg_22;
    reg [3:0] delay_reg_23;
    reg [3:0] delay_reg_24;
    reg [3:0] delay_reg_25;
    reg [3:0] delay_reg_26;
    reg [3:0] delay_reg_27;
    reg [3:0] delay_reg_28;
    reg [3:0] delay_reg_29;
    reg [3:0] delay_reg_30;
    reg [3:0] delay_reg_31;
    reg [3:0] delay_reg_32;
    reg [3:0] delay_reg_33;
    reg [3:0] delay_reg_34;
    reg [3:0] delay_reg_35;
    reg [3:0] delay_reg_36;
    reg [3:0] delay_reg_37;
    reg [3:0] delay_reg_38;
    reg [3:0] delay_reg_39;
    reg [3:0] delay_reg_40;
    reg [3:0] delay_reg_41;
    reg [3:0] delay_reg_42;
    reg [3:0] delay_reg_43;
    reg [3:0] delay_reg_44;
    reg [3:0] delay_reg_45;
    reg [3:0] delay_reg_46;
    reg [3:0] delay_reg_47;
    reg [3:0] delay_reg_48;
    reg [3:0] delay_reg_49;
    reg [3:0] delay_reg_50;
    reg [3:0] delay_reg_51;
    reg [3:0] delay_reg_52;
    reg [3:0] delay_reg_53;
    reg [3:0] delay_reg_54;
    reg [3:0] delay_reg_55;
    reg [3:0] delay_reg_56;
    reg [3:0] delay_reg_57;
    reg [3:0] delay_reg_58;
    reg [3:0] delay_reg_59;
    reg [3:0] delay_reg_60;
    reg [3:0] delay_reg_61;
    reg [3:0] delay_reg_62;
    reg [3:0] delay_reg_63;
    reg [3:0] delay_reg_64;
    reg [3:0] delay_reg_65;
    reg [3:0] delay_reg_66;
    reg [3:0] delay_reg_67;
    reg [3:0] delay_reg_68;
    reg [3:0] delay_reg_69;
    reg [3:0] delay_reg_70;
    reg [3","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= (data)? Count:Wait;
            Count: NS <= (counting)? Count:S;
            Wait: NS <= (ack)? S:S;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= (data)? Count:Wait;
            Count: NS <= (counting)? Count:S;
            Wait: NS <= (ack)? S:S;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Count:Wait;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
    
    assign count = (PS == Count)? count+1:4'd0;
    
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Count:Wait;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
    
    assign count = (PS == Count)? count+1:4'd0;
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    reg [3:0] count_reg;
    reg done_reg;
    reg counting_reg;
    reg [3:0] count_next;
    reg [3:0] count_next_reg;
    reg done_next;
    reg counting_next;
    
    always @(*) begin
        count_next = count_reg;
        done_next = done_reg;
        counting_next = counting_reg;
        case(count_reg)
            4'b0000: begin
                count_next_reg = data? 4'b0001 : 4'b0000;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0001: begin
                count_next_reg = data? 4'b0010 : 4'b0001;
                counting_next = 1'b1;
                done_next = 1'b0;
            end
            4'b0010: begin
                count_next_reg = data? 4'b0011 : 4'b0010;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0011: begin
                count_next_reg = data? 4'b0100 : 4'b0011;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0100: begin
                count_next_reg = data? 4'b0101 : 4'b0100;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0101: begin
                count_next_reg = data? 4'b0110 : 4'b0101;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0110: begin
                count_next_reg = data? 4'b0111 : 4'b0110;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0111: begin
                count_next_reg = data? 4'b1000 : 4'b0111;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1000: begin
                count_next_reg = data? 4'b1001 : 4'b1000;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1001: begin
                count_next_reg = data? 4'b1010 : 4'b1001;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1010: begin
                count_next_reg = data? 4'b1011 : 4'b1010;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1011: begin
                count_next_reg = data? 4'b1100 : 4'b1011;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1100: begin
                count_next_reg = data? 4'b1101 : 4'b1100;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1101: begin
                count_next_reg = data? 4'b1110 : 4'b1101;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1110: begin
                count_next_reg = data? 4'b1111 : 4'b1110;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1111: begin
                count_next_reg = data? 4'b0000 : 4'b1111;
                counting_next = 1'b0;
                done_next = 1'b1;
            end
            default: begin
                count_next_reg = 4'b0000;
                count",-1,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    reg [3:0] count_reg;
    reg done_reg;
    reg counting_reg;
    reg [3:0] count_next;
    reg [3:0] count_next_reg;
    reg done_next;
    reg counting_next;
    
    always @(*) begin
        count_next = count_reg;
        done_next = done_reg;
        counting_next = counting_reg;
        case(count_reg)
            4'b0000: begin
                count_next_reg = data? 4'b0001 : 4'b0000;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0001: begin
                count_next_reg = data? 4'b0010 : 4'b0001;
                counting_next = 1'b1;
                done_next = 1'b0;
            end
            4'b0010: begin
                count_next_reg = data? 4'b0011 : 4'b0010;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0011: begin
                count_next_reg = data? 4'b0100 : 4'b0011;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0100: begin
                count_next_reg = data? 4'b0101 : 4'b0100;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0101: begin
                count_next_reg = data? 4'b0110 : 4'b0101;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0110: begin
                count_next_reg = data? 4'b0111 : 4'b0110;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b0111: begin
                count_next_reg = data? 4'b1000 : 4'b0111;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1000: begin
                count_next_reg = data? 4'b1001 : 4'b1000;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1001: begin
                count_next_reg = data? 4'b1010 : 4'b1001;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1010: begin
                count_next_reg = data? 4'b1011 : 4'b1010;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1011: begin
                count_next_reg = data? 4'b1100 : 4'b1011;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1100: begin
                count_next_reg = data? 4'b1101 : 4'b1100;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1101: begin
                count_next_reg = data? 4'b1110 : 4'b1101;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1110: begin
                count_next_reg = data? 4'b1111 : 4'b1110;
                counting_next = 1'b0;
                done_next = 1'b0;
            end
            4'b1111: begin
                count_next_reg = data? 4'b0000 : 4'b1111;
                counting_next = 1'b0;
                done_next = 1'b1;
            end
            default: begin
                count_next_reg = 4'b0000;
                count","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case(state)
            S: begin
                if(~data)
                    next_state = S;
                else
                    next_state = S1;
            end
            S1: begin
                if(data)
                    next_state = S11;
                else
                    next_state = S;
            end
            S11: begin
                if(data)
                    next_state = S110;
                else
                    next_state = S1;
            end
            S110: begin
                if(data)
                    next_state = B0;
                else
                    next_state = S1;
            end
            B0: begin
                if(data)
                    next_state = B1;
                else
                    next_state = B0;
            end
            B1: begin
                if(data)
                    next_state = B2;
                else
                    next_state = B1;
            end
            B2: begin
                if(data)
                    next_state = B3;
                else
                    next_state = B2;
            end
            B3: begin
                if(data)
                    next_state = Count;
                else
                    next_state = B3;
            end
            Count: begin
                if(count == 4'd11)
                    next_state = Wait;
                else
                    next_state = Count;
            end
            Wait: begin
                if(ack)
                    next_state = S;
                else
                    next_state = Wait;
            end
            default: next_state = S;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= S;
        else
            state <= next_state;
    end
    
    assign counting = (state == Count);
    assign done = (state == Wait);
    assign count = count;
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] state, next_state;
    
    always @(*) begin
        case(state)
            S: begin
                if(~data)
                    next_state = S;
                else
                    next_state = S1;
            end
            S1: begin
                if(data)
                    next_state = S11;
                else
                    next_state = S;
            end
            S11: begin
                if(data)
                    next_state = S110;
                else
                    next_state = S1;
            end
            S110: begin
                if(data)
                    next_state = B0;
                else
                    next_state = S1;
            end
            B0: begin
                if(data)
                    next_state = B1;
                else
                    next_state = B0;
            end
            B1: begin
                if(data)
                    next_state = B2;
                else
                    next_state = B1;
            end
            B2: begin
                if(data)
                    next_state = B3;
                else
                    next_state = B2;
            end
            B3: begin
                if(data)
                    next_state = Count;
                else
                    next_state = B3;
            end
            Count: begin
                if(count == 4'd11)
                    next_state = Wait;
                else
                    next_state = Count;
            end
            Wait: begin
                if(ack)
                    next_state = S;
                else
                    next_state = Wait;
            end
            default: next_state = S;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= S;
        else
            state <= next_state;
    end
    
    assign counting = (state == Count);
    assign done = (state == Wait);
    assign count = count;
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == B3)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Wait:Count;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == B3)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Wait:Count;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Count:Wait;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
    
    assign count = (PS == Count)? count+1:4'd0;
    
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Count:Wait;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
    
    assign count = (PS == Count)? count+1:4'd0;
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Wait:Count;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fancytimer.v,"// We want to create a timer with one input that:

// first, is started when a particular input pattern (1101) is detected,
// second, shifts in 4 more bits to determine the duration to delay,
// third, waits for the counters to finish counting, and
// fourth, notifies the user and waits for the user to acknowledge the timer.
// fifth, The serial data is available on the data input pin. When the pattern 1101 is received, the circuit must then shift in the next 4 bits, // most-significant-bit first. These 4 bits determine the duration of the timer delay. I'll refer to this as the delay[3:0].

// After that, the state machine asserts its counting output to indicate it is counting. The state machine must count for exactly (delay[3:0] + 1) * 1000 clock cycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count 6000 cycles. Also output the current remaining time. This should be equal to delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until it is 0 for 1000 cycles. When the circuit isn't counting, the count[3:0] output is don't-care (whatever value is convenient for you to implement).

// At that point, the circuit must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The circuit should reset into a state where it begins searching for the input sequence 1101.

// Hint: It's ok to have all the code in a single module if the components are in their own always blocks, as long as it's clear which blob of code corresponds to which hardware block. Don't merge multiple always blocks together, as that's hard to read and error-prone.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign counting = (PS == Count)? 1:0;
    assign done = (PS == Wait)? 1:0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1:S;
            S1: NS <= (data)? S11:S;
            S11: NS <= (data)? S11:S110;
            S110: NS <= (data)? B0:S;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= Count;
            Count: NS <= (counting)? Wait:Count;
            Wait: NS <= (ack)? S:Wait;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output [3:0] count,
    output counting,
    output done,
    input ack );

    parameter idle = 0, s1 = 1, s2 = 2, s3 = 3, b0 = 4, b1 = 5;
    parameter b2 = 6, b3 = 7, counts = 8, waiting = 9;
    reg [3:0] state, next_state;
    reg [9:0] counter;

    always @(*) begin
        case (state)
            idle:   next_state = data ? s1 : idle;
            s1:     next_state = data ? s2 : idle;
            s2:     next_state = data ? s2 : s3;
            s3:     next_state = data ? b0 : idle;
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = counts;
            counts: next_state = (count == 0 && counter == 999) ? waiting : counts;
            waiting:next_state = ack ? idle : waiting;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            count <= 0;
            counter <= 0;
        end
        else begin
            case (state)
                b0: count[3] <= data;
                b1: count[2] <= data;
                b2: count[1] <= data;
                b3: count[0] <= data;
                counts: begin
                    if (count >= 0) begin
                        if (counter < 999) begin
                            counter <= counter + 1;
                        end
                        else begin
                            count <= count - 1;
                            counter <= 0;
                        end
                    end
                end
                default: counter <= 0;
            endcase
        end
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= idle;
        end
        else begin
            state <= next_state;
        end
    end

    assign counting = (state == counts);
    assign done = (state == waiting);

endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6;
    reg state, next_state;
    
    localparam IDLE = 0, DATA = 1, STOP = 2, DELAY = 3;
    
    // State transition logic (combinational)
    always @(*) begin
        case (state)
            S0: begin
                if(data) next_state = DATA;
                else next_state = S0;
            end
            
            S1: next_state = S2;
            
            S2: next_state = S3;
            
            S3: begin
                if(~data) next_state = IDLE;
                else next_state = S4;
            end
            
            S4: next_state = S5;
            
            S5: next_state = S6;
            
            S6: begin
                if(done_counting) next_state = STOP;
                else next_state = DELAY;
            end
            
            DELAY: next_state = DELAY;
            
            default: next_state = S0;
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset) state <= S0;
        else state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == DATA);
    assign counting = (state == DATA) | (state == DELAY);
    assign done = (state == STOP);
endmodule",-0.5,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6;
    reg state, next_state;
    
    localparam IDLE = 0, DATA = 1, STOP = 2, DELAY = 3;
    
    // State transition logic (combinational)
    always @(*) begin
        case (state)
            S0: begin
                if(data) next_state = DATA;
                else next_state = S0;
            end
            
            S1: next_state = S2;
            
            S2: next_state = S3;
            
            S3: begin
                if(~data) next_state = IDLE;
                else next_state = S4;
            end
            
            S4: next_state = S5;
            
            S5: next_state = S6;
            
            S6: begin
                if(done_counting) next_state = STOP;
                else next_state = DELAY;
            end
            
            DELAY: next_state = DELAY;
            
            default: next_state = S0;
        endcase
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset) state <= S0;
        else state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == DATA);
    assign counting = (state == DATA) | (state == DELAY);
    assign done = (state == STOP);
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4;
    reg [1:0] PS, NS;
    
    assign shift_ena = ((PS == S4) && (NS == S0))? 1'b1 : 1'b0;
    assign counting = ((PS == S0) && (NS == S1))? 1'b1 : 1'b0;
    assign done = ((PS == S4) && (NS == S0))? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
        else
            PS <= NS;
    
    always @(PS, data, done_counting, ack)
        case(PS)
            S0: begin
                if(data == 1'b1)
                    NS <= S1;
                else if(data == 1'b0)
                    NS <= S0;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S0;
            end
            
            S1: begin
                if(data == 1'b1)
                    NS <= S2;
                else if(data == 1'b0)
                    NS <= S1;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S1;
            end
            
            S2: begin
                if(data == 1'b1)
                    NS <= S3;
                else if(data == 1'b0)
                    NS <= S2;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S2;
            end
            
            S3: begin
                if(data == 1'b1)
                    NS <= S4;
                else if(data == 1'b0)
                    NS <= S3;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S3;
            end
            
            S4: begin
                if(data == 1'b1)
                    NS <= S0;
                else if(data == 1'b0)
                    NS <= S4;
                else if(ack == 1'b1)
                    NS <= S4;
                else
                    NS <= S4;
            end
            
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4;
    reg [1:0] PS, NS;
    
    assign shift_ena = ((PS == S4) && (NS == S0))? 1'b1 : 1'b0;
    assign counting = ((PS == S0) && (NS == S1))? 1'b1 : 1'b0;
    assign done = ((PS == S4) && (NS == S0))? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
        else
            PS <= NS;
    
    always @(PS, data, done_counting, ack)
        case(PS)
            S0: begin
                if(data == 1'b1)
                    NS <= S1;
                else if(data == 1'b0)
                    NS <= S0;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S0;
            end
            
            S1: begin
                if(data == 1'b1)
                    NS <= S2;
                else if(data == 1'b0)
                    NS <= S1;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S1;
            end
            
            S2: begin
                if(data == 1'b1)
                    NS <= S3;
                else if(data == 1'b0)
                    NS <= S2;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S2;
            end
            
            S3: begin
                if(data == 1'b1)
                    NS <= S4;
                else if(data == 1'b0)
                    NS <= S3;
                else if(done_counting == 1'b1)
                    NS <= S4;
                else
                    NS <= S3;
            end
            
            S4: begin
                if(data == 1'b1)
                    NS <= S0;
                else if(data == 1'b0)
                    NS <= S4;
                else if(ack == 1'b1)
                    NS <= S4;
                else
                    NS <= S4;
            end
            
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4;
    reg [1:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        state <= next_state;
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Next state logic (combinational)
    always @(*) begin
        next_state = state;
        shift_ena = 1'b0;
        counting = 1'b0;
        done = 1'b0;
        case (state)
            S0: begin
                if(data)
                    next_state = S1;
            end
            S1: begin
                shift_ena = 1'b1;
                if(data)
                    next_state = S2;
            end
            S2: begin
                counting = 1'b1;
                if(done_counting)
                    next_state = S3;
            end
            S3: begin
                done = 1'b1;
                if(ack)
                    next_state = S4;
            end
            S4: begin
                if(data)
                    next_state = S1;
            end
            default: next_state = S0;
        endcase
    end
    
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4;
    reg [1:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        state <= next_state;
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Next state logic (combinational)
    always @(*) begin
        next_state = state;
        shift_ena = 1'b0;
        counting = 1'b0;
        done = 1'b0;
        case (state)
            S0: begin
                if(data)
                    next_state = S1;
            end
            S1: begin
                shift_ena = 1'b1;
                if(data)
                    next_state = S2;
            end
            S2: begin
                counting = 1'b1;
                if(done_counting)
                    next_state = S3;
            end
            S3: begin
                done = 1'b1;
                if(ack)
                    next_state = S4;
            end
            S4: begin
                if(data)
                    next_state = S1;
            end
            default: next_state = S0;
        endcase
    end
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7, S8 = 8, S9 = 9, S10 = 10;
    reg [3:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(*) begin
        case (state)
            S0: begin
                if(data == 1'b1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(data == 1'b1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(data == 1'b1)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(data == 1'b1)
                    next_state = S4;
                else
                    next_state = S0;
            end
            S4: begin
                if(data == 1'b1)
                    next_state = S5;
                else
                    next_state = S0;
            end
            S5: begin
                if(data == 1'b1)
                    next_state = S6;
                else
                    next_state = S0;
            end
            S6: begin
                if(data == 1'b1)
                    next_state = S7;
                else
                    next_state = S0;
            end
            S7: begin
                if(data == 1'b1)
                    next_state = S8;
                else
                    next_state = S0;
            end
            S8: begin
                if(data == 1'b1)
                    next_state = S9;
                else
                    next_state = S0;
            end
            S9: begin
                if(data == 1'b1)
                    next_state = S10;
                else
                    next_state = S0;
            end
            S10: begin
                if(data == 1'b1)
                    next_state = S10;
                else
                    next_state = S0;
            end
            default: begin
                next_state = S0;
            end
        endcase
    end
    
    assign shift_ena = (state == S10)? 1'b1 : 1'b0;
    assign counting = (state == S8 || state == S9)? 1'b1 : 1'b0;
    assign done = (state == S10)? 1'b1 : 1'b0;
    assign done_counting = (state == S8 || state == S9)? 1'b1 : 1'b0;
    assign ack = (state == S10)? 1'b1 : 1'b0;
    
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7, S8 = 8, S9 = 9, S10 = 10;
    reg [3:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(*) begin
        case (state)
            S0: begin
                if(data == 1'b1)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(data == 1'b1)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(data == 1'b1)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(data == 1'b1)
                    next_state = S4;
                else
                    next_state = S0;
            end
            S4: begin
                if(data == 1'b1)
                    next_state = S5;
                else
                    next_state = S0;
            end
            S5: begin
                if(data == 1'b1)
                    next_state = S6;
                else
                    next_state = S0;
            end
            S6: begin
                if(data == 1'b1)
                    next_state = S7;
                else
                    next_state = S0;
            end
            S7: begin
                if(data == 1'b1)
                    next_state = S8;
                else
                    next_state = S0;
            end
            S8: begin
                if(data == 1'b1)
                    next_state = S9;
                else
                    next_state = S0;
            end
            S9: begin
                if(data == 1'b1)
                    next_state = S10;
                else
                    next_state = S0;
            end
            S10: begin
                if(data == 1'b1)
                    next_state = S10;
                else
                    next_state = S0;
            end
            default: begin
                next_state = S0;
            end
        endcase
    end
    
    assign shift_ena = (state == S10)? 1'b1 : 1'b0;
    assign counting = (state == S8 || state == S9)? 1'b1 : 1'b0;
    assign done = (state == S10)? 1'b1 : 1'b0;
    assign done_counting = (state == S8 || state == S9)? 1'b1 : 1'b0;
    assign ack = (state == S10)? 1'b1 : 1'b0;
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] PS, NS;
    
    assign shift_ena = (PS == S4)? 1'b1 : 1'b0;
    assign counting = (PS == S1)? 1'b1 : 1'b0;
    assign done = (PS == S4)? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
        else
            PS <= NS;
    
    always @(PS, data, done_counting)
        case(PS)
            S0: begin
                NS <= (data == 1'b1)? S1 : S0;
                done_counting <= 1'b0;
            end
            S1: begin
                NS <= (data == 1'b1)? S2 : S0;
                done_counting <= 1'b0;
            end
            S2: begin
                NS <= (data == 1'b1)? S3 : S0;
                done_counting <= 1'b0;
            end
            S3: begin
                NS <= (data == 1'b1)? S4 : S0;
                done_counting <= 1'b0;
            end
            S4: begin
                NS <= (data == 1'b1)? S4 : S0;
                done_counting <= 1'b1;
            end
            default: NS <= S0;
        endcase
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] PS, NS;
    
    assign shift_ena = (PS == S4)? 1'b1 : 1'b0;
    assign counting = (PS == S1)? 1'b1 : 1'b0;
    assign done = (PS == S4)? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
        else
            PS <= NS;
    
    always @(PS, data, done_counting)
        case(PS)
            S0: begin
                NS <= (data == 1'b1)? S1 : S0;
                done_counting <= 1'b0;
            end
            S1: begin
                NS <= (data == 1'b1)? S2 : S0;
                done_counting <= 1'b0;
            end
            S2: begin
                NS <= (data == 1'b1)? S3 : S0;
                done_counting <= 1'b0;
            end
            S3: begin
                NS <= (data == 1'b1)? S4 : S0;
                done_counting <= 1'b0;
            end
            S4: begin
                NS <= (data == 1'b1)? S4 : S0;
                done_counting <= 1'b1;
            end
            default: NS <= S0;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] PS, NS;
    
    assign shift_ena = (PS == S4)? 1 : 0;
    assign counting = (PS == S1)? 1 : 0;
    assign done = (PS == S4)? 1 : 0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
    	else
            PS <= NS;
    
    always @(PS, data, done_counting, ack)
        case (PS)
            S0: begin
                NS <= (data == 1'b1)? S1 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S1: begin
                NS <= (data == 1'b1)? S2 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S2: begin
                NS <= (data == 1'b1)? S3 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S3: begin
                NS <= (data == 1'b1)? S4 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S4: begin
                NS <= S4;
                done_counting <= 1'b1;
                ack <= 1'b1;
            end
            default: NS <= S0;
        endcase
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] PS, NS;
    
    assign shift_ena = (PS == S4)? 1 : 0;
    assign counting = (PS == S1)? 1 : 0;
    assign done = (PS == S4)? 1 : 0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
    	else
            PS <= NS;
    
    always @(PS, data, done_counting, ack)
        case (PS)
            S0: begin
                NS <= (data == 1'b1)? S1 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S1: begin
                NS <= (data == 1'b1)? S2 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S2: begin
                NS <= (data == 1'b1)? S3 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S3: begin
                NS <= (data == 1'b1)? S4 : S0;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S4: begin
                NS <= S4;
                done_counting <= 1'b1;
                ack <= 1'b1;
            end
            default: NS <= S0;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    parameter S5=5, S6=6, S7=7, S8=8, S9=9;
    parameter S10=10, S11=11, S12=12, S13=13, S14=14;
    parameter S15=15, S16=16, S17=17, S18=18, S19=19;
    parameter S20=20, S21=21, S22=22, S23=23, S24=24;
    parameter S25=25, S26=26, S27=27, S28=28, S29=29;
    parameter S30=30, S31=31, S32=32, S33=33, S34=34;
    parameter S35=35, S36=36, S37=37, S38=38, S39=39;
    parameter S40=40, S41=41, S42=42, S43=43, S44=44;
    parameter S45=45, S46=46, S47=47, S48=48, S49=49;
    parameter S50=50, S51=51, S52=52, S53=53, S54=54;
    parameter S55=55, S56=56, S57=57, S58=58, S59=59;
    parameter S60=60, S61=61, S62=62, S63=63, S64=64;
    parameter S65=65, S66=66, S67=67, S68=68, S69=69;
    parameter S70=70, S71=71, S72=72, S73=73, S74=74;
    parameter S75=75, S76=76, S77=77, S78=78, S79=79;
    parameter S80=80, S81=81, S82=82, S83=83, S84=84;
    parameter S85=85, S86=86, S87=87, S88=88, S89=89;
    parameter S90=90, S91=91, S92=92, S93=93, S94=94;
    parameter S95=95, S96=96, S97=97, S98=98, S99=99;
    parameter S100=100, S101=101, S102=102, S103=103, S104=104;
    parameter S105=105, S106=106, S107=107, S108=108, S109=109;
    parameter S110=110, S111=111, S112=112, S113=113, S114=114;
    parameter S115=115, S116=116, S117=117, S118=118, S119=119;
    parameter S120=120, S121=121, S122=122, S123=123, S124=124;
    parameter S125=125, S126=126, S127=127, S128=128, S129=129;
    parameter S130=130, S131=131, S132=132, S133=133, S134=134;
    parameter S135=135, S136=136, S137=137, S138=138, S139=139;
    parameter S140=140, S141=141, S142=142, S143=143, S144=144;
    parameter S145=145, S146=146, S147=147, S148=148, S149=149;
    parameter S150=150, S151=151, S152=152, S153=153, S154=154;
    parameter S155=155, S156=156, S157=157, S158=158, S159=159;
    parameter S160=160, S161=161, S162=162, S163=163, S164=164;
    parameter S165=165, S166=166, S167=167, S168=168, S169=169;
    parameter S170=170, S171=171, S172=172, S173=173, S174=174;
    parameter S175=175",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    parameter S5=5, S6=6, S7=7, S8=8, S9=9;
    parameter S10=10, S11=11, S12=12, S13=13, S14=14;
    parameter S15=15, S16=16, S17=17, S18=18, S19=19;
    parameter S20=20, S21=21, S22=22, S23=23, S24=24;
    parameter S25=25, S26=26, S27=27, S28=28, S29=29;
    parameter S30=30, S31=31, S32=32, S33=33, S34=34;
    parameter S35=35, S36=36, S37=37, S38=38, S39=39;
    parameter S40=40, S41=41, S42=42, S43=43, S44=44;
    parameter S45=45, S46=46, S47=47, S48=48, S49=49;
    parameter S50=50, S51=51, S52=52, S53=53, S54=54;
    parameter S55=55, S56=56, S57=57, S58=58, S59=59;
    parameter S60=60, S61=61, S62=62, S63=63, S64=64;
    parameter S65=65, S66=66, S67=67, S68=68, S69=69;
    parameter S70=70, S71=71, S72=72, S73=73, S74=74;
    parameter S75=75, S76=76, S77=77, S78=78, S79=79;
    parameter S80=80, S81=81, S82=82, S83=83, S84=84;
    parameter S85=85, S86=86, S87=87, S88=88, S89=89;
    parameter S90=90, S91=91, S92=92, S93=93, S94=94;
    parameter S95=95, S96=96, S97=97, S98=98, S99=99;
    parameter S100=100, S101=101, S102=102, S103=103, S104=104;
    parameter S105=105, S106=106, S107=107, S108=108, S109=109;
    parameter S110=110, S111=111, S112=112, S113=113, S114=114;
    parameter S115=115, S116=116, S117=117, S118=118, S119=119;
    parameter S120=120, S121=121, S122=122, S123=123, S124=124;
    parameter S125=125, S126=126, S127=127, S128=128, S129=129;
    parameter S130=130, S131=131, S132=132, S133=133, S134=134;
    parameter S135=135, S136=136, S137=137, S138=138, S139=139;
    parameter S140=140, S141=141, S142=142, S143=143, S144=144;
    parameter S145=145, S146=146, S147=147, S148=148, S149=149;
    parameter S150=150, S151=151, S152=152, S153=153, S154=154;
    parameter S155=155, S156=156, S157=157, S158=158, S159=159;
    parameter S160=160, S161=161, S162=162, S163=163, S164=164;
    parameter S165=165, S166=166, S167=167, S168=168, S169=169;
    parameter S170=170, S171=171, S172=172, S173=173, S174=174;
    parameter S175=175","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign shift_ena = (PS == B0) | (PS == B1) | (PS == B2) | (PS == B3) | (PS == Count) | (PS == Wait);
    assign counting = (PS == Count) | (PS == Wait);
    assign done = (PS == S) | (PS == S1) | (PS == S11) | (PS == S110) | (PS == B0) | (PS == B1) | (PS == B2) | (PS == B3) | (PS == Count) | (PS == Wait);
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1 : S;
            S1: NS <= (data)? S11 : S1;
            S11: NS <= (data)? S11 : S110;
            S110: NS <= (data)? B0 : S110;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= (data)? Count : B3;
            Count: NS <= (data)? Count : Wait;
            Wait: NS <= (data)? Wait : S;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign shift_ena = (PS == B0) | (PS == B1) | (PS == B2) | (PS == B3) | (PS == Count) | (PS == Wait);
    assign counting = (PS == Count) | (PS == Wait);
    assign done = (PS == S) | (PS == S1) | (PS == S11) | (PS == S110) | (PS == B0) | (PS == B1) | (PS == B2) | (PS == B3) | (PS == Count) | (PS == Wait);
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data)? S1 : S;
            S1: NS <= (data)? S11 : S1;
            S11: NS <= (data)? S11 : S110;
            S110: NS <= (data)? B0 : S110;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= (data)? Count : B3;
            Count: NS <= (data)? Count : Wait;
            Wait: NS <= (data)? Wait : S;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign shift_ena = (PS == B0) || (PS == B1) || (PS == B2) || (PS == B3)? 1'b1 : 1'b0;
    assign counting = (PS == Count)? 1'b1 : 1'b0;
    assign done = (PS == Wait)? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data == 1'b0)? S1 : S;
            S1: NS <= (data == 1'b0)? S11 : S1;
            S11: NS <= (data == 1'b0)? S11 : S110;
            S110: NS <= (data == 1'b0)? B0 : S110;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= (data == 1'b0)? Count : B3;
            Count: NS <= (data == 1'b0)? Count : Wait;
            Wait: NS <= (data == 1'b0)? Wait : S;
            default: NS <= PS;
        endcase
endmodule",-0.5,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;
    reg [3:0] PS, NS;
    
    assign shift_ena = (PS == B0) || (PS == B1) || (PS == B2) || (PS == B3)? 1'b1 : 1'b0;
    assign counting = (PS == Count)? 1'b1 : 1'b0;
    assign done = (PS == Wait)? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S;
    	else
            PS <= NS;
    
    always @(*)
        case(PS)
            S: NS <= (data == 1'b0)? S1 : S;
            S1: NS <= (data == 1'b0)? S11 : S1;
            S11: NS <= (data == 1'b0)? S11 : S110;
            S110: NS <= (data == 1'b0)? B0 : S110;
            B0: NS <= B1;
            B1: NS <= B2;
            B2: NS <= B3;
            B3: NS <= (data == 1'b0)? Count : B3;
            Count: NS <= (data == 1'b0)? Count : Wait;
            Wait: NS <= (data == 1'b0)? Wait : S;
            default: NS <= PS;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7;
    reg [2:0] PS, NS;
    
    assign shift_ena = (PS == S4)? 1'b1 : 1'b0;
    assign counting = (PS == S0)? 1'b1 : 1'b0;
    assign done = (PS == S7)? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
    	else
            PS <= NS;
    
    always @(PS, data, done_counting, ack)
        case (PS)
            S0: begin
                NS <= (data == 1'b1)? S1 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S1: begin
                NS <= (data == 1'b1)? S2 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S2: begin
                NS <= (data == 1'b1)? S3 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S3: begin
                NS <= (data == 1'b1)? S4 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S4: begin
                NS <= (data == 1'b1)? S5 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S5: begin
                NS <= (data == 1'b1)? S6 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S6: begin
                NS <= (data == 1'b1)? S7 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S7: begin
                NS <= S0;
                counting <= 1'b0;
                done_counting <= 1'b1;
                ack <= 1'b1;
            end
            default: NS <= S0;
        endcase
endmodule",-1,Exams_review2015_fsm.v,"// We want to create a timer that:

// First, is started when a particular pattern (1101) is detected,
// Second, shifts in 4 more bits to determine the duration to delay,
// Third, waits for the counters to finish counting, and
// Fourth, notifies the user and waits for the user to acknowledge the timer.
// Fifth, In this problem, implement just the finite-state machine that controls the timer. The data path (counters and some comparators) are not included here.

// The serial data is available on the data input pin. When the pattern 1101 is received, the state machine must then assert output shift_ena for exactly 4 clock cycles.

// After that, the state machine asserts its counting output to indicate it is waiting for the counters, and waits until input done_counting is high.

// At that point, the state machine must assert done to notify the user the timer has timed out, and waits until input ack is 1 before being reset to look for the next occurrence of the start sequence (1101).

// The state machine should reset into a state where it begins searching for the input sequence 1101.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );
    
    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S6 = 6, S7 = 7;
    reg [2:0] PS, NS;
    
    assign shift_ena = (PS == S4)? 1'b1 : 1'b0;
    assign counting = (PS == S0)? 1'b1 : 1'b0;
    assign done = (PS == S7)? 1'b1 : 1'b0;
    
    always @(posedge clk)
        if(reset)
            PS <= S0;
    	else
            PS <= NS;
    
    always @(PS, data, done_counting, ack)
        case (PS)
            S0: begin
                NS <= (data == 1'b1)? S1 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S1: begin
                NS <= (data == 1'b1)? S2 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S2: begin
                NS <= (data == 1'b1)? S3 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S3: begin
                NS <= (data == 1'b1)? S4 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S4: begin
                NS <= (data == 1'b1)? S5 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S5: begin
                NS <= (data == 1'b1)? S6 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S6: begin
                NS <= (data == 1'b1)? S7 : S0;
                counting <= 1'b1;
                done_counting <= 1'b0;
                ack <= 1'b0;
            end
            S7: begin
                NS <= S0;
                counting <= 1'b0;
                done_counting <= 1'b1;
                ack <= 1'b1;
            end
            default: NS <= S0;
        endcase
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output shift_ena,
    output counting,
    input done_counting,
    output done,
    input ack );

    parameter idle=4'd0, s1=4'd1, s11=4'd2, s110=4'd3, b0=4'd4, b1=4'd5, b2=4'd6, b3=4'd7, count=4'd8, waiting=4'd9;
    reg [3:0]   state, next_state;
    
    always@(*) begin
        case(state)
            idle: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s1;
            end
            s1: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = s11;
            end
            s11: begin
                if(data==1'b0)
                    next_state = s110;
                else
                    next_state = s11;
            end
            s110: begin
                if(data==1'b0)
                    next_state = idle;
                else
                    next_state = b0;
            end
            b0:     next_state = b1;
            b1:     next_state = b2;
            b2:     next_state = b3;
            b3:     next_state = count;
            count: begin
                if(done_counting)
                    next_state = waiting;
                else
                    next_state = count;
            end
            waiting: begin
                if(ack)
                    next_state = idle;
                else
                    next_state = waiting;
            end
        endcase
    end
    
    always@(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign  shift_ena = (state==b0 || state==b1|| state==b2 || state==b3);
    assign  counting = (state==count);
    assign  done = (state==waiting);
    
endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        if(data)
                            next_state <= start_shifting;
                    start_shifting:
                        if(data)
                            next_state <= start_shifting;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        if(data)
                            next_state <= start_shifting;
                    start_shifting:
                        if(data)
                            next_state <= start_shifting;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        if(data)
                            next_state <= start_shifting;
                    start_shifting:
                        if(data)
                            next_state <= start_shifting;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= idle;
        else
            begin
                case(state)
                    idle:
                        if(data)
                            next_state <= start_shifting;
                    start_shifting:
                        if(data)
                            next_state <= start_shifting;
                    default:
                        next_state <= idle;
                endcase
            end
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1, done=2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~data)
                    next_state = idle;
                else
                    next_state = start_shifting;
            end
            start_shifting: begin
                if(data)
                    next_state = start_shifting;
                else
                    next_state = done;
            end
            done: begin
                if(data)
                    next_state = idle;
                else
                    next_state = done;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1, done=2;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~data)
                    next_state = idle;
                else
                    next_state = start_shifting;
            end
            start_shifting: begin
                if(data)
                    next_state = start_shifting;
                else
                    next_state = done;
            end
            done: begin
                if(data)
                    next_state = idle;
                else
                    next_state = done;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(data)
                    next_state = start_shifting;
                else
                    next_state = idle;
            end
            start_shifting: begin
                if(data)
                    next_state = start_shifting;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            idle: begin
                if(data)
                    next_state = start_shifting;
                else
                    next_state = idle;
            end
            start_shifting: begin
                if(data)
                    next_state = start_shifting;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule",-1,Exams_review2015_fsmseq.v,"// Build a finite-state machine that searches for the sequence 1101 in an input bit stream. When the sequence is found, it should set start_shifting to 1, forever, until reset. Getting stuck in the final state is intended to model going to other states in a bigger FSM that is not yet implemented. We will be extending this FSM in the next few exercises.

module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter idle=0, start_shifting=1;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case(state)
            idle: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            start_shifting: begin
                if(data)
                    next_state <= start_shifting;
                else
                    next_state <= idle;
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign start_shifting = (state == start_shifting);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    input data,
    output start_shifting);

    parameter a = 0, b = 1, c = 2, d = 3, e = 4;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            a: next_state = data ? b : a;
            b: next_state = data ? c : a;
            c: next_state = data ? c : d;
            d: next_state = data ? e : a;
            e: next_state = data ? e : e;
        endcase
    end
    always @(posedge clk) begin
        if (reset) begin
            state <= a;
        end
        else begin
            state <= next_state;
        end
    end

    assign start_shifting = (state == e);

endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset)
            state = S0;
        else
            state = next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset)
            state = S0;
        else
            state = next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if (shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if (shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if (shift_ena)
                    next_state <= S4;
                else
                    next_state <= S0;
            end
            S4: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S4);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if (shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if (shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if (shift_ena)
                    next_state <= S4;
                else
                    next_state <= S0;
            end
            S4: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S4);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S4;
                else
                    next_state = S0;
            end
            S4: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= S0;
    	else
            state <= next_state;
    
    // Output logic
    assign shift_ena = (state == S4);

endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 3'd0, S1 = 3'd1, S2 = 3'd2, S3 = 3'd3, S4 = 3'd4;
    reg [2:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*)
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S4;
                else
                    next_state = S0;
            end
            S4: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    
    // State flip-flops (sequential)
    always @(posedge clk)
        if(reset)
            state <= S0;
    	else
            state <= next_state;
    
    // Output logic
    assign shift_ena = (state == S4);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0=0, S1=1, S2=2, S3=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(shift_ena)
                    next_state <= S2;
                else
                    next_state <= S1;
            end
            S2: begin
                if(shift_ena)
                    next_state <= S3;
                else
                    next_state <= S2;
            end
            S3: begin
                if(shift_ena)
                    next_state <= S0;
                else
                    next_state <= S3;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0=0, S1=1, S2=2, S3=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(shift_ena)
                    next_state <= S2;
                else
                    next_state <= S1;
            end
            S2: begin
                if(shift_ena)
                    next_state <= S3;
                else
                    next_state <= S2;
            end
            S3: begin
                if(shift_ena)
                    next_state <= S0;
                else
                    next_state <= S3;
            end
            default: next_state <= S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(reset)
            state = S0;
        else
            state = next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with asynchronous reset
        if(reset)
            state = S0;
        else
            state = next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;

    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if (shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if (shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end

    // State flip-flops with synchronous reset
    always @(posedge clk) begin
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end

    // Output logic
    assign shift_ena = (state == S3);

endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;

    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case (state)
            S0: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if (shift_ena)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if (shift_ena)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if (shift_ena)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end

    // State flip-flops with synchronous reset
    always @(posedge clk) begin
        if (reset)
            state <= S0;
        else
            state <= next_state;
    end

    // Output logic
    assign shift_ena = (state == S3);

endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0=0, S1=1, S2=2, S3=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset)
            state = S0;
        else
            state = next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule",-0.5,Exams_review2015_fsmshift.v,"// As part of the FSM for controlling the shift register, we want the ability to enable the shift register for exactly 4 clock cycles whenever the proper bit pattern is detected. Design an FSM handles enabling the shift register for 4 cycles.

// Whenever the FSM is reset, assert shift_ena for 4 cycles, then 0 forever (until reset).

module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);

    parameter S0=0, S1=1, S2=2, S3=3;
    reg [1:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            S1: begin
                if(shift_ena)
                    next_state = S2;
                else
                    next_state = S0;
            end
            S2: begin
                if(shift_ena)
                    next_state = S3;
                else
                    next_state = S0;
            end
            S3: begin
                if(shift_ena)
                    next_state = S1;
                else
                    next_state = S0;
            end
            default: next_state = S0;
        endcase
    end
    
    always @(posedge clk) begin
        // State flip-flops with synchronous reset
        if(reset)
            state = S0;
        else
            state = next_state;
    end
    
    // Output logic
    assign shift_ena = (state == S3);
    
endmodule","module top_module (
    input clk,
    input reset,      // Synchronous reset
    output shift_ena);
    
    parameter c0=3'd0, c1=3'd1, c2=3'd2, c3=3'd3, c4=3'd4;
    reg [2:0]   state, next_state;
    
    always@(*) begin
        case(state)
            c0:     next_state = reset ? c1 : c0;
            c1:     next_state = c2;
            c2:     next_state = c3;
            c3:     next_state = c4;
            c4:     next_state = c0;
        endcase
    end
    
    always@(posedge clk) begin
       state <= next_state; 
    end
    
    assign shift_ena = (state==c1 || state==c2 || state==c3 || state==c4);
    
endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @ (posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @ (posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
    
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @ (posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @ (posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
    
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @ (posedge clk) begin
        if(shift_ena) begin
            q <= {data, q[3:1]};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end

endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @ (posedge clk) begin
        if(shift_ena) begin
            q <= {data, q[3:1]};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end

endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
    
endmodule",-1,Exams_review2015_shiftcount.v,"// Build a four-bit shift register that also acts as a down counter. Data is shifted in most-significant-bit first when shift_ena is 1. The number currently in the shift register is decremented when count_ena is 1. Since the full system doesn't ever use shift_ena and count_ena together, it does not matter what your circuit does if both control inputs are 1 (This mainly means that it doesn't matter which case gets higher priority).

module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);
    
    always @(posedge clk) begin
        if(shift_ena) begin
            q <= {q[2:0], data};
        end
        else if(count_ena) begin
            q <= q - 1;
        end
    end
    
endmodule","module top_module (
    input clk,
    input shift_ena,
    input count_ena,
    input data,
    output [3:0] q);

    always @(posedge clk) begin
        if (shift_ena) begin
            q <= {q[2:0], data};  // an useful skill
        end
        else if (count_ena) begin
            q <= q - 1;
        end
        else begin
            q <= q;
        end
    end

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (a & cin) | (b & cin);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (a & cin) | (b & cin);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a&b | a&cin | b&cin;
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule",1,Fadd.v,"//Create a full adder. A full adder adds three bits (including carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b, cin,
    output cout, sum );
","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = (a & b) | (b & cin) | (cin & a);
    
endmodule","module top_module( 
    input a, b, cin,
    output cout, sum );
    
    assign sum = a ^ b ^ cin;
    assign cout = a & b | a & cin | b & cin;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    reg [3:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(in[3] == 1'b1)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(in[3] == 1'b1)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(in[3] == 1'b1)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(in[3] == 1'b1)
                    next_state <= S4;
                else
                    next_state <= S0;
            end
            S4: begin
                if(in[3] == 1'b1)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == S4);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    reg [3:0] state, next_state;
    
    always @(*) begin
        // State transition logic
        case(state)
            S0: begin
                if(in[3] == 1'b1)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(in[3] == 1'b1)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(in[3] == 1'b1)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(in[3] == 1'b1)
                    next_state <= S4;
                else
                    next_state <= S0;
            end
            S4: begin
                if(in[3] == 1'b1)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == S4);
    
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, rec_msg=1, done=2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] in_buffer;
    
    always @(posedge clk)
        if(reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case(state)
            idle:
                begin
                    if(in[3]==1)
                        next_state = rec_msg;
                    else
                        next_state = idle;
                end
            rec_msg:
                begin
                    if(counter==7)
                        next_state = done;
                    else
                        next_state = rec_msg;
                end
            done:
                begin
                    if(in[3]==1)
                        next_state = rec_msg;
                    else
                        next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset)
            counter <= 4'b0;
        else if(state==rec_msg)
            counter <= counter + 1;
    
    always @(posedge clk)
        if(reset)
            in_buffer <= 8'b0;
        else if(state==rec_msg)
            in_buffer <= in;
    
    assign done = (state==done)? 1:0;
    assign in_ = in_buffer[7:4];
    
endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, rec_msg=1, done=2;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg [7:0] in_buffer;
    
    always @(posedge clk)
        if(reset)
            state <= idle;
        else
            state <= next_state;
    
    always @(*)
        case(state)
            idle:
                begin
                    if(in[3]==1)
                        next_state = rec_msg;
                    else
                        next_state = idle;
                end
            rec_msg:
                begin
                    if(counter==7)
                        next_state = done;
                    else
                        next_state = rec_msg;
                end
            done:
                begin
                    if(in[3]==1)
                        next_state = rec_msg;
                    else
                        next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    
    always @(posedge clk)
        if(reset)
            counter <= 4'b0;
        else if(state==rec_msg)
            counter <= counter + 1;
    
    always @(posedge clk)
        if(reset)
            in_buffer <= 8'b0;
        else if(state==rec_msg)
            in_buffer <= in;
    
    assign done = (state==done)? 1:0;
    assign in_ = in_buffer[7:4];
    
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            START: begin
                if(in[3] == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA: begin
                if(in[3] == 1'b1)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in[3] == 1'b0)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(counter == 15)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == DATA && in[3] == 1'b1)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    assign done = (state == DELAY)? (counter == 15):(state == STOP);
    
    always @(*) begin
        case(state)
            START: begin
                out <= 0;
            end
            DATA: begin
                out <= in[3];
            end
            STOP: begin
                out <= 0;
            end
            DELAY: begin
                out <= 0;
            end
        endcase
    end
    
    assign out_byte = (state == START)? (in[3]):(out);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            START: begin
                if(in[3] == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA: begin
                if(in[3] == 1'b1)
                    next_state = STOP;
                else
                    next_state = DATA;
            end
            STOP: begin
                if(in[3] == 1'b0)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(counter == 15)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            default: next_state = START;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == DATA && in[3] == 1'b1)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    assign done = (state == DELAY)? (counter == 15):(state == STOP);
    
    always @(*) begin
        case(state)
            START: begin
                out <= 0;
            end
            DATA: begin
                out <= in[3];
            end
            STOP: begin
                out <= 0;
            end
            DELAY: begin
                out <= 0;
            end
        endcase
    end
    
    assign out_byte = (state == START)? (in[3]):(out);
    
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, rec_data=1, stop=2, done=3;
    reg [2:0] state, next_state;
    reg [3:0] i;
    reg [7:0] data;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    if(in[3]==1'b1)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(i==7)
                        next_state = stop;
                    else
                        next_state = rec_data;
                end
            stop:
                begin
                    if(in[3]==1'b1)
                        next_state = done;
                    else
                        next_state = idle;
                end
            done:
                begin
                    if(in[3]==1'b1)
                        next_state = idle;
                    else
                        next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    data = 8'b0;
                    i = 4'b0;
                end
            rec_data:
                begin
                    data = in;
                    i = i + 1'b1;
                end
            stop:
                begin
                    done = 1'b1;
                end
            done:
                begin
                    done = 1'b0;
                end
        endcase
    end
endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter idle=0, rec_data=1, stop=2, done=3;
    reg [2:0] state, next_state;
    reg [3:0] i;
    reg [7:0] data;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    if(in[3]==1'b1)
                        next_state = rec_data;
                    else
                        next_state = idle;
                end
            rec_data:
                begin
                    if(i==7)
                        next_state = stop;
                    else
                        next_state = rec_data;
                end
            stop:
                begin
                    if(in[3]==1'b1)
                        next_state = done;
                    else
                        next_state = idle;
                end
            done:
                begin
                    if(in[3]==1'b1)
                        next_state = idle;
                    else
                        next_state = idle;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(state) begin
        case(state)
            idle:
                begin
                    data = 8'b0;
                    i = 4'b0;
                end
            rec_data:
                begin
                    data = in;
                    i = i + 1'b1;
                end
            stop:
                begin
                    done = 1'b1;
                end
            done:
                begin
                    done = 1'b0;
                end
        endcase
    end
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            START: begin
                if(in[3] == 1)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in[3] == 1)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(count == 8)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 8)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == DATA && count < 8)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        case(state)
            START: begin
                out <= 0;
            end
            DATA: begin
                out <= in[3];
            end
            STOP: begin
                out <= 0;
            end
            DELAY: begin
                out <= 0;
            end
        endcase
    end
    
    assign done = (state == DELAY);
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            START: begin
                if(in[3] == 1)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(in[3] == 1)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(count == 8)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 8)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == DATA && count < 8)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        case(state)
            START: begin
                out <= 0;
            end
            DATA: begin
                out <= in[3];
            end
            STOP: begin
                out <= 0;
            end
            DELAY: begin
                out <= 0;
            end
        endcase
    end
    
    assign done = (state == DELAY);
    
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter STATE_IDLE = 0,
              STATE_CHECK = 1,
              STATE_DONE = 2,
              STATE_DONE_0 = 3;

    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [7:0] in_buffer;
    reg [7:0] out_buffer;
    reg out_enable;

    always @(*) begin
        next_state = state;
        case (state)
            STATE_IDLE : begin
                if (in!= 8'b0)
                    next_state = STATE_CHECK;
            end
            STATE_CHECK : begin
                if (in[7:4] == 4'b1010)
                    next_state = STATE_DONE;
            end
            STATE_DONE : begin
                if (count == 8'h0)
                    next_state = STATE_DONE_0;
            end
            STATE_DONE_0 : begin
                if (count == 8'h0)
                    next_state = STATE_IDLE;
            end
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= STATE_IDLE;
            count <= 4'b0;
        end
        else begin
            state <= next_state;
            if (next_state == STATE_DONE)
                count <= count + 4'b1;
            else if (next_state == STATE_DONE_0)
                count <= 4'b0;
            else
                count <= count;
        end
    end

    always @(*) begin
        if (state == STATE_IDLE) begin
            in_buffer = in;
            out_buffer = 8'b0;
            out_enable = 1'b0;
        end
        else if (state == STATE_CHECK) begin
            in_buffer = in;
            out_buffer = 8'b0;
            out_enable = 1'b0;
        end
        else if (state == STATE_DONE) begin
            in_buffer = in;
            out_buffer = {in[7:4], 4'b1010};
            out_enable = 1'b1;
        end
        else if (state == STATE_DONE_0) begin
            in_buffer = in;
            out_buffer = {in[7:4], 4'b1010};
            out_enable = 1'b1;
        end
    end

    assign done = (state == STATE_DONE)? 1'b1 : 1'b0;

    always @(posedge clk) begin
        if (out_enable)
            out <= out_buffer;
    end

endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter STATE_IDLE = 0,
              STATE_CHECK = 1,
              STATE_DONE = 2,
              STATE_DONE_0 = 3;

    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [7:0] in_buffer;
    reg [7:0] out_buffer;
    reg out_enable;

    always @(*) begin
        next_state = state;
        case (state)
            STATE_IDLE : begin
                if (in!= 8'b0)
                    next_state = STATE_CHECK;
            end
            STATE_CHECK : begin
                if (in[7:4] == 4'b1010)
                    next_state = STATE_DONE;
            end
            STATE_DONE : begin
                if (count == 8'h0)
                    next_state = STATE_DONE_0;
            end
            STATE_DONE_0 : begin
                if (count == 8'h0)
                    next_state = STATE_IDLE;
            end
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= STATE_IDLE;
            count <= 4'b0;
        end
        else begin
            state <= next_state;
            if (next_state == STATE_DONE)
                count <= count + 4'b1;
            else if (next_state == STATE_DONE_0)
                count <= 4'b0;
            else
                count <= count;
        end
    end

    always @(*) begin
        if (state == STATE_IDLE) begin
            in_buffer = in;
            out_buffer = 8'b0;
            out_enable = 1'b0;
        end
        else if (state == STATE_CHECK) begin
            in_buffer = in;
            out_buffer = 8'b0;
            out_enable = 1'b0;
        end
        else if (state == STATE_DONE) begin
            in_buffer = in;
            out_buffer = {in[7:4], 4'b1010};
            out_enable = 1'b1;
        end
        else if (state == STATE_DONE_0) begin
            in_buffer = in;
            out_buffer = {in[7:4], 4'b1010};
            out_enable = 1'b1;
        end
    end

    assign done = (state == STATE_DONE)? 1'b1 : 1'b0;

    always @(posedge clk) begin
        if (out_enable)
            out <= out_buffer;
    end

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [7:0] data;

    always @(*) begin
        case(state)
            START: begin
                if(in[3] == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA: begin
                if(count < 4'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in[3] == 1'b1)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 4'd8)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end

    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end

    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 4'd1;
        else
            count <= 4'd0;
    end

    always @(posedge clk) begin
        if(state == DATA)
            data <= in;
    end

    assign done = (state == STOP);

endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg [7:0] data;

    always @(*) begin
        case(state)
            START: begin
                if(in[3] == 1'b0)
                    next_state = START;
                else
                    next_state = DATA;
            end
            DATA: begin
                if(count < 4'd8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in[3] == 1'b1)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 4'd8)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            default: next_state = START;
        endcase
    end

    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end

    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 4'd1;
        else
            count <= 4'd0;
    end

    always @(posedge clk) begin
        if(state == DATA)
            data <= in;
    end

    assign done = (state == STOP);

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter BYTE1 = 0, BYTE2 = 1, BYTE3 = 2, DONE = 3;
    reg [2:0] state, next_state;

    // State transition logic (combinational)
    always @(*)
        begin
            state <= next_state;
        end
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            if(reset)
                state <= BYTE1;
            else
                state <= next_state;
        end
    // Output logic
    assign done = (state == DONE);
    // New: Datapath to store incoming bytes.
    reg [7:0] in_byte;
    always @(posedge clk)
        begin
            in_byte <= in;
        end
    // New: Output a message when we see the start of a message.
    reg [2:0] msg_count;
    always @(posedge clk)
        begin
            msg_count <= msg_count + 1'b1;
        end
    assign msg_done = (msg_count == 3);
    // New: Output a message when we see the end of a message.
    reg [7:0] msg_byte1, msg_byte2, msg_byte3;
    always @(posedge clk)
        begin
            msg_byte1 <= in_byte;
            msg_byte2 <= msg_byte1;
            msg_byte3 <= msg_byte2;
        end
    assign msg_byte = msg_byte3;
    assign msg_start = (state == BYTE1) & (in_byte[7:4] == 4'h1);
    assign msg_end = (state == BYTE3) & (in_byte[7:4] == 4'h2);
    // New: Use a finite state machine to store incoming bytes.
    always @(posedge clk)
        begin
            if(reset)
                next_state <= BYTE1;
            else
                begin
                    case(state)
                        BYTE1 : begin
                            if(in_byte[7:4] == 4'h1)
                                next_state <= BYTE2;
                            else
                                next_state <= BYTE1;
                        end
                        BYTE2 : begin
                            if(in_byte[7:4] == 4'h2)
                                next_state <= BYTE3;
                            else
                                next_state <= BYTE2;
                        end
                        BYTE3 : begin
                            if(msg_done)
                                next_state <= DONE;
                            else if(msg_end)
                                next_state <= BYTE1;
                            else
                                next_state <= BYTE3;
                        end
                        DONE : begin
                            if(in_byte[7:4] == 4'h3)
                                next_state <= BYTE1;
                            else
                                next_state <= DONE;
                        end
                        default: next_state <= BYTE1;
                    endcase
                end
        end
    // New: Datapath to accumulate bytes
    always @(posedge clk)
        begin
            if(reset)
                out <= 8'h00;
            else
                begin
                    case(state)
                        BYTE1 : out <= in_byte[7:4];
                        BYTE2 : out <= {in_byte[7], in_byte[3:1]};
                        BYTE3 : out <= {in_byte[7], in_byte[3:1], in_byte[0]};
                        DONE : out <= 8'h00;
                        default: out <= 8'h00;
                    endcase
                end
        end
endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter BYTE1 = 0, BYTE2 = 1, BYTE3 = 2, DONE = 3;
    reg [2:0] state, next_state;

    // State transition logic (combinational)
    always @(*)
        begin
            state <= next_state;
        end
    // State flip-flops (sequential)
    always @(posedge clk)
        begin
            if(reset)
                state <= BYTE1;
            else
                state <= next_state;
        end
    // Output logic
    assign done = (state == DONE);
    // New: Datapath to store incoming bytes.
    reg [7:0] in_byte;
    always @(posedge clk)
        begin
            in_byte <= in;
        end
    // New: Output a message when we see the start of a message.
    reg [2:0] msg_count;
    always @(posedge clk)
        begin
            msg_count <= msg_count + 1'b1;
        end
    assign msg_done = (msg_count == 3);
    // New: Output a message when we see the end of a message.
    reg [7:0] msg_byte1, msg_byte2, msg_byte3;
    always @(posedge clk)
        begin
            msg_byte1 <= in_byte;
            msg_byte2 <= msg_byte1;
            msg_byte3 <= msg_byte2;
        end
    assign msg_byte = msg_byte3;
    assign msg_start = (state == BYTE1) & (in_byte[7:4] == 4'h1);
    assign msg_end = (state == BYTE3) & (in_byte[7:4] == 4'h2);
    // New: Use a finite state machine to store incoming bytes.
    always @(posedge clk)
        begin
            if(reset)
                next_state <= BYTE1;
            else
                begin
                    case(state)
                        BYTE1 : begin
                            if(in_byte[7:4] == 4'h1)
                                next_state <= BYTE2;
                            else
                                next_state <= BYTE1;
                        end
                        BYTE2 : begin
                            if(in_byte[7:4] == 4'h2)
                                next_state <= BYTE3;
                            else
                                next_state <= BYTE2;
                        end
                        BYTE3 : begin
                            if(msg_done)
                                next_state <= DONE;
                            else if(msg_end)
                                next_state <= BYTE1;
                            else
                                next_state <= BYTE3;
                        end
                        DONE : begin
                            if(in_byte[7:4] == 4'h3)
                                next_state <= BYTE1;
                            else
                                next_state <= DONE;
                        end
                        default: next_state <= BYTE1;
                    endcase
                end
        end
    // New: Datapath to accumulate bytes
    always @(posedge clk)
        begin
            if(reset)
                out <= 8'h00;
            else
                begin
                    case(state)
                        BYTE1 : out <= in_byte[7:4];
                        BYTE2 : out <= {in_byte[7], in_byte[3:1]};
                        BYTE3 : out <= {in_byte[7], in_byte[3:1], in_byte[0]};
                        DONE : out <= 8'h00;
                        default: out <= 8'h00;
                    endcase
                end
        end
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter STATE_SIZE = 4; // The number of states is 4

    // State transition logic (combinational)
    reg [STATE_SIZE-1:0] state_new, state_next;
    // State flip-flops (sequential)
    reg [STATE_SIZE-1:0] state, state_next;
    // Output logic
    reg done_reg, done_next;

    always @(*) begin
        state_new = state_next;
    end

    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            done_reg <= 1'b0;
        end
        else begin
            state <= state_next;
            done_reg <= done_next;
        end
    end

    always @(*) begin
        state_next = state;
        done_next = done_reg;
        case(state)
            0: begin
                if(in[3] == 1'b1) begin
                    state_next = 1;
                end
            end
            1: begin
                if(in[3] == 1'b0) begin
                    state_next = 2;
                end
            end
            2: begin
                if(in[3] == 1'b1) begin
                    state_next = 3;
                end
            end
            3: begin
                if(in[3] == 1'b0) begin
                    state_next = 0;
                    done_next = 1'b1;
                end
            end
            default: begin
                state_next = 0;
            end
        endcase
    end

    assign done = done_reg;

endmodule",-1,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter STATE_SIZE = 4; // The number of states is 4

    // State transition logic (combinational)
    reg [STATE_SIZE-1:0] state_new, state_next;
    // State flip-flops (sequential)
    reg [STATE_SIZE-1:0] state, state_next;
    // Output logic
    reg done_reg, done_next;

    always @(*) begin
        state_new = state_next;
    end

    always @(posedge clk) begin
        if(reset) begin
            state <= 0;
            done_reg <= 1'b0;
        end
        else begin
            state <= state_next;
            done_reg <= done_next;
        end
    end

    always @(*) begin
        state_next = state;
        done_next = done_reg;
        case(state)
            0: begin
                if(in[3] == 1'b1) begin
                    state_next = 1;
                end
            end
            1: begin
                if(in[3] == 1'b0) begin
                    state_next = 2;
                end
            end
            2: begin
                if(in[3] == 1'b1) begin
                    state_next = 3;
                end
            end
            3: begin
                if(in[3] == 1'b0) begin
                    state_next = 0;
                    done_next = 1'b1;
                end
            end
            default: begin
                state_next = 0;
            end
        endcase
    end

    assign done = done_reg;

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter S0=0, S1=1, S2=2, S3=3;
    reg [3:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        state <= next_state;
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == S3);
    
    // New: Datapath to store incoming bytes.
    reg [7:0] in_reg;
    
    always @(posedge clk) begin
        if(reset)
            in_reg <= 0;
        else if(state == S0)
            in_reg <= in;
    end
    
    // New: Datapath to accumulate bytes
    reg [7:0] acc = 0;
    
    always @(posedge clk) begin
        if(state == S0)
            acc <= in;
        else if(state == S1)
            acc <= {in[0], acc[7:1]};
        else if(state == S2)
            acc <= {acc[0], acc[7:1], in[0]};
        else if(state == S3)
            acc <= {acc[0], acc[7:1], in[0], acc[7:1]};
    end
    
    // New: Output logic
    always @(posedge clk) begin
        if(state == S3)
            in_reg <= acc;
    end
    
    // Next state logic
    always @(*) begin
        case(state)
            S0: if(in[3])
                    next_state = S1;
                else
                    next_state = S0;
            S1: if(in[3])
                    next_state = S1;
                else
                    next_state = S2;
            S2: if(in[3])
                    next_state = S3;
                else
                    next_state = S0;
            S3: if(in[3])
                    next_state = S3;
                else
                    next_state = S0;
            default: next_state = S0;
        endcase
    end
    
endmodule",-0.5,Fsm_ps2.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).

// The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Although in[7:0] is a byte, the FSM only has one input: in[3].
// You need ~4 states. Three states likely wouldn't work because one of them needs to assert done, and done is asserted for only one cycle for each received message.
// State transition logic (combinational)
// State flip-flops (sequential)
// Output logic
module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done);","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter S0=0, S1=1, S2=2, S3=3;
    reg [3:0] state, next_state;
    
    // State transition logic
    always @(*) begin
        state <= next_state;
    end
    
    // State flip-flops with asynchronous reset
    always @(posedge clk) begin
        if(reset)
            state <= S0;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == S3);
    
    // New: Datapath to store incoming bytes.
    reg [7:0] in_reg;
    
    always @(posedge clk) begin
        if(reset)
            in_reg <= 0;
        else if(state == S0)
            in_reg <= in;
    end
    
    // New: Datapath to accumulate bytes
    reg [7:0] acc = 0;
    
    always @(posedge clk) begin
        if(state == S0)
            acc <= in;
        else if(state == S1)
            acc <= {in[0], acc[7:1]};
        else if(state == S2)
            acc <= {acc[0], acc[7:1], in[0]};
        else if(state == S3)
            acc <= {acc[0], acc[7:1], in[0], acc[7:1]};
    end
    
    // New: Output logic
    always @(posedge clk) begin
        if(state == S3)
            in_reg <= acc;
    end
    
    // Next state logic
    always @(*) begin
        case(state)
            S0: if(in[3])
                    next_state = S1;
                else
                    next_state = S0;
            S1: if(in[3])
                    next_state = S1;
                else
                    next_state = S2;
            S2: if(in[3])
                    next_state = S3;
                else
                    next_state = S0;
            S3: if(in[3])
                    next_state = S3;
                else
                    next_state = S0;
            default: next_state = S0;
        endcase
    end
    
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output done); //

    parameter byte1 = 1, byte2 = 2, byte3 = 3, dn = 4;
    reg [3:0] state, next_state;

    // State transition logic (combinational)
    always @(*) begin
        case ({state, in[3]})
            {byte1, 1'b0}: next_state = byte1;
            {byte1, 1'b1}: next_state = byte2;
            {byte2, 1'b0}: next_state = byte3;
            {byte2, 1'b1}: next_state = byte3;
            {byte3, 1'b0}: next_state = dn;
            {byte3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = byte1;
            {dn, 1'b1}: next_state = byte2;
        endcase
    end

    // State flip-flops (sequential)
    always @(posedge clk) begin
        if (reset) begin
            state <= byte1;
        end
        else begin
            state <= next_state;
        end
    end

    // Output logic
    assign done = (state == dn);

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        state <= next_state;
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == stop);
    
    // New: Datapath to store incoming bytes.
    reg [7:0] bytes[3:0];
    integer i;
    always @(posedge clk) begin
        if(reset) begin
            for(i=0; i<=3; i=i+1)
                bytes[i] <= 8'd0;
        end
        else begin
            bytes[0] <= in[7:0];
            bytes[1] <= bytes[0];
            bytes[2] <= bytes[1];
            bytes[3] <= bytes[2];
        end
    end
    assign out_bytes = {bytes[2], bytes[1], bytes[0]};
    
    // New: Add parity checking.
    reg [3:0] bytes_cnt;
    always @(posedge clk) begin
        if(reset)
            bytes_cnt <= 4'd0;
        else if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            bytes_cnt <= bytes_cnt + 4'd1;
        else
            bytes_cnt <= bytes_cnt;
    end
    assign parity = ^bytes;
    assign valid = (bytes_cnt == 4'd7)? 1'b1 : 1'b0;
    
    // New: Add parity checking.
    always @(*) begin
        case (state)
            idle: begin
                if(~in[7] && valid)  next_state = start;
                else                next_state = idle;
            end
            start: begin
                if(in[7:0] == 8'hFA) begin
                    if(valid)  next_state = trans0;
                    else      next_state = error;
                end
                else begin
                    next_state = idle;
                end
            end
            trans0: begin
                if(in[7:0] == 8'hA0) begin
                    if(valid)  next_state = trans1;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans0;
                end
            end
            trans1: begin
                if(in[7:0] == 8'hB0) begin
                    if(valid)  next_state = trans2;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans1;
                end
            end
            trans2: begin
                if(in[7:0] == 8'hC0) begin
                    if(valid)  next_state = trans3;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans2;
                end
            end
            trans3: begin
                if(in[7:0] == 8'hD0) begin
                    if(valid)  next_state = trans4;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans3;
                end
            end
            trans4: begin
                if(in[7:0] == 8'hE0) begin
                    if(valid)  next_state = trans5;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans4;
                end
            end
            trans5: begin",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    
    // State transition logic (combinational)
    always @(*) begin
        state <= next_state;
    end
    
    // State flip-flops (sequential)
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    // Output logic
    assign done = (state == stop);
    
    // New: Datapath to store incoming bytes.
    reg [7:0] bytes[3:0];
    integer i;
    always @(posedge clk) begin
        if(reset) begin
            for(i=0; i<=3; i=i+1)
                bytes[i] <= 8'd0;
        end
        else begin
            bytes[0] <= in[7:0];
            bytes[1] <= bytes[0];
            bytes[2] <= bytes[1];
            bytes[3] <= bytes[2];
        end
    end
    assign out_bytes = {bytes[2], bytes[1], bytes[0]};
    
    // New: Add parity checking.
    reg [3:0] bytes_cnt;
    always @(posedge clk) begin
        if(reset)
            bytes_cnt <= 4'd0;
        else if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7)
            bytes_cnt <= bytes_cnt + 4'd1;
        else
            bytes_cnt <= bytes_cnt;
    end
    assign parity = ^bytes;
    assign valid = (bytes_cnt == 4'd7)? 1'b1 : 1'b0;
    
    // New: Add parity checking.
    always @(*) begin
        case (state)
            idle: begin
                if(~in[7] && valid)  next_state = start;
                else                next_state = idle;
            end
            start: begin
                if(in[7:0] == 8'hFA) begin
                    if(valid)  next_state = trans0;
                    else      next_state = error;
                end
                else begin
                    next_state = idle;
                end
            end
            trans0: begin
                if(in[7:0] == 8'hA0) begin
                    if(valid)  next_state = trans1;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans0;
                end
            end
            trans1: begin
                if(in[7:0] == 8'hB0) begin
                    if(valid)  next_state = trans2;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans1;
                end
            end
            trans2: begin
                if(in[7:0] == 8'hC0) begin
                    if(valid)  next_state = trans3;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans2;
                end
            end
            trans3: begin
                if(in[7:0] == 8'hD0) begin
                    if(valid)  next_state = trans4;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans3;
                end
            end
            trans4: begin
                if(in[7:0] == 8'hE0) begin
                    if(valid)  next_state = trans5;
                    else      next_state = idle;
                end
                else begin
                    next_state = trans4;
                end
            end
            trans5: begin","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_buffer;
    reg [3:0] n;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            trans0: begin
                if(in[1])
                    next_state = trans1;
                else
                    next_state = trans0;
            end
            trans1: begin
                if(in[2])
                    next_state = trans2;
                else
                    next_state = trans0;
            end
            trans2: begin
                if(in[3])
                    next_state = trans3;
                else
                    next_state = trans0;
            end
            trans3: begin
                if(in[4])
                    next_state = trans4;
                else
                    next_state = trans0;
            end
            trans4: begin
                if(in[5])
                    next_state = trans5;
                else
                    next_state = trans0;
            end
            trans5: begin
                if(in[6])
                    next_state = trans6;
                else
                    next_state = trans0;
            end
            trans6: begin
                if(in[7])
                    next_state = trans7;
                else
                    next_state = trans0;
            end
            trans7: begin
                if(in[8])
                    next_state = trans8;
                else
                    next_state = trans0;
            end
            trans8: begin
                if(in[9])
                    next_state = trans9;
                else
                    next_state = trans0;
            end
            trans9: begin
                if(in[10])
                    next_state = trans10;
                else
                    next_state = trans0;
            end
            trans10: begin
                if(in[11])
                    next_state = trans11;
                else
                    next_state = trans0;
            end
            trans11: begin
                if(in[12])
                    next_state = trans12;
                else
                    next_state = trans0;
            end
            trans12: begin
                if(in[13])
                    next_state = trans13;
                else
                    next_state = trans0;
            end
            trans13: begin
                if(in[14])
                    next_state = trans14;
                else
                    next_state = trans0;
            end
            trans14: begin
                if(in[15])
                    next_state = trans15;
                else
                    next_state = trans0;
            end
            trans15: begin
                if(in[16])
                    next_state = trans16;
                else
                    next_state = trans0;
            end
            trans16: begin
                if(in[17])
                    next_state = trans17;
                else
                    next_state = trans0;
            end
            trans17: begin
                if(in[18])
                    next_state = trans18;
                else
                    next_state = trans0;
            end
            trans18: begin
                if(in[19])
                    next_state = trans19;
                else
                    next_state = trans0;
            end
            trans19: begin
                if(in[20])
                    next_state = trans20;
                else
                    next_state = trans0;
            end",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_buffer;
    reg [3:0] n;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            trans0: begin
                if(in[1])
                    next_state = trans1;
                else
                    next_state = trans0;
            end
            trans1: begin
                if(in[2])
                    next_state = trans2;
                else
                    next_state = trans0;
            end
            trans2: begin
                if(in[3])
                    next_state = trans3;
                else
                    next_state = trans0;
            end
            trans3: begin
                if(in[4])
                    next_state = trans4;
                else
                    next_state = trans0;
            end
            trans4: begin
                if(in[5])
                    next_state = trans5;
                else
                    next_state = trans0;
            end
            trans5: begin
                if(in[6])
                    next_state = trans6;
                else
                    next_state = trans0;
            end
            trans6: begin
                if(in[7])
                    next_state = trans7;
                else
                    next_state = trans0;
            end
            trans7: begin
                if(in[8])
                    next_state = trans8;
                else
                    next_state = trans0;
            end
            trans8: begin
                if(in[9])
                    next_state = trans9;
                else
                    next_state = trans0;
            end
            trans9: begin
                if(in[10])
                    next_state = trans10;
                else
                    next_state = trans0;
            end
            trans10: begin
                if(in[11])
                    next_state = trans11;
                else
                    next_state = trans0;
            end
            trans11: begin
                if(in[12])
                    next_state = trans12;
                else
                    next_state = trans0;
            end
            trans12: begin
                if(in[13])
                    next_state = trans13;
                else
                    next_state = trans0;
            end
            trans13: begin
                if(in[14])
                    next_state = trans14;
                else
                    next_state = trans0;
            end
            trans14: begin
                if(in[15])
                    next_state = trans15;
                else
                    next_state = trans0;
            end
            trans15: begin
                if(in[16])
                    next_state = trans16;
                else
                    next_state = trans0;
            end
            trans16: begin
                if(in[17])
                    next_state = trans17;
                else
                    next_state = trans0;
            end
            trans17: begin
                if(in[18])
                    next_state = trans18;
                else
                    next_state = trans0;
            end
            trans18: begin
                if(in[19])
                    next_state = trans19;
                else
                    next_state = trans0;
            end
            trans19: begin
                if(in[20])
                    next_state = trans20;
                else
                    next_state = trans0;
            end","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11, pari=4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_parity;
    reg [3:0] count;
    reg [8:0] shift_reg;
    reg [8:0] next_shift_reg;
    reg [23:0] out_parity;
    reg [7:0] next_out;
    reg [7:0] temp;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(count==7)
                    next_state = trans0;
                else
                    next_state = start;
            trans0:
                if(count==7)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(count==7)
                    next_state = trans2;
                else
                    next_state = trans1;
            trans2:
                if(count==7)
                    next_state = trans3;
                else
                    next_state = trans2;
            trans3:
                if(count==7)
                    next_state = trans4;
                else
                    next_state = trans3;
            trans4:
                if(count==7)
                    next_state = trans5;
                else
                    next_state = trans4;
            trans5:
                if(count==7)
                    next_state = trans6;
                else
                    next_state = trans5;
            trans6:
                if(count==7)
                    next_state = trans7;
                else
                    next_state = trans6;
            trans7:
                if(count==7)
                    next_state = idle;
                else
                    next_state = trans7;
            error:
                if(count==7)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(count==7)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7)
            out_parity = out[23:16];
        else
            out_parity = 8'b11111111;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                shift_reg = 9'b000000000;
                out = 24'b11111111111111111111;
                count = 4'b0000;
                in_parity = in[7:0];
                out_parity = 8'b11111111;
                next_out = 8'b00000000;
                next_shift_reg = 9'b000000000;
            end
            start: begin
                shift_reg = 9'b000000000;
                out = 24'b11111111111111111111;
                count = 4'b0000;
                in_parity = in[7:0];
                out_parity = 8'b11111111;
                next_out = 8'b00000000;
                next_shift_reg = 9'b000000000;
            end
            trans0:
                if(count==4'd7)
                    next_shift_reg = {in[7:0],shift_reg[8:1]};
                else
                    next_shift_reg = shift_reg;
            trans1:
                if(count==",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle=4'd0, start=4'd1, trans0=4'd2, trans1=4'd3, trans2=4'd4, trans3=4'd5;
    parameter trans4=4'd6, trans5=4'd7, trans6=4'd8, trans7=4'd9, stop=4'd10, error=4'd11, pari=4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_parity;
    reg [3:0] count;
    reg [8:0] shift_reg;
    reg [8:0] next_shift_reg;
    reg [23:0] out_parity;
    reg [7:0] next_out;
    reg [7:0] temp;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(count==7)
                    next_state = trans0;
                else
                    next_state = start;
            trans0:
                if(count==7)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(count==7)
                    next_state = trans2;
                else
                    next_state = trans1;
            trans2:
                if(count==7)
                    next_state = trans3;
                else
                    next_state = trans2;
            trans3:
                if(count==7)
                    next_state = trans4;
                else
                    next_state = trans3;
            trans4:
                if(count==7)
                    next_state = trans5;
                else
                    next_state = trans4;
            trans5:
                if(count==7)
                    next_state = trans6;
                else
                    next_state = trans5;
            trans6:
                if(count==7)
                    next_state = trans7;
                else
                    next_state = trans6;
            trans7:
                if(count==7)
                    next_state = idle;
                else
                    next_state = trans7;
            error:
                if(count==7)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(count==7)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7)
            out_parity = out[23:16];
        else
            out_parity = 8'b11111111;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                shift_reg = 9'b000000000;
                out = 24'b11111111111111111111;
                count = 4'b0000;
                in_parity = in[7:0];
                out_parity = 8'b11111111;
                next_out = 8'b00000000;
                next_shift_reg = 9'b000000000;
            end
            start: begin
                shift_reg = 9'b000000000;
                out = 24'b11111111111111111111;
                count = 4'b0000;
                in_parity = in[7:0];
                out_parity = 8'b11111111;
                next_out = 8'b00000000;
                next_shift_reg = 9'b000000000;
            end
            trans0:
                if(count==4'd7)
                    next_shift_reg = {in[7:0],shift_reg[8:1]};
                else
                    next_shift_reg = shift_reg;
            trans1:
                if(count==","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_buffer;
    reg [2:0] n;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in[1])
                    next_state = trans1;
                else
                    next_state = idle;
            trans1:
                if(in[2])
                    next_state = trans2;
                else
                    next_state = idle;
            trans2:
                if(in[3])
                    next_state = trans3;
                else
                    next_state = idle;
            trans3:
                if(in[4])
                    next_state = trans4;
                else
                    next_state = idle;
            trans4:
                if(in[5])
                    next_state = trans5;
                else
                    next_state = idle;
            trans5:
                if(in[6])
                    next_state = trans6;
                else
                    next_state = idle;
            trans6:
                if(in[7])
                    next_state = trans7;
                else
                    next_state = idle;
            trans7:
                if(in[8])
                    next_state = trans0;
                else
                    next_state = idle;
            error:
                if(in[0])
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(~in[0])
                    next_state = idle;
                else
                    next_state = pari;
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b000;
        end
        else if(state == trans0) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b001;
        end
        else if(state == trans1) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b010;
        end
        else if(state == trans2) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b011;
        end
        else if(state == trans3) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b100;
        end
        else if(state == trans4) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b101;
        end
        else if(state == trans5) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b110;
        end
        else if(state == trans6) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b111;
        end
        else if(state == trans7) begin
            if(n == 3'b111",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_buffer;
    reg [2:0] n;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in[1])
                    next_state = trans1;
                else
                    next_state = idle;
            trans1:
                if(in[2])
                    next_state = trans2;
                else
                    next_state = idle;
            trans2:
                if(in[3])
                    next_state = trans3;
                else
                    next_state = idle;
            trans3:
                if(in[4])
                    next_state = trans4;
                else
                    next_state = idle;
            trans4:
                if(in[5])
                    next_state = trans5;
                else
                    next_state = idle;
            trans5:
                if(in[6])
                    next_state = trans6;
                else
                    next_state = idle;
            trans6:
                if(in[7])
                    next_state = trans7;
                else
                    next_state = idle;
            trans7:
                if(in[8])
                    next_state = trans0;
                else
                    next_state = idle;
            error:
                if(in[0])
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(~in[0])
                    next_state = idle;
                else
                    next_state = pari;
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b000;
        end
        else if(state == trans0) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b001;
        end
        else if(state == trans1) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b010;
        end
        else if(state == trans2) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b011;
        end
        else if(state == trans3) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b100;
        end
        else if(state == trans4) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b101;
        end
        else if(state == trans5) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b110;
        end
        else if(state == trans6) begin
            in_buffer <= {in[7:0], in[7:0]};
            n <= 3'b111;
        end
        else if(state == trans7) begin
            if(n == 3'b111","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101;
    parameter trans4 = 3'b110, trans5 = 3'b111, trans6 = 3'b000, trans7 = 3'b001;
    reg [2:0] state, next_state;
    reg [7:0] reg_data, out_byte;
    reg [2:0] reg_counter;
    reg out_data;

    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end

    always @(*) begin
        done = 0;
        next_state = state;
        out_byte = 8'b00000000;
        case (state)
            idle: begin
                if(in[0])
                    next_state = start;
            end
            start: begin
                if(in[0])
                    next_state = trans0;
                else if(in[1])
                    next_state = trans1;
                else if(in[2])
                    next_state = trans2;
                else if(in[3])
                    next_state = trans3;
                else if(in[4])
                    next_state = trans4;
                else if(in[5])
                    next_state = trans5;
                else if(in[6])
                    next_state = trans6;
                else if(in[7])
                    next_state = trans7;
                else
                    next_state = idle;
            end
            trans0: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans0;
            end
            trans1: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans1;
            end
            trans2: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans2;
            end
            trans3: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans3;
            end
            trans4: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans4;
            end
            trans5: begin
                out_byte[0] = in[0",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101;
    parameter trans4 = 3'b110, trans5 = 3'b111, trans6 = 3'b000, trans7 = 3'b001;
    reg [2:0] state, next_state;
    reg [7:0] reg_data, out_byte;
    reg [2:0] reg_counter;
    reg out_data;

    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end

    always @(*) begin
        done = 0;
        next_state = state;
        out_byte = 8'b00000000;
        case (state)
            idle: begin
                if(in[0])
                    next_state = start;
            end
            start: begin
                if(in[0])
                    next_state = trans0;
                else if(in[1])
                    next_state = trans1;
                else if(in[2])
                    next_state = trans2;
                else if(in[3])
                    next_state = trans3;
                else if(in[4])
                    next_state = trans4;
                else if(in[5])
                    next_state = trans5;
                else if(in[6])
                    next_state = trans6;
                else if(in[7])
                    next_state = trans7;
                else
                    next_state = idle;
            end
            trans0: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans0;
            end
            trans1: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans1;
            end
            trans2: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans2;
            end
            trans3: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans3;
            end
            trans4: begin
                out_byte[0] = in[0];
                out_byte[1] = in[1];
                out_byte[2] = in[2];
                out_byte[3] = in[3];
                out_byte[4] = in[4];
                out_byte[5] = in[5];
                out_byte[6] = in[6];
                out_byte[7] = in[7];
                next_state = trans4;
            end
            trans5: begin
                out_byte[0] = in[0","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [7:0] b0, b1, b2, b3;
    reg [23:0] out_bytes;
    reg done;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        done = 0;
        next_state = state;
        case (state)
            idle: begin
                if(in[7] == 1)
                    next_state = start;
            end
            start: begin
                if(in[7:0] == 8'hf0)
                    next_state = trans0;
            end
            trans0: begin
                if(in[7:0] == 8'hc0 || in[7:0] == 8'hf0)
                    next_state = trans1;
            end
            trans1: begin
                if(in[7:0] == 8'h44 || in[7:0] == 8'hf0)
                    next_state = trans2;
            end
            trans2: begin
                if(in[7:0] == 8'h4d || in[7:0] == 8'hf0)
                    next_state = trans3;
            end
            trans3: begin
                if(in[7:0] == 8'h69 || in[7:0] == 8'hf0)
                    next_state = trans4;
            end
            trans4: begin
                if(in[7:0] == 8'h74 || in[7:0] == 8'hf0)
                    next_state = trans5;
            end
            trans5: begin
                if(in[7:0] == 8'h65 || in[7:0] == 8'hf0)
                    next_state = trans6;
            end
            trans6: begin
                if(in[7:0] == 8'h6e || in[7:0] == 8'hf0)
                    next_state = trans7;
            end
            trans7: begin
                if(in[7:0] == 8'h65 || in[7:0] == 8'hf0)
                    next_state = stop;
            end
            stop: begin
                if(in[7:0] == 8'hf0)
                    next_state = idle;
            end
            error: begin
                if(in[7:0] == 8'hf0)
                    next_state = idle;
            end
            pari: begin
                if(in[7:0] == 8'hf0)
                    next_state = idle;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7) begin
            b3 <= in[7:0];
            b2 <= b3;
            b1 <= b2;
            b0 <= b1;
        end
        if(state == start) begin
            b3 <= in[7:0];
            b2 <= b3;
            b1 <= b2;
            b0 <= b1;
        end
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7) begin
            b2 <= b1;
            b1 <= b0;
            b0 <= in[7:0];
        end
        if(state == start) begin
            b2 <= b1;
            b1 <= b0;
            b0 <= in[7:0];
        end
        if(state == trans",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [7:0] b0, b1, b2, b3;
    reg [23:0] out_bytes;
    reg done;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        done = 0;
        next_state = state;
        case (state)
            idle: begin
                if(in[7] == 1)
                    next_state = start;
            end
            start: begin
                if(in[7:0] == 8'hf0)
                    next_state = trans0;
            end
            trans0: begin
                if(in[7:0] == 8'hc0 || in[7:0] == 8'hf0)
                    next_state = trans1;
            end
            trans1: begin
                if(in[7:0] == 8'h44 || in[7:0] == 8'hf0)
                    next_state = trans2;
            end
            trans2: begin
                if(in[7:0] == 8'h4d || in[7:0] == 8'hf0)
                    next_state = trans3;
            end
            trans3: begin
                if(in[7:0] == 8'h69 || in[7:0] == 8'hf0)
                    next_state = trans4;
            end
            trans4: begin
                if(in[7:0] == 8'h74 || in[7:0] == 8'hf0)
                    next_state = trans5;
            end
            trans5: begin
                if(in[7:0] == 8'h65 || in[7:0] == 8'hf0)
                    next_state = trans6;
            end
            trans6: begin
                if(in[7:0] == 8'h6e || in[7:0] == 8'hf0)
                    next_state = trans7;
            end
            trans7: begin
                if(in[7:0] == 8'h65 || in[7:0] == 8'hf0)
                    next_state = stop;
            end
            stop: begin
                if(in[7:0] == 8'hf0)
                    next_state = idle;
            end
            error: begin
                if(in[7:0] == 8'hf0)
                    next_state = idle;
            end
            pari: begin
                if(in[7:0] == 8'hf0)
                    next_state = idle;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7) begin
            b3 <= in[7:0];
            b2 <= b3;
            b1 <= b2;
            b0 <= b1;
        end
        if(state == start) begin
            b3 <= in[7:0];
            b2 <= b3;
            b1 <= b2;
            b0 <= b1;
        end
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5 || state == trans6 || state == trans7) begin
            b2 <= b1;
            b1 <= b0;
            b0 <= in[7:0];
        end
        if(state == start) begin
            b2 <= b1;
            b1 <= b0;
            b0 <= in[7:0];
        end
        if(state == trans","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_pari;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in[1])
                    next_state = trans1;
                else
                    next_state = idle;
            trans1:
                if(in[2])
                    next_state = trans2;
                else
                    next_state = idle;
            trans2:
                if(in[3])
                    next_state = trans3;
                else
                    next_state = idle;
            trans3:
                if(in[4])
                    next_state = trans4;
                else
                    next_state = idle;
            trans4:
                if(in[5])
                    next_state = trans5;
                else
                    next_state = idle;
            trans5:
                if(in[6])
                    next_state = trans6;
                else
                    next_state = idle;
            trans6:
                if(in[7])
                    next_state = trans7;
                else
                    next_state = idle;
            trans7:
                if(in[0])
                    next_state = stop;
                else
                    next_state = idle;
            stop: begin
                if(in[1])
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in[2])
                    next_state = idle;
                else
                    next_state = pari;
            end
            pari: begin
                if(in[0])
                    next_state = idle;
                else
                    next_state = pari;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            out <= 0;
        end
        else begin
            state <= next_state;
            case (next_state)
                start: begin
                    out_bytes <= 0;
                    out <= 0;
                    in_pari <= 0;
                end
                trans0: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans1: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans2: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans3: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans4: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans5: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans6: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans7: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                stop: begin
                    out_bytes[23:16] <=",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_pari;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            trans0:
                if(in[1])
                    next_state = trans1;
                else
                    next_state = idle;
            trans1:
                if(in[2])
                    next_state = trans2;
                else
                    next_state = idle;
            trans2:
                if(in[3])
                    next_state = trans3;
                else
                    next_state = idle;
            trans3:
                if(in[4])
                    next_state = trans4;
                else
                    next_state = idle;
            trans4:
                if(in[5])
                    next_state = trans5;
                else
                    next_state = idle;
            trans5:
                if(in[6])
                    next_state = trans6;
                else
                    next_state = idle;
            trans6:
                if(in[7])
                    next_state = trans7;
                else
                    next_state = idle;
            trans7:
                if(in[0])
                    next_state = stop;
                else
                    next_state = idle;
            stop: begin
                if(in[1])
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in[2])
                    next_state = idle;
                else
                    next_state = pari;
            end
            pari: begin
                if(in[0])
                    next_state = idle;
                else
                    next_state = pari;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= idle;
            out <= 0;
        end
        else begin
            state <= next_state;
            case (next_state)
                start: begin
                    out_bytes <= 0;
                    out <= 0;
                    in_pari <= 0;
                end
                trans0: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans1: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans2: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans3: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans4: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans5: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans6: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                trans7: begin
                    out_bytes[23:16] <= 0;
                    out_bytes[15:8] <= in;
                    out <= 0;
                end
                stop: begin
                    out_bytes[23:16] <=","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101, trans4 = 3'b110, trans5 = 3'b111, stop = 3'b110;
    reg [2:0] state, next_state;
    reg [23:0] out_bytes_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        done_reg = 0;
        case (state)
            idle: begin
                if(~in[7])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: begin
                if(in[7])
                    next_state = trans0;
                else
                    next_state = idle;
            end
            trans0: begin
                if(in[15])
                    next_state = trans1;
                else
                    next_state = trans0;
            end
            trans1: begin
                if(in[23])
                    next_state = trans2;
                else
                    next_state = trans1;
            end
            trans2: begin
                if(in[31])
                    next_state = trans3;
                else
                    next_state = trans2;
            end
            trans3: begin
                if(in[39])
                    next_state = trans4;
                else
                    next_state = trans3;
            end
            trans4: begin
                if(in[47])
                    next_state = trans5;
                else
                    next_state = trans4;
            end
            trans5: begin
                if(in[55])
                    next_state = stop;
                else
                    next_state = trans5;
            end
            stop: begin
                if(in[7])
                    next_state = start;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5)
            out_bytes_reg <= {in[23:16], in[15:8], in[7:0]};
        else
            out_bytes_reg <= 24'b0;
    end
    
    assign done = done_reg;
    assign out_bytes = done?out_bytes_reg:24'b0;
    
endmodule",-0.5,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101, trans4 = 3'b110, trans5 = 3'b111, stop = 3'b110;
    reg [2:0] state, next_state;
    reg [23:0] out_bytes_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        done_reg = 0;
        case (state)
            idle: begin
                if(~in[7])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: begin
                if(in[7])
                    next_state = trans0;
                else
                    next_state = idle;
            end
            trans0: begin
                if(in[15])
                    next_state = trans1;
                else
                    next_state = trans0;
            end
            trans1: begin
                if(in[23])
                    next_state = trans2;
                else
                    next_state = trans1;
            end
            trans2: begin
                if(in[31])
                    next_state = trans3;
                else
                    next_state = trans2;
            end
            trans3: begin
                if(in[39])
                    next_state = trans4;
                else
                    next_state = trans3;
            end
            trans4: begin
                if(in[47])
                    next_state = trans5;
                else
                    next_state = trans4;
            end
            trans5: begin
                if(in[55])
                    next_state = stop;
                else
                    next_state = trans5;
            end
            stop: begin
                if(in[7])
                    next_state = start;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3 || state == trans4 || state == trans5)
            out_bytes_reg <= {in[23:16], in[15:8], in[7:0]};
        else
            out_bytes_reg <= 24'b0;
    end
    
    assign done = done_reg;
    assign out_bytes = done?out_bytes_reg:24'b0;
    
endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 0, start = 1, trans0 = 2, trans1 = 3, trans2 = 4, trans3 = 5;
    reg [3:0] state, next_state;
    reg [7:0] b0, b1, b2, b3;
    reg [23:0] out_bytes;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        done = 0;
        next_state = state;
        case (state)
            idle: begin
                if(in[0])
                    next_state = start;
            end
            start: begin
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            end
            trans0: begin
                if(in[0])
                    next_state = trans1;
                else
                    next_state = idle;
            end
            trans1: begin
                if(in[0])
                    next_state = trans2;
                else
                    next_state = idle;
            end
            trans2: begin
                if(in[0])
                    next_state = trans3;
                else
                    next_state = idle;
            end
            trans3: begin
                if(in[0])
                    next_state = idle;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            b0 <= in[7:4];
            b1 <= in[3:0];
        end
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            b2 <= in[7:4];
            b3 <= in[3:0];
        end
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            out_bytes[23:16] <= b0;
            out_bytes[15:8] <= b1;
            out_bytes[7:0] <= b2;
            out_bytes[31:24] <= b3;
        end
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            done <= 1;
        end
        else begin
            done <= 0;
        end
    end

endmodule",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 0, start = 1, trans0 = 2, trans1 = 3, trans2 = 4, trans3 = 5;
    reg [3:0] state, next_state;
    reg [7:0] b0, b1, b2, b3;
    reg [23:0] out_bytes;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        done = 0;
        next_state = state;
        case (state)
            idle: begin
                if(in[0])
                    next_state = start;
            end
            start: begin
                if(in[0])
                    next_state = trans0;
                else
                    next_state = idle;
            end
            trans0: begin
                if(in[0])
                    next_state = trans1;
                else
                    next_state = idle;
            end
            trans1: begin
                if(in[0])
                    next_state = trans2;
                else
                    next_state = idle;
            end
            trans2: begin
                if(in[0])
                    next_state = trans3;
                else
                    next_state = idle;
            end
            trans3: begin
                if(in[0])
                    next_state = idle;
                else
                    next_state = idle;
            end
            default: next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            b0 <= in[7:4];
            b1 <= in[3:0];
        end
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            b2 <= in[7:4];
            b3 <= in[3:0];
        end
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            out_bytes[23:16] <= b0;
            out_bytes[15:8] <= b1;
            out_bytes[7:0] <= b2;
            out_bytes[31:24] <= b3;
        end
    end
    
    always @(posedge clk) begin
        if(state == trans0 || state == trans1 || state == trans2 || state == trans3) begin
            done <= 1;
        end
        else begin
            done <= 0;
        end
    end

endmodule","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_parity;
    reg [3:0] count;
    reg [8:0] shift_reg;
    reg out_enable;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(count==7)
                    next_state = trans0;
                else
                    next_state = start;
            trans0:
                if(count==7)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(count==7)
                    next_state = trans2;
                else
                    next_state = trans1;
            trans2:
                if(count==7)
                    next_state = trans3;
                else
                    next_state = trans2;
            trans3:
                if(count==7)
                    next_state = trans4;
                else
                    next_state = trans3;
            trans4:
                if(count==7)
                    next_state = trans5;
                else
                    next_state = trans4;
            trans5:
                if(count==7)
                    next_state = trans6;
                else
                    next_state = trans5;
            trans6:
                if(count==7)
                    next_state = trans7;
                else
                    next_state = trans6;
            trans7:
                if(count==7)
                    next_state = idle;
                else
                    next_state = trans7;
            error:
                if(count==7)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(count==7)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7)
            out_enable = 1'b1;
        else
            out_enable = 1'b0;
    end
    
    always @(posedge clk) begin
        if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7)
            out_bytes[count-1:0] = shift_reg[23:16];
        else
            out_bytes[count-1:0] = 8'd0;
    end
    
    always @(posedge clk) begin
        if(state==start) begin
            shift_reg[0] = in[0];
            shift_reg[1] = in[1];
            shift_reg[2] = in[2];
            shift_reg[3] = in[3];
            shift_reg[4] = in[4];
            shift_reg[5] = in[5];
            shift_reg[6] = in[6];
            shift_reg[7] = in[7];
            shift_reg[8] = 1'b0;
            count = 4'd0;
        end
        else if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7) begin
            shift_reg[8] = shift_reg[7];",-1,Fsm_ps2data.v,"// The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has bit[3]=1 (but bit[3] of the other two bytes may be 1 or 0 depending on data).

// We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with bit[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done).


//Now that you have a state machine that will identify three-byte messages in a PS/2 byte stream, add a datapath that will also output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.).

// out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care).


// Hint: Use the FSM from PS/2 packet parser and add a datapath to capture the incoming bytes.
    
// FSM from fsm_ps2
// New: Datapath to store incoming bytes.

module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done);

    parameter idle = 4'd0, start = 4'd1, trans0 = 4'd2, trans1 = 4'd3, trans2 = 4'd4, trans3 = 4'd5;
    parameter trans4 = 4'd6, trans5 = 4'd7, trans6 = 4'd8, trans7 = 4'd9, stop = 4'd10, error = 4'd11, pari = 4'd12;
    reg [3:0] state, next_state;
    reg [23:0] out;
    reg [7:0] in_parity;
    reg [3:0] count;
    reg [8:0] shift_reg;
    reg out_enable;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in[0])
                    next_state = start;
                else
                    next_state = idle;
            end
            start: 
                if(count==7)
                    next_state = trans0;
                else
                    next_state = start;
            trans0:
                if(count==7)
                    next_state = trans1;
                else
                    next_state = trans0;
            trans1:
                if(count==7)
                    next_state = trans2;
                else
                    next_state = trans1;
            trans2:
                if(count==7)
                    next_state = trans3;
                else
                    next_state = trans2;
            trans3:
                if(count==7)
                    next_state = trans4;
                else
                    next_state = trans3;
            trans4:
                if(count==7)
                    next_state = trans5;
                else
                    next_state = trans4;
            trans5:
                if(count==7)
                    next_state = trans6;
                else
                    next_state = trans5;
            trans6:
                if(count==7)
                    next_state = trans7;
                else
                    next_state = trans6;
            trans7:
                if(count==7)
                    next_state = idle;
                else
                    next_state = trans7;
            error:
                if(count==7)
                    next_state = idle;
                else
                    next_state = error;
            pari:
                if(count==7)
                    next_state = idle;
                else
                    next_state = pari;
        endcase
    end
    
    always @(posedge clk) begin
        if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7)
            out_enable = 1'b1;
        else
            out_enable = 1'b0;
    end
    
    always @(posedge clk) begin
        if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7)
            out_bytes[count-1:0] = shift_reg[23:16];
        else
            out_bytes[count-1:0] = 8'd0;
    end
    
    always @(posedge clk) begin
        if(state==start) begin
            shift_reg[0] = in[0];
            shift_reg[1] = in[1];
            shift_reg[2] = in[2];
            shift_reg[3] = in[3];
            shift_reg[4] = in[4];
            shift_reg[5] = in[5];
            shift_reg[6] = in[6];
            shift_reg[7] = in[7];
            shift_reg[8] = 1'b0;
            count = 4'd0;
        end
        else if(state==trans0 || state==trans1 || state==trans2 || state==trans3 || state==trans4 || state==trans5 || state==trans6 || state==trans7) begin
            shift_reg[8] = shift_reg[7];","module top_module(
    input clk,
    input [7:0] in,
    input reset,    // Synchronous reset
    output [23:0] out_bytes,
    output done); //

    // FSM from fsm_ps2
    parameter b1 = 1, b2 = 2, b3 = 3, dn = 4;
    reg [2:0] state, next_state;
    reg [23:0] data;

    always @(*) begin
        case ({state, in[3]})
            {b1, 1'b0}: next_state = b1;
            {b1, 1'b1}: next_state = b2;
            {b2, 1'b0}: next_state = b3;
            {b2, 1'b1}: next_state = b3;
            {b3, 1'b0}: next_state = dn;
            {b3, 1'b1}: next_state = dn;
            {dn, 1'b0}: next_state = b1;
            {dn, 1'b1}: next_state = b2;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= b1;
        end
        else begin
            state <= next_state;
        end
    end

    assign done = (state == dn);

    // New: Datapath to store incoming bytes.
    always @(posedge clk) begin
        if (reset) begin
            data <= 24'd0;
        end
        else begin
            data[23:16] <= data[15:8];
            data[15:8] <= data[7:0];
            data[7:0]  <= in;
        end
    end

    assign out_bytes = (done) ? data : 24'd0;

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case(state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 20)
                    next_state = DELAY;
                else
                    next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case(state)
            START: out = 0;
            DATA: out = count < 9;
            STOP: out = count < 20;
            DELAY: out = 0;
        endcase
    end
    
    assign done = out;
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case(state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 9)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                if(count < 20)
                    next_state = DELAY;
                else
                    next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(*) begin
        case(state)
            START: out = 0;
            DATA: out = count < 9;
            STOP: out = count < 20;
            DELAY: out = 0;
        endcase
    end
    
    assign done = out;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203, trans",-1,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203, trans","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203",-1,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203, trans",-1,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203, trans","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*)
        case(state)
            S0: begin
                if(in)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(in)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(in)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(in)
                    next_state <= S4;
                else
                    next_state <= S0;
            end
            S4: begin
                if(in)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state <= S0;
    	else
            state <= next_state;
    
    // Output logic
    assign done = (state == S4);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    reg [2:0] state, next_state;
    
    // State transition logic
    always @(*)
        case(state)
            S0: begin
                if(in)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            S1: begin
                if(in)
                    next_state <= S2;
                else
                    next_state <= S0;
            end
            S2: begin
                if(in)
                    next_state <= S3;
                else
                    next_state <= S0;
            end
            S3: begin
                if(in)
                    next_state <= S4;
                else
                    next_state <= S0;
            end
            S4: begin
                if(in)
                    next_state <= S1;
                else
                    next_state <= S0;
            end
            default: next_state <= S0;
        endcase
    
    // State flip-flops with asynchronous reset
    always @(posedge clk)
        if(reset)
            state <= S0;
    	else
            state <= next_state;
    
    // Output logic
    assign done = (state == S4);
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= 1'b0;
    end
    
    assign done = (state == DELAY)? 1:0;
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                if(in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count < 8)
                    next_state = DATA;
                else
                    next_state = STOP;
            end
            STOP: begin
                if(in)
                    next_state = START;
                else
                    next_state = DELAY;
            end
            DELAY: begin
                next_state = START;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            count <= count + 1;
        else
            count <= 0;
    end
    
    always @(posedge clk) begin
        if(state == DATA)
            out <= in;
        else
            out <= 1'b0;
    end
    
    assign done = (state == DELAY)? 1:0;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter START = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] count;
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(next_state == DATA)
            data <= {data[6:0], in};
        else if(next_state == STOP)
            data <= {data[6:0], 1'b0};
    end
    
    always @(posedge clk) begin
        if(state == DATA && next_state == DELAY)
            count <= 4;
        else if(state == DELAY && next_state == START)
            count <= 4;
        else if(state == START && next_state == START)
            count <= 0;
        else if(state == START && next_state == DATA)
            count <= 1;
        else if(state == DATA && next_state == STOP)
            count <= 0;
        else if(state == STOP && next_state == START)
            count <= 1;
        else if(state == STOP && next_state == DATA)
            count <= 2;
        else if(state == STOP && next_state == DELAY)
            count <= 3;
        else if(state == DELAY && next_state == STOP)
            count <= 3;
    end
    
    assign done = (state == DELAY && next_state == START);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter START = 3'd0, DATA = 3'd1, STOP = 3'd2, DELAY = 3'd3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] count;
    
    always @(*) begin
        case (state)
            START: begin
                if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            DATA: begin
                if(count == 8)
                    next_state = STOP;
                else if(~in)
                    next_state = DATA;
                else
                    next_state = START;
            end
            STOP: begin
                if(in)
                    next_state = DELAY;
                else
                    next_state = START;
            end
            DELAY: begin
                if(count == 4)
                    next_state = START;
                else
                    next_state = DELAY;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
    always @(posedge clk) begin
        if(next_state == DATA)
            data <= {data[6:0], in};
        else if(next_state == STOP)
            data <= {data[6:0], 1'b0};
    end
    
    always @(posedge clk) begin
        if(state == DATA && next_state == DELAY)
            count <= 4;
        else if(state == DELAY && next_state == START)
            count <= 4;
        else if(state == START && next_state == START)
            count <= 0;
        else if(state == START && next_state == DATA)
            count <= 1;
        else if(state == DATA && next_state == STOP)
            count <= 0;
        else if(state == STOP && next_state == START)
            count <= 1;
        else if(state == STOP && next_state == DATA)
            count <= 2;
        else if(state == STOP && next_state == DELAY)
            count <= 3;
        else if(state == DELAY && next_state == STOP)
            count <= 3;
    end
    
    assign done = (state == DELAY && next_state == START);
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203, trans",-1,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter idle=0, start=1, trans0=2, trans1=3, trans2=4, trans3=5, trans4=6, trans5=7, trans6=8, trans7=9, trans8=10, trans9=11, trans10=12, trans11=13, trans12=14, trans13=15, trans14=16, trans15=17, trans16=18, trans17=19, trans18=20, trans19=21, trans20=22, trans21=23, trans22=24, trans23=25, trans24=26, trans25=27, trans26=28, trans27=29, trans28=30, trans29=31, trans30=32, trans31=33, trans32=34, trans33=35, trans34=36, trans35=37, trans36=38, trans37=39, trans38=40, trans39=41, trans40=42, trans41=43, trans42=44, trans43=45, trans44=46, trans45=47, trans46=48, trans47=49, trans48=50, trans49=51, trans50=52, trans51=53, trans52=54, trans53=55, trans54=56, trans55=57, trans56=58, trans57=59, trans58=60, trans59=61, trans60=62, trans61=63, trans62=64, trans63=65, trans64=66, trans65=67, trans66=68, trans67=69, trans68=70, trans69=71, trans70=72, trans71=73, trans72=74, trans73=75, trans74=76, trans75=77, trans76=78, trans77=79, trans78=80, trans79=81, trans80=82, trans81=83, trans82=84, trans83=85, trans84=86, trans85=87, trans86=88, trans87=89, trans88=90, trans89=91, trans90=92, trans91=93, trans92=94, trans93=95, trans94=96, trans95=97, trans96=98, trans97=99, trans98=100, trans99=101, trans100=102, trans101=103, trans102=104, trans103=105, trans104=106, trans105=107, trans106=108, trans107=109, trans108=110, trans109=111, trans110=112, trans111=113, trans112=114, trans113=115, trans114=116, trans115=117, trans116=118, trans117=119, trans118=120, trans119=121, trans120=122, trans121=123, trans122=124, trans123=125, trans124=126, trans125=127, trans126=128, trans127=129, trans128=130, trans129=131, trans130=132, trans131=133, trans132=134, trans133=135, trans134=136, trans135=137, trans136=138, trans137=139, trans138=140, trans139=141, trans140=142, trans141=143, trans142=144, trans143=145, trans144=146, trans145=147, trans146=148, trans147=149, trans148=150, trans149=151, trans150=152, trans151=153, trans152=154, trans153=155, trans154=156, trans155=157, trans156=158, trans157=159, trans158=160, trans159=161, trans160=162, trans161=163, trans162=164, trans163=165, trans164=166, trans165=167, trans166=168, trans167=169, trans168=170, trans169=171, trans170=172, trans171=173, trans172=174, trans173=175, trans174=176, trans175=177, trans176=178, trans177=179, trans178=180, trans179=181, trans180=182, trans181=183, trans182=184, trans183=185, trans184=186, trans185=187, trans186=188, trans187=189, trans188=190, trans189=191, trans190=192, trans191=193, trans192=194, trans193=195, trans194=196, trans195=197, trans196=198, trans197=199, trans198=200, trans199=201, trans200=202, trans201=203, trans","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= S0;
        else
            begin
                case(state)
                    S0: begin
                        if(in)
                            next_state <= S1;
                        else
                            next_state <= S0;
                    end
                    
                    S1: begin
                        if(in)
                            next_state <= S1;
                        else
                            next_state <= S2;
                    end
                    
                    S2: begin
                        if(in)
                            next_state <= S3;
                        else
                            next_state <= S0;
                    end
                    
                    S3: begin
                        if(in)
                            next_state <= S4;
                        else
                            next_state <= S2;
                    end
                    
                    S4: begin
                        if(in)
                            next_state <= S1;
                        else
                            next_state <= S2;
                    end
                    
                    default: begin
                        next_state <= S0;
                    end
                endcase
            end
    end
    
    assign done = (state == S4);
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 
    
    parameter S0=0, S1=1, S2=2, S3=3, S4=4;
    reg [1:0] state, next_state;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset)
            next_state <= S0;
        else
            begin
                case(state)
                    S0: begin
                        if(in)
                            next_state <= S1;
                        else
                            next_state <= S0;
                    end
                    
                    S1: begin
                        if(in)
                            next_state <= S1;
                        else
                            next_state <= S2;
                    end
                    
                    S2: begin
                        if(in)
                            next_state <= S3;
                        else
                            next_state <= S0;
                    end
                    
                    S3: begin
                        if(in)
                            next_state <= S4;
                        else
                            next_state <= S2;
                    end
                    
                    S4: begin
                        if(in)
                            next_state <= S1;
                        else
                            next_state <= S2;
                    end
                    
                    default: begin
                        next_state <= S0;
                    end
                endcase
            end
    end
    
    assign done = (state == S4);
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                next_state <= in? START : DATA;
                out <= 0;
            end
            DATA: begin
                next_state <= in? DATA : (count < 8? DATA : STOP);
                count <= count + 1;
                out <= in;
            end
            STOP: begin
                next_state <= in? START : DELAY;
                out <= in;
            end
            DELAY: begin
                next_state <= in? DELAY : (done? START : DATA);
                out <= 0;
            end
        endcase
    end
    
    assign done = (state == DELAY) && (next_state == START);
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
endmodule",-0.5,Fsm_serial.v,"// In many (older) serial communications protocols, each data byte is sent along with a start bit and a stop bit, to help the receiver delimit bytes from the stream of bits. One common scheme is to use one start bit (0), 8 data bits, and 1 stop bit (1). The line is also at logic 1 when nothing is being transmitted (idle).

// Design a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
);","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;
    reg [1:0] state, next_state;
    reg [3:0] count;
    reg out;
    
    always @(*) begin
        case (state)
            START: begin
                next_state <= in? START : DATA;
                out <= 0;
            end
            DATA: begin
                next_state <= in? DATA : (count < 8? DATA : STOP);
                count <= count + 1;
                out <= in;
            end
            STOP: begin
                next_state <= in? START : DELAY;
                out <= in;
            end
            DELAY: begin
                next_state <= in? DELAY : (done? START : DATA);
                out <= 0;
            end
        endcase
    end
    
    assign done = (state == DELAY) && (next_state == START);
    
    always @(posedge clk) begin
        if(reset)
            state <= START;
        else
            state <= next_state;
    end
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output done
); 

    reg [3:0] i;
    parameter rc = 0, dn = 1, rd = 2, err = 3;
    reg [2:0] state, next_state;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                end
            end
            dn: next_state <= in ? rd : rc;
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if (state == err) begin
                i <= 0;
            end
            else if (state == dn) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            next_state <= state;
        end else begin
            if(state == 0) begin
                if(~in)
                    next_state <= 1;
                else
                    next_state <= 0;
            end else begin
                if(state == 1) begin
                    if(in) begin
                        next_state <= 2;
                    end else begin
                        next_state <= 0;
                    end
                end else if(state == 2) begin
                    if(~in) begin
                        next_state <= 3;
                    end else begin
                        next_state <= 0;
                    end
                end else begin
                    if(state == 3) begin
                        if(in) begin
                            next_state <= 4;
                        end else begin
                            next_state <= 0;
                        end
                    end else if(state == 4) begin
                        if(~in) begin
                            next_state <= 5;
                        end else begin
                            next_state <= 0;
                        end
                    end else begin
                        if(state == 5) begin
                            if(in) begin
                                next_state <= 6;
                            end else begin
                                next_state <= 0;
                            end
                        end else if(state == 6) begin
                            if(~in) begin
                                next_state <= 7;
                            end else begin
                                next_state <= 0;
                            end
                        end else begin
                            if(state == 7) begin
                                if(in) begin
                                    next_state <= 8;
                                end else begin
                                    next_state <= 0;
                                end
                            end else if(state == 8) begin
                                if(~in) begin
                                    next_state <= 9;
                                end else begin
                                    next_state <= 0;
                                end
                            end else begin
                                next_state <= 0;
                            end
                        end
                    end
                end
            end
        end
    end
    
    always @(posedge clk) begin
        if(state == 0) begin
            out_byte <= out;
        end else begin
            if(state == 1) begin
                out_bit <= out[7];
            end else if(state == 2) begin
                out_bit <= out[6];
            end else if(state == 3) begin
                out_bit <= out[5];
            end else if(state == 4) begin
                out_bit <= out[4];
            end else if(state == 5) begin
                out_bit <= out[3];
            end else if(state == 6) begin
                out_bit <= out[2];
            end else if(state == 7) begin
                out_bit <= out[1];
            end else if(state == 8) begin
                out_bit <= out[0];
            end else if(state == 9) begin
                out_byte <= {out[6:0], out_bit};
            end
        end
    end
    
    assign done = (state == 9)? 1 : 0;
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg out_bit;
    
    always @(*) begin
        state <= next_state;
    end
    
    always @(posedge clk) begin
        if(reset) begin
            out <= 0;
            out_bit <= 0;
            next_state <= state;
        end else begin
            if(state == 0) begin
                if(~in)
                    next_state <= 1;
                else
                    next_state <= 0;
            end else begin
                if(state == 1) begin
                    if(in) begin
                        next_state <= 2;
                    end else begin
                        next_state <= 0;
                    end
                end else if(state == 2) begin
                    if(~in) begin
                        next_state <= 3;
                    end else begin
                        next_state <= 0;
                    end
                end else begin
                    if(state == 3) begin
                        if(in) begin
                            next_state <= 4;
                        end else begin
                            next_state <= 0;
                        end
                    end else if(state == 4) begin
                        if(~in) begin
                            next_state <= 5;
                        end else begin
                            next_state <= 0;
                        end
                    end else begin
                        if(state == 5) begin
                            if(in) begin
                                next_state <= 6;
                            end else begin
                                next_state <= 0;
                            end
                        end else if(state == 6) begin
                            if(~in) begin
                                next_state <= 7;
                            end else begin
                                next_state <= 0;
                            end
                        end else begin
                            if(state == 7) begin
                                if(in) begin
                                    next_state <= 8;
                                end else begin
                                    next_state <= 0;
                                end
                            end else if(state == 8) begin
                                if(~in) begin
                                    next_state <= 9;
                                end else begin
                                    next_state <= 0;
                                end
                            end else begin
                                next_state <= 0;
                            end
                        end
                    end
                end
            end
        end
    end
    
    always @(posedge clk) begin
        if(state == 0) begin
            out_byte <= out;
        end else begin
            if(state == 1) begin
                out_bit <= out[7];
            end else if(state == 2) begin
                out_bit <= out[6];
            end else if(state == 3) begin
                out_bit <= out[5];
            end else if(state == 4) begin
                out_bit <= out[4];
            end else if(state == 5) begin
                out_bit <= out[3];
            end else if(state == 6) begin
                out_bit <= out[2];
            end else if(state == 7) begin
                out_bit <= out[1];
            end else if(state == 8) begin
                out_bit <= out[0];
            end else if(state == 9) begin
                out_byte <= {out[6:0], out_bit};
            end
        end
    end
    
    assign done = (state == 9)? 1 : 0;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b000;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
                else
                    next_state = 3'b000;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            done_reg <= (next_state == 3'b111)? 1'b1 : 1'b0;
            out <= 8'b0;
            case(state)
                3'b000: begin
                    out[7:0] <= 8'b0;
                end
                3'b001: begin
                    out[7:0] <= {1'b0, in};
                end
                3'b010: begin
                    out[7:0] <= {in, 1'b0};
                end
                3'b011: begin
                    out[7:0] <= {1'b0, in, 1'b0};
                end
                3'b100: begin
                    out[7:0] <= {in, 1'b0, 1'b0};
                end
                3'b101: begin
                    out[7:0] <= {1'b0, in, 1'b0, 1'b0};
                end
                3'b110: begin
                    out[7:0] <= {in, 1'b0, 1'b0, 1'b0};
                end
                3'b111: begin
                    out[7:0] <= in;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    reg done_reg;
    
    always @(*) begin
        case (state)
            3'b000: begin
                if(~in)
                    next_state = 3'b001;
                else
                    next_state = 3'b000;
            end
            3'b001: begin
                if(in)
                    next_state = 3'b010;
                else
                    next_state = 3'b000;
            end
            3'b010: begin
                if(in)
                    next_state = 3'b011;
                else
                    next_state = 3'b000;
            end
            3'b011: begin
                if(in)
                    next_state = 3'b100;
                else
                    next_state = 3'b000;
            end
            3'b100: begin
                if(in)
                    next_state = 3'b101;
                else
                    next_state = 3'b000;
            end
            3'b101: begin
                if(in)
                    next_state = 3'b110;
                else
                    next_state = 3'b000;
            end
            3'b110: begin
                if(in)
                    next_state = 3'b111;
                else
                    next_state = 3'b000;
            end
            3'b111: begin
                if(in)
                    next_state = 3'b000;
                else
                    next_state = 3'b000;
            end
            default: begin
                next_state = 3'b000;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(reset) begin
            state <= 3'b000;
            done_reg <= 1'b0;
        end
        else begin
            state <= next_state;
            done_reg <= (next_state == 3'b111)? 1'b1 : 1'b0;
            out <= 8'b0;
            case(state)
                3'b000: begin
                    out[7:0] <= 8'b0;
                end
                3'b001: begin
                    out[7:0] <= {1'b0, in};
                end
                3'b010: begin
                    out[7:0] <= {in, 1'b0};
                end
                3'b011: begin
                    out[7:0] <= {1'b0, in, 1'b0};
                end
                3'b100: begin
                    out[7:0] <= {in, 1'b0, 1'b0};
                end
                3'b101: begin
                    out[7:0] <= {1'b0, in, 1'b0, 1'b0};
                end
                3'b110: begin
                    out[7:0] <= {in, 1'b0, 1'b0, 1'b0};
                end
                3'b111: begin
                    out[7:0] <= in;
                end
            endcase
        end
    end
    
    assign done = done_reg;
    assign out_byte = out;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Datapath to latch input bits.
    
    reg [7:0] out_byte_reg;
    reg done_reg;
    
    always @(posedge clk) begin
        if(reset) begin
            out_byte_reg <= 0;
            done_reg <= 0;
        end
        else begin
            out_byte_reg <= out_byte;
            done_reg <= done;
        end
    end
    
    assign out_byte = out_byte_reg;
    assign done = done_reg;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            data <= {data[6:0], out};
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 7)
            out <= in;
    end
    
    assign done = (state == stop_bit)? 1:0;
    assign out_byte = data;
    
endmodule",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] data;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case(state)
            idle: begin
                if(~in)
                    next_state = rec_data;
                else
                    next_state = idle;
            end
            rec_data: begin
                if(counter == 7)
                    next_state = stop_bit;
                else
                    next_state = rec_data;
            end
            stop_bit: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
            error: begin
                if(in)
                    next_state = idle;
                else
                    next_state = error;
            end
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            data <= {data[6:0], out};
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 7)
            out <= in;
    end
    
    assign done = (state == stop_bit)? 1:0;
    assign out_byte = data;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101, trans4 = 3'b110, trans5 = 3'b111, stop = 3'b110;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state <= start;
                else
                    next_state <= idle;
                out <= 0;
            end
            start: begin
                if(in)
                    next_state <= trans0;
                else
                    next_state <= idle;
                out <= 0;
            end
            trans0: begin
                if(in)
                    next_state <= trans1;
                else
                    next_state <= idle;
                out <= {out[6:0], 1'b0};
            end
            trans1: begin
                if(in)
                    next_state <= trans2;
                else
                    next_state <= idle;
                out <= {out[5:0], 1'b0};
            end
            trans2: begin
                if(in)
                    next_state <= trans3;
                else
                    next_state <= idle;
                out <= {out[4:0], 1'b0};
            end
            trans3: begin
                if(in)
                    next_state <= trans4;
                else
                    next_state <= idle;
                out <= {out[3:0], 1'b0};
            end
            trans4: begin
                if(in)
                    next_state <= trans5;
                else
                    next_state <= idle;
                out <= {out[2:0], 1'b0};
            end
            trans5: begin
                if(in)
                    next_state <= stop;
                else
                    next_state <= idle;
                out <= {out[1:0], 1'b0};
            end
            stop: begin
                if(in)
                    next_state <= idle;
                else
                    next_state <= idle;
                out <= {out[0], 1'b0};
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    assign out_byte = out;
    
endmodule",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    // New: Latch input bits.
    
    reg [2:0] state, next_state;
    reg [7:0] out;
    
    parameter idle = 3'b000, start = 3'b001, trans0 = 3'b010, trans1 = 3'b011, trans2 = 3'b100, trans3 = 3'b101, trans4 = 3'b110, trans5 = 3'b111, stop = 3'b110;
    
    always @(*) begin
        case (state)
            idle: begin
                if(~in)
                    next_state <= start;
                else
                    next_state <= idle;
                out <= 0;
            end
            start: begin
                if(in)
                    next_state <= trans0;
                else
                    next_state <= idle;
                out <= 0;
            end
            trans0: begin
                if(in)
                    next_state <= trans1;
                else
                    next_state <= idle;
                out <= {out[6:0], 1'b0};
            end
            trans1: begin
                if(in)
                    next_state <= trans2;
                else
                    next_state <= idle;
                out <= {out[5:0], 1'b0};
            end
            trans2: begin
                if(in)
                    next_state <= trans3;
                else
                    next_state <= idle;
                out <= {out[4:0], 1'b0};
            end
            trans3: begin
                if(in)
                    next_state <= trans4;
                else
                    next_state <= idle;
                out <= {out[3:0], 1'b0};
            end
            trans4: begin
                if(in)
                    next_state <= trans5;
                else
                    next_state <= idle;
                out <= {out[2:0], 1'b0};
            end
            trans5: begin
                if(in)
                    next_state <= stop;
                else
                    next_state <= idle;
                out <= {out[1:0], 1'b0};
            end
            stop: begin
                if(in)
                    next_state <= idle;
                else
                    next_state <= idle;
                out <= {out[0], 1'b0};
            end
            default: next_state <= idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    assign done = (state == stop);
    assign out_byte = out;
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle:
                begin
                    if(~in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            rec_data:
                begin
                    if(counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = error;
                    else
                        next_state = idle;
                end
            error:
                begin
                    if(counter == 8)
                        next_state = idle;
                    else
                        next_state = error;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 7)
            out_byte <= rec_data_reg;
        else
            out_byte <= 8'b0;
    end
    
    always @(*) begin
        case (state)
            idle:
                out = 1'b0;
            rec_data:
                out = 1'b0;
            stop_bit:
                out = 1'b1;
            error:
                out = 1'b0;
        endcase
    end
    
    assign done = (state == stop_bit);
    
endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Modify FSM and datapath from Fsm_serial
    
    parameter idle = 0, rec_data = 1, stop_bit = 2, error = 3;
    reg [2:0] state, next_state;
    reg [7:0] rec_data_reg;
    reg [3:0] counter;
    reg out;
    
    always @(posedge clk) begin
        if(reset)
            state <= idle;
        else
            state <= next_state;
    end
    
    always @(*) begin
        case (state)
            idle:
                begin
                    if(~in)
                        next_state = idle;
                    else
                        next_state = rec_data;
                end
            rec_data:
                begin
                    if(counter == 7)
                        next_state = stop_bit;
                    else
                        next_state = rec_data;
                end
            stop_bit:
                begin
                    if(in)
                        next_state = error;
                    else
                        next_state = idle;
                end
            error:
                begin
                    if(counter == 8)
                        next_state = idle;
                    else
                        next_state = error;
                end
            default:
                next_state = idle;
        endcase
    end
    
    always @(posedge clk) begin
        if(state == rec_data)
            rec_data_reg <= {rec_data_reg[6:0], in};
    end
    
    always @(posedge clk) begin
        if(state == stop_bit)
            counter <= counter + 1;
        else
            counter <= 0;
    end
    
    always @(posedge clk) begin
        if(state == rec_data && counter == 7)
            out_byte <= rec_data_reg;
        else
            out_byte <= 8'b0;
    end
    
    always @(*) begin
        case (state)
            idle:
                out = 1'b0;
            rec_data:
                out = 1'b0;
            stop_bit:
                out = 1'b1;
            error:
                out = 1'b0;
        endcase
    end
    
    assign done = (state == stop_bit);
    
endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule",-0.5,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial

// New: Datapath to latch input bits.

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;

reg [1:0] state, next_state;
reg [3:0] counter;
reg out;

always @(posedge clk)
begin
    if(reset)
        state <= START;
    else
        state <= next_state;
end

always @(*)
begin
    case(state)
        START:
        begin
            if(in)
                next_state = DATA;
            else
                next_state = START;
        end
        DATA:
        begin
            if(counter == 8)
                next_state = STOP;
            else
                next_state = DATA;
        end
        STOP:
        begin
            if(in)
            begin
                next_state = DELAY;
                out = 1'b0;
            end
            else
                next_state = START;
        end
        DELAY:
        begin
            if(counter == 4)
                next_state = START;
            else
                next_state = DELAY;
        end
        default:
            next_state = START;
    endcase
end

always @(posedge clk)
begin
    if(state == DATA)
        counter <= counter + 4'h1;
    else
        counter <= 4'h0;
end

always @(posedge clk)
begin
    if(state == STOP)
    begin
        if(in)
            out = 1'b1;
        else
            out = 1'b0;
    end
end

assign done = (state == DELAY)? (counter == 4) : (state == STOP);

// New: Datapath to latch input bits.
always @(posedge clk)
begin
    if(state == DATA)
        out_byte[7:0] <= {out, out_byte[7:1]};
end

endmodule",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);

// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

// Define states
parameter START = 0, DATA = 1, STOP = 2, DELAY = 3;

reg [1:0] state, next_state;
reg [3:0] counter;
reg out;

always @(posedge clk)
begin
    if(reset)
        state <= START;
    else
        state <= next_state;
end

always @(*)
begin
    case(state)
        START:
        begin
            if(in)
                next_state = DATA;
            else
                next_state = START;
        end
        DATA:
        begin
            if(counter == 8)
                next_state = STOP;
            else
                next_state = DATA;
        end
        STOP:
        begin
            if(in)
            begin
                next_state = DELAY;
                out = 1'b0;
            end
            else
                next_state = START;
        end
        DELAY:
        begin
            if(counter == 4)
                next_state = START;
            else
                next_state = DELAY;
        end
        default:
            next_state = START;
    endcase
end

always @(posedge clk)
begin
    if(state == DATA)
        counter <= counter + 4'h1;
    else
        counter <= 4'h0;
end

always @(posedge clk)
begin
    if(state == STOP)
    begin
        if(in)
            out = 1'b1;
        else
            out = 1'b0;
    end
end

assign done = (state == DELAY)? (counter == 4) : (state == STOP);

// New: Datapath to latch input bits.
always @(posedge clk)
begin
    if(state == DATA)
        out_byte[7:0] <= {out, out_byte[7:1]};
end

endmodule","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    // New: Datapath to latch input bits.
    
    // New: Datapath to output byte.
    
    // New: Datapath to output done.
    
    // New: Define states.
    
    // New: Define outputs.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions",-1,Fsm_serialdata.v,"// Assume you have a finite state machine that will identify when bytes have been correctly received when given a stream of bits. It needs to identify the start bit, wait for all 8 data bits, then verify that the stop bit was correct. If the stop bit does not appear when expected, the FSM must wait until it finds a stop bit before attempting to receive the next byte.
// Now that you have a finite state machine that can identify when bytes are correctly received in a serial bitstream, add a datapath that will output the correctly-received data byte. out_byte needs to be valid when done is 1, and is don't-care otherwise.

// Note that the serial protocol sends the least significant bit first.

// Hint: The serial bitstream needs to be shifted in one bit at a time, then read out in parallel. 
// Use FSM from Fsm_serial
// New: Datapath to latch input bits.

module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
);
    
    // Use FSM from Fsm_serial
    
    // New: Latch input bits.
    
    // New: Datapath to latch input bits.
    
    // New: Datapath to output byte.
    
    // New: Datapath to output done.
    
    // New: Define states.
    
    // New: Define outputs.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions.
    
    // New: Define state transitions","module top_module(
    input clk,
    input in,
    input reset,    // Synchronous reset
    output [7:0] out_byte,
    output done
); //

    // Use FSM from Fsm_serial
    reg [3:0] i;
    parameter rc = 0, rd = 1, dn = 2, err = 3;
    reg [2:0] state, next_state;
    reg [7:0] date;

    always @(*) begin
        case (state)
            rd: next_state <= in ? rd : rc;
            rc: begin
                if ((i == 8) & in) begin
                    next_state <= dn;
                end
                else if ((i == 8) & (~in)) begin
                    next_state <= err;
                end
                else begin
                    next_state <= rc;
                    date[i] <= in;
                end
            end
            dn: begin
                next_state <= in ? rd : rc;
                out_byte <= date;
            end
            err: next_state <= in ? rd : err;
        endcase
    end

    always @(posedge clk) begin
        if (reset) begin
            state <= rd;
            i <= 0;
        end
        else begin
            if ((state == rc) && (i != 8)) begin
                i <= i + 1;
            end
            else if ((state == dn)) begin
                i <= 0;
            end
            else if (state == err) begin
                i <= 0;
            end
            state <= next_state;
        end
    end

    // New: Datapath to latch input bits.
    assign done = (state == dn);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset)
        if(areset)
            out <= 1'b0;
        else
            out <= in;
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset)
        if(areset)
            out <= 1'b0;
        else
            out <= in;
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out_ff;
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            out_ff <= 0;
        end
        else begin
            out_ff <= in_ff;
        end
    end
    assign out = out_ff;
    // State flip-flops with synchronous reset
    // Output logic
    // State transition logic
    // Synchronous reset
    // Asynchronous reset
    // Input logic
    // Asynchronous reset
    // Synchronous reset
    // Asynchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip",-1,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out_ff;
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            out_ff <= 0;
        end
        else begin
            out_ff <= in_ff;
        end
    end
    assign out = out_ff;
    // State flip-flops with synchronous reset
    // Output logic
    // State transition logic
    // Synchronous reset
    // Asynchronous reset
    // Input logic
    // Asynchronous reset
    // Synchronous reset
    // Asynchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip-flops with synchronous reset
    // State flip","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in})
                1'b0: out <= 1'b0;
                1'b1: out <= 1'b1;
            endcase
        end
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in})
                1'b0: out <= 1'b0;
                1'b1: out <= 1'b1;
            endcase
        end
    end
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk, posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in, out})
                2'b00: out <= 1'b0;
                2'b01: out <= 1'b0;
                2'b10: out <= 1'b0;
                2'b11: out <= 1'b1;
            endcase
        end
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk, posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in, out})
                2'b00: out <= 1'b0;
                2'b01: out <= 1'b0;
                2'b10: out <= 1'b0;
                2'b11: out <= 1'b1;
            endcase
        end
    end
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset)
        if(areset)
            out <= 0;
        else
            out <= in;
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset)
        if(areset)
            out <= 0;
        else
            out <= in;
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in})
                1'b0: out <= 1'b0;
                1'b1: out <= 1'b1;
            endcase
        end
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in})
                1'b0: out <= 1'b0;
                1'b1: out <= 1'b1;
            endcase
        end
    end
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    assign out = state_out;
    // State register
    reg state_reg, state_next;
    // State output logic
    always @(posedge clk, posedge areset)
        if(areset)
            state_reg <= 1'b0;
        else
            state_reg <= state_next;
    // Next state logic
    always @(*)
        case(state_reg)
            1'b0: state_next = 1'b1;
            1'b1: state_next = 1'b0;
            default: state_next = 1'b0;
        endcase
    // State flip-flops with synchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge reset)
    //     if(reset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with asynchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge areset)
    //     if(areset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with synchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge reset)
    //     if(reset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with asynchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge areset)
    //     if(areset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with synchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge reset)
    //     if(reset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;",-1,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    assign out = state_out;
    // State register
    reg state_reg, state_next;
    // State output logic
    always @(posedge clk, posedge areset)
        if(areset)
            state_reg <= 1'b0;
        else
            state_reg <= state_next;
    // Next state logic
    always @(*)
        case(state_reg)
            1'b0: state_next = 1'b1;
            1'b1: state_next = 1'b0;
            default: state_next = 1'b0;
        endcase
    // State flip-flops with synchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge reset)
    //     if(reset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with asynchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge areset)
    //     if(areset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with synchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge reset)
    //     if(reset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with asynchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge areset)
    //     if(areset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;
    //         1'b1: state_next = 1'b0;
    //         default: state_next = 1'b0;
    //     endcase
    // State flip-flops with synchronous reset
    // Output logic
    // assign out = state_out;
    // State register
    // reg state_reg, state_next;
    // State output logic
    // always @(posedge clk, posedge reset)
    //     if(reset)
    //         state_reg <= 1'b0;
    //     else
    //         state_reg <= state_next;
    // Next state logic
    // always @(*)
    //     case(state_reg)
    //         1'b0: state_next = 1'b1;","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            out <= 0;
        end
        else begin
            out <= in;
        end
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            out <= 0;
        end
        else begin
            out <= in;
        end
    end
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            out <= 1'b0;
        end
        else begin
            out <= in;
        end
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            out <= 1'b0;
        end
        else begin
            out <= in;
        end
    end
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in})
                1'b0: out <= 1'b0;
                1'b1: out <= 1'b1;
            endcase
        end
    end
endmodule",-0.5,Fsm3.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Implement this state machine. Include an asynchronous reset that resets the FSM to state A.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1


module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
","module top_module(
    input clk,
    input in,
    input areset,
    output out);
    // Insert your code below
    // State transition logic
    // State flip-flops with asynchronous reset
    // Output logic
    reg out;
    always @(posedge clk or posedge areset) begin
        if(areset)
            out <= 1'b0;
        else begin
            case({in})
                1'b0: out <= 1'b0;
                1'b1: out <= 1'b1;
            endcase
        end
    end
endmodule","module top_module(
    input clk,
    input in,
    input areset,
    output out); //
    
    reg [2:0] state, next_state;
    parameter A=1, B=2, C=3, D=4; 
    // State transition logic
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // State flip-flops with asynchronous reset
    always @(posedge clk or posedge areset) begin
        if(areset) begin
            state <= A;
        end else begin
            state <= next_state;
        end
    end

    // Output logic
    assign out = (state == D);
endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (~in) | state[D] & (in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (~in) | state[D] & (in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10)? 1'b1 : 1'b0;

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10)? 1'b1 : 1'b0;

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always@(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b00) || (state == 2'b11);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always@(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b00) || (state == 2'b11);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10)? 1'b1 : 1'b0;

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10)? 1'b1 : 1'b0;

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10) | (state == 2'b11);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10) | (state == 2'b11);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10)? 1'b1 : 1'b0;

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10)? 1'b1 : 1'b0;

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (~in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (~in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (~in) | state[D] & (in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (~in) | state[D] & (in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[B] & (in);
    assign next_state[B] = state[A] & (in) | state[C] & (~in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (in);
    assign next_state[D] = state[C] & (~in) | state[D] & (in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    assign next_state[A] = state[A] & (~in) | state[B] & (in);
    assign next_state[B] = state[A] & (in) | state[C] & (~in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (in);
    assign next_state[D] = state[C] & (~in) | state[D] & (in);

    // Output logic:  out = f(state) for a Moore state machine
    assign out = state[D] & (~in) | state[D] & (in);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10) | (state == 2'b11);

endmodule",-1,Fsm3comb.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following state encoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.

// Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. Given the current state (state), compute the next_state and output (out) based on the state transition table.

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// State transition logic: next_state = f(state, in)
// Output logic:  out = f(state) for a Moore state machine

module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;


    // State transition logic: next_state = f(state, in)
    always @(*)
        case(state)
            A: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= B;
            end
            B: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            C: begin
                if(in == 1'b0)
                    next_state <= A;
                else
                    next_state <= D;
            end
            D: begin
                if(in == 1'b0)
                    next_state <= C;
                else
                    next_state <= B;
            end
            default: next_state <= A;
        endcase

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == 2'b10) | (state == 2'b11);

endmodule","module top_module(
    input in,
    input [1:0] state,
    output [1:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: next_state = f(state, in)
    always @(*) begin
        case (state)
            A: next_state <= in ? B : A;
            B: next_state <= in ? B : C;
            C: next_state <= in ? D : A;
            D: next_state <= in ? B : C;
        endcase
    end

    // Output logic:  out = f(state) for a Moore state machine
    assign out = (state == D);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[B] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[C] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[B] & in | state[C] & in | state[D] & in;
    //assign next_state[D] = state[D] & in;
    assign out = state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[B] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[C] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[B] & in | state[C] & in | state[D] & in;
    //assign next_state[D] = state[D] & in;
    assign out = state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    assign next_state[A] = (state[A] & ~in) | (state[B] & ~in) | (state[C] & ~in) | (state[D] & ~in);
    assign next_state[B] = (state[A] & in) | (state[B] & in) | (state[C] & in) | (state[D] & in);
    assign next_state[C] = (state[A] & in) | (state[B] & in) | (state[C] & in) | (state[D] & in);
    assign next_state[D] = (state[A] & in) | (state[B] & in) | (state[C] & in) | (state[D] & in);
    assign out = (state[D] == 1);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    assign next_state[A] = (state[A] & ~in) | (state[B] & ~in) | (state[C] & ~in) | (state[D] & ~in);
    assign next_state[B] = (state[A] & in) | (state[B] & in) | (state[C] & in) | (state[D] & in);
    assign next_state[C] = (state[A] & in) | (state[B] & in) | (state[C] & in) | (state[D] & in);
    assign next_state[D] = (state[A] & in) | (state[B] & in) | (state[C] & in) | (state[D] & in);
    assign out = (state[D] == 1);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);
    //assign out = state[D];

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);
    //assign out = state[D];

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);
    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);
    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (~in);
    assign next_state[C] = state[B] & (in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in) | state[D] & (~in);

    // Output logic: 
    assign out = state[D] & (~in) | state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (~in);
    assign next_state[C] = state[B] & (in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in) | state[D] & (~in);

    // Output logic: 
    assign out = state[D] & (~in) | state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (~in);
    assign next_state[C] = state[B] & (in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in) | state[D] & (~in);

    // Output logic: 
    assign out = state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (~in);
    assign next_state[C] = state[B] & (in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in) | state[D] & (~in);

    // Output logic: 
    assign out = state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A]&(~in) | state[C]&(~in);
    assign next_state[B] = state[A]&(in) | state[B]&(in) | state[D]&(in);
    assign next_state[C] = state[B]&(~in) | state[D]&(~in);
    assign next_state[D] = state[C]&(in);

    // Output logic: 
    assign out = state[D]&(~in) | state[D]&(in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A]&(~in) | state[C]&(~in);
    assign next_state[B] = state[A]&(in) | state[B]&(in) | state[D]&(in);
    assign next_state[C] = state[B]&(~in) | state[D]&(~in);
    assign next_state[D] = state[C]&(in);

    // Output logic: 
    assign out = state[D]&(~in) | state[D]&(in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);
    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);
    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;
    
    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (~in);
    assign next_state[C] = state[B] & (in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in) | state[D] & (~in);
    
    // Output logic: 
    assign out = state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    //assign next_state[B] =...;
    //assign next_state[C] =...;
    //assign next_state[D] =...;
    
    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (~in);
    assign next_state[C] = state[B] & (in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in) | state[D] & (~in);
    
    // Output logic: 
    assign out = state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);
    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);

endmodule",-1,Fsm3onehot.v,"// The following is the state transition table for a Moore state machine with one input, one output, and four states. Use the following one-hot state encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000.

// Derive state transition and output logic equations by inspection assuming a one-hot encoding. Implement only the state transition logic and output logic (the combinational logic portion) for this state machine. (The testbench will test with non-one hot inputs to make sure you're not trying to do something more complicated).

//	 	 	  Next state

//	State					Output
//			in=0	in=1
//	A		A		B		0
//	B		C		B		0
//	C		A		D		0
//	D		C		B		1

// Hint: Logic equations for one-hot state transition logic can be derived by looking at in-edges of the state transition diagram.
// State transition logic: Derive an equation for each state flip-flop.

module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] = ...;","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;
    //assign next_state[A] =...;
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & (in) | state[B] & (in) | state[D] & (in);
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);
    //assign next_state[D] = state[D] & (in);
    assign out = state[D] & (~in);

endmodule","module top_module(
    input in,
    input [3:0] state,
    output [3:0] next_state,
    output out); //

    parameter A=0, B=1, C=2, D=3;

    // State transition logic: Derive an equation for each state flip-flop.
    assign next_state[A] = state[A] & (~in) | state[C] & (~in);
    assign next_state[B] = state[A] & in | state[B] & in | state[D] & in;
    assign next_state[C] = state[B] & (~in) | state[D] & (~in);
    assign next_state[D] = state[C] & (in);

    // Output logic: 
    assign out = (state[D] == 1);

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule",1,Gates.v,"//Build a combinational circuit with two inputs, a and b.

//There are 7 outputs, each with a logic gate driving it:

//out_and: a and b
//out_or: a or b
//out_xor: a xor b
//out_nand: a nand b
//out_nor: a nor b
//out_xnor: a xnor b
//out_anotb: a and-not b

module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & (~b);
endmodule","module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    
    assign out_and = a & b;
    assign out_or = a | b;
    assign out_xor = a ^ b;
    assign out_nand = ~(a & b);
    assign out_nor = ~(a | b);
    assign out_xnor = ~(a ^ b);
    assign out_anotb = a & ~b;

endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates100.v,"// Build a combinational circuit with 100 inputs, in[99:0].

// There are 3 outputs:

// out_and: output of a 100-input AND gate.
// out_or: output of a 100-input OR gate.
// out_xor: output of a 100-input XOR gate.

// Hint: The reduction operators will be useful here.

module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = & in[99:0];
    assign out_or = | in[99:0];
    assign out_xor = ^ in[99:0];
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule",1,Gates4.v,"// Build a combinational circuit with four inputs, in[3:0].

// There are 3 outputs as follows:
// out_and: output of a 4-input AND gate.
// out_or: output of a 4-input OR gate.
// out_xor: output of a 4-input XOR gate.


module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = &in;
    assign out_or = |in;
    assign out_xor = ^in;

endmodule","module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);

    assign out_and = in[0] & in[1] & in[2] & in[3];
    assign out_or = in[0] | in[1] | in[2] | in[3];
    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];
    
endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[0] = in[0] & in[1];
    assign out_both[1] = in[1] & in[2];
    assign out_both[2] = in[2] & in[3];
    assign out_both[3] = in[3] & in[4];
    assign out_both[4] = in[4] & in[5];
    assign out_both[5] = in[5] & in[6];
    assign out_both[6] = in[6] & in[7];
    assign out_both[7] = in[7] & in[8];
    assign out_both[8] = in[8] & in[9];
    assign out_both[9] = in[9] & in[10];
    assign out_both[10] = in[10] & in[11];
    assign out_both[11] = in[11] & in[12];
    assign out_both[12] = in[12] & in[13];
    assign out_both[13] = in[13] & in[14];
    assign out_both[14] = in[14] & in[15];
    assign out_both[15] = in[15] & in[16];
    assign out_both[16] = in[16] & in[17];
    assign out_both[17] = in[17] & in[18];
    assign out_both[18] = in[18] & in[19];
    assign out_both[19] = in[19] & in[20];
    assign out_both[20] = in[20] & in[21];
    assign out_both[21] = in[21] & in[22];
    assign out_both[22] = in[22] & in[23];
    assign out_both[23] = in[23] & in[24];
    assign out_both[24] = in[24] & in[25];
    assign out_both[25] = in[25] & in[26];
    assign out_both[26] = in[26] & in[27];
    assign out_both[27] = in[27] & in[28];
    assign out_both[28] = in[28] & in[29];
    assign out_both[29] = in[29] & in[30];
    assign out_both[30] = in[30] & in[31];
    assign out_both[31] = in[31] & in[32];
    assign out_both[32] = in[32] & in[33];
    assign out_both[33] = in[33] & in[34];
    assign out_both[34] = in[34] & in[35];
    assign out_both[35] = in[35] & in[36];
    assign out_both[36] = in[36] & in[37];
    assign out_both[37] = in[37] & in[38];
    assign out_both[38] = in[38] & in[39];
    assign out_both[39] = in[39] & in[40];
    assign out_both[40] = in[40] & in[41];
    assign out_both[41] = in[41] & in[42];
    assign out_both[42] = in[42] & in[43];
    assign out_both[43] = in[43] & in[44];
    assign out_both[44] = in[44] & in[45];
    assign out_both[45] = in[45] & in[46];
    assign out_both[46] = in[46] & in[47];
    assign out_both[47] = in[47] & in[48];
    assign out_both[48] = in[48] & in[49];
    assign out_both[49] = in[49] & in[50];
    assign out_both[50] = in[50] & in[51];
    ass",-1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[0] = in[0] & in[1];
    assign out_both[1] = in[1] & in[2];
    assign out_both[2] = in[2] & in[3];
    assign out_both[3] = in[3] & in[4];
    assign out_both[4] = in[4] & in[5];
    assign out_both[5] = in[5] & in[6];
    assign out_both[6] = in[6] & in[7];
    assign out_both[7] = in[7] & in[8];
    assign out_both[8] = in[8] & in[9];
    assign out_both[9] = in[9] & in[10];
    assign out_both[10] = in[10] & in[11];
    assign out_both[11] = in[11] & in[12];
    assign out_both[12] = in[12] & in[13];
    assign out_both[13] = in[13] & in[14];
    assign out_both[14] = in[14] & in[15];
    assign out_both[15] = in[15] & in[16];
    assign out_both[16] = in[16] & in[17];
    assign out_both[17] = in[17] & in[18];
    assign out_both[18] = in[18] & in[19];
    assign out_both[19] = in[19] & in[20];
    assign out_both[20] = in[20] & in[21];
    assign out_both[21] = in[21] & in[22];
    assign out_both[22] = in[22] & in[23];
    assign out_both[23] = in[23] & in[24];
    assign out_both[24] = in[24] & in[25];
    assign out_both[25] = in[25] & in[26];
    assign out_both[26] = in[26] & in[27];
    assign out_both[27] = in[27] & in[28];
    assign out_both[28] = in[28] & in[29];
    assign out_both[29] = in[29] & in[30];
    assign out_both[30] = in[30] & in[31];
    assign out_both[31] = in[31] & in[32];
    assign out_both[32] = in[32] & in[33];
    assign out_both[33] = in[33] & in[34];
    assign out_both[34] = in[34] & in[35];
    assign out_both[35] = in[35] & in[36];
    assign out_both[36] = in[36] & in[37];
    assign out_both[37] = in[37] & in[38];
    assign out_both[38] = in[38] & in[39];
    assign out_both[39] = in[39] & in[40];
    assign out_both[40] = in[40] & in[41];
    assign out_both[41] = in[41] & in[42];
    assign out_both[42] = in[42] & in[43];
    assign out_both[43] = in[43] & in[44];
    assign out_both[44] = in[44] & in[45];
    assign out_both[45] = in[45] & in[46];
    assign out_both[46] = in[46] & in[47];
    assign out_both[47] = in[47] & in[48];
    assign out_both[48] = in[48] & in[49];
    assign out_both[49] = in[49] & in[50];
    assign out_both[50] = in[50] & in[51];
    ass","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0], in[99:1]};
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0], in[99:1]};
    
endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[0] = in[0] & in[1];
    assign out_both[1] = in[1] & in[2];
    assign out_both[2] = in[2] & in[3];
    assign out_both[3] = in[3] & in[4];
    assign out_both[4] = in[4] & in[5];
    assign out_both[5] = in[5] & in[6];
    assign out_both[6] = in[6] & in[7];
    assign out_both[7] = in[7] & in[8];
    assign out_both[8] = in[8] & in[9];
    assign out_both[9] = in[9] & in[10];
    assign out_both[10] = in[10] & in[11];
    assign out_both[11] = in[11] & in[12];
    assign out_both[12] = in[12] & in[13];
    assign out_both[13] = in[13] & in[14];
    assign out_both[14] = in[14] & in[15];
    assign out_both[15] = in[15] & in[16];
    assign out_both[16] = in[16] & in[17];
    assign out_both[17] = in[17] & in[18];
    assign out_both[18] = in[18] & in[19];
    assign out_both[19] = in[19] & in[20];
    assign out_both[20] = in[20] & in[21];
    assign out_both[21] = in[21] & in[22];
    assign out_both[22] = in[22] & in[23];
    assign out_both[23] = in[23] & in[24];
    assign out_both[24] = in[24] & in[25];
    assign out_both[25] = in[25] & in[26];
    assign out_both[26] = in[26] & in[27];
    assign out_both[27] = in[27] & in[28];
    assign out_both[28] = in[28] & in[29];
    assign out_both[29] = in[29] & in[30];
    assign out_both[30] = in[30] & in[31];
    assign out_both[31] = in[31] & in[32];
    assign out_both[32] = in[32] & in[33];
    assign out_both[33] = in[33] & in[34];
    assign out_both[34] = in[34] & in[35];
    assign out_both[35] = in[35] & in[36];
    assign out_both[36] = in[36] & in[37];
    assign out_both[37] = in[37] & in[38];
    assign out_both[38] = in[38] & in[39];
    assign out_both[39] = in[39] & in[40];
    assign out_both[40] = in[40] & in[41];
    assign out_both[41] = in[41] & in[42];
    assign out_both[42] = in[42] & in[43];
    assign out_both[43] = in[43] & in[44];
    assign out_both[44] = in[44] & in[45];
    assign out_both[45] = in[45] & in[46];
    assign out_both[46] = in[46] & in[47];
    assign out_both[47] = in[47] & in[48];
    assign out_both[48] = in[48] & in[49];
    assign out_both[49] = in[49] & in[50];
    assign out_both[50] = in[50] & in[51];
    ass",-1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[0] = in[0] & in[1];
    assign out_both[1] = in[1] & in[2];
    assign out_both[2] = in[2] & in[3];
    assign out_both[3] = in[3] & in[4];
    assign out_both[4] = in[4] & in[5];
    assign out_both[5] = in[5] & in[6];
    assign out_both[6] = in[6] & in[7];
    assign out_both[7] = in[7] & in[8];
    assign out_both[8] = in[8] & in[9];
    assign out_both[9] = in[9] & in[10];
    assign out_both[10] = in[10] & in[11];
    assign out_both[11] = in[11] & in[12];
    assign out_both[12] = in[12] & in[13];
    assign out_both[13] = in[13] & in[14];
    assign out_both[14] = in[14] & in[15];
    assign out_both[15] = in[15] & in[16];
    assign out_both[16] = in[16] & in[17];
    assign out_both[17] = in[17] & in[18];
    assign out_both[18] = in[18] & in[19];
    assign out_both[19] = in[19] & in[20];
    assign out_both[20] = in[20] & in[21];
    assign out_both[21] = in[21] & in[22];
    assign out_both[22] = in[22] & in[23];
    assign out_both[23] = in[23] & in[24];
    assign out_both[24] = in[24] & in[25];
    assign out_both[25] = in[25] & in[26];
    assign out_both[26] = in[26] & in[27];
    assign out_both[27] = in[27] & in[28];
    assign out_both[28] = in[28] & in[29];
    assign out_both[29] = in[29] & in[30];
    assign out_both[30] = in[30] & in[31];
    assign out_both[31] = in[31] & in[32];
    assign out_both[32] = in[32] & in[33];
    assign out_both[33] = in[33] & in[34];
    assign out_both[34] = in[34] & in[35];
    assign out_both[35] = in[35] & in[36];
    assign out_both[36] = in[36] & in[37];
    assign out_both[37] = in[37] & in[38];
    assign out_both[38] = in[38] & in[39];
    assign out_both[39] = in[39] & in[40];
    assign out_both[40] = in[40] & in[41];
    assign out_both[41] = in[41] & in[42];
    assign out_both[42] = in[42] & in[43];
    assign out_both[43] = in[43] & in[44];
    assign out_both[44] = in[44] & in[45];
    assign out_both[45] = in[45] & in[46];
    assign out_both[46] = in[46] & in[47];
    assign out_both[47] = in[47] & in[48];
    assign out_both[48] = in[48] & in[49];
    assign out_both[49] = in[49] & in[50];
    assign out_both[50] = in[50] & in[51];
    ass","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ in[99:1];
    
endmodule",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ in[99:1];
    
endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0],in[99:1]};

endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0],in[99:1]};

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ in[99:1];
    
endmodule",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ in[99:1];
    
endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0],in[99:1]};
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0],in[99:1]};
    
endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[0] = in[0] & in[1];
    assign out_both[1] = in[1] & in[2];
    assign out_both[2] = in[2] & in[3];
    assign out_both[3] = in[3] & in[4];
    assign out_both[4] = in[4] & in[5];
    assign out_both[5] = in[5] & in[6];
    assign out_both[6] = in[6] & in[7];
    assign out_both[7] = in[7] & in[8];
    assign out_both[8] = in[8] & in[9];
    assign out_both[9] = in[9] & in[10];
    assign out_both[10] = in[10] & in[11];
    assign out_both[11] = in[11] & in[12];
    assign out_both[12] = in[12] & in[13];
    assign out_both[13] = in[13] & in[14];
    assign out_both[14] = in[14] & in[15];
    assign out_both[15] = in[15] & in[16];
    assign out_both[16] = in[16] & in[17];
    assign out_both[17] = in[17] & in[18];
    assign out_both[18] = in[18] & in[19];
    assign out_both[19] = in[19] & in[20];
    assign out_both[20] = in[20] & in[21];
    assign out_both[21] = in[21] & in[22];
    assign out_both[22] = in[22] & in[23];
    assign out_both[23] = in[23] & in[24];
    assign out_both[24] = in[24] & in[25];
    assign out_both[25] = in[25] & in[26];
    assign out_both[26] = in[26] & in[27];
    assign out_both[27] = in[27] & in[28];
    assign out_both[28] = in[28] & in[29];
    assign out_both[29] = in[29] & in[30];
    assign out_both[30] = in[30] & in[31];
    assign out_both[31] = in[31] & in[32];
    assign out_both[32] = in[32] & in[33];
    assign out_both[33] = in[33] & in[34];
    assign out_both[34] = in[34] & in[35];
    assign out_both[35] = in[35] & in[36];
    assign out_both[36] = in[36] & in[37];
    assign out_both[37] = in[37] & in[38];
    assign out_both[38] = in[38] & in[39];
    assign out_both[39] = in[39] & in[40];
    assign out_both[40] = in[40] & in[41];
    assign out_both[41] = in[41] & in[42];
    assign out_both[42] = in[42] & in[43];
    assign out_both[43] = in[43] & in[44];
    assign out_both[44] = in[44] & in[45];
    assign out_both[45] = in[45] & in[46];
    assign out_both[46] = in[46] & in[47];
    assign out_both[47] = in[47] & in[48];
    assign out_both[48] = in[48] & in[49];
    assign out_both[49] = in[49] & in[50];
    assign out_both[50] = in[50] & in[51];
    ass",-1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both[0] = in[0] & in[1];
    assign out_both[1] = in[1] & in[2];
    assign out_both[2] = in[2] & in[3];
    assign out_both[3] = in[3] & in[4];
    assign out_both[4] = in[4] & in[5];
    assign out_both[5] = in[5] & in[6];
    assign out_both[6] = in[6] & in[7];
    assign out_both[7] = in[7] & in[8];
    assign out_both[8] = in[8] & in[9];
    assign out_both[9] = in[9] & in[10];
    assign out_both[10] = in[10] & in[11];
    assign out_both[11] = in[11] & in[12];
    assign out_both[12] = in[12] & in[13];
    assign out_both[13] = in[13] & in[14];
    assign out_both[14] = in[14] & in[15];
    assign out_both[15] = in[15] & in[16];
    assign out_both[16] = in[16] & in[17];
    assign out_both[17] = in[17] & in[18];
    assign out_both[18] = in[18] & in[19];
    assign out_both[19] = in[19] & in[20];
    assign out_both[20] = in[20] & in[21];
    assign out_both[21] = in[21] & in[22];
    assign out_both[22] = in[22] & in[23];
    assign out_both[23] = in[23] & in[24];
    assign out_both[24] = in[24] & in[25];
    assign out_both[25] = in[25] & in[26];
    assign out_both[26] = in[26] & in[27];
    assign out_both[27] = in[27] & in[28];
    assign out_both[28] = in[28] & in[29];
    assign out_both[29] = in[29] & in[30];
    assign out_both[30] = in[30] & in[31];
    assign out_both[31] = in[31] & in[32];
    assign out_both[32] = in[32] & in[33];
    assign out_both[33] = in[33] & in[34];
    assign out_both[34] = in[34] & in[35];
    assign out_both[35] = in[35] & in[36];
    assign out_both[36] = in[36] & in[37];
    assign out_both[37] = in[37] & in[38];
    assign out_both[38] = in[38] & in[39];
    assign out_both[39] = in[39] & in[40];
    assign out_both[40] = in[40] & in[41];
    assign out_both[41] = in[41] & in[42];
    assign out_both[42] = in[42] & in[43];
    assign out_both[43] = in[43] & in[44];
    assign out_both[44] = in[44] & in[45];
    assign out_both[45] = in[45] & in[46];
    assign out_both[46] = in[46] & in[47];
    assign out_both[47] = in[47] & in[48];
    assign out_both[48] = in[48] & in[49];
    assign out_both[49] = in[49] & in[50];
    assign out_both[50] = in[50] & in[51];
    ass","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[1:0];
    assign out_any = in | in[99:1];
    assign out_different = in ^ {in[0],in[99:1]};

endmodule",-0.5,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[1:0];
    assign out_any = in | in[99:1];
    assign out_different = in ^ {in[0],in[99:1]};

endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0],in[99:1]};
    
endmodule",1,Gatesv100.v,"// You are given a 100-bit input vector in[99:0]. 
//We want to know some relationships between each bit and its neighbour:

//out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99].
//out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0].
//out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].


// Hint: Using vectors, this can still be done in 3 assign statements.

module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in & in[99:1];
    assign out_any = in[99:1] | in;
    assign out_different = in ^ {in[0],in[99:1]};
    
endmodule","module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    integer i;
    
    always @(*) begin
        for(i = 0; i < 99; i ++) begin
            out_both[i] = in[i] & in[i+1];
            out_any[i+1] = in[i] | in[i+1];
            out_different[i] = (in[i] != in[i+1]) ? 1:0;
        end
        out_different[99] = (in[0] != in[99]) ? 1:0;
    end

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );
    
    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule",1,Hadd.v,"// Create a half adder. A half adder adds two bits (with no carry-in) and produces a sum and carry-out.

module top_module( 
    input a, b,
    output cout, sum );","module top_module( 
    input a, b,
    output cout, sum );

    assign sum = a ^ b;
    assign cout = a & b;
endmodule","module top_module( 
    input a, b,
    output cout, sum );
    
    assign {cout, sum} = a + b;

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;
    
endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;
    
endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a ^ b ^ c;

endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a ^ b ^ c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;
    
endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;
    
endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | (b ^ c);

endmodule",-0.5,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | (b ^ c);

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule",1,Kmap1.v,"// Implement the circuit described by the Karnaugh map below. Values in bracket show the correponding binary
// |          | a'(0) | a(1) |
// |----------|-------|------|
// | b'c'(00) | 1     | 1    |
// | b'c (01) | 1     | 1    |
// | bc (11)  | 1     | 1    |
// | bc'(10)  | 1     | 1    |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = a | b | c;

endmodule","module top_module(
    input a,
    input b,
    input c,
    output out  ); 
    
    assign out = ~(~a & ~b & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (a&b) | (a&c) | (a&d) | (b&c) | (b&d) | (c&d);
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (a&b) | (a&c) | (a&d) | (b&c) | (b&d) | (c&d);
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & c) | (~a & b & ~c) | (a & ~b & ~c) | (a & b & c) | (a & b & d);

endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & c) | (~a & b & ~c) | (a & ~b & ~c) | (a & b & c) | (a & b & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (a&b) | (a&c) | (a&d) | (b&c) | (b&d) | (c&d);
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (a&b) | (a&c) | (a&d) | (b&c) | (b&d) | (c&d);
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) |",-1,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & c & ~d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & ~d);
    
    // You can also use the following reduction:
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) |","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (a & b & c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & d) | (a & b & ~c & ~d) | (a & b & c & ~d);

endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (a & b & c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (a & ~b & ~c & d) | (a & b & ~c & ~d) | (a & b & c & ~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule",-0.5,Kmap2.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 1    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 0   | 1   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 1    | 1    | 0   | 0   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&~b&~c) | (~a&~c&~d) | (a&~b&~c) | (b&c&d) | (a&c&d) | (~a&b&c) | (~a&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & b & c) | (~a & ~b & ~c & d) | (a & ~b & ~c & d) | (a & b & ~c & d);

endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & b & c) | (~a & ~b & ~c & d) | (a & ~b & ~c & d) | (a & b & ~c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);

endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) ;
    
    // This is another way to code the same thing.
    // assign out = (a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) ;
    
    // Yet another way.
    // assign out = (a & b & ~c & d) | (a & b & c & ~d) | (a & ~b & c & d) | (~a & b & c & ~d) ;
    
    // Yet another way.
    // assign out = (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & c & d) | (a & b & ~c & ~d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & c & ~d) | (~a & ~b & c & d) | (~a & b & c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & ~c & ~d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (~a & b & c & d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & ~b & c & d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b",-1,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) ;
    
    // This is another way to code the same thing.
    // assign out = (a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) ;
    
    // Yet another way.
    // assign out = (a & b & ~c & d) | (a & b & c & ~d) | (a & ~b & c & d) | (~a & b & c & ~d) ;
    
    // Yet another way.
    // assign out = (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & c & d) | (a & b & ~c & ~d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & c & ~d) | (~a & ~b & c & d) | (~a & b & c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & ~c & ~d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (~a & b & c & d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & ~b & c & d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d) ;
    
    // Yet another way.
    // assign out = (~a & ~b & ~c & d) | (~a & ~b & ~c & ~d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & ~c & ~d) | (a & ~b & ~c & d) | (a & ~b","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & ~c & d) | (~a & b & c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & ~d);
    
    // The above can be simplified, using boolean algebra. It can be simplified further.
    // assign out = a & (b | c & d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & ~(b & c);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b",-1,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & ~c & d) | (~a & b & c & ~d) | (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & ~d);
    
    // The above can be simplified, using boolean algebra. It can be simplified further.
    // assign out = a & (b | c & d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & ~(b & c);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b & c & d | ~b & c & ~d & ~a | ~b & ~c & d & ~a | ~b & ~c & ~d & ~a | ~b & ~c & ~d & ~a);
    
    // The above can be simplified further.
    // assign out = a & (b | c & d) & (~b | ~c | ~d | ~a | b","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & c) | (a & ~b & ~c & d) | (a & b & ~c & d) | (a & b & c & d);
    
    // This is another way to code the same gates.
    // assign out = a & b & c | ~a & b & ~c & d | ~a & ~b & c & d | a & b & ~c & d;

endmodule",-0.5,Kmap3.v,"// Implement the circuit described by the Karnaugh map below. d is don't-care a particular cell in the following map, which means you may choose to output whatever value is convenient.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | d    | 0    | 1   | 1   |
// | c'd   | 0    | 0    | d   | d   |
// | cd    | 0    | 1    | 1   | 1   |
// | cd'   | 0    | 1    | 1   | 1   |


// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.

module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & c) | (a & ~b & ~c & d) | (a & b & ~c & d) | (a & b & c & d);
    
    // This is another way to code the same gates.
    // assign out = a & b & c | ~a & b & ~c & d | ~a & ~b & c & d | a & b & ~c & d;

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~b & c) | (a & c) | (a & ~c);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & c) | (~a & b & ~c) | (a & ~b & ~c) | (a & b & c);
    
    // This is another way to code the same circuit.
    assign out = a & b & c;
    
    // The following is equivalent and shorter.
    assign out = a | b | c;
    
    // The following is equivalent and shorter.
    assign out = a ^ b ^ c;
    
    // The following is equivalent and shorter.
    assign out = ~(a & b & c);
    
    // The following is equivalent and shorter.
    assign out = a ^ b ^ ~c;
    
    // The following is equivalent and shorter.
    assign out = ~a & b & ~c;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & c;
    
    // The following is equivalent and shorter.
    assign out = a & ~b & ~c;
    
    // The following is equivalent and shorter.
    assign out = a & b & ~c;
    
    // The following is equivalent and shorter.
    assign out = ~a & b & c;
    
    // The following is equivalent and shorter.
    assign out = a & b & c;
    
    // The following is equivalent and shorter.
    assign out = a | b;
    
    // The following is equivalent and shorter.
    assign out = a | b | c;
    
    // The following is equivalent and shorter.
    assign out = a | b | c | d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c | a & b & d | a & c & d | b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c | a & b & d | a & c & d | b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b | a & c | a & d | b & c | b & d | c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c | a & b & d | a & c & d | b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & ~d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~",-1,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & c) | (~a & b & ~c) | (a & ~b & ~c) | (a & b & c);
    
    // This is another way to code the same circuit.
    assign out = a & b & c;
    
    // The following is equivalent and shorter.
    assign out = a | b | c;
    
    // The following is equivalent and shorter.
    assign out = a ^ b ^ c;
    
    // The following is equivalent and shorter.
    assign out = ~(a & b & c);
    
    // The following is equivalent and shorter.
    assign out = a ^ b ^ ~c;
    
    // The following is equivalent and shorter.
    assign out = ~a & b & ~c;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & c;
    
    // The following is equivalent and shorter.
    assign out = a & ~b & ~c;
    
    // The following is equivalent and shorter.
    assign out = a & b & ~c;
    
    // The following is equivalent and shorter.
    assign out = ~a & b & c;
    
    // The following is equivalent and shorter.
    assign out = a & b & c;
    
    // The following is equivalent and shorter.
    assign out = a | b;
    
    // The following is equivalent and shorter.
    assign out = a | b | c;
    
    // The following is equivalent and shorter.
    assign out = a | b | c | d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c | a & b & d | a & c & d | b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c | a & b & d | a & c & d | b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b | a & c | a & d | b & c | b & d | c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c | a & b & d | a & c & d | b & c & d;
    
    // The following is equivalent and shorter.
    assign out = a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & ~d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~a & ~b & c & ~d | ~a & b & ~c & ~d | ~a & b & c & d;
    
    // The following is equivalent and shorter.
    assign out = ~a & ~b & ~c & d | ~","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & c) | (~a & b & ~d) | (a & ~b & ~d) | (a & b & d);

endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & c) | (~a & b & ~d) | (a & ~b & ~d) | (a & b & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);

endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d) | (a & b & c & ~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = (~a & ~b & ~c & d) | (~a & b & ~c & ~d) | (a & ~b & c & d) | (a & b & ~c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & c) | (~a & b & d) | (~a & c & d) | (a & ~b & c) | (a & ~b & d) | (a & b & ~c) | (a & b & ~d);

endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & c) | (~a & b & d) | (~a & c & d) | (a & ~b & c) | (a & ~b & d) | (a & b & ~c) | (a & b & ~d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & c) | (~a & b & ~d) | (a & ~b & ~d) | (a & b & d);

endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & ~b & c) | (~a & b & ~d) | (a & ~b & ~d) | (a & b & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = a | b | c | d;
endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & c & d) | (~a & ~b & ~c & d) | (a & ~b & ~c & d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d);

endmodule",-0.5,Kmap4.v,"// Implement the circuit described by the Karnaugh map below.
// |       | a'b' | a'b  | ab  | ab' |
// |-------|------|------|-----|-----|
// | c'd'  | 0    | 1    | 0   | 1   |
// | c'd   | 1    | 0    | 1   | 0   |
// | cd    | 0    | 1    | 0   | 1   |
// | cd'   | 1    | 0    | 1   | 0   |

// Try to simplify the k-map before coding it. Try both product-of-sums and sum-of-products forms. We can't check whether you have the optimal simplification of the k-map. But we can check if your reduction is equivalent, and we can check whether you can translate a k-map into a circuit.


module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  );","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    assign out = (~a & b & c & d) | (~a & ~b & ~c & d) | (a & ~b & ~c & d) | (a & b & ~c & d) | (a & b & c & ~d) | (a & b & c & d);

endmodule","module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = (~a&b&~c&~d) | (a&~b&~c&~d) | (~a&~b&~c&d) |  (a&b&~c&d) |  (~a&b&c&d) |  (a&~b&c&d) |  (~a&~b&c&~d) |  (a&b&c&~d);

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30];
        q_next[31] = q[30];
        q_next[30] = q[29];
        q_next[29] = q[28];
        q_next[28] = q[27];
        q_next[27] = q[26];
        q_next[26] = q[25];
        q_next[25] = q[24];
        q_next[24] = q[23];
        q_next[23] = q[22];
        q_next[22] = q[21];
        q_next[21] = q[20];
        q_next[20] = q[19];
        q_next[19] = q[18];
        q_next[18] = q[17];
        q_next[17] = q[16];
        q_next[16] = q[15];
        q_next[15] = q[14];
        q_next[14] = q[13];
        q_next[13] = q[12];
        q_next[12] = q[11];
        q_next[11] = q[10];
        q_next[10] = q[9];
        q_next[9] = q[8];
        q_next[8] = q[7];
        q_next[7] = q[6];
        q_next[6] = q[5];
        q_next[5] = q[4];
        q_next[4] = q[3];
        q_next[3] = q[2];
        q_next[2] = q[1];
        q_next[1] = q[0];
        q_next[0] = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[30];
        q_next[31] = q[30];
        q_next[30] = q[29];
        q_next[29] = q[28];
        q_next[28] = q[27];
        q_next[27] = q[26];
        q_next[26] = q[25];
        q_next[25] = q[24];
        q_next[24] = q[23];
        q_next[23] = q[22];
        q_next[22] = q[21];
        q_next[21] = q[20];
        q_next[20] = q[19];
        q_next[19] = q[18];
        q_next[18] = q[17];
        q_next[17] = q[16];
        q_next[16] = q[15];
        q_next[15] = q[14];
        q_next[14] = q[13];
        q_next[13] = q[12];
        q_next[12] = q[11];
        q_next[11] = q[10];
        q_next[10] = q[9];
        q_next[9] = q[8];
        q_next[8] = q[7];
        q_next[7] = q[6];
        q_next[6] = q[5];
        q_next[5] = q[4];
        q_next[4] = q[3];
        q_next[3] = q[2];
        q_next[2] = q[1];
        q_next[1] = q[0];
        q_next[0] = q[31] ^ q[0];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    
    assign d = {1'b0, reset};
    assign r_val = {1'b1, reset};
    
    genvar i;
    generate
        for(i=0; i<32; i=i+1) begin
            dff d1(clk, d[i], r_val[i], q[i]);
        end
    endgenerate

endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] d, r_val;
    
    assign d = {1'b0, reset};
    assign r_val = {1'b1, reset};
    
    genvar i;
    generate
        for(i=0; i<32; i=i+1) begin
            dff d1(clk, d[i], r_val[i], q[i]);
        end
    endgenerate

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    // Give the parameter values their proper size.
    parameter WIDTH = 32;
    
    // Declare the RAM variable
    reg [WIDTH-1:0] ram[2**WIDTH-1:0];
    
    // Variable to hold the registered output
    reg [WIDTH-1:0] q_reg;
    
    // Specify the initial contents.  You can also use the $readmemb
    // system task to initialize the RAM variable from a text file.
    // See the $readmemb template page for details.
    initial 
    begin : INIT
        $readmemb(""ram_init.txt"", ram);
    end
    
    // This process is a lot like a shift register, except that
    // the value is loaded only when the clock goes from low to high.
    // This is called a ""latch"" in hardware.
    always @(posedge clk)
    begin
        if(reset)
            q_reg <= 32'h1;
        else
            q_reg <= ram[q_reg];
    end
    
    // The final output is a combination of the shift register output
    // and the ""reset"" output, which is active low.
    assign q = {q_reg, reset};
    
endmodule",-0.5,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    // Give the parameter values their proper size.
    parameter WIDTH = 32;
    
    // Declare the RAM variable
    reg [WIDTH-1:0] ram[2**WIDTH-1:0];
    
    // Variable to hold the registered output
    reg [WIDTH-1:0] q_reg;
    
    // Specify the initial contents.  You can also use the $readmemb
    // system task to initialize the RAM variable from a text file.
    // See the $readmemb template page for details.
    initial 
    begin : INIT
        $readmemb(""ram_init.txt"", ram);
    end
    
    // This process is a lot like a shift register, except that
    // the value is loaded only when the clock goes from low to high.
    // This is called a ""latch"" in hardware.
    always @(posedge clk)
    begin
        if(reset)
            q_reg <= 32'h1;
        else
            q_reg <= ram[q_reg];
    end
    
    // The final output is a combination of the shift register output
    // and the ""reset"" output, which is active low.
    assign q = {q_reg, reset};
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    always @ (posedge clk) begin
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= {q_wire[30:0], q_wire[31] ^ q_wire[30]};
    end

endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    wire [31:0] q_wire;
    
    assign q = q_wire;
    
    always @ (posedge clk) begin
        if(reset)
            q_wire <= 32'h1;
        else
            q_wire <= {q_wire[30:0], q_wire[31] ^ q_wire[30]};
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next = q_next >> 1;
        q_next[31] = q[0] ^ q[1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0];
        q_next = q_next >> 1;
        q_next[31] = q[0] ^ q[1];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] q_next;
    
    always @(*) begin
        q_next = q[31] ^ q[0] ^ q[1] ^ q[2] ^ q[3] ^ q[4] ^ q[5] ^ q[6] ^ q[7] ^ q[8] ^ q[9] ^ q[10] ^ q[11] ^ q[12] ^ q[13] ^ q[14] ^ q[15] ^ q[16] ^ q[17] ^ q[18] ^ q[19] ^ q[20] ^ q[21] ^ q[22] ^ q[23] ^ q[24] ^ q[25] ^ q[26] ^ q[27] ^ q[28] ^ q[29] ^ q[30] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= q_next;
    end
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] next_state;
    
    always @(*) begin
        case (q)
            32'h1: next_state = 32'h1;
            32'h2: next_state = 32'h8;
            32'h4: next_state = 32'h4;
            32'h8: next_state = 32'h2;
            32'h10: next_state = 32'h20;
            32'h20: next_state = 32'h1;
            default: next_state = 32'h1;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= next_state;
    end
    
endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] next_state;
    
    always @(*) begin
        case (q)
            32'h1: next_state = 32'h1;
            32'h2: next_state = 32'h8;
            32'h4: next_state = 32'h4;
            32'h8: next_state = 32'h2;
            32'h10: next_state = 32'h20;
            32'h20: next_state = 32'h1;
            default: next_state = 32'h1;
        endcase
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= next_state;
    end
    
endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] next_state;
    
    always @(*) begin
        next_state = q + 1;
        next_state[31] = q[31] ^ q[23];
        next_state[30:22] = q[30:22] + q[31:23];
        next_state[21:1] = q[21:1] + q[22:2];
        next_state[0] = q[0] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= next_state;
    end

endmodule",-1,Lfsr32.v,"// Build a 32-bit Galois LFSR with taps at bit positions 32, 22, 2, and 1.

// Hint: This is long enough that you'd want to use vectors, not 32 instantiations of DFFs.

module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
);","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 

    reg [31:0] next_state;
    
    always @(*) begin
        next_state = q + 1;
        next_state[31] = q[31] ^ q[23];
        next_state[30:22] = q[30:22] + q[31:23];
        next_state[21:1] = q[21:1] + q[22:2];
        next_state[0] = q[0] ^ q[31];
    end
    
    always @(posedge clk) begin
        if(reset)
            q <= 32'h1;
        else
            q <= next_state;
    end

endmodule","module top_module(
    input clk,
    input reset,    // Active-high synchronous reset to 32'h1
    output [31:0] q
); 
    
    always @(posedge clk) begin
        if(reset) begin
            q <= 32'h1;
        end
        else begin
            q <= {0 ^ q[0], q[31:23], q[22] ^ q[0], q[21:3], q[2] ^ q[0], q[1] ^ q[0]};
        end
    end

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin = 1'b0;
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2, cout3;
    add16 u1(a[15:0], b[15:0], cin, sum1, cout1);
    add16 u2(a[31:16], b[31:16], cout1, sum2, cout2);
    add16 u3(a[31:16], b[31:16], cout2, sum3, cout3);
    assign sum[31:16] = cout3;
    assign sum[15:0] = sum3;
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin = 1'b0;
    wire [15:0] sum1, sum2, sum3;
    wire cout1, cout2, cout3;
    add16 u1(a[15:0], b[15:0], cin, sum1, cout1);
    add16 u2(a[31:16], b[31:16], cout1, sum2, cout2);
    add16 u3(a[31:16], b[31:16], cout2, sum3, cout3);
    assign sum[31:16] = cout3;
    assign sum[15:0] = sum3;
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,    assign sum = a + b;
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign {cout, sum} = a + b;
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign {cout, sum} = a + b;
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,endmodule
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign {cout, sum} = a + b;
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign {cout, sum} = a + b;
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin = 1'b0;
    wire [15:0] sum1, sum2;
    wire [16:0] sum3;
    
    add16 add16_0 (a[15:0], b[15:0], cin, sum1, c1);
    add16 add16_1 (a[31:16], b[31:16], c1, sum2, c2);
    
    assign sum3 = {1'b0, c2, sum1, sum2};
    
    assign sum = sum3[31:0];
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin = 1'b0;
    wire [15:0] sum1, sum2;
    wire [16:0] sum3;
    
    add16 add16_0 (a[15:0], b[15:0], cin, sum1, c1);
    add16 add16_1 (a[31:16], b[31:16], c1, sum2, c2);
    
    assign sum3 = {1'b0, c2, sum1, sum2};
    
    assign sum = sum3[31:0];
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a+b;

endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a+b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire cin = 1'b0;
    wire [15:0] sum1, sum2;
    wire [16:0] sum3;
    add16 one(a[15:0], b[15:0], cin, sum1, c1);
    add16 two(a[31:16], b[31:16], c1, sum2, c2);
    assign sum3 = {sum2, c1};
    assign sum = sum3[16:0];
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire cin = 1'b0;
    wire [15:0] sum1, sum2;
    wire [16:0] sum3;
    add16 one(a[15:0], b[15:0], cin, sum1, c1);
    add16 two(a[31:16], b[31:16], c1, sum2, c2);
    assign sum3 = {sum2, c1};
    assign sum = sum3[16:0];
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire cin = 1'b0;
    wire [31:0] sum_l = {1'b0,a} + {1'b0,b};
    wire [31:0] sum_h = {1'b0,a[31:16]} + {1'b0,b[31:16]};
    assign sum = {sum_h[31:16], sum_l};
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire cin = 1'b0;
    wire [31:0] sum_l = {1'b0,a} + {1'b0,b};
    wire [31:0] sum_h = {1'b0,a[31:16]} + {1'b0,b[31:16]};
    assign sum = {sum_h[31:16], sum_l};
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin = 1'b0;
    wire [15:0] sum0, sum1;
    wire cout0, cout1;
    
    add16 u0_add16 (a[15:0], b[15:0], cin, sum0, cout0);
    add16 u1_add16 (a[31:16], b[31:16], cout0, sum1, cout1);
    
    assign sum[31:16] = sum1;
    assign sum[15:0] = sum0;
    
endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin = 1'b0;
    wire [15:0] sum0, sum1;
    wire cout0, cout1;
    
    add16 u0_add16 (a[15:0], b[15:0], cin, sum0, cout0);
    add16 u1_add16 (a[31:16], b[31:16], cout0, sum1, cout1);
    
    assign sum[31:16] = sum1;
    assign sum[15:0] = sum0;
    
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a+b;

endmodule",-1,Module_add.v,"// You are given a module add16 that performs a 16-bit addition. 
//Instantiate two of them to create a 32-bit adder. 
//One add16 module computes the lower 16 bits of the addition result, 
//while the second add16 module computes the upper 16 bits of the result, 
//after receiving the carry-out from the first adder. Your 32-bit adder does 
//not need to handle carry-in (assume 0) or carry-out (ignored), 
//but the internal modules need to in order to function correctly. 
//(In other words, the add16 module performs 16-bit a + b + cin, while your module performs 32-bit a + b).

// Connect the modules together as shown in the diagram below. 
//The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a+b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    
    wire cin1, cout1,cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_xor_sub = b ^ {sub, cin};

// Instantiate two 16-bit adders.

adder16 adder0(a[15:0], b_xor_sub[15:0], sub, sum[15:0], cin);
adder16 adder1(a[31:16], b_xor_sub[31:16], sub, sum[31:16], cin);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_xor_sub = b ^ {sub, cin};

// Instantiate two 16-bit adders.

adder16 adder0(a[15:0], b_xor_sub[15:0], sub, sum[15:0], cin);
adder16 adder1(a[31:16], b_xor_sub[31:16], sub, sum[31:16], cin);

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

// This is a 32-bit adder with carry-in. The output is a 32-bit number, so there is a single carry-out.

// The first carry-in is zero, and the carry-out is the same as the carry-in of the next adder.

// The carry-in and carry-out wires are named cin and cout, respectively.

// The sum is named sum, and the carry-out of the last adder is named cout.

// The carry-in of the first adder is zero, and the carry-out is named cin.

// The carry-in of the second adder is the carry-out of the first adder.

// The carry-out of the second adder is named cout.

// The carry-in of the third adder is the carry-out of the second adder.

// The carry-out of the third adder is named cin.

// The carry-in of the fourth adder is the carry-out of the third adder.

// The carry-out of the fourth adder is named cout.

// The carry-in of the fifth adder is the carry-out of the fourth adder.

// The carry-out of the fifth adder is named cin.

// The carry-in of the sixth adder is the carry-out of the fifth adder.

// The carry-out of the sixth adder is named cout.

// The carry-in of the seventh adder is the carry-out of the sixth adder.

// The carry-out of the seventh adder is named cin.

// The carry-in of the eighth adder is the carry-out of the seventh adder.

// The carry-out of the eighth adder is named cout.

// The carry-in of the ninth adder is the carry-out of the eighth adder.

// The carry-out of the ninth adder is named cin.

// The carry-in of the tenth adder is the carry-out of the ninth adder.

// The carry-out of the tenth adder is named cout.

// The carry-in of the eleventh adder is the carry-out of the tenth adder.

// The carry-out of the eleventh adder is named cin.

// The carry-in of the twelfth adder is the carry-out of the eleventh adder.

// The carry-out of the twelfth adder is named cout.

// The carry-in of the thirteenth adder is the carry-out of the twelfth adder.

// The carry-out of the thirteenth adder is named cin.

// The carry-in of the fourteenth adder is the carry-out of the thirteenth adder.

// The carry-out of the fourteenth adder is named cout.

// The carry-in of the fifteenth adder is the carry-out of the fourteenth adder.

// The carry-out of the fifteenth adder is named cin.

// The carry-in of the sixteenth adder is the carry-out of the fifteenth adder.

// The carry-out of the sixteenth adder is named cout.

// The carry-in of the seventeenth adder is the carry-out of the sixteenth adder.

// The carry-out of the seventeenth adder is named cin.

// The carry-in of the eighteenth adder is the carry-out of the seventeenth adder.

// The carry-out of the eighteenth adder is named cout.

// The carry-in of the nineteenth adder is the carry-out of the eighteenth adder.

// The carry-out of the nineteenth adder is named cin.

// The carry-in of the twentieth adder is the carry-out of the nineteenth adder.

// The carry-out of the twentieth adder is named cout.

// The carry-in of the twenty-first adder is the carry-out of the twentieth adder.

// The carry-out of the twenty-first adder is named cin.

// The carry-in of the twenty-second adder is the carry-out of the twenty-first adder.

// The carry-out of the twenty-second adder is named cout.

// The carry-in of the twenty-third adder is the carry-out of the twenty-second adder.",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

// This is a 32-bit adder with carry-in. The output is a 32-bit number, so there is a single carry-out.

// The first carry-in is zero, and the carry-out is the same as the carry-in of the next adder.

// The carry-in and carry-out wires are named cin and cout, respectively.

// The sum is named sum, and the carry-out of the last adder is named cout.

// The carry-in of the first adder is zero, and the carry-out is named cin.

// The carry-in of the second adder is the carry-out of the first adder.

// The carry-out of the second adder is named cout.

// The carry-in of the third adder is the carry-out of the second adder.

// The carry-out of the third adder is named cin.

// The carry-in of the fourth adder is the carry-out of the third adder.

// The carry-out of the fourth adder is named cout.

// The carry-in of the fifth adder is the carry-out of the fourth adder.

// The carry-out of the fifth adder is named cin.

// The carry-in of the sixth adder is the carry-out of the fifth adder.

// The carry-out of the sixth adder is named cout.

// The carry-in of the seventh adder is the carry-out of the sixth adder.

// The carry-out of the seventh adder is named cin.

// The carry-in of the eighth adder is the carry-out of the seventh adder.

// The carry-out of the eighth adder is named cout.

// The carry-in of the ninth adder is the carry-out of the eighth adder.

// The carry-out of the ninth adder is named cin.

// The carry-in of the tenth adder is the carry-out of the ninth adder.

// The carry-out of the tenth adder is named cout.

// The carry-in of the eleventh adder is the carry-out of the tenth adder.

// The carry-out of the eleventh adder is named cin.

// The carry-in of the twelfth adder is the carry-out of the eleventh adder.

// The carry-out of the twelfth adder is named cout.

// The carry-in of the thirteenth adder is the carry-out of the twelfth adder.

// The carry-out of the thirteenth adder is named cin.

// The carry-in of the fourteenth adder is the carry-out of the thirteenth adder.

// The carry-out of the fourteenth adder is named cout.

// The carry-in of the fifteenth adder is the carry-out of the fourteenth adder.

// The carry-out of the fifteenth adder is named cin.

// The carry-in of the sixteenth adder is the carry-out of the fifteenth adder.

// The carry-out of the sixteenth adder is named cout.

// The carry-in of the seventeenth adder is the carry-out of the sixteenth adder.

// The carry-out of the seventeenth adder is named cin.

// The carry-in of the eighteenth adder is the carry-out of the seventeenth adder.

// The carry-out of the eighteenth adder is named cout.

// The carry-in of the nineteenth adder is the carry-out of the eighteenth adder.

// The carry-out of the nineteenth adder is named cin.

// The carry-in of the twentieth adder is the carry-out of the nineteenth adder.

// The carry-out of the twentieth adder is named cout.

// The carry-in of the twenty-first adder is the carry-out of the twentieth adder.

// The carry-out of the twenty-first adder is named cin.

// The carry-in of the twenty-second adder is the carry-out of the twenty-first adder.

// The carry-out of the twenty-second adder is named cout.

// The carry-in of the twenty-third adder is the carry-out of the twenty-second adder.","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_xor_sub = b ^ {sub, cin};

// The first adder takes b_xor_sub and the carry-in cin.
adder32 add1(a, b_xor_sub, cin, sum[31:0], c[0]);

// The second adder takes the carry-out from the first adder and the input sub.
adder32 add2(a, sub, c[0], sum[63:32], c[1]);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_xor_sub = b ^ {sub, cin};

// The first adder takes b_xor_sub and the carry-in cin.
adder32 add1(a, b_xor_sub, cin, sum[31:0], c[0]);

// The second adder takes the carry-out from the first adder and the input sub.
adder32 add2(a, sub, c[0], sum[63:32], c[1]);

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire [31:0] b_xor_sub;
    assign b_xor_sub = (sub)? ~b : b;
    
    wire [31:0] sum_final;
    wire [31:0] carry_in;
    
    assign carry_in[0] = 1'b0;
    assign sum_final[0] = a[0] ^ b_xor_sub[0] ^ carry_in[0];
    assign sum_final[1] = a[1] ^ b_xor_sub[1] ^ carry_in[1];
    assign sum_final[2] = a[2] ^ b_xor_sub[2] ^ carry_in[2];
    assign sum_final[3] = a[3] ^ b_xor_sub[3] ^ carry_in[3];
    assign sum_final[4] = a[4] ^ b_xor_sub[4] ^ carry_in[4];
    assign sum_final[5] = a[5] ^ b_xor_sub[5] ^ carry_in[5];
    assign sum_final[6] = a[6] ^ b_xor_sub[6] ^ carry_in[6];
    assign sum_final[7] = a[7] ^ b_xor_sub[7] ^ carry_in[7];
    assign sum_final[8] = a[8] ^ b_xor_sub[8] ^ carry_in[8];
    assign sum_final[9] = a[9] ^ b_xor_sub[9] ^ carry_in[9];
    assign sum_final[10] = a[10] ^ b_xor_sub[10] ^ carry_in[10];
    assign sum_final[11] = a[11] ^ b_xor_sub[11] ^ carry_in[11];
    assign sum_final[12] = a[12] ^ b_xor_sub[12] ^ carry_in[12];
    assign sum_final[13] = a[13] ^ b_xor_sub[13] ^ carry_in[13];
    assign sum_final[14] = a[14] ^ b_xor_sub[14] ^ carry_in[14];
    assign sum_final[15] = a[15] ^ b_xor_sub[15] ^ carry_in[15];
    assign sum_final[16] = a[16] ^ b_xor_sub[16] ^ carry_in[16];
    assign sum_final[17] = a[17] ^ b_xor_sub[17] ^ carry_in[17];
    assign sum_final[18] = a[18] ^ b_xor_sub[18] ^ carry_in[18];
    assign sum_final[19] = a[19] ^ b_xor_sub[19] ^ carry_in[19];
    assign sum_final[20] = a[20] ^ b_xor_sub[20] ^ carry_in[20];
    assign sum_final[21] = a[21] ^ b_xor_sub[21] ^ carry_in[21];
    assign sum_final[22] = a[22] ^ b_xor_sub[22] ^ carry_in[22];
    assign sum_final[23] = a[23] ^ b_xor_sub[23] ^ carry_in[23];
    assign sum_final[24] = a[24] ^ b_xor_sub[24] ^ carry_in[24];
    assign sum_final[25] = a[25] ^ b_xor_sub[25] ^ carry_in[25];
    assign sum_final[26] = a[26] ^ b_xor_sub[26] ^ carry_in[26];
    assign sum_final[27] = a[27] ^ b_xor_sub[27] ^ carry_in[27];
    assign sum_final[28] = a[28] ^ b_xor_sub[28] ^ carry_in[28];
    assign sum_final[29] = a[29] ^ b",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire [31:0] b_xor_sub;
    assign b_xor_sub = (sub)? ~b : b;
    
    wire [31:0] sum_final;
    wire [31:0] carry_in;
    
    assign carry_in[0] = 1'b0;
    assign sum_final[0] = a[0] ^ b_xor_sub[0] ^ carry_in[0];
    assign sum_final[1] = a[1] ^ b_xor_sub[1] ^ carry_in[1];
    assign sum_final[2] = a[2] ^ b_xor_sub[2] ^ carry_in[2];
    assign sum_final[3] = a[3] ^ b_xor_sub[3] ^ carry_in[3];
    assign sum_final[4] = a[4] ^ b_xor_sub[4] ^ carry_in[4];
    assign sum_final[5] = a[5] ^ b_xor_sub[5] ^ carry_in[5];
    assign sum_final[6] = a[6] ^ b_xor_sub[6] ^ carry_in[6];
    assign sum_final[7] = a[7] ^ b_xor_sub[7] ^ carry_in[7];
    assign sum_final[8] = a[8] ^ b_xor_sub[8] ^ carry_in[8];
    assign sum_final[9] = a[9] ^ b_xor_sub[9] ^ carry_in[9];
    assign sum_final[10] = a[10] ^ b_xor_sub[10] ^ carry_in[10];
    assign sum_final[11] = a[11] ^ b_xor_sub[11] ^ carry_in[11];
    assign sum_final[12] = a[12] ^ b_xor_sub[12] ^ carry_in[12];
    assign sum_final[13] = a[13] ^ b_xor_sub[13] ^ carry_in[13];
    assign sum_final[14] = a[14] ^ b_xor_sub[14] ^ carry_in[14];
    assign sum_final[15] = a[15] ^ b_xor_sub[15] ^ carry_in[15];
    assign sum_final[16] = a[16] ^ b_xor_sub[16] ^ carry_in[16];
    assign sum_final[17] = a[17] ^ b_xor_sub[17] ^ carry_in[17];
    assign sum_final[18] = a[18] ^ b_xor_sub[18] ^ carry_in[18];
    assign sum_final[19] = a[19] ^ b_xor_sub[19] ^ carry_in[19];
    assign sum_final[20] = a[20] ^ b_xor_sub[20] ^ carry_in[20];
    assign sum_final[21] = a[21] ^ b_xor_sub[21] ^ carry_in[21];
    assign sum_final[22] = a[22] ^ b_xor_sub[22] ^ carry_in[22];
    assign sum_final[23] = a[23] ^ b_xor_sub[23] ^ carry_in[23];
    assign sum_final[24] = a[24] ^ b_xor_sub[24] ^ carry_in[24];
    assign sum_final[25] = a[25] ^ b_xor_sub[25] ^ carry_in[25];
    assign sum_final[26] = a[26] ^ b_xor_sub[26] ^ carry_in[26];
    assign sum_final[27] = a[27] ^ b_xor_sub[27] ^ carry_in[27];
    assign sum_final[28] = a[28] ^ b_xor_sub[28] ^ carry_in[28];
    assign sum_final[29] = a[29] ^ b","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_not;

assign b_not = ~b;

wire [31:0] sum1;
wire [31:0] sum2;

add16 add1(a[15:0], b_not[15:0], sub, sum1, cin);
add16 add2(a[31:16], b_not[31:16], sub, sum2, cin);

assign sum = {sum2[31:16], sum1[15:0]};

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_not;

assign b_not = ~b;

wire [31:0] sum1;
wire [31:0] sum2;

add16 add1(a[15:0], b_not[15:0], sub, sum1, cin);
add16 add2(a[31:16], b_not[31:16], sub, sum2, cin);

assign sum = {sum2[31:16], sum1[15:0]};

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

// Use the Verilog '+' operator for addition, and '-' for subtraction.
// The '+' operator requires two operands, while the '-' operator takes one.
// The number of operands must match in a binary operator.

assign sum = sub? (a-b) : (a+b);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

// Use the Verilog '+' operator for addition, and '-' for subtraction.
// The '+' operator requires two operands, while the '-' operator takes one.
// The number of operands must match in a binary operator.

assign sum = sub? (a-b) : (a+b);

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_not;

assign b_not = ~b;

assign sum = sub? (a ^ b_not) : (a + b);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_not;

assign b_not = ~b;

assign sum = sub? (a ^ b_not) : (a + b);

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] b_xor_sub;

assign b_xor_sub = b ^ sub;

assign sum = a + b_xor_sub;

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] b_xor_sub;

assign b_xor_sub = b ^ sub;

assign sum = a + b_xor_sub;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_xor_sub = b ^ {32{sub}};

// The first adder is instantiated using wires.
adder_top_module instant1(
   .a(a[31:0]),
   .b(b_xor_sub[31:0]),
   .cin(cin),
   .sum(sum[31:0]),
   .cout(cout)
);

// The second adder is instantiated using wires.
adder_top_module instant2(
   .a(a[63:32]),
   .b(b_xor_sub[63:32]),
   .cin(cout),
   .sum(sum[63:32]),
   .cout(cout)
);

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire cin = 1'b0;
wire [31:0] b_xor_sub = b ^ {32{sub}};

// The first adder is instantiated using wires.
adder_top_module instant1(
   .a(a[31:0]),
   .b(b_xor_sub[31:0]),
   .cin(cin),
   .sum(sum[31:0]),
   .cout(cout)
);

// The second adder is instantiated using wires.
adder_top_module instant2(
   .a(a[63:32]),
   .b(b_xor_sub[63:32]),
   .cin(cout),
   .sum(sum[63:32]),
   .cout(cout)
);

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] b_xor_sub;

assign b_xor_sub = (sub)? ~b : b;

wire [31:0] sum_1;

assign sum_1 = a + b_xor_sub;

assign sum = sum_1[31:0];

endmodule",-1,Module_addsub.v,"// Build the adder-subtractor below.
// You are provided with a 16-bit adder module, which you need to instantiate twice:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Use a 32-bit wide XOR gate to invert the b input whenever sub is 1. 
// (This can also be viewed as b[31:0] XORed with sub replicated 32 times.). 
// Also connect the sub input to the carry-in of the adder.

// Hint: An XOR gate can also be viewed as a programmable inverter, where one input controls whether the other should be inverted.

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

wire [31:0] b_xor_sub;

assign b_xor_sub = (sub)? ~b : b;

wire [31:0] sum_1;

assign sum_1 = a + b_xor_sub;

assign sum = sum_1[31:0];

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);

    wire cout1, cout2;
    wire [15:0] sum1, sum2;
    wire [31:0] b_xor;
    
    always @(*) begin
        if(sub)
            b_xor = ~b;
        else
            b_xor = b;
    end
    
    add16 instance1(.a(a[15:0]), .b(b_xor[15:0]), .cin(sub), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b_xor[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire cin = 1'b0;
    wire [15:0] sum1, sum2;
    wire [16:0] sum3;
    add16 instance1(.a(a[15:0]),.b(b[15:0]),.cin(cin),.sum(sum1),.cout(cout1));
    add16 instance2(.a(a[31:16]),.b(b[31:16]),.cin(cout1),.sum(sum2),.cout(cout2));
    assign sum3 = {cout2, sum2};
    assign sum = sum3[16:0];
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire cin = 1'b0;
    wire [15:0] sum1, sum2;
    wire [16:0] sum3;
    add16 instance1(.a(a[15:0]),.b(b[15:0]),.cin(cin),.sum(sum1),.cout(cout1));
    add16 instance2(.a(a[31:16]),.b(b[31:16]),.cin(cout1),.sum(sum2),.cout(cout2));
    assign sum3 = {cout2, sum2};
    assign sum = sum3[16:0];
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout,sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

assign {cout, sum} = a + b;

endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign {cout, sum} = a + b;
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign {cout, sum} = a + b;
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign sum = a + b;
endmodule",-1,Module_cseladd.v,"// you are provided with the same module add16 as the previous exercise, 
// which adds two 16-bit numbers with carry-in and produces a carry-out and 16-bit sum. 
// You must instantiate three of these to build the carry-select adder, 
// using your own 16-bit 2-to-1 multiplexer.

// Connect the modules together as shown in the diagram below. 
// The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    assign sum = a + b;
endmodule","module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);

    wire cin1, cout1, cin2, cout2, cin3, cout3;
    wire [15:0] sum1, sum2, sum3, sum_h;
    assign cin1 = 0;
    assign cin2 = 0;
    assign cin3 = 1;
    
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cin2), .cout(cout2), .sum(sum2));
    add16 instance3(.a(a[31:16]), .b(b[31:16]), .cin(cin3), .cout(cout3), .sum(sum3));
    
    always @(*) begin
        case(cout1)
            0 : sum_h = sum2;
            1 : sum_h = sum3;
        endcase
    end
    
    assign sum = {sum_h, sum1};
    
endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
    
    wire cin = 1'b0;
    wire cout;
    wire [15:0] sum1, sum2;
    
    add16 u1_add16 (a[15:0], b[15:0], cin, sum1, cout);
    add16 u2_add16 (a[31:16], b[31:16], cout, sum2, cout);
    
    assign sum = {sum2, sum1};
    
endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
    
    wire cin = 1'b0;
    wire cout;
    wire [15:0] sum1, sum2;
    
    add16 u1_add16 (a[15:0], b[15:0], cin, sum1, cout);
    add16 u2_add16 (a[31:16], b[31:16], cout, sum2, cout);
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
    
    wire cin = 1'b0;
    wire cout;
    wire [15:0] sum1, sum2;
    
    add16 u1_add16 (
       .a(a[15:0]),
       .b(b[15:0]),
       .cin(cin),
       .sum(sum1),
       .cout(cout)
    );
    
    add16 u2_add16 (
       .a(a[31:16]),
       .b(b[31:16]),
       .cin(cout),
       .sum(sum2),
       .cout(cout)
    );
    
    assign sum = {sum2, sum1};
    
endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
    
    wire cin = 1'b0;
    wire cout;
    wire [15:0] sum1, sum2;
    
    add16 u1_add16 (
       .a(a[15:0]),
       .b(b[15:0]),
       .cin(cin),
       .sum(sum1),
       .cout(cout)
    );
    
    add16 u2_add16 (
       .a(a[31:16]),
       .b(b[31:16]),
       .cin(cout),
       .sum(sum2),
       .cout(cout)
    );
    
    assign sum = {sum2, sum1};
    
endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

wire [15:0] sum1, sum2;

add16 u1(a[15:0], b[15:0], 0, sum1, sum2);
add16 u2(a[31:16], b[31:16], sum2[15], sum, sum2);

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

wire [15:0] sum1, sum2;

add16 u1(a[15:0], b[15:0], 0, sum1, sum2);
add16 u2(a[31:16], b[31:16], sum2[15], sum, sum2);

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

wire [15:0] sum1, sum2;

add16 add1_0 (
   .a(a[15:0]),
   .b(b[15:0]),
   .cin(0),
   .sum(sum1),
   .cout(sum2[0])
);

add16 add1_1 (
   .a(a[31:16]),
   .b(b[31:16]),
   .cin(sum2[0]),
   .sum(sum1),
   .cout(sum2[1])
);

assign sum[31:16] = sum1;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

wire [15:0] sum1, sum2;

add16 add1_0 (
   .a(a[15:0]),
   .b(b[15:0]),
   .cin(0),
   .sum(sum1),
   .cout(sum2[0])
);

add16 add1_1 (
   .a(a[31:16]),
   .b(b[31:16]),
   .cin(sum2[0]),
   .sum(sum1),
   .cout(sum2[1])
);

assign sum[31:16] = sum1;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a + b;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
    
    assign sum = a + b;
    
endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
    
    assign sum = a + b;
    
endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a+b;

endmodule",-1,Module_fadd.v,"// you are given a module add16 that performs a 16-bit addition. You must instantiate two of them to create a 32-bit adder. 
// One add16 module computes the lower 16 bits of the addition result, 
// while the second add16 module computes the upper 16 bits of the result. 
// Your 32-bit adder does not need to handle carry-in (assume 0) or carry-out (ignored).

// Connect the add16 modules together as shown in the diagram below. The provided module add16 has the following declaration:

module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );

// Within each add16, 16 full adders (module add1, not provided) are instantiated to actually perform the addition. 
// You must write the full adder module that has the following declaration:

module add1 ( input a, input b, input cin, output sum, output cout );

// Recall that a full adder computes the sum and carry-out of a+b+cin.

// In summary, there are three modules in this design:

// Hint: top_module — Your top-level module that contains two of...
// add16, provided — A 16-bit adder module 
// add1 — A 1-bit full adder module.
// If your submission is missing a module add1, 
// you will get an error message that says Error (12006): Node instance ""user_fadd[0].a1"" instantiates undefined entity ""add1"".

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);
","module add16 ( input[15:0] a, input[15:0] b, input cin, output[15:0] sum, output cout );
    assign sum = a + b;
endmodule

module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
    // Insert your code here
);

assign sum = a+b;

endmodule","module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);//
    wire cin1, cout1, cout2;
    wire [15:0] sum1, sum2;
    assign cin1 = 0;
    add16 instance1(.a(a[15:0]), .b(b[15:0]), .cin(cin1), .cout(cout1), .sum(sum1));
    add16 instance2(.a(a[31:16]), .b(b[31:16]), .cin(cout1), .cout(cout2), .sum(sum2));
    
    assign sum = {sum2, sum1};

endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

// Full adder module here
    assign {cout, sum} = a + b + cin;

endmodule",,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",good,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);


endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);


endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1 (out1, out2, a, b, c, d);
endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a;
assign out2 = b;

endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a;
assign out2 = b;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",,,
"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);


endmodule",-1,Module_name.v,"e th// You are given a module named mod_a that has 2 outputs and 4 inputs, in some order. 
// You must connect the 6 ports by name to your top-level module's ports:

// Port in mod_a	Port in top_module
// output out1	out1
// output out2	out2
// input in1	a
// input in2	b
// input in3	c
// input in4	d

// You are given the following module:

module mod_a ( output out1, output out2, input in1, input in2, input in3, input in4);


module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);


endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2),);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a;
assign out2 = b;

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a;
assign out2 = b;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",good,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a instance1 (out1, out2, a, b, c, d);

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",good,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a aa(
       .out1(out1),
       .out2(out2),
       .a(a),
       .b(b),
       .c(c),
       .d(d)
    );

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

    mod_a aa(
       .out1(out1),
       .out2(out2),
       .a(a),
       .b(b),
       .c(c),
       .d(d)
    );

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",good,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a;
assign out2 = b;

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a;
assign out2 = b;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a & b;
assign out2 = c | d;

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a & b;
assign out2 = c | d;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a | b;
assign out2 = c | d;

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a | b;
assign out2 = c | d;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a & b;
assign out2 = c | d;

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a & b;
assign out2 = c | d;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a & b;
assign out2 = c | d;

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a & b;
assign out2 = c | d;

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a | b | c;
assign out2 = d | (a & b) | (b & c);

endmodule",-1,Module_pos.v,"// You are given a module named mod_a that has 2 outputs and 4 inputs, in that order. 
// You must connect the 6 ports by position to your top-level module's ports 
// out1, out2, a, b, c, and d, in that order.

// You are given the following module:

module mod_a ( output, output, input, input, input, input );

module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);

assign out1 = a | b | c;
assign out2 = d | (a & b) | (b & c);

endmodule","module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a instance1(out1, out2, a, b, c, d);
endmodule",bad,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff d1 (clk, d, q);
    my_dff d2 (clk, q, q);
    my_dff d3 (clk, q, q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff d1 (clk, d, q);
    my_dff d2 (clk, q, q);
    my_dff d3 (clk, q, q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",bad,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff ff1 (clk, d, q1);
    my_dff ff2 (q1, q2, q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff ff1 (clk, d, q1);
    my_dff ff2 (q1, q2, q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff ff1 (clk, d, q);
    my_dff ff2 (q, d, q1);
    my_dff ff3 (q1, d, q2);
    my_dff ff4 (q2, d, q3);
    my_dff ff5 (q3, d, q4);
    my_dff ff6 (q4, d, q5);
    my_dff ff7 (q5, d, q6);
    my_dff ff8 (q6, d, q7);
    my_dff ff9 (q7, d, q8);
    my_dff ff10 (q8, d, q9);
    my_dff ff11 (q9, d, q10);
    my_dff ff12 (q10, d, q11);
    my_dff ff13 (q11, d, q12);
    my_dff ff14 (q12, d, q13);
    my_dff ff15 (q13, d, q14);
    my_dff ff16 (q14, d, q15);
    my_dff ff17 (q15, d, q16);
    my_dff ff18 (q16, d, q17);
    my_dff ff19 (q17, d, q18);
    my_dff ff20 (q18, d, q19);
    my_dff ff21 (q19, d, q20);
    my_dff ff22 (q20, d, q21);
    my_dff ff23 (q21, d, q22);
    my_dff ff24 (q22, d, q23);
    my_dff ff25 (q23, d, q24);
    my_dff ff26 (q24, d, q25);
    my_dff ff27 (q25, d, q26);
    my_dff ff28 (q26, d, q27);
    my_dff ff29 (q27, d, q28);
    my_dff ff30 (q28, d, q29);
    my_dff ff31 (q29, d, q30);
    my_dff ff32 (q30, d, q31);
    my_dff ff33 (q31, d, q32);
    my_dff ff34 (q32, d, q33);
    my_dff ff35 (q33, d, q34);
    my_dff ff36 (q34, d, q35);
    my_dff ff37 (q35, d, q36);
    my_dff ff38 (q36, d, q37);
    my_dff ff39 (q37, d, q38);
    my_dff ff40 (q38, d, q39);
    my_dff ff41 (q39, d, q40);
    my_dff ff42 (q40, d, q41);
    my_dff ff43 (q41, d, q42);
    my_dff ff44 (q42, d, q43);
    my_dff ff45 (q43, d, q44);
    my_dff ff46 (q44, d, q45);
    my_dff ff47 (q45, d, q46);
    my_dff ff48 (q46, d, q47);
    my_dff ff49 (q47, d, q48);
    my_dff ff50 (q48, d, q49);
    my_dff ff51 (q49, d, q50);
    my_dff ff52 (q50, d, q51);
    my_dff ff53 (q51, d, q52);
    my_dff ff54 (q52, d, q53);
    my_dff ff55 (q53, d, q54);
    my_dff ff56 (q54, d, q55);
    my_dff ff57 (q55, d, q56);
    my_dff ff58 (q56, d, q57);
    my_dff ff59 (q57, d, q58);
    my_dff ff60 (q58, d, q59);
    my_dff",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff ff1 (clk, d, q);
    my_dff ff2 (q, d, q1);
    my_dff ff3 (q1, d, q2);
    my_dff ff4 (q2, d, q3);
    my_dff ff5 (q3, d, q4);
    my_dff ff6 (q4, d, q5);
    my_dff ff7 (q5, d, q6);
    my_dff ff8 (q6, d, q7);
    my_dff ff9 (q7, d, q8);
    my_dff ff10 (q8, d, q9);
    my_dff ff11 (q9, d, q10);
    my_dff ff12 (q10, d, q11);
    my_dff ff13 (q11, d, q12);
    my_dff ff14 (q12, d, q13);
    my_dff ff15 (q13, d, q14);
    my_dff ff16 (q14, d, q15);
    my_dff ff17 (q15, d, q16);
    my_dff ff18 (q16, d, q17);
    my_dff ff19 (q17, d, q18);
    my_dff ff20 (q18, d, q19);
    my_dff ff21 (q19, d, q20);
    my_dff ff22 (q20, d, q21);
    my_dff ff23 (q21, d, q22);
    my_dff ff24 (q22, d, q23);
    my_dff ff25 (q23, d, q24);
    my_dff ff26 (q24, d, q25);
    my_dff ff27 (q25, d, q26);
    my_dff ff28 (q26, d, q27);
    my_dff ff29 (q27, d, q28);
    my_dff ff30 (q28, d, q29);
    my_dff ff31 (q29, d, q30);
    my_dff ff32 (q30, d, q31);
    my_dff ff33 (q31, d, q32);
    my_dff ff34 (q32, d, q33);
    my_dff ff35 (q33, d, q34);
    my_dff ff36 (q34, d, q35);
    my_dff ff37 (q35, d, q36);
    my_dff ff38 (q36, d, q37);
    my_dff ff39 (q37, d, q38);
    my_dff ff40 (q38, d, q39);
    my_dff ff41 (q39, d, q40);
    my_dff ff42 (q40, d, q41);
    my_dff ff43 (q41, d, q42);
    my_dff ff44 (q42, d, q43);
    my_dff ff45 (q43, d, q44);
    my_dff ff46 (q44, d, q45);
    my_dff ff47 (q45, d, q46);
    my_dff ff48 (q46, d, q47);
    my_dff ff49 (q47, d, q48);
    my_dff ff50 (q48, d, q49);
    my_dff ff51 (q49, d, q50);
    my_dff ff52 (q50, d, q51);
    my_dff ff53 (q51, d, q52);
    my_dff ff54 (q52, d, q53);
    my_dff ff55 (q53, d, q54);
    my_dff ff56 (q54, d, q55);
    my_dff ff57 (q55, d, q56);
    my_dff ff58 (q56, d, q57);
    my_dff ff59 (q57, d, q58);
    my_dff ff60 (q58, d, q59);
    my_dff","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff d1 (clk, d, q1);
    my_dff d2 (q1, d, q2);
    my_dff d3 (q2, d, q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff d1 (clk, d, q1);
    my_dff d2 (q1, d, q2);
    my_dff d3 (q2, d, q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff d1(clk,d,q);
    my_dff d2(q,d,q1);
    my_dff d3(q1,d,q2);
    my_dff d4(q2,d,q3);
    my_dff d5(q3,d,q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff d1(clk,d,q);
    my_dff d2(q,d,q1);
    my_dff d3(q1,d,q2);
    my_dff d4(q2,d,q3);
    my_dff d5(q3,d,q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff ff1 (clk, d, q);
    my_dff ff2 (q, d, q1);
    my_dff ff3 (q1, d, q2);
    my_dff ff4 (q2, d, q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff ff1 (clk, d, q);
    my_dff ff2 (q, d, q1);
    my_dff ff3 (q1, d, q2);
    my_dff ff4 (q2, d, q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff d1(clk,d,q);
    my_dff d2(q,d,q1);
    my_dff d3(q1,d,q2);
    my_dff d4(q2,d,q3);
    my_dff d5(q3,d,q);
    
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff d1(clk,d,q);
    my_dff d2(q,d,q1);
    my_dff d3(q1,d,q2);
    my_dff d4(q2,d,q3);
    my_dff d5(q3,d,q);
    
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff d1(clk, d, q);
    my_dff d2(q, d, q1);
    my_dff d3(q1, d, q2);
    my_dff d4(q2, d, q3);
    my_dff d5(q3, d, q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff d1(clk, d, q);
    my_dff d2(q, d, q1);
    my_dff d3(q1, d, q2);
    my_dff d4(q2, d, q3);
    my_dff d5(q3, d, q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    my_dff d1(clk,d,q);
    my_dff d2(q,d,q1);
    my_dff d3(q1,d,q2);
    my_dff d4(q2,d,q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    my_dff d1(clk,d,q);
    my_dff d2(q,d,q1);
    my_dff d3(q1,d,q2);
    my_dff d4(q2,d,q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff ff1 (clk, d, q1);
    my_dff ff2 (q1, q2, q);
endmodule",-1,Module_shift.v,"// You are given a module my_dff with two inputs and one output (that implements a D flip-flop). 
// Instantiate three of them, then chain them together to make a shift register of length 3. 
// The clk port needs to be connected to all instances.

// The module provided to you is: 

module my_dff ( input clk, input d, output q );


module top_module ( input clk, input d, output q );","module my_dff (input clk, input d, output q);
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff ff1 (clk, d, q1);
    my_dff ff2 (q1, q2, q);
endmodule","module top_module ( input clk, input d, output q );
    wire q1, q2;
    my_dff instance1(.clk(clk), .d(d), .q(q1));
    my_dff instance2(.clk(clk), .d(q1), .q(q2));
    my_dff instance3(.clk(clk), .d(q2), .q(q));
endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write your code here
    reg [7:0] q_0;
    reg [7:0] q_1;
    reg [7:0] q_2;
    always @(posedge clk)
        begin
            case(sel)
                2'b00: q_0 <= d;
                2'b01: q_1 <= d;
                2'b10: q_2 <= d;
                2'b11: q_2 <= q_1;
            endcase
        end
    assign q = q_2;",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write your code here
    reg [7:0] q_0;
    reg [7:0] q_1;
    reg [7:0] q_2;
    always @(posedge clk)
        begin
            case(sel)
                2'b00: q_0 <= d;
                2'b01: q_1 <= d;
                2'b10: q_2 <= d;
                2'b11: q_2 <= q_1;
            endcase
        end
    assign q = q_2;","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @(*) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= d;
            2'b10: q <= d;
            2'b11: q <= 8'b00000000;
        endcase
    end

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @(*) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= d;
            2'b10: q <= d;
            2'b11: q <= 8'b00000000;
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase
    end

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase
    end

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk)
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk)
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase
    end

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0], d[7:1]};
            2'b10: q <= {d[1:0], d[7:2]};
            2'b11: q <= {d[2:0], d[7:3]};
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0],d[7:1]};
            2'b10: q <= {d[1:0],d[7:2]};
            2'b11: q <= {d[2:0],d[7:3]};
        endcase
    end

endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule  

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    always @ (posedge clk) begin
        case (sel)
            2'b00: q <= d;
            2'b01: q <= {d[0],d[7:1]};
            2'b10: q <= {d[1:0],d[7:2]};
            2'b11: q <= {d[2:0],d[7:3]};
        endcase
    end

endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write code here
    reg [7:0] q1, q2, q3;
    always @(posedge clk) begin
        q1 <= d;
        q2 <= q1;
        q3 <= q2;
    end
    
    always @(sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
    
    
endmodule",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write code here
    reg [7:0] q1, q2, q3;
    always @(posedge clk) begin
        q1 <= d;
        q2 <= q1;
        q3 <= q2;
    end
    
    always @(sel) begin
        case(sel)
            2'b00: q <= d;
            2'b01: q <= q1;
            2'b10: q <= q2;
            2'b11: q <= q3;
        endcase
    end
    
    
endmodule","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write your code here
    reg [7:0] q1, q2, q3;
    always @ (posedge clk) begin
        case (sel)
            2'b00: q1 <= d;
            2'b01: q2 <= d;
            2'b10: q3 <= d;
            default: q <= d;
        endcase
    end
    always @ (posedge clk) begin
        q <= q1;
    end
    
    // Write your code here
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write your code here
    reg [7:0] q1, q2, q3;
    always @ (posedge clk) begin
        case (sel)
            2'b00: q1 <= d;
            2'b01: q2 <= d;
            2'b10: q3 <= d;
            default: q <= d;
        endcase
    end
    always @ (posedge clk) begin
        q <= q1;
    end
    
    // Write your code here
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html
    
    // or browse Examples
    // https://www.fpga4student.com/2017/04/verilog-practice-8-using-case-statement-to.html","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write your code here
    reg [7:0] q_0, q_1, q_2;
    always @(posedge clk)
        case (sel)
            2'd0: q_0 <= d;
            2'd1: q_1 <= d;
            2'd2: q_2 <= d;
        endcase
    assign q = (sel == 2'd0)? q_0 :
               (sel == 2'd1)? q_1 :
               (sel == 2'd2)? q_2 : 8'd0;",-1,Module_shift8.v,"// You are given a module my_dff8 with two inputs and one output (that implements a set of 8 D flip-flops). 
// Instantiate three of them, then chain them together to make a 8-bit wide shift register of length 3. 
// In addition, create a 4-to-1 multiplexer (not provided) that chooses what to output depending on sel[1:0]: 
// The value at the input d, after the first, after the second, or after the third D flip-flop. 
// (Essentially, sel selects how many cycles to delay the input, from zero to three clock cycles.)

// The module provided to you is: 

module my_dff8 ( input clk, input [7:0] d, output [7:0] q );

// Hint: The multiplexer is not provided. One possible way to write one is inside an always block with a case statement inside.

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

","module my_dff8 ( input clk, input [7:0] d, output [7:0] q );    
    always @(posedge clk)
        q <= d;
endmodule

module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);

    // Write your code here
    reg [7:0] q_0, q_1, q_2;
    always @(posedge clk)
        case (sel)
            2'd0: q_0 <= d;
            2'd1: q_1 <= d;
            2'd2: q_2 <= d;
        endcase
    assign q = (sel == 2'd0)? q_0 :
               (sel == 2'd1)? q_1 :
               (sel == 2'd2)? q_2 : 8'd0;","module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    
    wire [7:0] q1, q2, q3;
    my_dff8 instance1(.clk(clk), .d(d), .q(q1));
    my_dff8 instance2(.clk(clk), .d(q1), .q(q2));
    my_dff8 instance3(.clk(clk), .d(q2), .q(q3));
    
    always @(*) begin
        case(sel)
            0 : q = d;
            1 : q = q1;
            2 : q = q2;
            3 : q = q3;
        endcase
    end

endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

//Define a module called mod_a. It has two ports (a and b), and one output (out)
module mod_a ( input a, input b, output out );

//Define the instance of the module mod_a
//Notice that the instance name is the same as the module name
//(in this case, mod_a). 
//Inside the instance, define the ports as wires. 
//Connect the ports to other wires or to other modules.
//In this example, the ports are connected to wires, which are then
//connected to other wires or modules.

assign out = a & b;

endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );

//Define a module called mod_a. It has two ports (a and b), and one output (out)
module mod_a ( input a, input b, output out );

//Define the instance of the module mod_a
//Notice that the instance name is the same as the module name
//(in this case, mod_a). 
//Inside the instance, define the ports as wires. 
//Connect the ports to other wires or to other modules.
//In this example, the ports are connected to wires, which are then
//connected to other wires or modules.

assign out = a & b;

endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );

wire w1, w2, w3;

mod_a instance1 (a, b, w1);
mod_b instance2 (a, b, w2);
mod_c instance3 (a, b, w3);

assign out = w1 | w2 | w3;

endmodule",-1,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );

wire w1, w2, w3;

mod_a instance1 (a, b, w1);
mod_b instance2 (a, b, w2);
mod_c instance3 (a, b, w3);

assign out = w1 | w2 | w3;

endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule",-0.5,Module_1.v,"// create one instance of module mod_a, then connect the module's three pins (in1, in2, and out) 
// to your top-level module's three ports (wires a, b, and out). 
//The module mod_a is provided for you — you must instantiate it.


//Hint: When connecting modules, only the ports on the module are important. 
// You do not need to know the code inside the module. 
// The code for module mod_a looks like this:

module top_module ( input a, input b, output out );","module top_module ( input a, input b, output out );
    assign out = a & b;
endmodule","module top_module ( input a, input b, output out );
    mod_a instance1(.out(out), .in1(a), .in2(b));
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    
    assign z = (A == B)? 1:0;
    
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );
    
    assign z = (A == B)? 1:0;
    
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for the circuit here

assign z = (A == B);

endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for the circuit here

assign z = (A == B);

endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;

endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;

endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for an AND gate here. Your code should be very simple.
assign z = (A & B);

endmodule",-0.5,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for an AND gate here. Your code should be very simple.
assign z = (A & B);

endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for the circuit here

assign z = (A == B);

endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for the circuit here

assign z = (A == B);

endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for an AND gate here. The output z should be 1 only if A = B.
// The AND gate should have two ports, one for each input. Use the wires l1 and l2.

assign l1 = A[0] & B[0];
assign l2 = A[1] & B[1];
assign z = l1 | l2;

endmodule",-0.5,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );

// Write code for an AND gate here. The output z should be 1 only if A = B.
// The AND gate should have two ports, one for each input. Use the wires l1 and l2.

assign l1 = A[0] & B[0];
assign l2 = A[1] & B[1];
assign z = l1 | l2;

endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule",1,Mt2015_eq2.v,"// Create a circuit that has two 2-bit inputs A[1:0] and B[1:0], and produces an output z. 
// The value of z should be 1 if A = B, otherwise z should be 0.


module top_module ( input [1:0] A, input [1:0] B, output z );
","module top_module ( input [1:0] A, input [1:0] B, output z );
    assign z = (A==B)?1:0;
endmodule","module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @(*) begin
    if(A == B)
        z = 1;
    else
        z = 0;
    end
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule",-0.5,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = x ^ y;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule",1,Mt2015_q4a.v,"// Module A is supposed to implement the function z = (x^y) & x. Implement this module.


module top_module (input x, input y, output z);
","module top_module (input x, input y, output z);
    assign z = (x^y) & x;
    
endmodule","module top_module (input x, input y, output z);
    assign z = (x ^ y) & x;
endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule",1,Mux256to1.v,"// Create a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed into a 
// single 256-bit input vector. sel=0 should select in[0], sel=1 selects bits in[1], 
// sel=2 selects bits in[2], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that 
// the width of the bits being selected is constant. In particular, 
// selecting one bit out of a vector using a variable index will work.


module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];
    
endmodule","module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out = in[sel];

endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];

endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule",-1,Mux256to1v.v,"// Create a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all packed into a single 1024-bit input vector. 
// sel=0 should select bits in[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.

// Hint: With this many options, a case statement isn't so useful.
// Vector indices can be variable, as long as the synthesizer can figure out that the width of the bits being selected is constant. It's not always good at this. An error saying ""... is not a constant"" means it couldn't prove that the select width is constant. In particular, in[ sel*4+3 : sel*4 ] does not work.
// Bit slicing (""Indexed vector part select"", since Verilog-2001) has an even more compact syntax.

module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 : sel*4];
    
endmodule","module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

    assign out = in[sel*4+3 -: 4]; // - and : should be put together
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = sel? b : a;

endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = sel? b : a;

endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );

    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );

    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule",1,Mux2to1.v,"//Create a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

//Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.

module top_module( 
    input a, b, sel,
    output out );","module top_module( 
    input a, b, sel,
    output out );
    
    assign out = sel? b : a;
    
endmodule","module top_module( 
    input a, b, sel,
    output out ); 

    assign out = sel ? b : a;
    
endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    // assign out = sel? b : a;
    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    // assign out = sel? b : a;
    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );//

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule",1,Mux2to1v.v,"// Create a 100-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When sel=1, choose b.

// Hint: The ternary operator (cond ? iftrue : iffalse) is easier to read.


module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );

    assign out = sel? b : a;

endmodule","module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
    
    assign out = sel ? b : a;

endmodule",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hffff;
    
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hffff;
    
endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                 sel == 4'b0001? b :
                 sel == 4'b0010? c :
                 sel == 4'b0011? d :
                 sel == 4'b0100? e :
                 sel == 4'b0101? f :
                 sel == 4'b0110? g :
                 sel == 4'b0111? h :
                 sel == 4'b1000? i :
                 16'bXXXXXXXXXXXXXXXX;
endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                 sel == 4'b0001? b :
                 sel == 4'b0010? c :
                 sel == 4'b0011? d :
                 sel == 4'b0100? e :
                 sel == 4'b0101? f :
                 sel == 4'b0110? g :
                 sel == 4'b0111? h :
                 sel == 4'b1000? i :
                 16'bXXXXXXXXXXXXXXXX;
endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hXXXX;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hXXXX;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                1'bx;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                1'bx;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hXXXX;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hXXXX;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hffff;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hffff;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    assign out = sel == 4'd0? a :
                sel == 4'd1? b :
                sel == 4'd2? c :
                sel == 4'd3? d :
                sel == 4'd4? e :
                sel == 4'd5? f :
                sel == 4'd6? g :
                sel == 4'd7? h :
                sel == 4'd8? i :
                sel == 4'd9? 1'b1 :
                                 1'b0;
                
endmodule",-0.5,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    assign out = sel == 4'd0? a :
                sel == 4'd1? b :
                sel == 4'd2? c :
                sel == 4'd3? d :
                sel == 4'd4? e :
                sel == 4'd5? f :
                sel == 4'd6? g :
                sel == 4'd7? h :
                sel == 4'd8? i :
                sel == 4'd9? 1'b1 :
                                 1'b0;
                
endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'd0? a :
                sel == 4'd1? b :
                sel == 4'd2? c :
                sel == 4'd3? d :
                sel == 4'd4? e :
                sel == 4'd5? f :
                sel == 4'd6? g :
                sel == 4'd7? h :
                sel == 4'd8? i :
                'b;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'd0? a :
                sel == 4'd1? b :
                sel == 4'd2? c :
                sel == 4'd3? d :
                sel == 4'd4? e :
                sel == 4'd5? f :
                sel == 4'd6? g :
                sel == 4'd7? h :
                sel == 4'd8? i :
                'b;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel==4'b0000? a :
                 sel==4'b0001? b :
                 sel==4'b0010? c :
                 sel==4'b0011? d :
                 sel==4'b0100? e :
                 sel==4'b0101? f :
                 sel==4'b0110? g :
                 sel==4'b0111? h :
                 sel==4'b1000? i :
                 16'hXXXX;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel==4'b0000? a :
                 sel==4'b0001? b :
                 sel==4'b0010? c :
                 sel==4'b0011? d :
                 sel==4'b0100? e :
                 sel==4'b0101? f :
                 sel==4'b0110? g :
                 sel==4'b0111? h :
                 sel==4'b1000? i :
                 16'hXXXX;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hXXXX;

endmodule",-1,Mux9to1v.v,"// Create a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses b, etc. 
// For the unused cases (sel=9 to 15), set all output bits to '1'.

// Hint: With this many options, a case statement may be useful.

module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    assign out = sel == 4'b0000? a :
                sel == 4'b0001? b :
                sel == 4'b0010? c :
                sel == 4'b0011? d :
                sel == 4'b0100? e :
                sel == 4'b0101? f :
                sel == 4'b0110? g :
                sel == 4'b0111? h :
                sel == 4'b1000? i :
                16'hXXXX;

endmodule","module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );
    
    always @(*) begin
        case(sel)
            0 : out = a;
            1 : out = b;
            2 : out = c;
            3 : out = d;
            4 : out = e;
            5 : out = f;
            6 : out = g;
            7 : out = h;
            8 : out = i;
            default : out = 16'hffff;
        endcase
    end

endmodule
",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a|b);
    
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a|b);
    
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a|b);
    
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a|b);
    
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a|b);

endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a|b);

endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule",1,Norgate.v,"// Create a module that implements a NOR gate. 
// A NOR gate is an OR gate with its output inverted. 
// A NOR function needs two operators when written in Verilog.

// Hint: Verilog has separate bitwise-OR (|) and logical-OR (||) operators, like C. 
// Since we're working with a one-bit here, it doesn't matter which we choose.

module top_module( 
    input a, 
    input b, 
    output out );
","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a|b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a | b);
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = 0;
    
    integer i;
    
    always @(*) begin
        for(i=0; i<255; i=i+1) begin
            if(in[i])
                out = out + 1;
        end
    end
    
endmodule",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = 0;
    
    integer i;
    
    always @(*) begin
        for(i=0; i<255; i=i+1) begin
            if(in[i])
                out = out + 1;
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    // assign out = (in == 0)? 0 : ( (in == 1)? 1 : ( (in > 1)? 1 : 0 ) );
    
    assign out = (in == 0)? 0 : ((in[0] == 1'b1)? 1 : ((in[1] == 1'b1)? 2 : ((in[2] == 1'b1)? 3 : ((in[3] == 1'b1)? 4 : ((in[4] == 1'b1)? 5 : ((in[5] == 1'b1)? 6 : ((in[6] == 1'b1)? 7 : ((in[7] == 1'b1)? 8 : ((in[8] == 1'b1)? 9 : ((in[9] == 1'b1)? 10 : ((in[10] == 1'b1)? 11 : ((in[11] == 1'b1)? 12 : ((in[12] == 1'b1)? 13 : ((in[13] == 1'b1)? 14 : ((in[14] == 1'b1)? 15 : ((in[15] == 1'b1)? 16 : ((in[16] == 1'b1)? 17 : ((in[17] == 1'b1)? 18 : ((in[18] == 1'b1)? 19 : ((in[19] == 1'b1)? 20 : ((in[20] == 1'b1)? 21 : ((in[21] == 1'b1)? 22 : ((in[22] == 1'b1)? 23 : ((in[23] == 1'b1)? 24 : ((in[24] == 1'b1)? 25 : ((in[25] == 1'b1)? 26 : ((in[26] == 1'b1)? 27 : ((in[27] == 1'b1)? 28 : ((in[28] == 1'b1)? 29 : ((in[29] == 1'b1)? 30 : ((in[30] == 1'b1)? 31 : ((in[31] == 1'b1)? 32 : ((in[32] == 1'b1)? 33 : ((in[33] == 1'b1)? 34 : ((in[34] == 1'b1)? 35 : ((in[35] == 1'b1)? 36 : ((in[36] == 1'b1)? 37 : ((in[37] == 1'b1)? 38 : ((in[38] == 1'b1)? 39 : ((in[39] == 1'b1)? 40 : ((in[40] == 1'b1)? 41 : ((in[41] == 1'b1)? 42 : ((in[42] == 1'b1)? 43 : ((in[43] == 1'b1)? 44 : ((in[44] == 1'b1)? 45 : ((in[45] == 1'b1)? 46 : ((in[46] == 1'b1)? 47 : ((in[47] == 1'b1)? 48 : ((in[48] == 1'b1)? 49 : ((in[49] == 1'b1)? 50 : ((in[50] == 1'b1)? 51 : ((in[51] == 1'b1)? 52 : ((in[52] == 1'b1)? 53 : ((in[53] == 1'b1)? 54 : ((in[54] == 1'b1)? 55 : ((in[55] == 1'b1)? 56 : ((in[56] == 1'b1)? 57 : ((in[57] == 1'b1)? 58 : ((in[58] == 1'b1)? 59 : ((in[59] == 1'b1)? 60 : ((in[60] == 1'b1)? 61 : ((in[61] == 1'b1)? 62 : ((in[62] == 1'b1)? 63 : ((in[63] == 1'b1)? 64 : ((in[64] == 1'b1)? 65 : ((in[65] == 1'b1)? 66 : ((in[66] == 1'b1)? 67 : ((in[67] == 1'b1)? 68 : ((in[68] == 1'b1)? 69 : ((in[69]",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    // assign out = (in == 0)? 0 : ( (in == 1)? 1 : ( (in > 1)? 1 : 0 ) );
    
    assign out = (in == 0)? 0 : ((in[0] == 1'b1)? 1 : ((in[1] == 1'b1)? 2 : ((in[2] == 1'b1)? 3 : ((in[3] == 1'b1)? 4 : ((in[4] == 1'b1)? 5 : ((in[5] == 1'b1)? 6 : ((in[6] == 1'b1)? 7 : ((in[7] == 1'b1)? 8 : ((in[8] == 1'b1)? 9 : ((in[9] == 1'b1)? 10 : ((in[10] == 1'b1)? 11 : ((in[11] == 1'b1)? 12 : ((in[12] == 1'b1)? 13 : ((in[13] == 1'b1)? 14 : ((in[14] == 1'b1)? 15 : ((in[15] == 1'b1)? 16 : ((in[16] == 1'b1)? 17 : ((in[17] == 1'b1)? 18 : ((in[18] == 1'b1)? 19 : ((in[19] == 1'b1)? 20 : ((in[20] == 1'b1)? 21 : ((in[21] == 1'b1)? 22 : ((in[22] == 1'b1)? 23 : ((in[23] == 1'b1)? 24 : ((in[24] == 1'b1)? 25 : ((in[25] == 1'b1)? 26 : ((in[26] == 1'b1)? 27 : ((in[27] == 1'b1)? 28 : ((in[28] == 1'b1)? 29 : ((in[29] == 1'b1)? 30 : ((in[30] == 1'b1)? 31 : ((in[31] == 1'b1)? 32 : ((in[32] == 1'b1)? 33 : ((in[33] == 1'b1)? 34 : ((in[34] == 1'b1)? 35 : ((in[35] == 1'b1)? 36 : ((in[36] == 1'b1)? 37 : ((in[37] == 1'b1)? 38 : ((in[38] == 1'b1)? 39 : ((in[39] == 1'b1)? 40 : ((in[40] == 1'b1)? 41 : ((in[41] == 1'b1)? 42 : ((in[42] == 1'b1)? 43 : ((in[43] == 1'b1)? 44 : ((in[44] == 1'b1)? 45 : ((in[45] == 1'b1)? 46 : ((in[46] == 1'b1)? 47 : ((in[47] == 1'b1)? 48 : ((in[48] == 1'b1)? 49 : ((in[49] == 1'b1)? 50 : ((in[50] == 1'b1)? 51 : ((in[51] == 1'b1)? 52 : ((in[52] == 1'b1)? 53 : ((in[53] == 1'b1)? 54 : ((in[54] == 1'b1)? 55 : ((in[55] == 1'b1)? 56 : ((in[56] == 1'b1)? 57 : ((in[57] == 1'b1)? 58 : ((in[58] == 1'b1)? 59 : ((in[59] == 1'b1)? 60 : ((in[60] == 1'b1)? 61 : ((in[61] == 1'b1)? 62 : ((in[62] == 1'b1)? 63 : ((in[63] == 1'b1)? 64 : ((in[64] == 1'b1)? 65 : ((in[65] == 1'b1)? 66 : ((in[66] == 1'b1)? 67 : ((in[67] == 1'b1)? 68 : ((in[68] == 1'b1)? 69 : ((in[69]","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    // assign out = (in == 0)? 0 :
    //              (in == 1)? 0 :
    //              (in == 2)? 0 :
    //              (in == 3)? 0 :
    //              (in == 4)? 0 :
    //              (in == 5)? 0 :
    //              (in == 6)? 0 :
    //              (in == 7)? 0 :
    //              (in == 8)? 0 :
    //              (in == 9)? 0 :
    //              (in == 10)? 0 :
    //              (in == 11)? 0 :
    //              (in == 12)? 0 :
    //              (in == 13)? 0 :
    //              (in == 14)? 0 :
    //              (in == 15)? 0 :
    //              (in == 16)? 0 :
    //              (in == 17)? 0 :
    //              (in == 18)? 0 :
    //              (in == 19)? 0 :
    //              (in == 20)? 0 :
    //              (in == 21)? 0 :
    //              (in == 22)? 0 :
    //              (in == 23)? 0 :
    //              (in == 24)? 0 :
    //              (in == 25)? 0 :
    //              (in == 26)? 0 :
    //              (in == 27)? 0 :
    //              (in == 28)? 0 :
    //              (in == 29)? 0 :
    //              (in == 30)? 0 :
    //              (in == 31)? 0 :
    //              (in == 32)? 0 :
    //              (in == 33)? 0 :
    //              (in == 34)? 0 :
    //              (in == 35)? 0 :
    //              (in == 36)? 0 :
    //              (in == 37)? 0 :
    //              (in == 38)? 0 :
    //              (in == 39)? 0 :
    //              (in == 40)? 0 :
    //              (in == 41)? 0 :
    //              (in == 42)? 0 :
    //              (in == 43)? 0 :
    //              (in == 44)? 0 :
    //              (in == 45)? 0 :
    //              (in == 46)? 0 :
    //              (in == 47)? 0 :
    //              (in == 48)? 0 :
    //              (in == 49)? 0 :
    //              (in == 50)? 0 :
    //              (in == 51)? 0 :
    //              (in == 52)? 0 :
    //              (in == 53)? 0 :
    //              (in == 54)? 0 :
    //              (in == 55)? 0 :
    //              (in == 56)? 0 :
    //              (in == 57)? 0 :
    //              (in == 58)? 0 :
    //              (in == 59)? 0 :
    //              (in == 60)? 0 :
    //              (in == 61)? 0 :
    //              (in == 62)? 0 :
    //              (in == 63)? 0 :
    //              (in == 64)? 0 :
    //              (in == 65)? 0 :
    //              (in == 66)? 0 :
    //              (in == 67)? 0 :
    //              (in == 68)? 0 :
    //              (in == 69)? 0 :
    //              (in == 70)? 0 :
    //              (in == 71)? 0 :
    //              (in == 72)? 0 :
    //              (in == 73)? 0 :
    //              (in == 74)? 0 :
    //              (in == 75)? 0 :
    //              (in == 76)? 0 :
    //              (in == 77)? 0 :
    //              (in == 78)? 0 :
    //              (in == 79)? 0 :
    //              (in == 80)? 0 :
    //              (in == 81)? 0 :
    //              (in == 82)? 0 :
    //              (in == 83)? 0 :
    //              (in == 84)? 0 :",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    // assign out = (in == 0)? 0 :
    //              (in == 1)? 0 :
    //              (in == 2)? 0 :
    //              (in == 3)? 0 :
    //              (in == 4)? 0 :
    //              (in == 5)? 0 :
    //              (in == 6)? 0 :
    //              (in == 7)? 0 :
    //              (in == 8)? 0 :
    //              (in == 9)? 0 :
    //              (in == 10)? 0 :
    //              (in == 11)? 0 :
    //              (in == 12)? 0 :
    //              (in == 13)? 0 :
    //              (in == 14)? 0 :
    //              (in == 15)? 0 :
    //              (in == 16)? 0 :
    //              (in == 17)? 0 :
    //              (in == 18)? 0 :
    //              (in == 19)? 0 :
    //              (in == 20)? 0 :
    //              (in == 21)? 0 :
    //              (in == 22)? 0 :
    //              (in == 23)? 0 :
    //              (in == 24)? 0 :
    //              (in == 25)? 0 :
    //              (in == 26)? 0 :
    //              (in == 27)? 0 :
    //              (in == 28)? 0 :
    //              (in == 29)? 0 :
    //              (in == 30)? 0 :
    //              (in == 31)? 0 :
    //              (in == 32)? 0 :
    //              (in == 33)? 0 :
    //              (in == 34)? 0 :
    //              (in == 35)? 0 :
    //              (in == 36)? 0 :
    //              (in == 37)? 0 :
    //              (in == 38)? 0 :
    //              (in == 39)? 0 :
    //              (in == 40)? 0 :
    //              (in == 41)? 0 :
    //              (in == 42)? 0 :
    //              (in == 43)? 0 :
    //              (in == 44)? 0 :
    //              (in == 45)? 0 :
    //              (in == 46)? 0 :
    //              (in == 47)? 0 :
    //              (in == 48)? 0 :
    //              (in == 49)? 0 :
    //              (in == 50)? 0 :
    //              (in == 51)? 0 :
    //              (in == 52)? 0 :
    //              (in == 53)? 0 :
    //              (in == 54)? 0 :
    //              (in == 55)? 0 :
    //              (in == 56)? 0 :
    //              (in == 57)? 0 :
    //              (in == 58)? 0 :
    //              (in == 59)? 0 :
    //              (in == 60)? 0 :
    //              (in == 61)? 0 :
    //              (in == 62)? 0 :
    //              (in == 63)? 0 :
    //              (in == 64)? 0 :
    //              (in == 65)? 0 :
    //              (in == 66)? 0 :
    //              (in == 67)? 0 :
    //              (in == 68)? 0 :
    //              (in == 69)? 0 :
    //              (in == 70)? 0 :
    //              (in == 71)? 0 :
    //              (in == 72)? 0 :
    //              (in == 73)? 0 :
    //              (in == 74)? 0 :
    //              (in == 75)? 0 :
    //              (in == 76)? 0 :
    //              (in == 77)? 0 :
    //              (in == 78)? 0 :
    //              (in == 79)? 0 :
    //              (in == 80)? 0 :
    //              (in == 81)? 0 :
    //              (in == 82)? 0 :
    //              (in == 83)? 0 :
    //              (in == 84)? 0 :","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    integer i;
    
    assign out = 0;
    
    for(i=0;i<255;i=i+1) begin
        if(in[i] == 1)
            out = out + 1;
    end

endmodule",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    integer i;
    
    assign out = 0;
    
    for(i=0;i<255;i=i+1) begin
        if(in[i] == 1)
            out = out + 1;
    end

endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    assign out = 0;
    
    integer i;
    
    always @(*) begin
        for(i=0;i<255;i=i+1) begin
            if(in[i]) begin
                out = out + 1;
            end
        end
    end
    
endmodule",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    assign out = 0;
    
    integer i;
    
    always @(*) begin
        for(i=0;i<255;i=i+1) begin
            if(in[i]) begin
                out = out + 1;
            end
        end
    end
    
endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    // assign out = (in == 0)? 0 :
    //              (in == 1)? 0 :
    //              (in == 2)? 0 :
    //              (in == 3)? 0 :
    //              (in == 4)? 0 :
    //              (in == 5)? 0 :
    //              (in == 6)? 0 :
    //              (in == 7)? 0 :
    //              (in == 8)? 0 :
    //              (in == 9)? 0 :
    //              (in == 10)? 0 :
    //              (in == 11)? 0 :
    //              (in == 12)? 0 :
    //              (in == 13)? 0 :
    //              (in == 14)? 0 :
    //              (in == 15)? 0 :
    //              (in == 16)? 0 :
    //              (in == 17)? 0 :
    //              (in == 18)? 0 :
    //              (in == 19)? 0 :
    //              (in == 20)? 0 :
    //              (in == 21)? 0 :
    //              (in == 22)? 0 :
    //              (in == 23)? 0 :
    //              (in == 24)? 0 :
    //              (in == 25)? 0 :
    //              (in == 26)? 0 :
    //              (in == 27)? 0 :
    //              (in == 28)? 0 :
    //              (in == 29)? 0 :
    //              (in == 30)? 0 :
    //              (in == 31)? 0 :
    //              (in == 32)? 0 :
    //              (in == 33)? 0 :
    //              (in == 34)? 0 :
    //              (in == 35)? 0 :
    //              (in == 36)? 0 :
    //              (in == 37)? 0 :
    //              (in == 38)? 0 :
    //              (in == 39)? 0 :
    //              (in == 40)? 0 :
    //              (in == 41)? 0 :
    //              (in == 42)? 0 :
    //              (in == 43)? 0 :
    //              (in == 44)? 0 :
    //              (in == 45)? 0 :
    //              (in == 46)? 0 :
    //              (in == 47)? 0 :
    //              (in == 48)? 0 :
    //              (in == 49)? 0 :
    //              (in == 50)? 0 :
    //              (in == 51)? 0 :
    //              (in == 52)? 0 :
    //              (in == 53)? 0 :
    //              (in == 54)? 0 :
    //              (in == 55)? 0 :
    //              (in == 56)? 0 :
    //              (in == 57)? 0 :
    //              (in == 58)? 0 :
    //              (in == 59)? 0 :
    //              (in == 60)? 0 :
    //              (in == 61)? 0 :
    //              (in == 62)? 0 :
    //              (in == 63)? 0 :
    //              (in == 64)? 0 :
    //              (in == 65)? 0 :
    //              (in == 66)? 0 :
    //              (in == 67)? 0 :
    //              (in == 68)? 0 :
    //              (in == 69)? 0 :
    //              (in == 70)? 0 :
    //              (in == 71)? 0 :
    //              (in == 72)? 0 :
    //              (in == 73)? 0 :
    //              (in == 74)? 0 :
    //              (in == 75)? 0 :
    //              (in == 76)? 0 :
    //              (in == 77)? 0 :
    //              (in == 78)? 0 :
    //              (in == 79)? 0 :
    //              (in == 80)? 0 :
    //              (in == 81)? 0 :
    //              (in == 82)? 0 :
    //              (in == 83)? 0 :
    //              (in == 84)? 0 :",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    // assign out = (in == 0)? 0 :
    //              (in == 1)? 0 :
    //              (in == 2)? 0 :
    //              (in == 3)? 0 :
    //              (in == 4)? 0 :
    //              (in == 5)? 0 :
    //              (in == 6)? 0 :
    //              (in == 7)? 0 :
    //              (in == 8)? 0 :
    //              (in == 9)? 0 :
    //              (in == 10)? 0 :
    //              (in == 11)? 0 :
    //              (in == 12)? 0 :
    //              (in == 13)? 0 :
    //              (in == 14)? 0 :
    //              (in == 15)? 0 :
    //              (in == 16)? 0 :
    //              (in == 17)? 0 :
    //              (in == 18)? 0 :
    //              (in == 19)? 0 :
    //              (in == 20)? 0 :
    //              (in == 21)? 0 :
    //              (in == 22)? 0 :
    //              (in == 23)? 0 :
    //              (in == 24)? 0 :
    //              (in == 25)? 0 :
    //              (in == 26)? 0 :
    //              (in == 27)? 0 :
    //              (in == 28)? 0 :
    //              (in == 29)? 0 :
    //              (in == 30)? 0 :
    //              (in == 31)? 0 :
    //              (in == 32)? 0 :
    //              (in == 33)? 0 :
    //              (in == 34)? 0 :
    //              (in == 35)? 0 :
    //              (in == 36)? 0 :
    //              (in == 37)? 0 :
    //              (in == 38)? 0 :
    //              (in == 39)? 0 :
    //              (in == 40)? 0 :
    //              (in == 41)? 0 :
    //              (in == 42)? 0 :
    //              (in == 43)? 0 :
    //              (in == 44)? 0 :
    //              (in == 45)? 0 :
    //              (in == 46)? 0 :
    //              (in == 47)? 0 :
    //              (in == 48)? 0 :
    //              (in == 49)? 0 :
    //              (in == 50)? 0 :
    //              (in == 51)? 0 :
    //              (in == 52)? 0 :
    //              (in == 53)? 0 :
    //              (in == 54)? 0 :
    //              (in == 55)? 0 :
    //              (in == 56)? 0 :
    //              (in == 57)? 0 :
    //              (in == 58)? 0 :
    //              (in == 59)? 0 :
    //              (in == 60)? 0 :
    //              (in == 61)? 0 :
    //              (in == 62)? 0 :
    //              (in == 63)? 0 :
    //              (in == 64)? 0 :
    //              (in == 65)? 0 :
    //              (in == 66)? 0 :
    //              (in == 67)? 0 :
    //              (in == 68)? 0 :
    //              (in == 69)? 0 :
    //              (in == 70)? 0 :
    //              (in == 71)? 0 :
    //              (in == 72)? 0 :
    //              (in == 73)? 0 :
    //              (in == 74)? 0 :
    //              (in == 75)? 0 :
    //              (in == 76)? 0 :
    //              (in == 77)? 0 :
    //              (in == 78)? 0 :
    //              (in == 79)? 0 :
    //              (in == 80)? 0 :
    //              (in == 81)? 0 :
    //              (in == 82)? 0 :
    //              (in == 83)? 0 :
    //              (in == 84)? 0 :","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = in[0] + in[1] + in[2] + in[3] +
                in[4] + in[5] + in[6] + in[7] +
                in[8] + in[9] + in[10] + in[11] +
                in[12] + in[13] + in[14] + in[15] +
                in[16] + in[17] + in[18] + in[19] +
                in[20] + in[21] + in[22] + in[23] +
                in[24] + in[25] + in[26] + in[27] +
                in[28] + in[29] + in[30] + in[31] +
                in[32] + in[33] + in[34] + in[35] +
                in[36] + in[37] + in[38] + in[39] +
                in[40] + in[41] + in[42] + in[43] +
                in[44] + in[45] + in[46] + in[47] +
                in[48] + in[49] + in[50] + in[51] +
                in[52] + in[53] + in[54] + in[55] +
                in[56] + in[57] + in[58] + in[59] +
                in[60] + in[61] + in[62] + in[63] +
                in[64] + in[65] + in[66] + in[67] +
                in[68] + in[69] + in[70] + in[71] +
                in[72] + in[73] + in[74] + in[75] +
                in[76] + in[77] + in[78] + in[79] +
                in[80] + in[81] + in[82] + in[83] +
                in[84] + in[85] + in[86] + in[87] +
                in[88] + in[89] + in[90] + in[91] +
                in[92] + in[93] + in[94] + in[95] +
                in[96] + in[97] + in[98] + in[99] +
                in[100] + in[101] + in[102] + in[103] +
                in[104] + in[105] + in[106] + in[107] +
                in[108] + in[109] + in[110] + in[111] +
                in[112] + in[113] + in[114] + in[115] +
                in[116] + in[117] + in[118] + in[119] +
                in[120] + in[121] + in[122] + in[123] +
                in[124] + in[125] + in[126] + in[127] +
                in[128] + in[129] + in[130] + in[131] +
                in[132] + in[133] + in[134] + in[135] +
                in[136] + in[137] + in[138] + in[139] +
                in[140] + in[141] + in[142] + in[143] +
                in[144] + in[145] + in[146] + in[147] +
                in[148] + in[149] + in[150] + in[151] +
                in[152] + in[153] + in[154] + in[155] +
                in[156] + in[157] + in[158] + in[159] +
                in[160] + in[161] + in[162] + in[163] +
                in[164] + in[165] + in[166] + in[167] +
                in[168] + in[169] + in[170] + in[171] +
                in[172] + in[173] + in[174] + in[175] +
                in[176] + in[177] + in[178] + in[179] +
                in[180] + in[181] + in[182] + in[183] +
                in[184] + in",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = in[0] + in[1] + in[2] + in[3] +
                in[4] + in[5] + in[6] + in[7] +
                in[8] + in[9] + in[10] + in[11] +
                in[12] + in[13] + in[14] + in[15] +
                in[16] + in[17] + in[18] + in[19] +
                in[20] + in[21] + in[22] + in[23] +
                in[24] + in[25] + in[26] + in[27] +
                in[28] + in[29] + in[30] + in[31] +
                in[32] + in[33] + in[34] + in[35] +
                in[36] + in[37] + in[38] + in[39] +
                in[40] + in[41] + in[42] + in[43] +
                in[44] + in[45] + in[46] + in[47] +
                in[48] + in[49] + in[50] + in[51] +
                in[52] + in[53] + in[54] + in[55] +
                in[56] + in[57] + in[58] + in[59] +
                in[60] + in[61] + in[62] + in[63] +
                in[64] + in[65] + in[66] + in[67] +
                in[68] + in[69] + in[70] + in[71] +
                in[72] + in[73] + in[74] + in[75] +
                in[76] + in[77] + in[78] + in[79] +
                in[80] + in[81] + in[82] + in[83] +
                in[84] + in[85] + in[86] + in[87] +
                in[88] + in[89] + in[90] + in[91] +
                in[92] + in[93] + in[94] + in[95] +
                in[96] + in[97] + in[98] + in[99] +
                in[100] + in[101] + in[102] + in[103] +
                in[104] + in[105] + in[106] + in[107] +
                in[108] + in[109] + in[110] + in[111] +
                in[112] + in[113] + in[114] + in[115] +
                in[116] + in[117] + in[118] + in[119] +
                in[120] + in[121] + in[122] + in[123] +
                in[124] + in[125] + in[126] + in[127] +
                in[128] + in[129] + in[130] + in[131] +
                in[132] + in[133] + in[134] + in[135] +
                in[136] + in[137] + in[138] + in[139] +
                in[140] + in[141] + in[142] + in[143] +
                in[144] + in[145] + in[146] + in[147] +
                in[148] + in[149] + in[150] + in[151] +
                in[152] + in[153] + in[154] + in[155] +
                in[156] + in[157] + in[158] + in[159] +
                in[160] + in[161] + in[162] + in[163] +
                in[164] + in[165] + in[166] + in[167] +
                in[168] + in[169] + in[170] + in[171] +
                in[172] + in[173] + in[174] + in[175] +
                in[176] + in[177] + in[178] + in[179] +
                in[180] + in[181] + in[182] + in[183] +
                in[184] + in","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    integer i;
    always @(*) begin
        out = 0;
        for(i=0;i<255;i=i+1) begin
            if(in[i] == 1'b1)
                out = out + 1;
        end
    end

endmodule",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    integer i;
    always @(*) begin
        out = 0;
        for(i=0;i<255;i=i+1) begin
            if(in[i] == 1'b1)
                out = out + 1;
        end
    end

endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i;
    
    assign out = 0;
    
    always @(*)
        for(i=0; i<255; i=i+1)
            if(in[i])
                out = out + 1;

endmodule",-1,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );
    
    integer i;
    
    assign out = 0;
    
    always @(*)
        for(i=0; i<255; i=i+1)
            if(in[i])
                out = out + 1;

endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = in[7:0] + in[15:8] + in[23:16] + in[31:24] +
                in[39:32] + in[47:40] + in[55:48] + in[63:56] +
                in[71:64] + in[79:72] + in[87:80] + in[95:88] +
                in[103:96] + in[111:104] + in[119:112] + in[127:120];

endmodule",-0.5,Popcount255.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
// Build a population count circuit for a 255-bit input vector.

// Hint: So many things to add... How about a for loop?

module top_module( 
    input [254:0] in,
    output [7:0] out );","module top_module( 
    input [254:0] in,
    output [7:0] out );

    assign out = in[7:0] + in[15:8] + in[23:16] + in[31:24] +
                in[39:32] + in[47:40] + in[55:48] + in[63:56] +
                in[71:64] + in[79:72] + in[87:80] + in[95:88] +
                in[103:96] + in[111:104] + in[119:112] + in[127:120];

endmodule","module top_module( 
    input [254:0] in,
    output [7:0] out );

    always @(*) begin
        out = 0;
        for(int i = 0; i < 255; i++) begin
            if(in[i])
                out = out + 1;
            else
                out = out + 0;
        end
    end
    
endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = (in == 3'd0 || in == 3'd1 || in == 3'd3)? 2'd1 : 2'd0;
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = (in == 3'd0 || in == 3'd1 || in == 3'd3)? 2'd1 : 2'd0;
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out[0] = in[0] + in[1];
    assign out[1] = in[1] + in[2];
    
endmodule",-0.5,Popcount3.v,"// A ""population count"" circuit counts the number of '1's in an input vector. 
//Build a population count circuit for a 3-bit input vector.

module top_module( 
    input [2:0] in,
    output [1:0] out );
","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    assign out[0] = in[0] + in[1];
    assign out[1] = in[1] + in[2];
    
endmodule","module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    
    always @(*) begin
        out = 0;
        for(i = 0; i < 3; i ++) begin
            if(in[i])
                out = out + 1;
        end
    end

endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;

endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;

endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule",1,Reduction.v,"// Parity checking is often used as a simple method of detecting errors when 
// transmitting data through an imperfect channel. Create a circuit that will 
// compute a parity bit for a 8-bit byte (which will add a 9th bit to the byte). 
// We will use ""even"" parity, where the parity bit is just the XOR of all 8 data bits.

module top_module (
    input [7:0] in,
    output parity);

","module top_module (
    input [7:0] in,
    output parity);

    assign parity = ^in;
    
endmodule","module top_module (
    input [7:0] in,
    output parity); 
    assign parity = ^ in[7:0];
endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring & ~vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule",1,Ringer.v,"// Suppose you are designing a circuit to control a cellphone's ringer and vibration motor. 
// Whenever the phone needs to ring from an incoming call (input ring), your circuit must either 
// turn on the ringer (output ringer = 1) or the motor (output motor = 1), but not both. 
// If the phone is in vibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn on the ringer.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Design hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. This is often the opposite 
// of how one would think about a (sequential, imperative) programming problem, where one would look 
// at the inputs first then decide on an action (or output). For sequential programs, one would 
// often think ""If (inputs are ___ ) then (output should be ___ )"". On the other hand, hardware 
// designers often think ""The (output should be ___ ) when (inputs are ___ )"".
// For this particular problem, one should be thinking ""The motor is on when ___"", rather than ""If (vibrate mode) then ___"".

module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);


    assign motor = ring & vibrate_mode;
    assign ringer = ring &!vibrate_mode;

endmodule","module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
    
    assign ringer = ring & (~vibrate_mode);
    assign motor = ring & vibrate_mode;

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;

    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end

    assign q = temp;

endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;

    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end

    assign q = temp;

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load) begin
            temp <= data;
        end
        else begin
            temp <= temp;
        end
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load) begin
            temp <= data;
        end
        else begin
            temp <= temp;
        end
    end
    
    assign q = temp;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <= q;
    end
    
endmodule",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <= q;
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load) temp <= data;
        else begin
            q <= temp;
            temp <= q;
        end
    end
    
endmodule",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load) temp <= data;
        else begin
            q <= temp;
            temp <= q;
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;

    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end

    assign q = temp;

endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;

    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end

    assign q = temp;

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @ (posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @ (posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    reg [511:0] temp;
    
    always @(posedge clk) begin
        if(load)
            temp <= data;
        else
            temp <= temp;
    end
    
    assign q = temp;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <= {q[510:0],1'b0};
    end

endmodule",-1,Rule110.v,"// Rule 110 is a one-dimensional cellular automaton with interesting properties (such as being Turing-complete).

// There is a one-dimensional array of cells (on or off). At each time step, the state of each cell changes. In Rule 110, the next state of each cell depends only on itself and its two neighbours, according to the following table:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	1
// 1	0	0	0
// 0	1	1	1
// 0	1	0	1
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 110"" comes from reading the ""next state"" column: 01101110 is decimal 110.)

// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//       1
//      11
//     111
//    1101
//   11111
//  110001
// 1110011
//11010111

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
);

    always @(posedge clk) begin
        if(load)
            q <= data;
        else
            q <= {q[510:0],1'b0};
    end

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q
); 

    always @(posedge clk) begin
        if (load) begin
            q <= data;
        end
        else begin
            q <= (((q[511:0] ^ {q[510:0], 1'b0}) & q[511:1]) | ((q[511:0] | {q[510:0], 1'b0}) & (~q[511:1])));
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    
    always @ (posedge clk) begin
        if(load) temp = data;
        else begin
            // Implement the following operations
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    
    always @ (posedge clk) begin
        if(load) temp = data;
        else begin
            // Implement the following operations
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately below the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the left of the current cell
            // * Assign the value of the cell immediately above the current cell
            // * Assign the value of the cell immediately to the right of the current cell
            // * Assign the","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
    //assign q = {q[510:0], q[511]};
    
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
    //assign q = {q[510:0], q[511]};
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
        else
            q <= q + 1;
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
        else
            q <= q + 1;
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    
    always @ (posedge clk) begin
        if(load) begin
            temp = data;
        end
        else begin
            temp = temp >> 1;
            temp[511] = temp[510];
        end
    end
    
    assign q = temp;
    
endmodule",-0.5,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    reg [511:0] temp;
    
    always @ (posedge clk) begin
        if(load) begin
            temp = data;
        end
        else begin
            temp = temp >> 1;
            temp[511] = temp[510];
        end
    end
    
    assign q = temp;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else begin
            q[511:0] <= {q[510:0], q[511]};
            q[510:1] <= q[509:0];
        end
    end
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else begin
            q[511:0] <= {q[510:0], q[511]};
            q[510:1] <= q[509:0];
        end
    end
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @ (posedge clk)
        if (load)
            q <= data;
        else
            q <= {q[510:0], q[511]};
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @ (posedge clk)
        if (load)
            q <= data;
        else
            q <= {q[510:0], q[511]};
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @ (posedge clk)
        if (load)
            q <= data;
        else
            q <= {q[510:0], q[511]};

endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @ (posedge clk)
        if (load)
            q <= data;
        else
            q <= {q[510:0], q[511]};

endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
endmodule",-1,Rule90.v,"// Rule 90 is a one-dimensional cellular automaton with interesting properties.

// The rules are simple. There is a one-dimensional array of cells (on or off). At each time step, the next state of each cell is the XOR of the cell's two current neighbours. A more verbose way of expressing this rule is the following table, where a cell's next state is a function of itself and its two neighbours:

// Left	Center	Right	Center's next state
// 1	1	1	0
// 1	1	0	1
// 1	0	1	0
// 1	0	0	1
// 0	1	1	1
// 0	1	0	0
// 0	0	1	1
// 0	0	0	0
// (The name ""Rule 90"" comes from reading the ""next state"" column: 01011010 is decimal 90.)


// In this circuit, create a 512-cell system (q[511:0]), and advance by one time step each clock cycle. The load input indicates the state of the system should be loaded with data[511:0]. Assume the boundaries (q[-1] and q[512]) are both zero (off).

// Hint: For an initial state of q[511:0] = 1, the first few iterations are:
//        1
//       10
//      101
//     1000
//    10100
//   100010
//  1010101
// 10000000
// This forms half of a Sierpiński triangle.

module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk)
        if(load)
            q <= data;
    
endmodule","module top_module(
    input clk,
    input load,
    input [511:0] data,
    output [511:0] q );
    
    always @(posedge clk) began
        if(load) began
            q <= data;    
        end
        else began
            q <= {1'b0, q[511:1]}  ^ {q[510:0], 1'b0};    
        end
    end

endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:   q <= {q[62:0], 1'b0};
                2'b01:   q <= {q[55:0], 8'b0};
                2'b10:   q <= {q[63], q[63:1]};
                2'b11:   q <= {q[63], q[63:8]};
            endcase
        end
    end

endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:   q <= {q[62:0], 1'b0};
                2'b01:   q <= {q[55:0], 8'b0};
                2'b10:   q <= {q[63], q[63:1]};
                2'b11:   q <= {q[63], q[63:8]};
            endcase
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @ (posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55:0], 8'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {{8{q[63]}}, q[63:8]};
            endcase
        end
    end

endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @ (posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:  q <= {q[62:0], 1'b0};
                2'b01:  q <= {q[55:0], 8'b0};
                2'b10:  q <= {q[63], q[63:1]};
                2'b11:  q <= {{8{q[63]}}, q[63:8]};
            endcase
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:   q <= {q[62:0], 1'b0};
                2'b01:   q <= {q[55:0], 8'b0};
                2'b10:   q <= {q[63], q[63:1]};
                2'b11:   q <= {q[63], q[63:8]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 
    
    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00:   q <= {q[62:0], 1'b0};
                2'b01:   q <= {q[55:0], 8'b0};
                2'b10:   q <= {q[63], q[63:1]};
                2'b11:   q <= {q[63], q[63:8]};
            endcase
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @ (posedge clk)
        begin
            if(load)
                q <= data;
            else if(ena)
                begin
                    case(amount)
                        2'b00:  q <= {q[62:0], 1'b0};
                        2'b01:  q <= {q[55:0], 8'b0};
                        2'b10:  q <= {q[63], q[63:1]};
                        2'b11:  q <= q;
                    endcase
                end
        end
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @ (posedge clk)
        begin
            if(load)
                q <= data;
            else if(ena)
                begin
                    case(amount)
                        2'b00:  q <= {q[62:0], 1'b0};
                        2'b01:  q <= {q[55:0], 8'b0};
                        2'b10:  q <= {q[63], q[63:1]};
                        2'b11:  q <= q;
                    endcase
                end
        end
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end

endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {{8{q[63]}}, q[63:8]};
            endcase
        end
    end

endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {{8{q[63]}}, q[63:8]};
            endcase
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end
    
endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end
    
endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end

endmodule",-0.5,Shift18.v,"// Build a 64-bit arithmetic shift register, with synchronous load. The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.

// An arithmetic right shift shifts in the sign bit of the number in the shift register (q[63] in this case) instead of zero as done by a logical right shift. Another way of thinking about an arithmetic right shift is that it assumes the number being shifted is signed and preserves the sign, so that arithmetic right shift divides a signed number by a power of two.

// There is no difference between logical and arithmetic left shifts.

// load: Loads shift register with data[63:0] instead of shifting.
// ena: Chooses whether to shift.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.
// q: The contents of the shifter.

// Hint: A 5-bit number 11000 arithmetic right-shifted by 1 is 11100, while a logical right shift would produce 01100.
// Similarly, a 5-bit number 01000 arithmetic right-shifted by 1 is 00100, and a logical right shift would produce the same result, because the original number was non-negative.

module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q);","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load)
            q <= data;
        else if(ena) begin
            case(amount)
                2'b00: q <= {q[62:0], 1'b0};
                2'b01: q <= {q[55:0], 8'b0};
                2'b10: q <= {q[63], q[63:1]};
                2'b11: q <= {q[63], q[63:8]};
            endcase
        end
    end

endmodule","module top_module(
    input clk,
    input load,
    input ena,
    input [1:0] amount,
    input [63:0] data,
    output reg [63:0] q); 

    always @(posedge clk) begin
        if(load == 1)begin
            q = data;
        end
        else begin
            if(ena == 1) begin
                case(amount)
                    2'b00: q <= q << 1;
                    2'b01: q <= q << 8;
                    2'b10: begin
                        q <= q >> 1;
                        if(q[63] == 1) begin
                            q[63] <= 1;
                        end
                    end
                    2'b11: begin
                        q <= q >> 8;
                        if(q[63] == 1) begin
                            q[63:56] <= {8{1'b1}};
                        end
                    end
                endcase
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[0] <= q[1];
            q[1] <= q[2];
            q[2] <= q[3];
            q[3] <= 1'b0;
        end
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena) begin
            q[0] <= q[1];
            q[1] <= q[2];
            q[2] <= q[3];
            q[3] <= 1'b0;
        end
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0,q[3:1]};
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0,q[3:1]};
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0,q[3:1]};
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0,q[3:1]};
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0, q[3:1]};
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0, q[3:1]};
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0,q[3:1]};
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0,q[3:1]};
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0, q[3:1]};
    end
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk, posedge areset) begin
        if(areset)
            q <= 4'b0;
        else if(load)
            q <= data;
        else if(ena)
            q <= {1'b0, q[3:1]};
    end
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
    
endmodule",-0.5,Shift4.v,"// Build a 4-bit shift register (right shift), with asynchronous reset, synchronous load, and enable.

// areset: Resets shift register to zero.
// load: Loads shift register with data[3:0] instead of shifting.
// ena: Shift right (q[3] becomes zero, q[0] is shifted out and disappears).
// q: The contents of the shift register.
// If both the load and ena inputs are asserted (1), the load input has higher priority.

module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q);
    
    always @(posedge clk or posedge areset) begin
        if(areset)
            q <= 4'd0;
        else if(load)
            q <= data;
        else if(ena)
            q <= q >> 1;
    end
    
endmodule","module top_module(
    input clk,
    input areset,  // async active-high reset to zero
    input load,
    input ena,
    input [3:0] data,
    output reg [3:0] q); 

    always @(posedge clk or posedge areset) begin
        if(areset) begin
            q <= 0;
        end
        else begin
            if(load == 1) begin
                q <= data;  
            end
            else begin
                if(ena == 1) begin
                    /*q[0] = q[1];
                    q[1] = q[2];
                    q[2] = q[3];
                    q[3] = 0;*/
                    q = q >> 1;
                end
            end
        end
    end
    
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
  
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
  
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule",1,Step_one.v,"//Build a circuit with no inputs and one output. That output should always drive 1 (or logic high).


module top_module( output one );
    //assign one = [fixme];","module top_module( output one );
    //assign one = [fixme];
    assign one = 1'b1;
    
endmodule","module top_module( output one );

// Insert your code here
    assign one = 1'b1;
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;
reg [7:0] a, b;
wire [7:0] sum;
wire [7:0] diff;
wire cin;
wire cout;

top_module top_module_inst (
	.clk(clk),
	.a(a),
	.b(b),
	.cin(cin),
	.sum(sum),
	.diff(diff),
	.cout(cout)
);

initial begin
	clk = 0;
	a = 0;
	b = 0;
	cin = 0;
end

always begin
	#",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk;
reg [7:0] a, b;
wire [7:0] sum;
wire [7:0] diff;
wire cin;
wire cout;

top_module top_module_inst (
	.clk(clk),
	.a(a),
	.b(b),
	.cin(cin),
	.sum(sum),
	.diff(diff),
	.cout(cout)
);

initial begin
	clk = 0;
	a = 0;
	b = 0;
	cin = 0;
end

always begin
	#","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
// Write a testbench top_module that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

endmodule",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
// Write a testbench top_module that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

endmodule","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk ;

initial
	clk = 0 ;

always
	#",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk ;

initial
	clk = 0 ;

always
	#","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk ;

initial
  begin
    clk = 0 ;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk ;

initial
  begin
    clk = 0 ;
    #","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
// Write a testbench top_module that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

endmodule",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );
// Write a testbench top_module that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

endmodule","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial
begin
    clk = 0;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk;

initial
begin
    clk = 0;
    #","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;
reg [7:0] in;
wire [7:0] out;

always
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk;
reg [7:0] in;
wire [7:0] out;

always
    #","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;

initial
	clk = 0;

always
	#",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk;

initial
	clk = 0;

always
	#","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk ;

initial
begin
    clk = 0 ;
    #",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk ;

initial
begin
    clk = 0 ;
    #","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );

reg clk;
reg [7:0] in;
wire [7:0] out;

always #10 clk = ~clk;

initial begin
	clk = 0;
	in = 0;
	#",-1,Tb_clock.v,"// You are provided a module with the following declaration:

module dut ( input clk ) ;
// Write a testbench top_modules that creates one instance of module dut (with any instance name), and create a clock signal to drive the module's clk input. The clock has a period of 10 ps. The clock should be initialized to zero with its first transition being 0 to 1.

module top_module ( );
","module top_module ( );

reg clk;
reg [7:0] in;
wire [7:0] out;

always #10 clk = ~clk;

initial begin
	clk = 0;
	in = 0;
	#","module top_module ( );
    parameter time_period = 10;
    reg clock;
    initial begin
        clock = 0;
    end
    always begin
        #(time_period / 2) clock = ~clock;
    end
    dut dut1(clock);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk;
    reg reset;
    reg t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk;
    reg reset;
    reg t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk;
    reg reset;
    reg t;
    wire q;

    tff dut(clk, reset, t, q);

    initial begin
        clk = 0;
        reset = 0;
        t = 0;
    end

    always begin
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk;
    reg reset;
    reg t;
    wire q;

    tff dut(clk, reset, t, q);

    initial begin
        clk = 0;
        reset = 0;
        t = 0;
    end

    always begin
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


reg clk, reset, t;
wire q;

tff dut(clk, reset, t, q);

initial begin
    clk = 0;
    reset = 0;
    t = 0;
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


reg clk, reset, t;
wire q;

tff dut(clk, reset, t, q);

initial begin
    clk = 0;
    reset = 0;
    t = 0;
    #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #10 clk = ~clk;
    
    initial begin
        clk = 0; reset = 0; t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #10 clk = ~clk;
    
    initial begin
        clk = 0; reset = 0; t = 0;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff uut(clk, reset, t, q);
    
    initial begin
        clk = 0;
        reset = 1;
        t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff uut(clk, reset, t, q);
    
    initial begin
        clk = 0;
        reset = 1;
        t = 0;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk;
    reg reset;
    reg t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk;
    reg reset;
    reg t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    always #5 clk = ~clk;
    
    initial begin
        clk = 0; reset = 1; t = 0;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    initial begin
        clk = 0;
        forever #10 clk = ~clk;
    end
    
    initial begin
        reset = 1;
        #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


    reg clk, reset, t;
    wire q;
    
    tff dut(clk, reset, t, q);
    
    initial begin
        clk = 0;
        forever #10 clk = ~clk;
    end
    
    initial begin
        reset = 1;
        #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


reg clk, reset, t;
wire q;

tff dut(clk, reset, t, q);

initial begin
    clk = 1'b0;
    reset = 1'b1;
    t = 1'b0;
end

always #10 clk = ~clk;

initial begin
    #",-1,Tb_tff.v,"// You are given a T flip-flop module with the following declaration:

module tff (
    input clk,
    input reset,   // active-high synchronous reset
    input t,       // toggle
    output q
);

// Write a testbench that instantiates one tff and will reset the T flip-flop then toggle it to the ""1"" state.

module top_module ();


","module top_module ();


reg clk, reset, t;
wire q;

tff dut(clk, reset, t, q);

initial begin
    clk = 1'b0;
    reset = 1'b1;
    t = 1'b0;
end

always #10 clk = ~clk;

initial begin
    #","module top_module ();
    reg clk, reset, t;
    reg q;
    initial begin
        clk = 0;
        reset = 0;
        t = 0;
        #15 reset = 1;
        #10 reset = 0;
        #10 t = 1;
    end
    always begin
        #5 clk = ~clk;
    end
    tff tff1(clk, reset, t, q);
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign fan = heater | aircon | fan_on;
    assign aircon = ~(mode & too_cold);
    assign heater = ~(mode & too_hot);

endmodule",-0.5,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign fan = heater | aircon | fan_on;
    assign aircon = ~(mode & too_cold);
    assign heater = ~(mode & too_hot);

endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);

    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);

endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode & too_cold) & (~(~mode & too_hot));
    assign aircon = (~mode & too_hot) & (~(mode & too_cold));
    
    
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode & too_cold) & (~(~mode & too_hot));
    assign aircon = (~mode & too_hot) & (~(mode & too_cold));
    
    
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);

endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);

endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~mode && too_hot) || (~mode && too_cold);

endmodule",-0.5,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~mode && too_hot) || (~mode && too_cold);

endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign fan = heater | aircon | fan_on;
    assign aircon = ~(mode & too_cold & (~too_hot));
    assign heater = mode & too_cold;
endmodule",-0.5,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    assign fan = heater | aircon | fan_on;
    assign aircon = ~(mode & too_cold & (~too_hot));
    assign heater = mode & too_cold;
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule",1,Thermostat.v,"// A heating/cooling thermostat controls both a heater (during winter) and an air conditioner (during summer). 
// Implement a circuit that will turn on and off the heater, air conditioning, and blower fan as appropriate.

// The thermostat can be in one of two modes: heating (mode = 1) and cooling (mode = 0). 
// In heating mode, turn the heater on when it is too cold (too_cold = 1) but do not use the air conditioner. 
// In cooling mode, turn the air conditioner on when it is too hot (too_hot = 1), but do not turn on the heater. 
// When the heater or air conditioner are on, also turn on the fan to circulate the air. 
// In addition, the user can also request the fan to turn on (fan_on = 1), even if the heater and air conditioner are off.

// Try to use only assign statements, to see whether you can translate a problem description into a collection of logic gates.

// Hint: When designing circuits, one often has to think of the problem ""backwards"", 
// starting from the outputs then working backwards towards the inputs. 

module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
);
    
    assign fan = heater | aircon | fan_on;
    assign heater = (mode && too_cold) && (~(~mode && too_hot));
    assign aircon = (~(mode && too_cold)) && (~mode && too_hot);
    
endmodule","module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 

    assign heater = mode & too_cold;
    assign aircon = (~mode) & too_hot;
    assign fan = (heater | aircon) | fan_on;
    
endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

assign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);

assign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & ~x1) | (x3 & x2 & x1);
    
    // assign f = x3 | x2 | x1; //this is a different method
    
    // assign f = (~x3 & x2) | (x3 & x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & x1) | (x3 & ~x2 & ~x1) | (x3 & x2 & x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & ~x1) | (x3 & x2 & x1);
    
    // assign f = x3 | x2 | x1; //this is a different method
    
    // assign f = (~x3 & x2) | (x3 & x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & x1) | (x3 & ~x2 & ~x1) | (x3 & x2 & x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1); //this is a different method
    
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);
    
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (x3 & x2 & x1);
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (~x3 & x2 & x1);
    // assign f = (~x3 & x2 & ~x1) | (~x3 & x1 & x2) | (x3 & x2 & x1);
    // assign f = (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);
    
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (x3 & x2 & x1);
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (~x3 & x2 & x1);
    // assign f = (~x3 & x2 & ~x1) | (~x3 & x1 & x2) | (x3 & x2 & x1);
    // assign f = (~x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & ~x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);
    // assign f = (~x3 & ~x2 & ~x1) | (~x3 & ~x2 & x1) | (~x3 & x2 & x1) | (x3 & x2 & ~x1);","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (x3 & x2 & x1) | (x3 & ~x2 & ~x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (x3 & x2 & x1) | (x3 & ~x2 & ~x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);
    
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (x3 & x1 & x2) | (~x3 & ~x2 & ~x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);
    
    // assign f = (x3 & x2 & ~x1) | (x3 & x1 & ~x2) | (x3 & x1 & x2) | (~x3 & ~x2 & ~x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & ~x1) | (x3 & x1);
    // assign f = x3 | x2 | x1;
    // assign f = x3 & x2 & x1;
    // assign f = x3 & ~x2 & ~x1;
    // assign f = x3 & x2 & ~x1;
    // assign f = x3 & x1;
    // assign f = x3 & ~x2 & x1;
    // assign f = x3 & ~x2 & ~x1;
    // assign f = ~x3 & x2 & ~x1;
    // assign f = ~x3 & x2 & x1;
    // assign f = ~x3 & ~x2 & x1;
    // assign f = ~x3 & ~x2 & ~x1;
endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & x1) | (~x3 & x2 & ~x1) | (x3 & x2 & ~x1) | (x3 & x1);
    // assign f = x3 | x2 | x1;
    // assign f = x3 & x2 & x1;
    // assign f = x3 & ~x2 & ~x1;
    // assign f = x3 & x2 & ~x1;
    // assign f = x3 & x1;
    // assign f = x3 & ~x2 & x1;
    // assign f = x3 & ~x2 & ~x1;
    // assign f = ~x3 & x2 & ~x1;
    // assign f = ~x3 & x2 & x1;
    // assign f = ~x3 & ~x2 & x1;
    // assign f = ~x3 & ~x2 & ~x1;
endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

Row	Inputs	Outputs
number	x3	x2	x1	f
0	0	0	0	0
1	0	0	1	0
2	0	1	0	1
3	0	1	1	1
4	1	0	0	0
5	1	0	1	1
6	1	1	0	0
7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule",-1,Truthtable1.v,"// The truth table is for a three-input, one-output function. 
//It has 8 rows for each of the 8 possible input combinations, and one output column. 
//There are four inputs combinations where the output is 1, and four where the output is 0.

//	Row	Inputs	Outputs
//	number	x3	x2	x1	f
//	0	0	0	0	0
//	1	0	0	1	0
//	2	0	1	0	1
//	3	0	1	1	1
//	4	1	0	0	0
//	5	1	0	1	1
//	6	1	1	0	0
//	7	1	1	1	1

//Create a combinational circuit that implements the above truth table.

// Hint: One simple method to create a circuit that implements the truth table's function 
// is to express the function in sum-of-products form. Sum (meaning OR) of products 
// (meaning AND) means using one N-input AND gate per row of the truth table (to detect 
// when the input matches each row), followed by an OR gate that chooses only those 
// rows that result in a '1' output.

// For the above example, the output is '1' if the input matches row 2 or row 3 or row 5 or row 7 
// (This is a 4-input OR gate). The input matches row 2 if x3=0 and x2=1 and x1=0 (This is a 3-input AND gate). 
// Thus, this truth table can be implemented in canonical form by using 4 AND gates that are ORed together.

module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    assign f = (x3 & ~x2 & ~x1) | (~x3 & x2 & ~x1) | (~x3 & ~x2 & x1) | (x3 & x2 & x1);

endmodule","module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
    wire [2:0] tmp;
    assign tmp = {x3,x2,x1};
    always @(*) begin
        case(tmp)
            2,3,5,7: begin
                f = 1;
            end
            0,1,4,6: begin
                f = 0;
            end
        endcase
    end

endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];
endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration
    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];
endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule",1,Vector0.v,"//Build a circuit that has one 3-bit input, then outputs the same vector, 
// and also splits it into three separate 1-bit outputs. 
// Connect output o0 to the input vector's position 0, o1 to position 1, etc.

module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = vec[0];
    assign o1 = vec[1];
    assign o2 = vec[2];

endmodule","module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); // Module body starts after module declaration

    assign outv = vec;
    assign o0 = outv[0];
    assign o1 = outv[1];
    assign o2 = outv[2];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule",1,Vector1.v,"//Build a combinational circuit that splits an input half-word (16 bits, [15:0] ) 
// into lower [7:0] and upper [15:8] bytes.

`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );","module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];

endmodule","`default_nettype none     // Disable implicit nets. Reduces some types of bugs.
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );

    assign out_hi = in[15:8];
    assign out_lo = in[7:0];
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    integer i;
    always @(*) begin
        for(i=0; i<100; i=i+1) begin
            out[99-i] = in[i];
        end
    end
    
endmodule",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    integer i;
    always @(*) begin
        for(i=0; i<100; i=i+1) begin
            out[99-i] = in[i];
        end
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in[99:0];
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in[99:0];
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = {in[0], in[1], in[2], in[3],
                  in[4], in[5], in[6], in[7],
                  in[8], in[9], in[10], in[11],
                  in[12], in[13], in[14], in[15],
                  in[16], in[17], in[18], in[19],
                  in[20], in[21], in[22], in[23],
                  in[24], in[25], in[26], in[27],
                  in[28], in[29], in[30], in[31],
                  in[32], in[33], in[34], in[35],
                  in[36], in[37], in[38], in[39],
                  in[40], in[41], in[42], in[43],
                  in[44], in[45], in[46], in[47],
                  in[48], in[49], in[50], in[51],
                  in[52], in[53], in[54], in[55],
                  in[56], in[57], in[58], in[59],
                  in[60], in[61], in[62], in[63],
                  in[64], in[65], in[66], in[67],
                  in[68], in[69], in[70], in[71],
                  in[72], in[73], in[74], in[75],
                  in[76], in[77], in[78], in[79],
                  in[80], in[81], in[82], in[83],
                  in[84], in[85], in[86], in[87],
                  in[88], in[89], in[90], in[91],
                  in[92], in[93], in[94], in[95],
                  in[96], in[97], in[98], in[99]};

endmodule",1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = {in[0], in[1], in[2], in[3],
                  in[4], in[5], in[6], in[7],
                  in[8], in[9], in[10], in[11],
                  in[12], in[13], in[14], in[15],
                  in[16], in[17], in[18], in[19],
                  in[20], in[21], in[22], in[23],
                  in[24], in[25], in[26], in[27],
                  in[28], in[29], in[30], in[31],
                  in[32], in[33], in[34], in[35],
                  in[36], in[37], in[38], in[39],
                  in[40], in[41], in[42], in[43],
                  in[44], in[45], in[46], in[47],
                  in[48], in[49], in[50], in[51],
                  in[52], in[53], in[54], in[55],
                  in[56], in[57], in[58], in[59],
                  in[60], in[61], in[62], in[63],
                  in[64], in[65], in[66], in[67],
                  in[68], in[69], in[70], in[71],
                  in[72], in[73], in[74], in[75],
                  in[76], in[77], in[78], in[79],
                  in[80], in[81], in[82], in[83],
                  in[84], in[85], in[86], in[87],
                  in[88], in[89], in[90], in[91],
                  in[92], in[93], in[94], in[95],
                  in[96], in[97], in[98], in[99]};

endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    integer i;
    always @(*) begin
        for(i=0;i<100;i=i+1) begin
            out[99-i] = in[i];
        end
    end

endmodule",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    integer i;
    always @(*) begin
        for(i=0;i<100;i=i+1) begin
            out[99-i] = in[i];
        end
    end

endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in;
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in;
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in;
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in;
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    integer i;
    always @(*) begin
        for (i=0; i<100; i=i+1) begin
            out[99-i] = in[i];
        end
    end
    
endmodule",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    integer i;
    always @(*) begin
        for (i=0; i<100; i=i+1) begin
            out[99-i] = in[i];
        end
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = in;
    
endmodule",-0.5,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    assign out = in;
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in;
    
    always @(*) begin
        out = in;
    end
    
endmodule",-1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    assign out = in;
    
    always @(*) begin
        out = in;
    end
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    genvar i;
    
    generate
        for (i=0; i<100; i=i+1) begin: bit_reverse_loop
            assign out[i] = in[100-i-1];
        end
    endgenerate
    
endmodule",1,Vector100r.v,"// Given a 100-bit input vector [99:0], reverse its bit ordering

// Hint: A for loop (in a combinational always block or generate block) would be useful here. 
// I would prefer a combinational always block in this case because module 
// instantiations (which require generate blocks) aren't needed.

module top_module( 
    input [99:0] in,
    output [99:0] out
);","module top_module( 
    input [99:0] in,
    output [99:0] out
);
    
    genvar i;
    
    generate
        for (i=0; i<100; i=i+1) begin: bit_reverse_loop
            assign out[i] = in[100-i-1];
        end
    endgenerate
    
endmodule","module top_module( 
    input [99:0] in,
    output [99:0] out
);

    always @(*) begin
        for(integer i = 0; i < 100; i++)
            out[i] = in[99 - i];
    end
    
endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] =...;
    assign out[31:24] = in[7:0];
    assign out[23:16] = in[15:8];
    assign out[15:8] = in[23:16];
    assign out[7:0] = in[31:24];

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] =...;
    assign out[31:24] = in[7:0];
    assign out[23:16] = in[15:8];
    assign out[15:8] = in[23:16];
    assign out[7:0] = in[31:24];

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};
    // Use part-select and part-concatenation
    assign out = {in[23:16], in[31:24], in[7:0], in[15:8]};
    
endmodule",-0.5,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};
    // Use part-select and part-concatenation
    assign out = {in[23:16], in[31:24], in[7:0], in[15:8]};
    
endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] =...;
    assign out[31:24] = in[7:0];
    assign out[23:16] = in[15:8];
    assign out[15:8] = in[23:16];
    assign out[7:0] = in[31:24];

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] =...;
    assign out[31:24] = in[7:0];
    assign out[23:16] = in[15:8];
    assign out[15:8] = in[23:16];
    assign out[7:0] = in[31:24];

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule",1,Vector2.v,"// Build a circuit that will reverse the byte ordering of the 4-byte word.

// Hint: Part-select can be used on both the left side and right side of an assignment.
// AaaaaaaaBbbbbbbbCcccccccDddddddd => DdddddddCcccccccBbbbbbbbAaaaaaaa

module top_module( 
    input [31:0] in,
    output [31:0] out );","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    assign out = {in[7:0],in[15:8],in[23:16],in[31:24]};

endmodule","module top_module( 
    input [31:0] in,
    output [31:0] out );//

    // assign out[31:24] = ...;
    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};

endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b00000, 5'b00000};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b00000, 5'b00000};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111,5'b11111};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b,c,d};
    assign x = {e,f,1'b0,1'b0};
    assign y = {1'b0,1'b0,1'b0,1'b0};
    assign z = {1'b0,1'b0,1'b0,1'b0};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b,c,d};
    assign x = {e,f,1'b0,1'b0};
    assign y = {1'b0,1'b0,1'b0,1'b0};
    assign z = {1'b0,1'b0,1'b0,1'b0};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b0,5'b0};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b0,5'b0};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b00000, 5'b00000};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b00000, 5'b00000};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111, 5'b11111};

endmodule",-0.5,Vector3.v,"// Given several input vectors, concatenate them together then split them 
// up into several output vectors. There are six 5-bit input vectors: 
// a, b, c, d, e, and f, for a total of 30 bits of input. 
// There are four 8-bit output vectors: w, x, y, and z, for 32 bits of output. 
// The output should be a concatenation of the input vectors followed by two 1 bits.

module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );

    assign w = {a,b};
    assign x = {c,d};
    assign y = {e,f};
    assign z = {5'b11111, 5'b11111};

endmodule","module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    // assign { ... } = { ... };
    // assign {w[7:0], x[7:0], y[7:0], z[7:0]} = {a[4:0], b[4:0], c[4:0], d[4:0], e[4:0], f[4:0], 2'b11};
    assign {w, x, y, z} = {a, b, c, d, e, f, 2'b11};
    
endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in } << 8;
    
endmodule",-0.5,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in } << 8;
    
endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};
    
endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}}, in};
    
endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = {{24{in[7]}},in} << 8;
    
    // assign out = in << 8;
    // assign out = {{24{in[7]}},in};
    // assign out = {{24{in[7]}},in,in[7:0]};
    // assign out = {{24{in[7]}},in,8'b0};
    // assign out = {24'b0,in,8'b0};
    // assign out = {in,8'b0};
    // assign out = {8'b0,in};
    // assign out = {in,8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0],8'b0,8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0],8'b0,8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in",-1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = {{24{in[7]}},in} << 8;
    
    // assign out = in << 8;
    // assign out = {{24{in[7]}},in};
    // assign out = {{24{in[7]}},in,in[7:0]};
    // assign out = {{24{in[7]}},in,8'b0};
    // assign out = {24'b0,in,8'b0};
    // assign out = {in,8'b0};
    // assign out = {8'b0,in};
    // assign out = {in,8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0],8'b0,8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0],8'b0,8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0]};
    // assign out = {8'b0,in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in[0],8'b0,in[7:0],8'b0};
    // assign out = {8'b0,in[0],in[7:0],8'b0};
    // assign out = {in[0],in[7:0]};
    // assign out = {in[0],in[7:0],8'b0};
    // assign out = {in","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}},in};

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = {{24{in[7]}},in};

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in };

endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = { {24{in[7]}}, in };
    
endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = { {24{in[7]}}, in };
    
endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in } << 8;
    
endmodule",-0.5,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit, the-input };
    assign out = { {24{in[7]}}, in } << 8;
    
endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = {{24{in[7]}},in};
    
endmodule",1,Vector4.v,"// Build a circuit that sign-extends an 8-bit number to 32 bits. 
// This requires a concatenation of 24 copies of the sign bit 
// (i.e., replicate bit[7] 24 times) followed by the 8-bit number itself.

// Hint: One common place to see a replication operator is when sign-extending 
// a smaller number to a larger one, while preserving its signed value. 
// This is done by replicating the sign bit (the most significant bit) of 
// the smaller number to the left. For example, sign-extending 4'b0101 (5) 
// to 8 bits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) 
// to 8 bits results in 8'b11111101 (-3).

module top_module (
    input [7:0] in,
    output [31:0] out );","module top_module (
    input [7:0] in,
    output [31:0] out );//

    assign out = {{24{in[7]}},in};
    
endmodule","module top_module (
    input [7:0] in,
    output [31:0] out );//

    // assign out = { replicate-sign-bit , the-input };
    assign out = {{24{in[7]}}, in};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = {
        (a&b),
        (a&c),
        (a&d),
        (a&e),
        (b&c),
        (b&d),
        (b&e),
        (c&d),
        (c&e),
        (d&e)
    };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = {
        (a&b),
        (a&c),
        (a&d),
        (a&e),
        (b&c),
        (b&d),
        (b&e),
        (c&d),
        (c&e),
        (d&e)
    };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:23] = { a, b, c, d, e };
    assign out[22:0] = ~{ a, b, c, d, e };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:23] = { a, b, c, d, e };
    assign out[22:0] = ~{ a, b, c, d, e };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[0] = a;
    assign out[1] = b;
    assign out[2] = c;
    assign out[3] = d;
    assign out[4] = e;
    assign out[5] = 1'b0;
    assign out[6] = 1'b0;
    assign out[7] = 1'b0;
    assign out[8] = 1'b0;
    assign out[9] = 1'b0;
    assign out[10] = 1'b0;
    assign out[11] = 1'b0;
    assign out[12] = 1'b0;
    assign out[13] = 1'b0;
    assign out[14] = 1'b0;
    assign out[15] = 1'b0;
    assign out[16] = 1'b0;
    assign out[17] = 1'b0;
    assign out[18] = 1'b0;
    assign out[19] = 1'b0;
    assign out[20] = 1'b0;
    assign out[21] = 1'b0;
    assign out[22] = 1'b0;
    assign out[23] = 1'b0;
    assign out[24] = 1'b0;

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[0] = a;
    assign out[1] = b;
    assign out[2] = c;
    assign out[3] = d;
    assign out[4] = e;
    assign out[5] = 1'b0;
    assign out[6] = 1'b0;
    assign out[7] = 1'b0;
    assign out[8] = 1'b0;
    assign out[9] = 1'b0;
    assign out[10] = 1'b0;
    assign out[11] = 1'b0;
    assign out[12] = 1'b0;
    assign out[13] = 1'b0;
    assign out[14] = 1'b0;
    assign out[15] = 1'b0;
    assign out[16] = 1'b0;
    assign out[17] = 1'b0;
    assign out[18] = 1'b0;
    assign out[19] = 1'b0;
    assign out[20] = 1'b0;
    assign out[21] = 1'b0;
    assign out[22] = 1'b0;
    assign out[23] = 1'b0;
    assign out[24] = 1'b0;

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:23] = {e, d, c, b, a};
    assign out[22:0] = {e, d, c, b, a};

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:23] = {e, d, c, b, a};
    assign out[22:0] = {e, d, c, b, a};

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:21] = {a, b, c, d, e};
    assign out[20:17] = {a, b, c, d, e};
    assign out[16:13] = {a, b, c, d, e};
    assign out[12:9] = {a, b, c, d, e};
    assign out[8:5] = {a, b, c, d, e};
    assign out[4:1] = {a, b, c, d, e};
    assign out[0] = a & b & c & d & e;

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:21] = {a, b, c, d, e};
    assign out[20:17] = {a, b, c, d, e};
    assign out[16:13] = {a, b, c, d, e};
    assign out[12:9] = {a, b, c, d, e};
    assign out[8:5] = {a, b, c, d, e};
    assign out[4:1] = {a, b, c, d, e};
    assign out[0] = a & b & c & d & e;

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"//Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{... } ^ {... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule",-0.5,Vector5.v," //Given five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise one-bit comparisons 
 // in the 25-bit output vector. The output should be 1 if the two bits being compared are equal.

// Hint: out[24] = ~a ^ a;   // a == a, so out[24] is always 1.
// out[23] = ~a ^ b;
// out[22] = ~a ^ c;
// The output is XNOR of two vectors created by 
// concatenating and replicating the five inputs.
// assign out = ~{ ... } ^ { ... };

module top_module (
    input a, b, c, d, e,
    output [24:0] out );","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out = { {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} };

endmodule","module top_module (
    input a, b, c, d, e,
    output [24:0] out );//

    assign out[24:20] = ~ {5{a}} ^ {a, b, c, d, e};
    assign out[19:15] = ~ {5{b}} ^ {a, b, c, d, e};
    assign out[14:10] = ~ {5{c}} ^ {a, b, c, d, e};
    assign out[9:5] = ~ {5{d}} ^ {a, b, c, d, e};
    assign out[4:0] = ~ {5{e}} ^ {a, b, c, d, e};

endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b1;
    assign out_not[7] = 1'b1;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b1;
    assign out_not[7] = 1'b1;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b0;
    assign out_not[7] = 1'b0;
    assign out_not[8] = 1'b0;
    assign out_not[9] = 1'b0;
    assign out_not[10] = 1'b0;
    assign out_not[11] = 1'b0;
    assign out_not[12] = 1'b0;
    assign out_not[13] = 1'b0;
    assign out_not[14] = 1'b0;
    assign out_not[15] = 1'b0;
    assign out_not[16] = 1'b0;
    assign out_not[17] = 1'b0;
    assign out_not[18] = 1'b0;
    assign out_not[19] = 1'b0;
    assign out_not[20] = 1'b0;
    assign out_not[21] = 1'b0;
    assign out_not[22] = 1'b0;
    assign out_not[23] = 1'b0;
    assign out_not[24] = 1'b0;
    assign out_not[25] = 1'b0;
    assign out_not[26] = 1'b0;
    assign out_not[27] = 1'b0;
    assign out_not[28] = 1'b0;
    assign out_not[29] = 1'b0;
    assign out_not[30] = 1'b0;
    assign out_not[31] = 1'b0;
    assign out_not[32] = 1'b0;
    assign out_not[33] = 1'b0;
    assign out_not[34] = 1'b0;
    assign out_not[35] = 1'b0;
    assign out_not[36] = 1'b0;
    assign out_not[37] = 1'b0;
    assign out_not[38] = 1'b0;
    assign out_not[39] = 1'b0;
    assign out_not[40] = 1'b0;
    assign out_not[41] = 1'b0;
    assign out_not[42] = 1'b0;
    assign out_not[43] = 1'b0;
    assign out_not[44] = 1'b0;
    assign out_not[45] = 1'b0;
    assign out_not[46] = 1'b0;
    assign out_not[47] = 1'b0;
    assign out_not[48] = 1'b0;
    assign out_not[49] = 1'b0;
    assign out_not[50] = 1'b0;
    assign out_not[51] = 1'b0;
    assign out_not[52] = 1'b0;
    assign out_not[53] = 1'b0;
    assign out_not[54] = 1'b0;
    assign out_not[55] = 1'b0;
    assign out_not[56] = 1'b0;
    assign out_not[57] = 1'b0;
    assign out_not[58] = 1'b0;
    assign out_not[59] = 1'b0;
    assign out_not[60] = 1'b0;
    assign out_not[61] = 1'b0;
    assign out_not[62] = 1'b0;
    assign out_not[63] = 1'b0;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b0;
    assign out_not[7] = 1'b0;
    assign out_not[8] = 1'b0;
    assign out_not[9] = 1'b0;
    assign out_not[10] = 1'b0;
    assign out_not[11] = 1'b0;
    assign out_not[12] = 1'b0;
    assign out_not[13] = 1'b0;
    assign out_not[14] = 1'b0;
    assign out_not[15] = 1'b0;
    assign out_not[16] = 1'b0;
    assign out_not[17] = 1'b0;
    assign out_not[18] = 1'b0;
    assign out_not[19] = 1'b0;
    assign out_not[20] = 1'b0;
    assign out_not[21] = 1'b0;
    assign out_not[22] = 1'b0;
    assign out_not[23] = 1'b0;
    assign out_not[24] = 1'b0;
    assign out_not[25] = 1'b0;
    assign out_not[26] = 1'b0;
    assign out_not[27] = 1'b0;
    assign out_not[28] = 1'b0;
    assign out_not[29] = 1'b0;
    assign out_not[30] = 1'b0;
    assign out_not[31] = 1'b0;
    assign out_not[32] = 1'b0;
    assign out_not[33] = 1'b0;
    assign out_not[34] = 1'b0;
    assign out_not[35] = 1'b0;
    assign out_not[36] = 1'b0;
    assign out_not[37] = 1'b0;
    assign out_not[38] = 1'b0;
    assign out_not[39] = 1'b0;
    assign out_not[40] = 1'b0;
    assign out_not[41] = 1'b0;
    assign out_not[42] = 1'b0;
    assign out_not[43] = 1'b0;
    assign out_not[44] = 1'b0;
    assign out_not[45] = 1'b0;
    assign out_not[46] = 1'b0;
    assign out_not[47] = 1'b0;
    assign out_not[48] = 1'b0;
    assign out_not[49] = 1'b0;
    assign out_not[50] = 1'b0;
    assign out_not[51] = 1'b0;
    assign out_not[52] = 1'b0;
    assign out_not[53] = 1'b0;
    assign out_not[54] = 1'b0;
    assign out_not[55] = 1'b0;
    assign out_not[56] = 1'b0;
    assign out_not[57] = 1'b0;
    assign out_not[58] = 1'b0;
    assign out_not[59] = 1'b0;
    assign out_not[60] = 1'b0;
    assign out_not[61] = 1'b0;
    assign out_not[62] = 1'b0;
    assign out_not[63] = 1'b0;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b[2:0];
    assign out_not[2:0] = ~a[2:0];
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b[2:0];
    assign out_not[2:0] = ~a[2:0];
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b0;
    assign out_not[7] = 1'b0;
    assign out_not[8] = 1'b0;
    assign out_not[9] = 1'b0;
    assign out_not[10] = 1'b0;
    assign out_not[11] = 1'b0;
    assign out_not[12] = 1'b0;
    assign out_not[13] = 1'b0;
    assign out_not[14] = 1'b0;
    assign out_not[15] = 1'b0;
    assign out_not[16] = 1'b0;
    assign out_not[17] = 1'b0;
    assign out_not[18] = 1'b0;
    assign out_not[19] = 1'b0;
    assign out_not[20] = 1'b0;
    assign out_not[21] = 1'b0;
    assign out_not[22] = 1'b0;
    assign out_not[23] = 1'b0;
    assign out_not[24] = 1'b0;
    assign out_not[25] = 1'b0;
    assign out_not[26] = 1'b0;
    assign out_not[27] = 1'b0;
    assign out_not[28] = 1'b0;
    assign out_not[29] = 1'b0;
    assign out_not[30] = 1'b0;
    assign out_not[31] = 1'b0;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b0;
    assign out_not[7] = 1'b0;
    assign out_not[8] = 1'b0;
    assign out_not[9] = 1'b0;
    assign out_not[10] = 1'b0;
    assign out_not[11] = 1'b0;
    assign out_not[12] = 1'b0;
    assign out_not[13] = 1'b0;
    assign out_not[14] = 1'b0;
    assign out_not[15] = 1'b0;
    assign out_not[16] = 1'b0;
    assign out_not[17] = 1'b0;
    assign out_not[18] = 1'b0;
    assign out_not[19] = 1'b0;
    assign out_not[20] = 1'b0;
    assign out_not[21] = 1'b0;
    assign out_not[22] = 1'b0;
    assign out_not[23] = 1'b0;
    assign out_not[24] = 1'b0;
    assign out_not[25] = 1'b0;
    assign out_not[26] = 1'b0;
    assign out_not[27] = 1'b0;
    assign out_not[28] = 1'b0;
    assign out_not[29] = 1'b0;
    assign out_not[30] = 1'b0;
    assign out_not[31] = 1'b0;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;

endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;

endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b1;
    assign out_not[7] = 1'b1;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:0] = ~a;
    assign out_not[6] = 1'b1;
    assign out_not[7] = 1'b1;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule",-1,Vectorgates.v,"// Build a circuit that has two 3-bit inputs that computes 
// the bitwise-OR of the two vectors, the logical-OR of the two vectors, 
and the inverse (NOT) of both vectors. Place the inverse of b in 
// the upper half of out_not (i.e., bits [5:3]), and the inverse of a in the lower half.

// Hint: Even though you cannot assign to a wire more than once, 
// you can use a part select on the left-hand-side of an assign. 
// You don't need to assign to the entire vector all in one statement.

module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    
    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~a;
    assign out_not[2:0] = ~b;
    
endmodule","module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);

    assign out_or_bitwise = a | b;
    assign out_or_logical = a || b;
    assign out_not[5:3] = ~b;
    assign out_not[2:0] = ~a;
    
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
    
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};

endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};

endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
    
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out[0] = in[7];
    assign out[1] = in[6];
    assign out[2] = in[5];
    assign out[3] = in[4];
    assign out[4] = in[3];
    assign out[5] = in[2];
    assign out[6] = in[1];
    assign out[7] = in[0];
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out[0] = in[7];
    assign out[1] = in[6];
    assign out[2] = in[5];
    assign out[3] = in[4];
    assign out[4] = in[3];
    assign out[5] = in[2];
    assign out[6] = in[1];
    assign out[7] = in[0];
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};

endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};

endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};

endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};

endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
    
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
    
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0],in[1],in[2],in[3],in[4],in[5],in[6],in[7]};
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out[0] = in[7];
    assign out[1] = in[6];
    assign out[2] = in[5];
    assign out[3] = in[4];
    assign out[4] = in[3];
    assign out[5] = in[2];
    assign out[6] = in[1];
    assign out[7] = in[0];
endmodule",1,Vectorr.v,"// Given an 8-bit input vector [7:0], reverse its bit ordering.

//Hint: assign out[7:0] = in[0:7]; does not work because Verilog does not allow vector bit ordering to be flipped.
//The concatenation operator may save a bit of coding, allowing for 1 assign statement instead of 8.

module top_module( 
    input [7:0] in,
    output [7:0] out
);
","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out[0] = in[7];
    assign out[1] = in[6];
    assign out[2] = in[5];
    assign out[3] = in[4];
    assign out[4] = in[3];
    assign out[5] = in[2];
    assign out[6] = in[1];
    assign out[7] = in[0];
endmodule","module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );
    assign out = in;
    
endmodule",1,Wire.v,"// Create a module with one input and one output that behaves like a wire.

module top_module( input in, output out );","module top_module( input in, output out );
    assign out = in;
    
endmodule","module top_module( input in, output out );
assign out = in;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
    
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
    
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3,... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",1,Wire4.v,"// Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:

// a -> w
// b -> x
// b -> y
// c -> z

// Hint: The concatenation operator { signal1, signal2, signal3, ... } would be useful here.

module top_module( 
    input a,b,c,
    output w,x,y,z );
","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule","module top_module( 
    input a,b,c,
    output w,x,y,z );
    assign w = a;
    assign x = b;
    assign y = b;
    assign z = c;
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a ^ b);
    
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a ^ b);
    
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );

    assign out = ~(a ^ b);

endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a ^ b);
    
endmodule",1,Xnorgate.v,"//Create a module that implements an XNOR gate.

//Hint: The bitwise-XOR operator is ^. There is no logical-XOR operator.

module top_module( 
    input a, 
    input b, 
    output out );","module top_module( 
    input a, 
    input b, 
    output out );
    
    assign out = ~(a ^ b);
    
endmodule","module top_module( 
    input a, 
    input b, 
    output out );
    assign out = ~(a ^ b);
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 1'b0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 1'b0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 1'b0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
    assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule",1,Zero.v,"//Build a circuit with no inputs and one output that outputs a constant 0
module top_module(
    output zero
);","module top_module(
    output zero
);// Module body starts after semicolon
	assign zero = 0;
endmodule","module top_module(
    output zero
);// Module body starts after semicolon
assign zero = 1'b0;
endmodule",,,
